<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ext4 › extents.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>extents.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2003-2006, Cluster File Systems, Inc, info@clusterfs.com</span>
<span class="cm"> * Written by Alex Tomas &lt;alex@clusterfs.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Architecture independence:</span>
<span class="cm"> *   Copyright (c) 2005, Bull S.A.</span>
<span class="cm"> *   Written by Pierre Peiffer &lt;pierre.peiffer@bull.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public Licens</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Extents support for EXT4</span>
<span class="cm"> *</span>
<span class="cm"> * TODO:</span>
<span class="cm"> *   - ext4*_error() should be used in some situations</span>
<span class="cm"> *   - analyze all BUG()/BUG_ON(), use -EIO where appropriate</span>
<span class="cm"> *   - smart tree reduction</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/jbd2.h&gt;</span>
<span class="cp">#include &lt;linux/highuid.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/quotaops.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/falloc.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/fiemap.h&gt;</span>
<span class="cp">#include &quot;ext4_jbd2.h&quot;</span>

<span class="cp">#include &lt;trace/events/ext4.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * used by extent splitting.</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_EXT_MAY_ZEROOUT	0x1  </span><span class="cm">/* safe to zeroout if split fails \</span>
<span class="cm">					due to ENOSPC */</span><span class="cp"></span>
<span class="cp">#define EXT4_EXT_MARK_UNINIT1	0x2  </span><span class="cm">/* mark first half uninitialized */</span><span class="cp"></span>
<span class="cp">#define EXT4_EXT_MARK_UNINIT2	0x4  </span><span class="cm">/* mark second half uninitialized */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">__le32</span> <span class="nf">ext4_extent_block_csum</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ext4_extent_header</span> <span class="o">*</span><span class="n">eh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">__u32</span> <span class="n">csum</span><span class="p">;</span>

	<span class="n">csum</span> <span class="o">=</span> <span class="n">ext4_chksum</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_csum_seed</span><span class="p">,</span> <span class="p">(</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)</span><span class="n">eh</span><span class="p">,</span>
			   <span class="n">EXT4_EXTENT_TAIL_OFFSET</span><span class="p">(</span><span class="n">eh</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">csum</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_extent_block_csum_verify</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">ext4_extent_header</span> <span class="o">*</span><span class="n">eh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_extent_tail</span> <span class="o">*</span><span class="n">et</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EXT4_HAS_RO_COMPAT_FEATURE</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
		<span class="n">EXT4_FEATURE_RO_COMPAT_METADATA_CSUM</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">et</span> <span class="o">=</span> <span class="n">find_ext4_extent_tail</span><span class="p">(</span><span class="n">eh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">et</span><span class="o">-&gt;</span><span class="n">et_checksum</span> <span class="o">!=</span> <span class="n">ext4_extent_block_csum</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">eh</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext4_extent_block_csum_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">ext4_extent_header</span> <span class="o">*</span><span class="n">eh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_extent_tail</span> <span class="o">*</span><span class="n">et</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EXT4_HAS_RO_COMPAT_FEATURE</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
		<span class="n">EXT4_FEATURE_RO_COMPAT_METADATA_CSUM</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">et</span> <span class="o">=</span> <span class="n">find_ext4_extent_tail</span><span class="p">(</span><span class="n">eh</span><span class="p">);</span>
	<span class="n">et</span><span class="o">-&gt;</span><span class="n">et_checksum</span> <span class="o">=</span> <span class="n">ext4_extent_block_csum</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">eh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ext4_split_extent</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">split_flag</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ext4_split_extent_at</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			     <span class="n">ext4_lblk_t</span> <span class="n">split</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">split_flag</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_ext_truncate_extend_restart</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					    <span class="kt">int</span> <span class="n">needed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext4_handle_valid</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_buffer_credits</span> <span class="o">&gt;</span> <span class="n">needed</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_journal_extend</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_truncate_restart_trans</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * could return:</span>
<span class="cm"> *  - EROFS</span>
<span class="cm"> *  - ENOMEM</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_ext_get_access</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* path points to block */</span>
		<span class="k">return</span> <span class="n">ext4_journal_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* path points to leaf/index in inode body */</span>
	<span class="cm">/* we use in-core data, no need to protect them */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * could return:</span>
<span class="cm"> *  - EROFS</span>
<span class="cm"> *  - ENOMEM</span>
<span class="cm"> *  - EIO</span>
<span class="cm"> */</span>
<span class="cp">#define ext4_ext_dirty(handle, inode, path) \</span>
<span class="cp">		__ext4_ext_dirty(__func__, __LINE__, (handle), (inode), (path))</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__ext4_ext_dirty</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">where</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span>
			    <span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext4_extent_block_csum_set</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext_block_hdr</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_bh</span><span class="p">));</span>
		<span class="cm">/* path points to block */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">__ext4_handle_dirty_metadata</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span>
						   <span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_bh</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* path points to leaf/index in inode body */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">ext4_fsblk_t</span> <span class="nf">ext4_ext_find_goal</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			      <span class="n">ext4_lblk_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_depth</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Try to predict block placement assuming that we are</span>
<span class="cm">		 * filling in a file which will eventually be</span>
<span class="cm">		 * non-sparse --- i.e., in the case of libbfd writing</span>
<span class="cm">		 * an ELF object sections out-of-order but in a way</span>
<span class="cm">		 * the eventually results in a contiguous object or</span>
<span class="cm">		 * executable file, or some database extending a table</span>
<span class="cm">		 * space file.  However, this is actually somewhat</span>
<span class="cm">		 * non-ideal if we are writing a sparse file such as</span>
<span class="cm">		 * qemu or KVM writing a raw image file that is going</span>
<span class="cm">		 * to stay fairly sparse, since it will end up</span>
<span class="cm">		 * fragmenting the file system&#39;s free space.  Maybe we</span>
<span class="cm">		 * should have some hueristics or some way to allow</span>
<span class="cm">		 * userspace to pass a hint to file system,</span>
<span class="cm">		 * especially if the latter case turns out to be</span>
<span class="cm">		 * common.</span>
<span class="cm">		 */</span>
		<span class="n">ex</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext4_fsblk_t</span> <span class="n">ext_pblk</span> <span class="o">=</span> <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
			<span class="n">ext4_lblk_t</span> <span class="n">ext_block</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;</span> <span class="n">ext_block</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ext_pblk</span> <span class="o">+</span> <span class="p">(</span><span class="n">block</span> <span class="o">-</span> <span class="n">ext_block</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="k">return</span> <span class="n">ext_pblk</span> <span class="o">-</span> <span class="p">(</span><span class="n">ext_block</span> <span class="o">-</span> <span class="n">block</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* it looks like index is empty;</span>
<span class="cm">		 * try to find starting block from index itself */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_bh</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* OK. use inode&#39;s group */</span>
	<span class="k">return</span> <span class="n">ext4_inode_to_goal_block</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocation for a meta data block</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ext4_fsblk_t</span>
<span class="nf">ext4_ext_new_meta_block</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">goal</span><span class="p">,</span> <span class="n">newblock</span><span class="p">;</span>

	<span class="n">goal</span> <span class="o">=</span> <span class="n">ext4_ext_find_goal</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">));</span>
	<span class="n">newblock</span> <span class="o">=</span> <span class="n">ext4_new_meta_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
					<span class="nb">NULL</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">newblock</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext4_ext_space_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">check</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_extent_header</span><span class="p">))</span>
			<span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_extent</span><span class="p">);</span>
<span class="cp">#ifdef AGGRESSIVE_TEST</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext4_ext_space_block_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">check</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_extent_header</span><span class="p">))</span>
			<span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_extent_idx</span><span class="p">);</span>
<span class="cp">#ifdef AGGRESSIVE_TEST</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext4_ext_space_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">check</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_extent_header</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">/=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_extent</span><span class="p">);</span>
<span class="cp">#ifdef AGGRESSIVE_TEST</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext4_ext_space_root_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">check</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_extent_header</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">/=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_extent_idx</span><span class="p">);</span>
<span class="cp">#ifdef AGGRESSIVE_TEST</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the number of metadata blocks needed</span>
<span class="cm"> * to allocate @blocks</span>
<span class="cm"> * Worse case is one block per extent</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext4_ext_calc_metadata_amount</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext4_lblk_t</span> <span class="n">lblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">idxs</span><span class="p">;</span>

	<span class="n">idxs</span> <span class="o">=</span> <span class="p">((</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_extent_header</span><span class="p">))</span>
		<span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_extent_idx</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the new delayed allocation block is contiguous with the</span>
<span class="cm">	 * previous da block, it can share index blocks with the</span>
<span class="cm">	 * previous block, so we only need to allocate a new index</span>
<span class="cm">	 * block every idxs leaf blocks.  At ldxs**2 blocks, we need</span>
<span class="cm">	 * an additional index block, and at ldxs**3 blocks, yet</span>
<span class="cm">	 * another index blocks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_da_metadata_calc_len</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_da_metadata_calc_last_lblock</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="n">lblock</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_da_metadata_calc_len</span> <span class="o">%</span> <span class="n">idxs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">num</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_da_metadata_calc_len</span> <span class="o">%</span> <span class="p">(</span><span class="n">idxs</span><span class="o">*</span><span class="n">idxs</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">num</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_da_metadata_calc_len</span> <span class="o">%</span> <span class="p">(</span><span class="n">idxs</span><span class="o">*</span><span class="n">idxs</span><span class="o">*</span><span class="n">idxs</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">num</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_da_metadata_calc_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_da_metadata_calc_len</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_da_metadata_calc_last_lblock</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">num</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * In the worst case we need a new set of index blocks at</span>
<span class="cm">	 * every level of the inode&#39;s extent tree.</span>
<span class="cm">	 */</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_da_metadata_calc_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_da_metadata_calc_last_lblock</span> <span class="o">=</span> <span class="n">lblock</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ext4_ext_max_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">max</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">max</span> <span class="o">=</span> <span class="n">ext4_ext_space_root</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">max</span> <span class="o">=</span> <span class="n">ext4_ext_space_root_idx</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">max</span> <span class="o">=</span> <span class="n">ext4_ext_space_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">max</span> <span class="o">=</span> <span class="n">ext4_ext_space_block_idx</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_valid_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ext</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">block</span> <span class="o">=</span> <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">ext</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ext</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ext4_data_block_valid</span><span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">),</span> <span class="n">block</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_valid_extent_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_extent_idx</span> <span class="o">*</span><span class="n">ext_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">block</span> <span class="o">=</span> <span class="n">ext4_idx_pblock</span><span class="p">(</span><span class="n">ext_idx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ext4_data_block_valid</span><span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">),</span> <span class="n">block</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_valid_extent_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_extent_header</span> <span class="o">*</span><span class="n">eh</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">depth</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">entries</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_entries</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">entries</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* leaf entries */</span>
		<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ext</span> <span class="o">=</span> <span class="n">EXT_FIRST_EXTENT</span><span class="p">(</span><span class="n">eh</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">entries</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext4_valid_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ext</span><span class="o">++</span><span class="p">;</span>
			<span class="n">entries</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ext4_extent_idx</span> <span class="o">*</span><span class="n">ext_idx</span> <span class="o">=</span> <span class="n">EXT_FIRST_INDEX</span><span class="p">(</span><span class="n">eh</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">entries</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext4_valid_extent_idx</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext_idx</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ext_idx</span><span class="o">++</span><span class="p">;</span>
			<span class="n">entries</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__ext4_ext_check</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">function</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext4_extent_header</span> <span class="o">*</span><span class="n">eh</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">error_msg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_magic</span> <span class="o">!=</span> <span class="n">EXT4_EXT_MAGIC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error_msg</span> <span class="o">=</span> <span class="s">&quot;invalid magic&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">corrupted</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_depth</span><span class="p">)</span> <span class="o">!=</span> <span class="n">depth</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error_msg</span> <span class="o">=</span> <span class="s">&quot;unexpected eh_depth&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">corrupted</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_max</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error_msg</span> <span class="o">=</span> <span class="s">&quot;invalid eh_max&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">corrupted</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">max</span> <span class="o">=</span> <span class="n">ext4_ext_max_entries</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_max</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error_msg</span> <span class="o">=</span> <span class="s">&quot;too large eh_max&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">corrupted</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_max</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">error_msg</span> <span class="o">=</span> <span class="s">&quot;invalid eh_entries&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">corrupted</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext4_valid_extent_entries</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">eh</span><span class="p">,</span> <span class="n">depth</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error_msg</span> <span class="o">=</span> <span class="s">&quot;invalid extent entries&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">corrupted</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Verify checksum on non-root extent tree nodes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">!=</span> <span class="n">depth</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">ext4_extent_block_csum_verify</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">eh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error_msg</span> <span class="o">=</span> <span class="s">&quot;extent tree corrupted&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">corrupted</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">corrupted:</span>
	<span class="n">ext4_error_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="s">&quot;bad header/extent: %s - magic %x, &quot;</span>
			<span class="s">&quot;entries %u, max %u(%u), depth %u(%u)&quot;</span><span class="p">,</span>
			<span class="n">error_msg</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_magic</span><span class="p">),</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">),</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_max</span><span class="p">),</span>
			<span class="n">max</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_depth</span><span class="p">),</span> <span class="n">depth</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define ext4_ext_check(inode, eh, depth)	\</span>
<span class="cp">	__ext4_ext_check(__func__, __LINE__, inode, eh, depth)</span>

<span class="kt">int</span> <span class="nf">ext4_ext_check_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ext4_ext_check</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext_inode_hdr</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__ext4_ext_check_block</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">function</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">line</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ext4_extent_header</span> <span class="o">*</span><span class="n">eh</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_verified</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ext4_ext_check</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">eh</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">set_buffer_verified</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define ext4_ext_check_block(inode, eh, depth, bh)	\</span>
<span class="cp">	__ext4_ext_check_block(__func__, __LINE__, inode, eh, depth, bh)</span>

<span class="cp">#ifdef EXT_DEBUG</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext4_ext_show_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_depth</span><span class="p">;</span>

	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;path:&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">,</span> <span class="n">path</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_idx</span><span class="p">)</span> <span class="p">{</span>
		  <span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;  %d-&gt;%llu&quot;</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_idx</span><span class="o">-&gt;</span><span class="n">ei_block</span><span class="p">),</span>
			    <span class="n">ext4_idx_pblock</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_idx</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_ext</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;  %d:[%d]%d:%llu &quot;</span><span class="p">,</span>
				  <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_ext</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">),</span>
				  <span class="n">ext4_ext_is_uninitialized</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_ext</span><span class="p">),</span>
				  <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_ext</span><span class="p">),</span>
				  <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_ext</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;  []&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext4_ext_show_leaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ext4_extent_header</span> <span class="o">*</span><span class="n">eh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">eh</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">;</span>
	<span class="n">ex</span> <span class="o">=</span> <span class="n">EXT_FIRST_EXTENT</span><span class="p">(</span><span class="n">eh</span><span class="p">);</span>

	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;Displaying leaf extents for inode %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">ex</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;%d:[%d]%d:%llu &quot;</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">),</span>
			  <span class="n">ext4_ext_is_uninitialized</span><span class="p">(</span><span class="n">ex</span><span class="p">),</span>
			  <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">),</span> <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">ex</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ext4_ext_show_move</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			<span class="n">ext4_fsblk_t</span> <span class="n">newblock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">!=</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ext4_extent_idx</span> <span class="o">*</span><span class="n">idx</span><span class="p">;</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">level</span><span class="p">].</span><span class="n">p_idx</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">EXT_MAX_INDEX</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">level</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;%d: move %d:%llu in new index %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span>
					<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">idx</span><span class="o">-&gt;</span><span class="n">ei_block</span><span class="p">),</span>
					<span class="n">ext4_idx_pblock</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span>
					<span class="n">newblock</span><span class="p">);</span>
			<span class="n">idx</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ex</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ex</span> <span class="o">&lt;=</span> <span class="n">EXT_MAX_EXTENT</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;move %d:%llu:[%d]%d in new leaf %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">),</span>
				<span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">ex</span><span class="p">),</span>
				<span class="n">ext4_ext_is_uninitialized</span><span class="p">(</span><span class="n">ex</span><span class="p">),</span>
				<span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">),</span>
				<span class="n">newblock</span><span class="p">);</span>
		<span class="n">ex</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="cp">#define ext4_ext_show_path(inode, path)</span>
<span class="cp">#define ext4_ext_show_leaf(inode, path)</span>
<span class="cp">#define ext4_ext_show_move(inode, path, newblock, level)</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="nf">ext4_ext_drop_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_depth</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">depth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">path</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_bh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_bh</span><span class="p">);</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">p_bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_ext_binsearch_idx:</span>
<span class="cm"> * binary search for the closest index of the given block</span>
<span class="cm"> * the header must be checked before calling this</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ext4_ext_binsearch_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">ext4_lblk_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_extent_header</span> <span class="o">*</span><span class="n">eh</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_extent_idx</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>


	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;binsearch for %u(idx):  &quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>

	<span class="n">l</span> <span class="o">=</span> <span class="n">EXT_FIRST_INDEX</span><span class="p">(</span><span class="n">eh</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">EXT_LAST_INDEX</span><span class="p">(</span><span class="n">eh</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&lt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">ei_block</span><span class="p">))</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">l</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;%p(%u):%p(%u):%p(%u) &quot;</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">ei_block</span><span class="p">),</span>
				<span class="n">m</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">ei_block</span><span class="p">),</span>
				<span class="n">r</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">ei_block</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">p_idx</span> <span class="o">=</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;  -&gt; %u-&gt;%lld &quot;</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_idx</span><span class="o">-&gt;</span><span class="n">ei_block</span><span class="p">),</span>
		  <span class="n">ext4_idx_pblock</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_idx</span><span class="p">));</span>

<span class="cp">#ifdef CHECK_BINSEARCH</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">ext4_extent_idx</span> <span class="o">*</span><span class="n">chix</span><span class="p">,</span> <span class="o">*</span><span class="n">ix</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">k</span><span class="p">;</span>

		<span class="n">chix</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">=</span> <span class="n">EXT_FIRST_INDEX</span><span class="p">(</span><span class="n">eh</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">);</span> <span class="n">k</span><span class="o">++</span><span class="p">,</span> <span class="n">ix</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		  <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		      <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ix</span><span class="o">-&gt;</span><span class="n">ei_block</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">ei_block</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;k=%d, ix=0x%p, &quot;</span>
				       <span class="s">&quot;first=0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span>
				       <span class="n">ix</span><span class="p">,</span> <span class="n">EXT_FIRST_INDEX</span><span class="p">(</span><span class="n">eh</span><span class="p">));</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%u &lt;= %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ix</span><span class="o">-&gt;</span><span class="n">ei_block</span><span class="p">),</span>
				       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">ei_block</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">k</span> <span class="o">&amp;&amp;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ix</span><span class="o">-&gt;</span><span class="n">ei_block</span><span class="p">)</span>
					   <span class="o">&lt;=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">ei_block</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&lt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ix</span><span class="o">-&gt;</span><span class="n">ei_block</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">chix</span> <span class="o">=</span> <span class="n">ix</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">chix</span> <span class="o">!=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_idx</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_ext_binsearch:</span>
<span class="cm"> * binary search for closest extent of the given block</span>
<span class="cm"> * the header must be checked before calling this</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ext4_ext_binsearch</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">ext4_lblk_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_extent_header</span> <span class="o">*</span><span class="n">eh</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_entries</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * this leaf is empty:</span>
<span class="cm">		 * we get such a leaf in split/add case</span>
<span class="cm">		 */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;binsearch for %u:  &quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>

	<span class="n">l</span> <span class="o">=</span> <span class="n">EXT_FIRST_EXTENT</span><span class="p">(</span><span class="n">eh</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">EXT_LAST_EXTENT</span><span class="p">(</span><span class="n">eh</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&lt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">))</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">l</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;%p(%u):%p(%u):%p(%u) &quot;</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">),</span>
				<span class="n">m</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">),</span>
				<span class="n">r</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">p_ext</span> <span class="o">=</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;  -&gt; %d:%llu:[%d]%d &quot;</span><span class="p">,</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_ext</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">),</span>
			<span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_ext</span><span class="p">),</span>
			<span class="n">ext4_ext_is_uninitialized</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_ext</span><span class="p">),</span>
			<span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_ext</span><span class="p">));</span>

<span class="cp">#ifdef CHECK_BINSEARCH</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">chex</span><span class="p">,</span> <span class="o">*</span><span class="n">ex</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">k</span><span class="p">;</span>

		<span class="n">chex</span> <span class="o">=</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">EXT_FIRST_EXTENT</span><span class="p">(</span><span class="n">eh</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">);</span> <span class="n">k</span><span class="o">++</span><span class="p">,</span> <span class="n">ex</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">k</span> <span class="o">&amp;&amp;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">)</span>
					  <span class="o">&lt;=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">ee_block</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&lt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">chex</span> <span class="o">=</span> <span class="n">ex</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">chex</span> <span class="o">!=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_ext</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ext4_ext_tree_init</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_extent_header</span> <span class="o">*</span><span class="n">eh</span><span class="p">;</span>

	<span class="n">eh</span> <span class="o">=</span> <span class="n">ext_inode_hdr</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_magic</span> <span class="o">=</span> <span class="n">EXT4_EXT_MAGIC</span><span class="p">;</span>
	<span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_max</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ext4_ext_space_root</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">ext4_ext_invalidate_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span>
<span class="nf">ext4_ext_find_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext4_lblk_t</span> <span class="n">block</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_extent_header</span> <span class="o">*</span><span class="n">eh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">short</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ppos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">eh</span> <span class="o">=</span> <span class="n">ext_inode_hdr</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="cm">/* account possible depth increase */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">path</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_ext_path</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span>
				<span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="n">alloc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">p_hdr</span> <span class="o">=</span> <span class="n">eh</span><span class="p">;</span>
	<span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">p_bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">depth</span><span class="p">;</span>
	<span class="cm">/* walk through the tree */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;depth %d: num %d, max %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">ppos</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">),</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_max</span><span class="p">));</span>

		<span class="n">ext4_ext_binsearch_idx</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
		<span class="n">path</span><span class="p">[</span><span class="n">ppos</span><span class="p">].</span><span class="n">p_block</span> <span class="o">=</span> <span class="n">ext4_idx_pblock</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">ppos</span><span class="p">].</span><span class="n">p_idx</span><span class="p">);</span>
		<span class="n">path</span><span class="p">[</span><span class="n">ppos</span><span class="p">].</span><span class="n">p_depth</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">path</span><span class="p">[</span><span class="n">ppos</span><span class="p">].</span><span class="n">p_ext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">path</span><span class="p">[</span><span class="n">ppos</span><span class="p">].</span><span class="n">p_block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh_uptodate_or_lock</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">trace_ext4_ext_load_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span>
						<span class="n">path</span><span class="p">[</span><span class="n">ppos</span><span class="p">].</span><span class="n">p_block</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh_submit_read</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">eh</span> <span class="o">=</span> <span class="n">ext_block_hdr</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">ppos</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ppos</span> <span class="o">&gt;</span> <span class="n">depth</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
					 <span class="s">&quot;ppos %d &gt; depth %d&quot;</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">path</span><span class="p">[</span><span class="n">ppos</span><span class="p">].</span><span class="n">p_bh</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
		<span class="n">path</span><span class="p">[</span><span class="n">ppos</span><span class="p">].</span><span class="n">p_hdr</span> <span class="o">=</span> <span class="n">eh</span><span class="p">;</span>
		<span class="n">i</span><span class="o">--</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ext4_ext_check_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">eh</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bh</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">path</span><span class="p">[</span><span class="n">ppos</span><span class="p">].</span><span class="n">p_depth</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">path</span><span class="p">[</span><span class="n">ppos</span><span class="p">].</span><span class="n">p_ext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">path</span><span class="p">[</span><span class="n">ppos</span><span class="p">].</span><span class="n">p_idx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* find extent */</span>
	<span class="n">ext4_ext_binsearch</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
	<span class="cm">/* if not an empty leaf */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">ppos</span><span class="p">].</span><span class="n">p_ext</span><span class="p">)</span>
		<span class="n">path</span><span class="p">[</span><span class="n">ppos</span><span class="p">].</span><span class="n">p_block</span> <span class="o">=</span> <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">ppos</span><span class="p">].</span><span class="n">p_ext</span><span class="p">);</span>

	<span class="n">ext4_ext_show_path</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">path</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="n">ext4_ext_drop_refs</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_ext_insert_index:</span>
<span class="cm"> * insert new index [@logical;@ptr] into the block at @curp;</span>
<span class="cm"> * check where to insert: before @curp or after @curp</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_ext_insert_index</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">curp</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">logical</span><span class="p">,</span> <span class="n">ext4_fsblk_t</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_extent_idx</span> <span class="o">*</span><span class="n">ix</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_get_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">curp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">logical</span> <span class="o">==</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">curp</span><span class="o">-&gt;</span><span class="n">p_idx</span><span class="o">-&gt;</span><span class="n">ei_block</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
				 <span class="s">&quot;logical %d == ei_block %d!&quot;</span><span class="p">,</span>
				 <span class="n">logical</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">curp</span><span class="o">-&gt;</span><span class="n">p_idx</span><span class="o">-&gt;</span><span class="n">ei_block</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">curp</span><span class="o">-&gt;</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">)</span>
			     <span class="o">&gt;=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">curp</span><span class="o">-&gt;</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_max</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
				 <span class="s">&quot;eh_entries %d &gt;= eh_max %d!&quot;</span><span class="p">,</span>
				 <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">curp</span><span class="o">-&gt;</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">),</span>
				 <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">curp</span><span class="o">-&gt;</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_max</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">logical</span> <span class="o">&gt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">curp</span><span class="o">-&gt;</span><span class="n">p_idx</span><span class="o">-&gt;</span><span class="n">ei_block</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* insert after */</span>
		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;insert new index %d after: %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">logical</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
		<span class="n">ix</span> <span class="o">=</span> <span class="n">curp</span><span class="o">-&gt;</span><span class="n">p_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* insert before */</span>
		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;insert new index %d before: %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">logical</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
		<span class="n">ix</span> <span class="o">=</span> <span class="n">curp</span><span class="o">-&gt;</span><span class="n">p_idx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">EXT_LAST_INDEX</span><span class="p">(</span><span class="n">curp</span><span class="o">-&gt;</span><span class="n">p_hdr</span><span class="p">)</span> <span class="o">-</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;insert new index %d: &quot;</span>
				<span class="s">&quot;move %d indices from 0x%p to 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">logical</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">len</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_extent_idx</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ix</span> <span class="o">&gt;</span> <span class="n">EXT_MAX_INDEX</span><span class="p">(</span><span class="n">curp</span><span class="o">-&gt;</span><span class="n">p_hdr</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="s">&quot;ix &gt; EXT_MAX_INDEX!&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ix</span><span class="o">-&gt;</span><span class="n">ei_block</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">logical</span><span class="p">);</span>
	<span class="n">ext4_idx_store_pblock</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
	<span class="n">le16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curp</span><span class="o">-&gt;</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ix</span> <span class="o">&gt;</span> <span class="n">EXT_LAST_INDEX</span><span class="p">(</span><span class="n">curp</span><span class="o">-&gt;</span><span class="n">p_hdr</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="s">&quot;ix &gt; EXT_LAST_INDEX!&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">curp</span><span class="p">);</span>
	<span class="n">ext4_std_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_ext_split:</span>
<span class="cm"> * inserts new subtree into the path, using free index entry</span>
<span class="cm"> * at depth @at:</span>
<span class="cm"> * - allocates all needed blocks (new leaf and all intermediate index blocks)</span>
<span class="cm"> * - makes decision where to split</span>
<span class="cm"> * - moves remaining extents and index entries (right to the split point)</span>
<span class="cm"> *   into the newly allocated blocks</span>
<span class="cm"> * - initializes subtree</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_ext_split</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">newext</span><span class="p">,</span> <span class="kt">int</span> <span class="n">at</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ext4_extent_header</span> <span class="o">*</span><span class="n">neh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_extent_idx</span> <span class="o">*</span><span class="n">fidx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">at</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">;</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">newblock</span><span class="p">,</span> <span class="n">oldblock</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">border</span><span class="p">;</span>
	<span class="n">ext4_fsblk_t</span> <span class="o">*</span><span class="n">ablocks</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* array of allocated blocks */</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* make decision: where to split? */</span>
	<span class="cm">/* FIXME: now decision is simplest: at current extent */</span>

	<span class="cm">/* if current leaf will be split, then we should use</span>
<span class="cm">	 * border from split point */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span> <span class="o">&gt;</span> <span class="n">EXT_MAX_EXTENT</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="s">&quot;p_ext &gt; EXT_MAX_EXTENT!&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span> <span class="o">!=</span> <span class="n">EXT_MAX_EXTENT</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">border</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">ee_block</span><span class="p">;</span>
		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;leaf will be split.&quot;</span>
				<span class="s">&quot; next leaf starts at %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">border</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">border</span> <span class="o">=</span> <span class="n">newext</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">;</span>
		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;leaf will be added.&quot;</span>
				<span class="s">&quot; next leaf starts at %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">border</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If error occurs, then we break processing</span>
<span class="cm">	 * and mark filesystem read-only. index won&#39;t</span>
<span class="cm">	 * be inserted and tree will be in consistent</span>
<span class="cm">	 * state. Next mount will repair buffers too.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get array to track all allocated blocks.</span>
<span class="cm">	 * We need this to handle errors and free blocks</span>
<span class="cm">	 * upon them.</span>
<span class="cm">	 */</span>
	<span class="n">ablocks</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ext4_fsblk_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">depth</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ablocks</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* allocate all needed blocks */</span>
	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;allocate %d blocks for indexes/leaf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">depth</span> <span class="o">-</span> <span class="n">at</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">depth</span> <span class="o">-</span> <span class="n">at</span><span class="p">;</span> <span class="n">a</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">newblock</span> <span class="o">=</span> <span class="n">ext4_ext_new_meta_block</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
						   <span class="n">newext</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newblock</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="n">ablocks</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">newblock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* initialize new leaf */</span>
	<span class="n">newblock</span> <span class="o">=</span> <span class="n">ablocks</span><span class="p">[</span><span class="o">--</span><span class="n">a</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">newblock</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="s">&quot;newblock == 0!&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">newblock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_journal_get_create_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="n">neh</span> <span class="o">=</span> <span class="n">ext_block_hdr</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">neh</span><span class="o">-&gt;</span><span class="n">eh_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">neh</span><span class="o">-&gt;</span><span class="n">eh_max</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ext4_ext_space_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="n">neh</span><span class="o">-&gt;</span><span class="n">eh_magic</span> <span class="o">=</span> <span class="n">EXT4_EXT_MAGIC</span><span class="p">;</span>
	<span class="n">neh</span><span class="o">-&gt;</span><span class="n">eh_depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* move remainder of path[depth] to the new leaf */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_entries</span> <span class="o">!=</span>
		     <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_max</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="s">&quot;eh_entries %d != eh_max %d!&quot;</span><span class="p">,</span>
				 <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">,</span>
				 <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_max</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* start copy from next extent */</span>
	<span class="n">m</span> <span class="o">=</span> <span class="n">EXT_MAX_EXTENT</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">)</span> <span class="o">-</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="o">++</span><span class="p">;</span>
	<span class="n">ext4_ext_show_move</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">newblock</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">;</span>
		<span class="n">ex</span> <span class="o">=</span> <span class="n">EXT_FIRST_EXTENT</span><span class="p">(</span><span class="n">neh</span><span class="p">);</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_extent</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="p">);</span>
		<span class="n">le16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ext4_extent_block_csum_set</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">neh</span><span class="p">);</span>
	<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_handle_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* correct old leaf */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_get_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">depth</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="n">le16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">,</span> <span class="o">-</span><span class="n">m</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">depth</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="cm">/* create intermediate indexes */</span>
	<span class="n">k</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">-</span> <span class="n">at</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="s">&quot;k %d &lt; 0!&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="p">)</span>
		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;create %d intermediate indices</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
	<span class="cm">/* insert new index into current index block */</span>
	<span class="cm">/* current depth stored in i var */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">k</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">oldblock</span> <span class="o">=</span> <span class="n">newblock</span><span class="p">;</span>
		<span class="n">newblock</span> <span class="o">=</span> <span class="n">ablocks</span><span class="p">[</span><span class="o">--</span><span class="n">a</span><span class="p">];</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">newblock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_journal_get_create_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

		<span class="n">neh</span> <span class="o">=</span> <span class="n">ext_block_hdr</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">neh</span><span class="o">-&gt;</span><span class="n">eh_entries</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">neh</span><span class="o">-&gt;</span><span class="n">eh_magic</span> <span class="o">=</span> <span class="n">EXT4_EXT_MAGIC</span><span class="p">;</span>
		<span class="n">neh</span><span class="o">-&gt;</span><span class="n">eh_max</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ext4_ext_space_block_idx</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
		<span class="n">neh</span><span class="o">-&gt;</span><span class="n">eh_depth</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">depth</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">fidx</span> <span class="o">=</span> <span class="n">EXT_FIRST_INDEX</span><span class="p">(</span><span class="n">neh</span><span class="p">);</span>
		<span class="n">fidx</span><span class="o">-&gt;</span><span class="n">ei_block</span> <span class="o">=</span> <span class="n">border</span><span class="p">;</span>
		<span class="n">ext4_idx_store_pblock</span><span class="p">(</span><span class="n">fidx</span><span class="p">,</span> <span class="n">oldblock</span><span class="p">);</span>

		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;int.index at %d (block %llu): %u -&gt; %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i</span><span class="p">,</span> <span class="n">newblock</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">border</span><span class="p">),</span> <span class="n">oldblock</span><span class="p">);</span>

		<span class="cm">/* move remainder of path[i] to the new index block */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">EXT_MAX_INDEX</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">)</span> <span class="o">!=</span>
					<span class="n">EXT_LAST_INDEX</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
					 <span class="s">&quot;EXT_MAX_INDEX != EXT_LAST_INDEX ee_block %d!&quot;</span><span class="p">,</span>
					 <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_ext</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">));</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* start copy indexes */</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">EXT_MAX_INDEX</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">)</span> <span class="o">-</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_idx</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;cur 0x%p, last 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_idx</span><span class="p">,</span>
				<span class="n">EXT_MAX_INDEX</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">));</span>
		<span class="n">ext4_ext_show_move</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">newblock</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memmove</span><span class="p">(</span><span class="o">++</span><span class="n">fidx</span><span class="p">,</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_idx</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_extent_idx</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="p">);</span>
			<span class="n">le16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ext4_extent_block_csum_set</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">neh</span><span class="p">);</span>
		<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_handle_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* correct old index */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_get_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
			<span class="n">le16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">,</span> <span class="o">-</span><span class="n">m</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">i</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* insert new index */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_insert_index</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">at</span><span class="p">,</span>
				    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">border</span><span class="p">),</span> <span class="n">newblock</span><span class="p">);</span>

<span class="nl">cleanup:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* free all allocated blocks in error case */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">depth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ablocks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">ext4_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ablocks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span>
					 <span class="n">EXT4_FREE_BLOCKS_METADATA</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ablocks</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_ext_grow_indepth:</span>
<span class="cm"> * implements tree growing procedure:</span>
<span class="cm"> * - allocates new block</span>
<span class="cm"> * - moves top-level data (index block or leaf) into the new block</span>
<span class="cm"> * - initializes new top-level, creating index that points to the</span>
<span class="cm"> *   just created block</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_ext_grow_indepth</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">newext</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_extent_header</span> <span class="o">*</span><span class="n">neh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">newblock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">newblock</span> <span class="o">=</span> <span class="n">ext4_ext_new_meta_block</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
		<span class="n">newext</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newblock</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">newblock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">ext4_std_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_journal_get_create_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* move top-level index/leaf into new block */</span>
	<span class="n">memmove</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">));</span>

	<span class="cm">/* set size of new block */</span>
	<span class="n">neh</span> <span class="o">=</span> <span class="n">ext_block_hdr</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="cm">/* old root could have indexes or leaves</span>
<span class="cm">	 * so calculate e_max right way */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">neh</span><span class="o">-&gt;</span><span class="n">eh_max</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ext4_ext_space_block_idx</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">neh</span><span class="o">-&gt;</span><span class="n">eh_max</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ext4_ext_space_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="n">neh</span><span class="o">-&gt;</span><span class="n">eh_magic</span> <span class="o">=</span> <span class="n">EXT4_EXT_MAGIC</span><span class="p">;</span>
	<span class="n">ext4_extent_block_csum_set</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">neh</span><span class="p">);</span>
	<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_handle_dirty_metadata</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Update top-level index: num,max,pointer */</span>
	<span class="n">neh</span> <span class="o">=</span> <span class="n">ext_inode_hdr</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">neh</span><span class="o">-&gt;</span><span class="n">eh_entries</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">ext4_idx_store_pblock</span><span class="p">(</span><span class="n">EXT_FIRST_INDEX</span><span class="p">(</span><span class="n">neh</span><span class="p">),</span> <span class="n">newblock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">eh_depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Root extent block becomes index block */</span>
		<span class="n">neh</span><span class="o">-&gt;</span><span class="n">eh_max</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ext4_ext_space_root_idx</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
		<span class="n">EXT_FIRST_INDEX</span><span class="p">(</span><span class="n">neh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ei_block</span> <span class="o">=</span>
			<span class="n">EXT_FIRST_EXTENT</span><span class="p">(</span><span class="n">neh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;new root: num %d(%d), lblock %d, ptr %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">),</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">eh_max</span><span class="p">),</span>
		  <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">EXT_FIRST_INDEX</span><span class="p">(</span><span class="n">neh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ei_block</span><span class="p">),</span>
		  <span class="n">ext4_idx_pblock</span><span class="p">(</span><span class="n">EXT_FIRST_INDEX</span><span class="p">(</span><span class="n">neh</span><span class="p">)));</span>

	<span class="n">neh</span><span class="o">-&gt;</span><span class="n">eh_depth</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">neh</span><span class="o">-&gt;</span><span class="n">eh_depth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_ext_create_new_leaf:</span>
<span class="cm"> * finds empty index and adds new leaf.</span>
<span class="cm"> * if no free index is found, then it requests in-depth growing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_ext_create_new_leaf</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">newext</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">curp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">repeat:</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="cm">/* walk up to the tree and look for free index entry */</span>
	<span class="n">curp</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="n">depth</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">EXT_HAS_FREE_INDEX</span><span class="p">(</span><span class="n">curp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">i</span><span class="o">--</span><span class="p">;</span>
		<span class="n">curp</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we use already allocated block for index block,</span>
<span class="cm">	 * so subsequent data blocks should be contiguous */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EXT_HAS_FREE_INDEX</span><span class="p">(</span><span class="n">curp</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* if we found index with free entry, then use that</span>
<span class="cm">		 * entry: create all needed subtree and add new leaf */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_split</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">newext</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* refill path */</span>
		<span class="n">ext4_ext_drop_refs</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">path</span> <span class="o">=</span> <span class="n">ext4_ext_find_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
				    <span class="p">(</span><span class="n">ext4_lblk_t</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">newext</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">),</span>
				    <span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* tree is full, time to grow in depth */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_grow_indepth</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">newext</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* refill path */</span>
		<span class="n">ext4_ext_drop_refs</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">path</span> <span class="o">=</span> <span class="n">ext4_ext_find_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">ext4_lblk_t</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">newext</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">),</span>
				    <span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">path</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * only first (depth 0 -&gt; 1) produces free space;</span>
<span class="cm">		 * in all other cases we have to split the grown tree</span>
<span class="cm">		 */</span>
		<span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_entries</span> <span class="o">==</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_max</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* now we need to split */</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * search the closest allocated block to the left for *logical</span>
<span class="cm"> * and returns it at @logical + it&#39;s physical address at @phys</span>
<span class="cm"> * if *logical is the smallest allocated block, the function</span>
<span class="cm"> * returns 0 at @phys</span>
<span class="cm"> * return value contains 0 (success) or error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_ext_search_left</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				<span class="n">ext4_lblk_t</span> <span class="o">*</span><span class="n">logical</span><span class="p">,</span> <span class="n">ext4_fsblk_t</span> <span class="o">*</span><span class="n">phys</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_extent_idx</span> <span class="o">*</span><span class="n">ix</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="n">ee_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">path</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="s">&quot;path == NULL *logical %d!&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">logical</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">depth</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_depth</span><span class="p">;</span>
	<span class="o">*</span><span class="n">phys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_ext</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* usually extent in the path covers blocks smaller</span>
<span class="cm">	 * then *logical, but it can be that extent is the</span>
<span class="cm">	 * first one in the file */</span>

	<span class="n">ex</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="p">;</span>
	<span class="n">ee_len</span> <span class="o">=</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">logical</span> <span class="o">&lt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">EXT_FIRST_EXTENT</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ex</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
					 <span class="s">&quot;EXT_FIRST_EXTENT != ex *logical %d ee_block %d!&quot;</span><span class="p">,</span>
					 <span class="o">*</span><span class="n">logical</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">depth</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ix</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_idx</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ix</span> <span class="o">!=</span> <span class="n">EXT_FIRST_INDEX</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
				  <span class="s">&quot;ix (%d) != EXT_FIRST_INDEX (%d) (depth %d)!&quot;</span><span class="p">,</span>
				  <span class="n">ix</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ix</span><span class="o">-&gt;</span><span class="n">ei_block</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
				  <span class="n">EXT_FIRST_INDEX</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">?</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">EXT_FIRST_INDEX</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ei_block</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
				  <span class="n">depth</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">*</span><span class="n">logical</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">)</span> <span class="o">+</span> <span class="n">ee_len</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
				 <span class="s">&quot;logical %d &lt; ee_block %d + ee_len %d!&quot;</span><span class="p">,</span>
				 <span class="o">*</span><span class="n">logical</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">),</span> <span class="n">ee_len</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">logical</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">)</span> <span class="o">+</span> <span class="n">ee_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="o">*</span><span class="n">phys</span> <span class="o">=</span> <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span> <span class="o">+</span> <span class="n">ee_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * search the closest allocated block to the right for *logical</span>
<span class="cm"> * and returns it at @logical + it&#39;s physical address at @phys</span>
<span class="cm"> * if *logical is the largest allocated block, the function</span>
<span class="cm"> * returns 0 at @phys</span>
<span class="cm"> * return value contains 0 (success) or error code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_ext_search_right</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				 <span class="n">ext4_lblk_t</span> <span class="o">*</span><span class="n">logical</span><span class="p">,</span> <span class="n">ext4_fsblk_t</span> <span class="o">*</span><span class="n">phys</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">**</span><span class="n">ret_ex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_extent_header</span> <span class="o">*</span><span class="n">eh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_extent_idx</span> <span class="o">*</span><span class="n">ix</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">;</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">block</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>	<span class="cm">/* Note, NOT eh_depth; depth from top of tree */</span>
	<span class="kt">int</span> <span class="n">ee_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">path</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="s">&quot;path == NULL *logical %d!&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">logical</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">depth</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_depth</span><span class="p">;</span>
	<span class="o">*</span><span class="n">phys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_ext</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* usually extent in the path covers blocks smaller</span>
<span class="cm">	 * then *logical, but it can be that extent is the</span>
<span class="cm">	 * first one in the file */</span>

	<span class="n">ex</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="p">;</span>
	<span class="n">ee_len</span> <span class="o">=</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">logical</span> <span class="o">&lt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">EXT_FIRST_EXTENT</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ex</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
					 <span class="s">&quot;first_extent(path[%d].p_hdr) != ex&quot;</span><span class="p">,</span>
					 <span class="n">depth</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">depth</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ix</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_idx</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ix</span> <span class="o">!=</span> <span class="n">EXT_FIRST_INDEX</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
						 <span class="s">&quot;ix != EXT_FIRST_INDEX *logical %d!&quot;</span><span class="p">,</span>
						 <span class="o">*</span><span class="n">logical</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">found_extent</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">*</span><span class="n">logical</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">)</span> <span class="o">+</span> <span class="n">ee_len</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
				 <span class="s">&quot;logical %d &lt; ee_block %d + ee_len %d!&quot;</span><span class="p">,</span>
				 <span class="o">*</span><span class="n">logical</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">),</span> <span class="n">ee_len</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ex</span> <span class="o">!=</span> <span class="n">EXT_LAST_EXTENT</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* next allocated block in this leaf */</span>
		<span class="n">ex</span><span class="o">++</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">found_extent</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* go up and search for index to the right */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">depth</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ix</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_idx</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ix</span> <span class="o">!=</span> <span class="n">EXT_LAST_INDEX</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">got_index</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we&#39;ve gone up to the root and found no index to the right */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">got_index:</span>
	<span class="cm">/* we&#39;ve found index to the right, let&#39;s</span>
<span class="cm">	 * follow it and find the closest allocated</span>
<span class="cm">	 * block to the right */</span>
	<span class="n">ix</span><span class="o">++</span><span class="p">;</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">ext4_idx_pblock</span><span class="p">(</span><span class="n">ix</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">depth</span> <span class="o">&lt;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_depth</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_bread</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">eh</span> <span class="o">=</span> <span class="n">ext_block_hdr</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="cm">/* subtract from p_depth to get proper eh_depth */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext4_ext_check_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">eh</span><span class="p">,</span>
					 <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_depth</span> <span class="o">-</span> <span class="n">depth</span><span class="p">,</span> <span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ix</span> <span class="o">=</span> <span class="n">EXT_FIRST_INDEX</span><span class="p">(</span><span class="n">eh</span><span class="p">);</span>
		<span class="n">block</span> <span class="o">=</span> <span class="n">ext4_idx_pblock</span><span class="p">(</span><span class="n">ix</span><span class="p">);</span>
		<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_bread</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">eh</span> <span class="o">=</span> <span class="n">ext_block_hdr</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_ext_check_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">eh</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_depth</span> <span class="o">-</span> <span class="n">depth</span><span class="p">,</span> <span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ex</span> <span class="o">=</span> <span class="n">EXT_FIRST_EXTENT</span><span class="p">(</span><span class="n">eh</span><span class="p">);</span>
<span class="nl">found_extent:</span>
	<span class="o">*</span><span class="n">logical</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">);</span>
	<span class="o">*</span><span class="n">phys</span> <span class="o">=</span> <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
	<span class="o">*</span><span class="n">ret_ex</span> <span class="o">=</span> <span class="n">ex</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span>
		<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_ext_next_allocated_block:</span>
<span class="cm"> * returns allocated block in subsequent extent or EXT_MAX_BLOCKS.</span>
<span class="cm"> * NOTE: it considers block number from index entry as</span>
<span class="cm"> * allocated block. Thus, index entries have to be consistent</span>
<span class="cm"> * with leaves.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ext4_lblk_t</span>
<span class="nf">ext4_ext_next_allocated_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">path</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">depth</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_depth</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_ext</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EXT_MAX_BLOCKS</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_depth</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* leaf */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span> <span class="o">&amp;&amp;</span>
				<span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span> <span class="o">!=</span>
					<span class="n">EXT_LAST_EXTENT</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">))</span>
			  <span class="k">return</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">ee_block</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* index */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_idx</span> <span class="o">!=</span>
					<span class="n">EXT_LAST_INDEX</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">))</span>
			  <span class="k">return</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">ei_block</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">depth</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">EXT_MAX_BLOCKS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_ext_next_leaf_block:</span>
<span class="cm"> * returns first allocated block from next leaf or EXT_MAX_BLOCKS</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">ext4_lblk_t</span> <span class="nf">ext4_ext_next_leaf_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">path</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">depth</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_depth</span><span class="p">;</span>

	<span class="cm">/* zero-tree has no leaf blocks at all */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EXT_MAX_BLOCKS</span><span class="p">;</span>

	<span class="cm">/* go to index block */</span>
	<span class="n">depth</span><span class="o">--</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_idx</span> <span class="o">!=</span>
				<span class="n">EXT_LAST_INDEX</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">))</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">ext4_lblk_t</span><span class="p">)</span>
				<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">ei_block</span><span class="p">);</span>
		<span class="n">depth</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">EXT_MAX_BLOCKS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_ext_correct_indexes:</span>
<span class="cm"> * if leaf gets modified and modified extent is first in the leaf,</span>
<span class="cm"> * then we have to correct all indexes above.</span>
<span class="cm"> * TODO: do we need to correct tree in all cases?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_ext_correct_indexes</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_extent_header</span> <span class="o">*</span><span class="n">eh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">border</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">eh</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">;</span>
	<span class="n">ex</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ex</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">eh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
				 <span class="s">&quot;ex %p == NULL or eh %p == NULL&quot;</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span> <span class="n">eh</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* there is no tree at all */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ex</span> <span class="o">!=</span> <span class="n">EXT_FIRST_EXTENT</span><span class="p">(</span><span class="n">eh</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* we correct tree if first leaf got modified only */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * TODO: we need correction if border is smaller than current one</span>
<span class="cm">	 */</span>
	<span class="n">k</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">border</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_get_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">k</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">path</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">p_idx</span><span class="o">-&gt;</span><span class="n">ei_block</span> <span class="o">=</span> <span class="n">border</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">k</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">k</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* change all left-side indexes */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">p_idx</span> <span class="o">!=</span> <span class="n">EXT_FIRST_INDEX</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_get_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">k</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">path</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">p_idx</span><span class="o">-&gt;</span><span class="n">ei_block</span> <span class="o">=</span> <span class="n">border</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">k</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">ext4_can_extents_be_merged</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex1</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ext1_ee_len</span><span class="p">,</span> <span class="n">ext2_ee_len</span><span class="p">,</span> <span class="n">max_len</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure that either both extents are uninitialized, or</span>
<span class="cm">	 * both are _not_.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_ext_is_uninitialized</span><span class="p">(</span><span class="n">ex1</span><span class="p">)</span> <span class="o">^</span> <span class="n">ext4_ext_is_uninitialized</span><span class="p">(</span><span class="n">ex2</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_ext_is_uninitialized</span><span class="p">(</span><span class="n">ex1</span><span class="p">))</span>
		<span class="n">max_len</span> <span class="o">=</span> <span class="n">EXT_UNINIT_MAX_LEN</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">max_len</span> <span class="o">=</span> <span class="n">EXT_INIT_MAX_LEN</span><span class="p">;</span>

	<span class="n">ext1_ee_len</span> <span class="o">=</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex1</span><span class="p">);</span>
	<span class="n">ext2_ee_len</span> <span class="o">=</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex1</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">)</span> <span class="o">+</span> <span class="n">ext1_ee_len</span> <span class="o">!=</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex2</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * To allow future support for preallocated extents to be added</span>
<span class="cm">	 * as an RO_COMPAT feature, refuse to merge to extents if</span>
<span class="cm">	 * this can result in the top bit of ee_len being set.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext1_ee_len</span> <span class="o">+</span> <span class="n">ext2_ee_len</span> <span class="o">&gt;</span> <span class="n">max_len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef AGGRESSIVE_TEST</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext1_ee_len</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">ex1</span><span class="p">)</span> <span class="o">+</span> <span class="n">ext1_ee_len</span> <span class="o">==</span> <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">ex2</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function tries to merge the &quot;ex&quot; extent to the next extent in the tree.</span>
<span class="cm"> * It always tries to merge towards right. If you want to merge towards</span>
<span class="cm"> * left, pass &quot;ex - 1&quot; as argument instead of &quot;ex&quot;.</span>
<span class="cm"> * Returns 0 if the extents (ex and ex+1) were _not_ merged and returns</span>
<span class="cm"> * 1 if they got merged.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_ext_try_to_merge_right</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_extent_header</span> <span class="o">*</span><span class="n">eh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">merge_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">uninitialized</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">eh</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">ex</span> <span class="o">&lt;</span> <span class="n">EXT_LAST_EXTENT</span><span class="p">(</span><span class="n">eh</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext4_can_extents_be_merged</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span> <span class="n">ex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* merge with next extent! */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext4_ext_is_uninitialized</span><span class="p">(</span><span class="n">ex</span><span class="p">))</span>
			<span class="n">uninitialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_len</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
				<span class="o">+</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uninitialized</span><span class="p">)</span>
			<span class="n">ext4_ext_mark_uninitialized</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ex</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">EXT_LAST_EXTENT</span><span class="p">(</span><span class="n">eh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">EXT_LAST_EXTENT</span><span class="p">(</span><span class="n">eh</span><span class="p">)</span> <span class="o">-</span> <span class="n">ex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				<span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_extent</span><span class="p">);</span>
			<span class="n">memmove</span><span class="p">(</span><span class="n">ex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ex</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">le16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">merge_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_entries</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">)</span>
			<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="s">&quot;eh-&gt;eh_entries = 0!&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">merge_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function tries to merge the @ex extent to neighbours in the tree.</span>
<span class="cm"> * return 1 if merge left else 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_ext_try_to_merge</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_extent_header</span> <span class="o">*</span><span class="n">eh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">merge_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">eh</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ex</span> <span class="o">&gt;</span> <span class="n">EXT_FIRST_EXTENT</span><span class="p">(</span><span class="n">eh</span><span class="p">))</span>
		<span class="n">merge_done</span> <span class="o">=</span> <span class="n">ext4_ext_try_to_merge_right</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">ex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">merge_done</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ext4_ext_try_to_merge_right</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">ex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * check if a portion of the &quot;newext&quot; extent overlaps with an</span>
<span class="cm"> * existing extent.</span>
<span class="cm"> *</span>
<span class="cm"> * If there is an overlap discovered, it updates the length of the newext</span>
<span class="cm"> * such that there will be no overlap, and then returns 1.</span>
<span class="cm"> * If there is no overlap found, it returns 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ext4_ext_check_overlap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">newext</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext4_lblk_t</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="n">len1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">b1</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">newext</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">);</span>
	<span class="n">len1</span> <span class="o">=</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">newext</span><span class="p">);</span>
	<span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">b2</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">);</span>
	<span class="n">b2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cluster_ratio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * get the next allocated block if the extent in the path</span>
<span class="cm">	 * is before the requested block(s)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">b2</span> <span class="o">&lt;</span> <span class="n">b1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">b2</span> <span class="o">=</span> <span class="n">ext4_ext_next_allocated_block</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">b2</span> <span class="o">==</span> <span class="n">EXT_MAX_BLOCKS</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">b2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cluster_ratio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* check for wrap through zero on extent logical start block*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">b1</span> <span class="o">+</span> <span class="n">len1</span> <span class="o">&lt;</span> <span class="n">b1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len1</span> <span class="o">=</span> <span class="n">EXT_MAX_BLOCKS</span> <span class="o">-</span> <span class="n">b1</span><span class="p">;</span>
		<span class="n">newext</span><span class="o">-&gt;</span><span class="n">ee_len</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">len1</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check for overlap */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">b1</span> <span class="o">+</span> <span class="n">len1</span> <span class="o">&gt;</span> <span class="n">b2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">newext</span><span class="o">-&gt;</span><span class="n">ee_len</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">b2</span> <span class="o">-</span> <span class="n">b1</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_ext_insert_extent:</span>
<span class="cm"> * tries to merge requsted extent into the existing extent or</span>
<span class="cm"> * inserts requested extent as new one into the tree,</span>
<span class="cm"> * creating new leaf in the no-space case.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ext4_ext_insert_extent</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">newext</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_extent_header</span> <span class="o">*</span><span class="n">eh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">,</span> <span class="o">*</span><span class="n">fex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">nearex</span><span class="p">;</span> <span class="cm">/* nearest extent */</span>
	<span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">npath</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">uninitialized</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">newext</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="s">&quot;ext4_ext_get_actual_len(newext) == 0&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ex</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="s">&quot;path[%d].p_hdr == NULL&quot;</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* try to insert block into found extent and return */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ex</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_PRE_IO</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="n">ext4_can_extents_be_merged</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span> <span class="n">newext</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;append [%d]%d block to %u:[%d]%d (from %llu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">ext4_ext_is_uninitialized</span><span class="p">(</span><span class="n">newext</span><span class="p">),</span>
			  <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">newext</span><span class="p">),</span>
			  <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">),</span>
			  <span class="n">ext4_ext_is_uninitialized</span><span class="p">(</span><span class="n">ex</span><span class="p">),</span>
			  <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">),</span>
			  <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">ex</span><span class="p">));</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_get_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">depth</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * ext4_can_extents_be_merged should have checked that either</span>
<span class="cm">		 * both extents are uninitialized, or both aren&#39;t. Thus we</span>
<span class="cm">		 * need to check only one of them here.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext4_ext_is_uninitialized</span><span class="p">(</span><span class="n">ex</span><span class="p">))</span>
			<span class="n">uninitialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_len</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
					<span class="o">+</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">newext</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uninitialized</span><span class="p">)</span>
			<span class="n">ext4_ext_mark_uninitialized</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
		<span class="n">eh</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">;</span>
		<span class="n">nearex</span> <span class="o">=</span> <span class="n">ex</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">merge</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">eh</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_max</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">has_space</span><span class="p">;</span>

	<span class="cm">/* probably next leaf has space for us? */</span>
	<span class="n">fex</span> <span class="o">=</span> <span class="n">EXT_LAST_EXTENT</span><span class="p">(</span><span class="n">eh</span><span class="p">);</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">EXT_MAX_BLOCKS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">newext</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">fex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">))</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">ext4_ext_next_leaf_block</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="n">EXT_MAX_BLOCKS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;next leaf block - %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">npath</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">npath</span> <span class="o">=</span> <span class="n">ext4_ext_find_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">npath</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">npath</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">npath</span><span class="o">-&gt;</span><span class="n">p_depth</span> <span class="o">!=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_depth</span><span class="p">);</span>
		<span class="n">eh</span> <span class="o">=</span> <span class="n">npath</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_max</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;next leaf isn&#39;t full(%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">));</span>
			<span class="n">path</span> <span class="o">=</span> <span class="n">npath</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">has_space</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;next leaf has no free space(%d,%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">),</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_max</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * There is no free space in the found leaf.</span>
<span class="cm">	 * We&#39;re gonna add a new leaf in the tree.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_PUNCH_OUT_EXT</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">EXT4_MB_USE_ROOT_BLOCKS</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_create_new_leaf</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">newext</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">eh</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">;</span>

<span class="nl">has_space:</span>
	<span class="n">nearex</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_get_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">depth</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nearex</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* there is no extent in this leaf, create first one */</span>
		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;first extent in the leaf: %u:%llu:[%d]%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">newext</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">),</span>
				<span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">newext</span><span class="p">),</span>
				<span class="n">ext4_ext_is_uninitialized</span><span class="p">(</span><span class="n">newext</span><span class="p">),</span>
				<span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">newext</span><span class="p">));</span>
		<span class="n">nearex</span> <span class="o">=</span> <span class="n">EXT_FIRST_EXTENT</span><span class="p">(</span><span class="n">eh</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">newext</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">)</span>
			   <span class="o">&gt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">nearex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Insert after */</span>
			<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;insert %u:%llu:[%d]%d before: &quot;</span>
					<span class="s">&quot;nearest %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">newext</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">),</span>
					<span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">newext</span><span class="p">),</span>
					<span class="n">ext4_ext_is_uninitialized</span><span class="p">(</span><span class="n">newext</span><span class="p">),</span>
					<span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">newext</span><span class="p">),</span>
					<span class="n">nearex</span><span class="p">);</span>
			<span class="n">nearex</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Insert before */</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">newext</span><span class="o">-&gt;</span><span class="n">ee_block</span> <span class="o">==</span> <span class="n">nearex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">);</span>
			<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;insert %u:%llu:[%d]%d after: &quot;</span>
					<span class="s">&quot;nearest %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">newext</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">),</span>
					<span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">newext</span><span class="p">),</span>
					<span class="n">ext4_ext_is_uninitialized</span><span class="p">(</span><span class="n">newext</span><span class="p">),</span>
					<span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">newext</span><span class="p">),</span>
					<span class="n">nearex</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">EXT_LAST_EXTENT</span><span class="p">(</span><span class="n">eh</span><span class="p">)</span> <span class="o">-</span> <span class="n">nearex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;insert %u:%llu:[%d]%d: &quot;</span>
					<span class="s">&quot;move %d extents from 0x%p to 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">newext</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">),</span>
					<span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">newext</span><span class="p">),</span>
					<span class="n">ext4_ext_is_uninitialized</span><span class="p">(</span><span class="n">newext</span><span class="p">),</span>
					<span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">newext</span><span class="p">),</span>
					<span class="n">len</span><span class="p">,</span> <span class="n">nearex</span><span class="p">,</span> <span class="n">nearex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">memmove</span><span class="p">(</span><span class="n">nearex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nearex</span><span class="p">,</span>
				<span class="n">len</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_extent</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">le16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span> <span class="o">=</span> <span class="n">nearex</span><span class="p">;</span>
	<span class="n">nearex</span><span class="o">-&gt;</span><span class="n">ee_block</span> <span class="o">=</span> <span class="n">newext</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">;</span>
	<span class="n">ext4_ext_store_pblock</span><span class="p">(</span><span class="n">nearex</span><span class="p">,</span> <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">newext</span><span class="p">));</span>
	<span class="n">nearex</span><span class="o">-&gt;</span><span class="n">ee_len</span> <span class="o">=</span> <span class="n">newext</span><span class="o">-&gt;</span><span class="n">ee_len</span><span class="p">;</span>

<span class="nl">merge:</span>
	<span class="cm">/* try to merge extents to the right */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_PRE_IO</span><span class="p">))</span>
		<span class="n">ext4_ext_try_to_merge</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">nearex</span><span class="p">);</span>

	<span class="cm">/* try to merge extents to the left */</span>

	<span class="cm">/* time to correct all indexes above */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_correct_indexes</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">depth</span><span class="p">);</span>

<span class="nl">cleanup:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">npath</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext4_ext_drop_refs</span><span class="p">(</span><span class="n">npath</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">npath</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ext4_ext_invalidate_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ext4_ext_walk_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext4_lblk_t</span> <span class="n">block</span><span class="p">,</span>
			       <span class="n">ext4_lblk_t</span> <span class="n">num</span><span class="p">,</span> <span class="n">ext_prepare_callback</span> <span class="n">func</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">*</span><span class="n">cbdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_ext_cache</span> <span class="n">cbex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span> <span class="n">next</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span> <span class="n">last</span> <span class="o">=</span> <span class="n">block</span> <span class="o">+</span> <span class="n">num</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="n">exists</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">func</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">inode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">block</span> <span class="o">&lt;</span> <span class="n">last</span> <span class="o">&amp;&amp;</span> <span class="n">block</span> <span class="o">!=</span> <span class="n">EXT_MAX_BLOCKS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">num</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">block</span><span class="p">;</span>
		<span class="cm">/* find extent for this block */</span>
		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data_sem</span><span class="p">);</span>
		<span class="n">path</span> <span class="o">=</span> <span class="n">ext4_ext_find_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data_sem</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">path</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="n">path</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="s">&quot;path[%d].p_hdr == NULL&quot;</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ex</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">ext4_ext_next_allocated_block</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

		<span class="n">exists</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* there is no extent yet, so try to allocate</span>
<span class="cm">			 * all requested space */</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">block</span> <span class="o">+</span> <span class="n">num</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">block</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* need to allocate space before found extent */</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">+</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
				<span class="n">end</span> <span class="o">=</span> <span class="n">block</span> <span class="o">+</span> <span class="n">num</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">)</span>
					<span class="o">+</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* need to allocate space after found extent */</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">block</span> <span class="o">+</span> <span class="n">num</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;=</span> <span class="n">next</span><span class="p">)</span>
				<span class="n">end</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * some part of requested space is covered</span>
<span class="cm">			 * by found extent</span>
<span class="cm">			 */</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">)</span>
				<span class="o">+</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">+</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
				<span class="n">end</span> <span class="o">=</span> <span class="n">block</span> <span class="o">+</span> <span class="n">num</span><span class="p">;</span>
			<span class="n">exists</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exists</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cbex</span><span class="p">.</span><span class="n">ec_block</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
			<span class="n">cbex</span><span class="p">.</span><span class="n">ec_len</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
			<span class="n">cbex</span><span class="p">.</span><span class="n">ec_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cbex</span><span class="p">.</span><span class="n">ec_block</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">);</span>
			<span class="n">cbex</span><span class="p">.</span><span class="n">ec_len</span> <span class="o">=</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
			<span class="n">cbex</span><span class="p">.</span><span class="n">ec_start</span> <span class="o">=</span> <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cbex</span><span class="p">.</span><span class="n">ec_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="s">&quot;cbex.ec_len == 0&quot;</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cbex</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span> <span class="n">cbdata</span><span class="p">);</span>
		<span class="n">ext4_ext_drop_refs</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">EXT_REPEAT</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">EXT_BREAK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">!=</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* depth was changed. we have to realloc path */</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="n">path</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">block</span> <span class="o">=</span> <span class="n">cbex</span><span class="p">.</span><span class="n">ec_block</span> <span class="o">+</span> <span class="n">cbex</span><span class="p">.</span><span class="n">ec_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext4_ext_drop_refs</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ext4_ext_put_in_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext4_lblk_t</span> <span class="n">block</span><span class="p">,</span>
			<span class="n">__u32</span> <span class="n">len</span><span class="p">,</span> <span class="n">ext4_fsblk_t</span> <span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_ext_cache</span> <span class="o">*</span><span class="n">cex</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_block_reservation_lock</span><span class="p">);</span>
	<span class="n">trace_ext4_ext_put_in_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">cex</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_cached_extent</span><span class="p">;</span>
	<span class="n">cex</span><span class="o">-&gt;</span><span class="n">ec_block</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
	<span class="n">cex</span><span class="o">-&gt;</span><span class="n">ec_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">cex</span><span class="o">-&gt;</span><span class="n">ec_start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_block_reservation_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_ext_put_gap_in_cache:</span>
<span class="cm"> * calculate boundaries of the gap that the requested block fits into</span>
<span class="cm"> * and cache this gap</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ext4_ext_put_gap_in_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				<span class="n">ext4_lblk_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span> <span class="n">lblock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">;</span>

	<span class="n">ex</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ex</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* there is no extent yet, so gap is [0;-] */</span>
		<span class="n">lblock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">EXT_MAX_BLOCKS</span><span class="p">;</span>
		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;cache gap(whole file):&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&lt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lblock</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">)</span> <span class="o">-</span> <span class="n">block</span><span class="p">;</span>
		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;cache gap(before): %u [%u:%u]&quot;</span><span class="p">,</span>
				<span class="n">block</span><span class="p">,</span>
				<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">),</span>
				 <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">)</span>
			<span class="o">+</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext4_lblk_t</span> <span class="n">next</span><span class="p">;</span>
		<span class="n">lblock</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">)</span>
			<span class="o">+</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>

		<span class="n">next</span> <span class="o">=</span> <span class="n">ext4_ext_next_allocated_block</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;cache gap(after): [%u:%u] %u&quot;</span><span class="p">,</span>
				<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">),</span>
				<span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">),</span>
				<span class="n">block</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="n">lblock</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">next</span> <span class="o">-</span> <span class="n">lblock</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lblock</span> <span class="o">=</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot; -&gt; %u:%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lblock</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">ext4_ext_put_in_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">lblock</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_ext_check_cache()</span>
<span class="cm"> * Checks to see if the given block is in the cache.</span>
<span class="cm"> * If it is, the cached extent is stored in the given</span>
<span class="cm"> * cache extent pointer.  If the cached extent is a hole,</span>
<span class="cm"> * this routine should be used instead of</span>
<span class="cm"> * ext4_ext_in_cache if the calling function needs to</span>
<span class="cm"> * know the size of the hole.</span>
<span class="cm"> *</span>
<span class="cm"> * @inode: The files inode</span>
<span class="cm"> * @block: The block to look for in the cache</span>
<span class="cm"> * @ex:    Pointer where the cached extent will be stored</span>
<span class="cm"> *         if it contains block</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if cache is invalid; 1 if the cache is valid</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ext4_ext_check_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext4_lblk_t</span> <span class="n">block</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ext4_ext_cache</span> <span class="o">*</span><span class="n">ex</span><span class="p">){</span>
	<span class="k">struct</span> <span class="n">ext4_ext_cache</span> <span class="o">*</span><span class="n">cex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We borrow i_block_reservation_lock to protect i_cached_extent</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_block_reservation_lock</span><span class="p">);</span>
	<span class="n">cex</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_cached_extent</span><span class="p">;</span>
	<span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="cm">/* has cache valid data? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cex</span><span class="o">-&gt;</span><span class="n">ec_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_range</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">cex</span><span class="o">-&gt;</span><span class="n">ec_block</span><span class="p">,</span> <span class="n">cex</span><span class="o">-&gt;</span><span class="n">ec_len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="n">cex</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_ext_cache</span><span class="p">));</span>
		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;%u cached by %u:%u:%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">block</span><span class="p">,</span>
				<span class="n">cex</span><span class="o">-&gt;</span><span class="n">ec_block</span><span class="p">,</span> <span class="n">cex</span><span class="o">-&gt;</span><span class="n">ec_len</span><span class="p">,</span> <span class="n">cex</span><span class="o">-&gt;</span><span class="n">ec_start</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">errout:</span>
	<span class="n">trace_ext4_ext_in_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_block_reservation_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_ext_in_cache()</span>
<span class="cm"> * Checks to see if the given block is in the cache.</span>
<span class="cm"> * If it is, the cached extent is stored in the given</span>
<span class="cm"> * extent pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * @inode: The files inode</span>
<span class="cm"> * @block: The block to look for in the cache</span>
<span class="cm"> * @ex:    Pointer where the cached extent will be stored</span>
<span class="cm"> *         if it contains block</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if cache is invalid; 1 if the cache is valid</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="n">ext4_ext_in_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext4_lblk_t</span> <span class="n">block</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_ext_cache</span> <span class="n">cex</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_ext_check_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cex</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">cex</span><span class="p">.</span><span class="n">ec_block</span><span class="p">);</span>
		<span class="n">ext4_ext_store_pblock</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="n">cex</span><span class="p">.</span><span class="n">ec_start</span><span class="p">);</span>
		<span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_len</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">cex</span><span class="p">.</span><span class="n">ec_len</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * ext4_ext_rm_idx:</span>
<span class="cm"> * removes index from the index block.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ext4_ext_rm_idx</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">leaf</span><span class="p">;</span>

	<span class="cm">/* free index block */</span>
	<span class="n">path</span><span class="o">--</span><span class="p">;</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">ext4_idx_pblock</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_idx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_entries</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="s">&quot;path-&gt;p_hdr-&gt;eh_entries == 0&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_get_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_idx</span> <span class="o">!=</span> <span class="n">EXT_LAST_INDEX</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_hdr</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">EXT_LAST_INDEX</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_hdr</span><span class="p">)</span> <span class="o">-</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_idx</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">*=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_extent_idx</span><span class="p">);</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_idx</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">le16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;index is empty, remove it, free block %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">leaf</span><span class="p">);</span>
	<span class="n">trace_ext4_ext_rm_idx</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">leaf</span><span class="p">);</span>

	<span class="n">ext4_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			 <span class="n">EXT4_FREE_BLOCKS_METADATA</span> <span class="o">|</span> <span class="n">EXT4_FREE_BLOCKS_FORGET</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_ext_calc_credits_for_single_extent:</span>
<span class="cm"> * This routine returns max. credits that needed to insert an extent</span>
<span class="cm"> * to the extent tree.</span>
<span class="cm"> * When pass the actual path, the caller should calculate credits</span>
<span class="cm"> * under i_data_sem.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ext4_ext_calc_credits_for_single_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nrblocks</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* probably there is space in leaf? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">)</span>
				<span class="o">&lt;</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_max</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/*</span>
<span class="cm">			 *  There are some space in the leaf tree, no</span>
<span class="cm">			 *  need to account for leaf block credit</span>
<span class="cm">			 *</span>
<span class="cm">			 *  bitmaps and block group descriptor blocks</span>
<span class="cm">			 *  and other metadata blocks still need to be</span>
<span class="cm">			 *  accounted.</span>
<span class="cm">			 */</span>
			<span class="cm">/* 1 bitmap, 1 block group descriptor */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">EXT4_META_TRANS_BLOCKS</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ext4_chunk_trans_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">nrblocks</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * How many index/leaf blocks need to change/allocate to modify nrblocks?</span>
<span class="cm"> *</span>
<span class="cm"> * if nrblocks are fit in a single extent (chunk flag is 1), then</span>
<span class="cm"> * in the worse case, each tree level index/leaf need to be changed</span>
<span class="cm"> * if the tree split due to insert a new extent, then the old tree</span>
<span class="cm"> * index/leaf need to be updated too</span>
<span class="cm"> *</span>
<span class="cm"> * If the nrblocks are discontiguous, they could cause</span>
<span class="cm"> * the whole tree split more than once, but this is really rare.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ext4_ext_index_trans_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nrblocks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ext4_remove_blocks</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">,</span>
			      <span class="n">ext4_fsblk_t</span> <span class="o">*</span><span class="n">partial_cluster</span><span class="p">,</span>
			      <span class="n">ext4_lblk_t</span> <span class="n">from</span><span class="p">,</span> <span class="n">ext4_lblk_t</span> <span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ee_len</span> <span class="o">=</span>  <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">pblk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">EXT4_FREE_BLOCKS_FORGET</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">EXT4_FREE_BLOCKS_METADATA</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * For bigalloc file systems, we never free a partial cluster</span>
<span class="cm">	 * at the beginning of the extent.  Instead, we make a note</span>
<span class="cm">	 * that we tried freeing the cluster, and check to see if we</span>
<span class="cm">	 * need to free it on a subsequent call to ext4_remove_blocks,</span>
<span class="cm">	 * or at the end of the ext4_truncate() operation.</span>
<span class="cm">	 */</span>
	<span class="n">flags</span> <span class="o">|=</span> <span class="n">EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER</span><span class="p">;</span>

	<span class="n">trace_ext4_remove_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="o">*</span><span class="n">partial_cluster</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we have a partial cluster, and it&#39;s different from the</span>
<span class="cm">	 * cluster of the last block, we need to explicitly free the</span>
<span class="cm">	 * partial cluster here.</span>
<span class="cm">	 */</span>
	<span class="n">pblk</span> <span class="o">=</span> <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span> <span class="o">+</span> <span class="n">ee_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">partial_cluster</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">EXT4_B2C</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">pblk</span><span class="p">)</span> <span class="o">!=</span> <span class="o">*</span><span class="n">partial_cluster</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ext4_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				 <span class="n">EXT4_C2B</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="o">*</span><span class="n">partial_cluster</span><span class="p">),</span>
				 <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cluster_ratio</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="o">*</span><span class="n">partial_cluster</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef EXTENTS_STATS</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_ext_stats_lock</span><span class="p">);</span>
		<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_ext_blocks</span> <span class="o">+=</span> <span class="n">ee_len</span><span class="p">;</span>
		<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_ext_extents</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ee_len</span> <span class="o">&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_ext_min</span><span class="p">)</span>
			<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_ext_min</span> <span class="o">=</span> <span class="n">ee_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ee_len</span> <span class="o">&gt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_ext_max</span><span class="p">)</span>
			<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_ext_max</span> <span class="o">=</span> <span class="n">ee_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_depth_max</span><span class="p">)</span>
			<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_depth_max</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_ext_stats_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">from</span> <span class="o">&gt;=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="n">to</span> <span class="o">==</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">)</span> <span class="o">+</span> <span class="n">ee_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* tail removal */</span>
		<span class="n">ext4_lblk_t</span> <span class="n">num</span><span class="p">;</span>

		<span class="n">num</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">)</span> <span class="o">+</span> <span class="n">ee_len</span> <span class="o">-</span> <span class="n">from</span><span class="p">;</span>
		<span class="n">pblk</span> <span class="o">=</span> <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span> <span class="o">+</span> <span class="n">ee_len</span> <span class="o">-</span> <span class="n">num</span><span class="p">;</span>
		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;free last %u blocks starting %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">pblk</span><span class="p">);</span>
		<span class="n">ext4_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">pblk</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the block range to be freed didn&#39;t start at the</span>
<span class="cm">		 * beginning of a cluster, and we removed the entire</span>
<span class="cm">		 * extent, save the partial cluster here, since we</span>
<span class="cm">		 * might need to delete if we determine that the</span>
<span class="cm">		 * truncate operation has removed all of the blocks in</span>
<span class="cm">		 * the cluster.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pblk</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cluster_ratio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ee_len</span> <span class="o">==</span> <span class="n">num</span><span class="p">))</span>
			<span class="o">*</span><span class="n">partial_cluster</span> <span class="o">=</span> <span class="n">EXT4_B2C</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">pblk</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">partial_cluster</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">from</span> <span class="o">==</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">)</span>
		   <span class="o">&amp;&amp;</span> <span class="n">to</span> <span class="o">&lt;=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">)</span> <span class="o">+</span> <span class="n">ee_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* head removal */</span>
		<span class="n">ext4_lblk_t</span> <span class="n">num</span><span class="p">;</span>
		<span class="n">ext4_fsblk_t</span> <span class="n">start</span><span class="p">;</span>

		<span class="n">num</span> <span class="o">=</span> <span class="n">to</span> <span class="o">-</span> <span class="n">from</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>

		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;free first %u blocks starting %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
		<span class="n">ext4_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;strange request: removal(2) &quot;</span>
				<span class="s">&quot;%u-%u from %u:%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">),</span> <span class="n">ee_len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * ext4_ext_rm_leaf() Removes the extents associated with the</span>
<span class="cm"> * blocks appearing between &quot;start&quot; and &quot;end&quot;, and splits the extents</span>
<span class="cm"> * if &quot;start&quot; and &quot;end&quot; appear in the same extent</span>
<span class="cm"> *</span>
<span class="cm"> * @handle: The journal handle</span>
<span class="cm"> * @inode:  The files inode</span>
<span class="cm"> * @path:   The path to the leaf</span>
<span class="cm"> * @start:  The first block to remove</span>
<span class="cm"> * @end:   The last block to remove</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="n">ext4_ext_rm_leaf</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">ext4_fsblk_t</span> <span class="o">*</span><span class="n">partial_cluster</span><span class="p">,</span>
		 <span class="n">ext4_lblk_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">ext4_lblk_t</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">correct_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">credits</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_extent_header</span> <span class="o">*</span><span class="n">eh</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span> <span class="n">ex_ee_block</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ex_ee_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">uninitialized</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">;</span>

	<span class="cm">/* the header must be checked already in ext4_ext_remove_space() */</span>
	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;truncate since %u in leaf to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">)</span>
		<span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span> <span class="o">=</span> <span class="n">ext_block_hdr</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_bh</span><span class="p">);</span>
	<span class="n">eh</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="s">&quot;path[%d].p_hdr == NULL&quot;</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* find where to start removing */</span>
	<span class="n">ex</span> <span class="o">=</span> <span class="n">EXT_LAST_EXTENT</span><span class="p">(</span><span class="n">eh</span><span class="p">);</span>

	<span class="n">ex_ee_block</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">);</span>
	<span class="n">ex_ee_len</span> <span class="o">=</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>

	<span class="n">trace_ext4_ext_rm_leaf</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span> <span class="o">*</span><span class="n">partial_cluster</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">ex</span> <span class="o">&gt;=</span> <span class="n">EXT_FIRST_EXTENT</span><span class="p">(</span><span class="n">eh</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">ex_ee_block</span> <span class="o">+</span> <span class="n">ex_ee_len</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ext4_ext_is_uninitialized</span><span class="p">(</span><span class="n">ex</span><span class="p">))</span>
			<span class="n">uninitialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">uninitialized</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;remove ext %u:[%d]%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ex_ee_block</span><span class="p">,</span>
			 <span class="n">uninitialized</span><span class="p">,</span> <span class="n">ex_ee_len</span><span class="p">);</span>
		<span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span> <span class="o">=</span> <span class="n">ex</span><span class="p">;</span>

		<span class="n">a</span> <span class="o">=</span> <span class="n">ex_ee_block</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="o">?</span> <span class="n">ex_ee_block</span> <span class="o">:</span> <span class="n">start</span><span class="p">;</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">ex_ee_block</span><span class="o">+</span><span class="n">ex_ee_len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">?</span>
			<span class="n">ex_ee_block</span><span class="o">+</span><span class="n">ex_ee_len</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">end</span><span class="p">;</span>

		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;  border %u:%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

		<span class="cm">/* If this extent is beyond the end of the hole, skip it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">ex_ee_block</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ex</span><span class="o">--</span><span class="p">;</span>
			<span class="n">ex_ee_block</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">);</span>
			<span class="n">ex_ee_len</span> <span class="o">=</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="n">ex_ee_block</span> <span class="o">+</span> <span class="n">ex_ee_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
					 <span class="s">&quot;can not handle truncate %u:%u &quot;</span>
					 <span class="s">&quot;on extent %u:%u&quot;</span><span class="p">,</span>
					 <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">ex_ee_block</span><span class="p">,</span>
					 <span class="n">ex_ee_block</span> <span class="o">+</span> <span class="n">ex_ee_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">ex_ee_block</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* remove tail of the extent */</span>
			<span class="n">num</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">ex_ee_block</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* remove whole extent: excellent! */</span>
			<span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * 3 for leaf, sb, and inode plus 2 (bmap and group</span>
<span class="cm">		 * descriptor) for each block group; assume two block</span>
<span class="cm">		 * groups plus ex_ee_len/blocks_per_block_group for</span>
<span class="cm">		 * the worst case</span>
<span class="cm">		 */</span>
		<span class="n">credits</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">ex_ee_len</span><span class="o">/</span><span class="n">EXT4_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ex</span> <span class="o">==</span> <span class="n">EXT_FIRST_EXTENT</span><span class="p">(</span><span class="n">eh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">correct_index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">credits</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">credits</span> <span class="o">+=</span> <span class="n">EXT4_MAXQUOTAS_TRANS_BLOCKS</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_truncate_extend_restart</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">credits</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_get_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">depth</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_remove_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span> <span class="n">partial_cluster</span><span class="p">,</span>
					 <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="cm">/* this extent is removed; mark slot entirely unused */</span>
			<span class="n">ext4_ext_store_pblock</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_len</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Do not mark uninitialized if all the blocks in the</span>
<span class="cm">		 * extent have been removed.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uninitialized</span> <span class="o">&amp;&amp;</span> <span class="n">num</span><span class="p">)</span>
			<span class="n">ext4_ext_mark_uninitialized</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the extent was completely released,</span>
<span class="cm">		 * we need to remove it from the leaf</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">!=</span> <span class="n">EXT_MAX_BLOCKS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * For hole punching, we need to scoot all the</span>
<span class="cm">				 * extents up when an extent is removed so that</span>
<span class="cm">				 * we dont have blank extents in the middle</span>
<span class="cm">				 */</span>
				<span class="n">memmove</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="n">ex</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">EXT_LAST_EXTENT</span><span class="p">(</span><span class="n">eh</span><span class="p">)</span> <span class="o">-</span> <span class="n">ex</span><span class="p">)</span> <span class="o">*</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_extent</span><span class="p">));</span>

				<span class="cm">/* Now get rid of the one at the end */</span>
				<span class="n">memset</span><span class="p">(</span><span class="n">EXT_LAST_EXTENT</span><span class="p">(</span><span class="n">eh</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_extent</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="n">le16_add_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="o">*</span><span class="n">partial_cluster</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">depth</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;new extent: %u:%u:%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ex_ee_block</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span>
				<span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">ex</span><span class="p">));</span>
		<span class="n">ex</span><span class="o">--</span><span class="p">;</span>
		<span class="n">ex_ee_block</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">);</span>
		<span class="n">ex_ee_len</span> <span class="o">=</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">correct_index</span> <span class="o">&amp;&amp;</span> <span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_correct_indexes</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there is still a entry in the leaf node, check to see if</span>
<span class="cm">	 * it references the partial cluster.  This is the only place</span>
<span class="cm">	 * where it could; if it doesn&#39;t, we can free the cluster.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">partial_cluster</span> <span class="o">&amp;&amp;</span> <span class="n">ex</span> <span class="o">&gt;=</span> <span class="n">EXT_FIRST_EXTENT</span><span class="p">(</span><span class="n">eh</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">EXT4_B2C</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span> <span class="o">+</span> <span class="n">ex_ee_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span>
	     <span class="o">*</span><span class="n">partial_cluster</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">EXT4_FREE_BLOCKS_FORGET</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">EXT4_FREE_BLOCKS_METADATA</span><span class="p">;</span>

		<span class="n">ext4_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				 <span class="n">EXT4_C2B</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="o">*</span><span class="n">partial_cluster</span><span class="p">),</span>
				 <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cluster_ratio</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="o">*</span><span class="n">partial_cluster</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if this leaf is free, then we should</span>
<span class="cm">	 * remove it from index block above */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_entries</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_bh</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_rm_idx</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">depth</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_ext_more_to_rm:</span>
<span class="cm"> * returns 1 if current index has to be freed (even partial)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="n">ext4_ext_more_to_rm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_idx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_idx</span> <span class="o">&lt;</span> <span class="n">EXT_FIRST_INDEX</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_hdr</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if truncate on deeper level happened, it wasn&#39;t partial,</span>
<span class="cm">	 * so we have to consider current index for truncation</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">)</span> <span class="o">==</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_block</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ext4_ext_remove_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext4_lblk_t</span> <span class="n">start</span><span class="p">,</span>
				 <span class="n">ext4_lblk_t</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">partial_cluster</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;truncate since %u to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

	<span class="cm">/* probably first extent we&#39;re gonna free will be last in block */</span>
	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

<span class="nl">again:</span>
	<span class="n">ext4_ext_invalidate_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">trace_ext4_ext_remove_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if we are removing extents inside the extent tree. If that</span>
<span class="cm">	 * is the case, we are going to punch a hole inside the extent tree</span>
<span class="cm">	 * so we have to check whether we need to split the extent covering</span>
<span class="cm">	 * the last block to remove so we can easily remove the part of it</span>
<span class="cm">	 * in ext4_ext_rm_leaf().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">EXT_MAX_BLOCKS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">;</span>
		<span class="n">ext4_lblk_t</span> <span class="n">ee_block</span><span class="p">;</span>

		<span class="cm">/* find extent for this block */</span>
		<span class="n">path</span> <span class="o">=</span> <span class="n">ext4_ext_find_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">path</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">ex</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ex</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">cont</span><span class="p">;</span>

		<span class="n">ee_block</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * See if the last block is inside the extent, if so split</span>
<span class="cm">		 * the extent at &#39;end&#39; block so we can easily remove the</span>
<span class="cm">		 * tail of the first part of the split extent in</span>
<span class="cm">		 * ext4_ext_rm_leaf().</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;=</span> <span class="n">ee_block</span> <span class="o">&amp;&amp;</span>
		    <span class="n">end</span> <span class="o">&lt;</span> <span class="n">ee_block</span> <span class="o">+</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">split_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ext4_ext_is_uninitialized</span><span class="p">(</span><span class="n">ex</span><span class="p">))</span>
				<span class="n">split_flag</span> <span class="o">=</span> <span class="n">EXT4_EXT_MARK_UNINIT1</span> <span class="o">|</span>
					     <span class="n">EXT4_EXT_MARK_UNINIT2</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Split the extent in two so that &#39;end&#39; is the last</span>
<span class="cm">			 * block in the first new extent</span>
<span class="cm">			 */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_split_extent_at</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
						<span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">split_flag</span><span class="p">,</span>
						<span class="n">EXT4_GET_BLOCKS_PRE_IO</span> <span class="o">|</span>
						<span class="n">EXT4_GET_BLOCKS_PUNCH_OUT_EXT</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ext4_ext_drop_refs</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">cont:</span>

	<span class="cm">/*</span>
<span class="cm">	 * We start scanning from right side, freeing all the blocks</span>
<span class="cm">	 * after i_size and walking into the tree depth-wise.</span>
<span class="cm">	 */</span>
	<span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">path</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_ext_path</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">p_depth</span> <span class="o">=</span> <span class="n">depth</span><span class="p">;</span>
	<span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">p_hdr</span> <span class="o">=</span> <span class="n">ext_inode_hdr</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_ext_check</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">,</span> <span class="n">depth</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* this is leaf block */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_rm_leaf</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">partial_cluster</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
					       <span class="n">end</span><span class="p">);</span>
			<span class="cm">/* root level has p_bh == NULL, brelse() eats this */</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_bh</span><span class="p">);</span>
			<span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">i</span><span class="o">--</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* this is index block */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;initialize header</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_hdr</span> <span class="o">=</span> <span class="n">ext_block_hdr</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_bh</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_idx</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* this level hasn&#39;t been touched yet */</span>
			<span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_idx</span> <span class="o">=</span> <span class="n">EXT_LAST_INDEX</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">);</span>
			<span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_block</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;init index ptr: hdr 0x%p, num %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">,</span>
				  <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* we were already here, see at next index */</span>
			<span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_idx</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;level %d - index, first 0x%p, cur 0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i</span><span class="p">,</span> <span class="n">EXT_FIRST_INDEX</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">),</span>
				<span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_idx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext4_ext_more_to_rm</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
			<span class="cm">/* go to the next level */</span>
			<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;move to level %d (block %llu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ext4_idx_pblock</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_idx</span><span class="p">));</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">path</span><span class="p">));</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ext4_idx_pblock</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_idx</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* should we reset i_size? */</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">depth</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ext4_ext_check_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext_block_hdr</span><span class="p">(</span><span class="n">bh</span><span class="p">),</span>
							<span class="n">depth</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">path</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">p_bh</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>

			<span class="cm">/* save actual number of indexes since this</span>
<span class="cm">			 * number is changed at the next iteration */</span>
			<span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_block</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">);</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* we finished processing this index, go up */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_entries</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* index is empty, remove it;</span>
<span class="cm">				 * handle must be already prepared by the</span>
<span class="cm">				 * truncatei_leaf() */</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_rm_idx</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* root level has p_bh == NULL, brelse() eats this */</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_bh</span><span class="p">);</span>
			<span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">i</span><span class="o">--</span><span class="p">;</span>
			<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;return to level %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">trace_ext4_ext_remove_space_done</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">partial_cluster</span><span class="p">,</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">);</span>

	<span class="cm">/* If we still have something in the partial cluster and we have removed</span>
<span class="cm">	 * even the first extent, then we should free the blocks in the partial</span>
<span class="cm">	 * cluster as well. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">partial_cluster</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_entries</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">EXT4_FREE_BLOCKS_FORGET</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">EXT4_FREE_BLOCKS_METADATA</span><span class="p">;</span>

		<span class="n">ext4_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				 <span class="n">EXT4_C2B</span><span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">),</span> <span class="n">partial_cluster</span><span class="p">),</span>
				 <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_cluster_ratio</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">partial_cluster</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* TODO: flexible tree reduction should be here */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">p_hdr</span><span class="o">-&gt;</span><span class="n">eh_entries</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * truncate to zero freed all the tree,</span>
<span class="cm">		 * so we need to correct eh_depth</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_get_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext_inode_hdr</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">eh_depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ext_inode_hdr</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">eh_max</span> <span class="o">=</span>
				<span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ext4_ext_space_root</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">ext4_ext_drop_refs</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * called at mount time</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ext4_ext_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * possible initialization would be here</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">EXT4_FEATURE_INCOMPAT_EXTENTS</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#if defined(AGGRESSIVE_TEST) || defined(CHECK_BINSEARCH) || defined(EXTENTS_STATS)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;EXT4-fs: file extents enabled&quot;</span>
<span class="cp">#ifdef AGGRESSIVE_TEST</span>
		       <span class="s">&quot;, aggressive tests&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CHECK_BINSEARCH</span>
		       <span class="s">&quot;, check binsearch&quot;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef EXTENTS_STATS</span>
		       <span class="s">&quot;, stats&quot;</span>
<span class="cp">#endif</span>
		       <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef EXTENTS_STATS</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_ext_stats_lock</span><span class="p">);</span>
		<span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_ext_min</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">;</span>
		<span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_ext_max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * called at umount time</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ext4_ext_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EXT4_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">EXT4_FEATURE_INCOMPAT_EXTENTS</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

<span class="cp">#ifdef EXTENTS_STATS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_ext_blocks</span> <span class="o">&amp;&amp;</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_ext_extents</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;EXT4-fs: %lu blocks in %lu extents (%lu ave)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_ext_blocks</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_ext_extents</span><span class="p">,</span>
			<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_ext_blocks</span> <span class="o">/</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_ext_extents</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;EXT4-fs: extents: %lu min, %lu max, max depth %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_ext_min</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_ext_max</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_depth_max</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* FIXME!! we need to try to merge to left or right after zero-out  */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ext4_ext_zeroout</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">ee_pblock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ee_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ee_len</span>    <span class="o">=</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
	<span class="n">ee_pblock</span> <span class="o">=</span> <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">sb_issue_zeroout</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">ee_pblock</span><span class="p">,</span> <span class="n">ee_len</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_split_extent_at() splits an extent at given block.</span>
<span class="cm"> *</span>
<span class="cm"> * @handle: the journal handle</span>
<span class="cm"> * @inode: the file inode</span>
<span class="cm"> * @path: the path to the extent</span>
<span class="cm"> * @split: the logical block where the extent is splitted.</span>
<span class="cm"> * @split_flags: indicates if the extent could be zeroout if split fails, and</span>
<span class="cm"> *		 the states(init or uninit) of new extents.</span>
<span class="cm"> * @flags: flags used to insert new extent to extent tree.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Splits extent [a, b] into two extents [a, @split) and [@split, b], states</span>
<span class="cm"> * of which are deterimined by split_flag.</span>
<span class="cm"> *</span>
<span class="cm"> * There are two cases:</span>
<span class="cm"> *  a&gt; the extent are splitted into two extent.</span>
<span class="cm"> *  b&gt; split is not needed, and just mark the extent.</span>
<span class="cm"> *</span>
<span class="cm"> * return 0 on success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ext4_split_extent_at</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			     <span class="n">ext4_lblk_t</span> <span class="n">split</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">split_flag</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">newblock</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span> <span class="n">ee_block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">,</span> <span class="n">newex</span><span class="p">,</span> <span class="n">orig_ex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ee_len</span><span class="p">,</span> <span class="n">depth</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;ext4_split_extents_at: inode %lu, logical&quot;</span>
		<span class="s">&quot;block %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">split</span><span class="p">);</span>

	<span class="n">ext4_ext_show_leaf</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>

	<span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ex</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="p">;</span>
	<span class="n">ee_block</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">);</span>
	<span class="n">ee_len</span> <span class="o">=</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
	<span class="n">newblock</span> <span class="o">=</span> <span class="n">split</span> <span class="o">-</span> <span class="n">ee_block</span> <span class="o">+</span> <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">split</span> <span class="o">&lt;</span> <span class="n">ee_block</span> <span class="o">||</span> <span class="n">split</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">ee_block</span> <span class="o">+</span> <span class="n">ee_len</span><span class="p">));</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_get_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">depth</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">split</span> <span class="o">==</span> <span class="n">ee_block</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * case b: block @split is the block that the extent begins with</span>
<span class="cm">		 * then we just change the state of the extent, and splitting</span>
<span class="cm">		 * is not needed.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">split_flag</span> <span class="o">&amp;</span> <span class="n">EXT4_EXT_MARK_UNINIT2</span><span class="p">)</span>
			<span class="n">ext4_ext_mark_uninitialized</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ext4_ext_mark_initialized</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_PRE_IO</span><span class="p">))</span>
			<span class="n">ext4_ext_try_to_merge</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">ex</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">depth</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* case a */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_ex</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">orig_ex</span><span class="p">));</span>
	<span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_len</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">split</span> <span class="o">-</span> <span class="n">ee_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">split_flag</span> <span class="o">&amp;</span> <span class="n">EXT4_EXT_MARK_UNINIT1</span><span class="p">)</span>
		<span class="n">ext4_ext_mark_uninitialized</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * path may lead to new leaf, not to original leaf any more</span>
<span class="cm">	 * after ext4_ext_insert_extent() returns,</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">depth</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fix_extent_len</span><span class="p">;</span>

	<span class="n">ex2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">newex</span><span class="p">;</span>
	<span class="n">ex2</span><span class="o">-&gt;</span><span class="n">ee_block</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">split</span><span class="p">);</span>
	<span class="n">ex2</span><span class="o">-&gt;</span><span class="n">ee_len</span>   <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ee_len</span> <span class="o">-</span> <span class="p">(</span><span class="n">split</span> <span class="o">-</span> <span class="n">ee_block</span><span class="p">));</span>
	<span class="n">ext4_ext_store_pblock</span><span class="p">(</span><span class="n">ex2</span><span class="p">,</span> <span class="n">newblock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">split_flag</span> <span class="o">&amp;</span> <span class="n">EXT4_EXT_MARK_UNINIT2</span><span class="p">)</span>
		<span class="n">ext4_ext_mark_uninitialized</span><span class="p">(</span><span class="n">ex2</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_insert_extent</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newex</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">EXT4_EXT_MAY_ZEROOUT</span> <span class="o">&amp;</span> <span class="n">split_flag</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_zeroout</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">orig_ex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fix_extent_len</span><span class="p">;</span>
		<span class="cm">/* update the extent length and mark as initialized */</span>
		<span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_len</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ee_len</span><span class="p">);</span>
		<span class="n">ext4_ext_try_to_merge</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">ex</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">depth</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fix_extent_len</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">ext4_ext_show_leaf</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">fix_extent_len:</span>
	<span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_len</span> <span class="o">=</span> <span class="n">orig_ex</span><span class="p">.</span><span class="n">ee_len</span><span class="p">;</span>
	<span class="n">ext4_ext_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">depth</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_split_extents() splits an extent and mark extent which is covered</span>
<span class="cm"> * by @map as split_flags indicates</span>
<span class="cm"> *</span>
<span class="cm"> * It may result in splitting the extent into multiple extents (upto three)</span>
<span class="cm"> * There are three possibilities:</span>
<span class="cm"> *   a&gt; There is no split required</span>
<span class="cm"> *   b&gt; Splits in two extents: Split is happening at either end of the extent</span>
<span class="cm"> *   c&gt; Splits in three extents: Somone is splitting in middle of the extent</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ext4_split_extent</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">split_flag</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext4_lblk_t</span> <span class="n">ee_block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ee_len</span><span class="p">,</span> <span class="n">depth</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">uninitialized</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">split_flag1</span><span class="p">,</span> <span class="n">flags1</span><span class="p">;</span>

	<span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ex</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="p">;</span>
	<span class="n">ee_block</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">);</span>
	<span class="n">ee_len</span> <span class="o">=</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
	<span class="n">uninitialized</span> <span class="o">=</span> <span class="n">ext4_ext_is_uninitialized</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span> <span class="o">&lt;</span> <span class="n">ee_block</span> <span class="o">+</span> <span class="n">ee_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">split_flag1</span> <span class="o">=</span> <span class="n">split_flag</span> <span class="o">&amp;</span> <span class="n">EXT4_EXT_MAY_ZEROOUT</span> <span class="o">?</span>
			      <span class="n">EXT4_EXT_MAY_ZEROOUT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">flags1</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">EXT4_GET_BLOCKS_PRE_IO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uninitialized</span><span class="p">)</span>
			<span class="n">split_flag1</span> <span class="o">|=</span> <span class="n">EXT4_EXT_MARK_UNINIT1</span> <span class="o">|</span>
				       <span class="n">EXT4_EXT_MARK_UNINIT2</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_split_extent_at</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
				<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">,</span> <span class="n">split_flag1</span><span class="p">,</span> <span class="n">flags1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ext4_ext_drop_refs</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">path</span> <span class="o">=</span> <span class="n">ext4_ext_find_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">&gt;=</span> <span class="n">ee_block</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">split_flag1</span> <span class="o">=</span> <span class="n">split_flag</span> <span class="o">&amp;</span> <span class="n">EXT4_EXT_MAY_ZEROOUT</span> <span class="o">?</span>
			      <span class="n">EXT4_EXT_MAY_ZEROOUT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uninitialized</span><span class="p">)</span>
			<span class="n">split_flag1</span> <span class="o">|=</span> <span class="n">EXT4_EXT_MARK_UNINIT1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">split_flag</span> <span class="o">&amp;</span> <span class="n">EXT4_EXT_MARK_UNINIT2</span><span class="p">)</span>
			<span class="n">split_flag1</span> <span class="o">|=</span> <span class="n">EXT4_EXT_MARK_UNINIT2</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_split_extent_at</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
				<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span> <span class="n">split_flag1</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ext4_ext_show_leaf</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span> <span class="o">?</span> <span class="n">err</span> <span class="o">:</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define EXT4_EXT_ZERO_LEN 7</span>
<span class="cm">/*</span>
<span class="cm"> * This function is called by ext4_ext_map_blocks() if someone tries to write</span>
<span class="cm"> * to an uninitialized extent. It may result in splitting the uninitialized</span>
<span class="cm"> * extent into multiple extents (up to three - one initialized and two</span>
<span class="cm"> * uninitialized).</span>
<span class="cm"> * There are three possibilities:</span>
<span class="cm"> *   a&gt; There is no split required: Entire extent should be initialized</span>
<span class="cm"> *   b&gt; Splits in two extents: Write is happening at either end of the extent</span>
<span class="cm"> *   c&gt; Splits in three extents: Somone is writing in middle of the extent</span>
<span class="cm"> *</span>
<span class="cm"> * Pre-conditions:</span>
<span class="cm"> *  - The extent pointed to by &#39;path&#39; is uninitialized.</span>
<span class="cm"> *  - The extent pointed to by &#39;path&#39; contains a superset</span>
<span class="cm"> *    of the logical span [map-&gt;m_lblk, map-&gt;m_lblk + map-&gt;m_len).</span>
<span class="cm"> *</span>
<span class="cm"> * Post-conditions on success:</span>
<span class="cm"> *  - the returned value is the number of blocks beyond map-&gt;l_lblk</span>
<span class="cm"> *    that are allocated and initialized.</span>
<span class="cm"> *    It is guaranteed to be &gt;= map-&gt;m_len.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ext4_ext_convert_to_initialized</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_extent_header</span> <span class="o">*</span><span class="n">eh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="n">split_map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="n">zero_ex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span> <span class="n">ee_block</span><span class="p">,</span> <span class="n">eof_block</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ee_len</span><span class="p">,</span> <span class="n">depth</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">allocated</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">split_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;ext4_ext_convert_to_initialized: inode %lu, logical&quot;</span>
		<span class="s">&quot;block %llu, max_blocks %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">);</span>

	<span class="n">eof_block</span> <span class="o">=</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eof_block</span> <span class="o">&lt;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">)</span>
		<span class="n">eof_block</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">;</span>

	<span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">eh</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">;</span>
	<span class="n">ex</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="p">;</span>
	<span class="n">ee_block</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">);</span>
	<span class="n">ee_len</span> <span class="o">=</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
	<span class="n">allocated</span> <span class="o">=</span> <span class="n">ee_len</span> <span class="o">-</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">-</span> <span class="n">ee_block</span><span class="p">);</span>

	<span class="n">trace_ext4_ext_convert_to_initialized_enter</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">ex</span><span class="p">);</span>

	<span class="cm">/* Pre-conditions */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ext4_ext_is_uninitialized</span><span class="p">(</span><span class="n">ex</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">in_range</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span> <span class="n">ee_block</span><span class="p">,</span> <span class="n">ee_len</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Attempt to transfer newly initialized blocks from the currently</span>
<span class="cm">	 * uninitialized extent to its left neighbor. This is much cheaper</span>
<span class="cm">	 * than an insertion followed by a merge as those involve costly</span>
<span class="cm">	 * memmove() calls. This is the common case in steady state for</span>
<span class="cm">	 * workloads doing fallocate(FALLOC_FL_KEEP_SIZE) followed by append</span>
<span class="cm">	 * writes.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Limitations of the current logic:</span>
<span class="cm">	 *  - L1: we only deal with writes at the start of the extent.</span>
<span class="cm">	 *    The approach could be extended to writes at the end</span>
<span class="cm">	 *    of the extent but this scenario was deemed less common.</span>
<span class="cm">	 *  - L2: we do not deal with writes covering the whole extent.</span>
<span class="cm">	 *    This would require removing the extent if the transfer</span>
<span class="cm">	 *    is possible.</span>
<span class="cm">	 *  - L3: we only attempt to merge with an extent stored in the</span>
<span class="cm">	 *    same extent tree node.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">==</span> <span class="n">ee_block</span><span class="p">)</span> <span class="o">&amp;&amp;</span>	<span class="cm">/*L1*/</span>
		<span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span> <span class="o">&lt;</span> <span class="n">ee_len</span><span class="p">)</span> <span class="o">&amp;&amp;</span>	<span class="cm">/*L2*/</span>
		<span class="p">(</span><span class="n">ex</span> <span class="o">&gt;</span> <span class="n">EXT_FIRST_EXTENT</span><span class="p">(</span><span class="n">eh</span><span class="p">)))</span> <span class="p">{</span>	<span class="cm">/*L3*/</span>
		<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">prev_ex</span><span class="p">;</span>
		<span class="n">ext4_lblk_t</span> <span class="n">prev_lblk</span><span class="p">;</span>
		<span class="n">ext4_fsblk_t</span> <span class="n">prev_pblk</span><span class="p">,</span> <span class="n">ee_pblk</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prev_len</span><span class="p">,</span> <span class="n">write_len</span><span class="p">;</span>

		<span class="n">prev_ex</span> <span class="o">=</span> <span class="n">ex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">prev_lblk</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">prev_ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">);</span>
		<span class="n">prev_len</span> <span class="o">=</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">prev_ex</span><span class="p">);</span>
		<span class="n">prev_pblk</span> <span class="o">=</span> <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">prev_ex</span><span class="p">);</span>
		<span class="n">ee_pblk</span> <span class="o">=</span> <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
		<span class="n">write_len</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * A transfer of blocks from &#39;ex&#39; to &#39;prev_ex&#39; is allowed</span>
<span class="cm">		 * upon those conditions:</span>
<span class="cm">		 * - C1: prev_ex is initialized,</span>
<span class="cm">		 * - C2: prev_ex is logically abutting ex,</span>
<span class="cm">		 * - C3: prev_ex is physically abutting ex,</span>
<span class="cm">		 * - C4: prev_ex can receive the additional blocks without</span>
<span class="cm">		 *   overflowing the (initialized) length limit.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">ext4_ext_is_uninitialized</span><span class="p">(</span><span class="n">prev_ex</span><span class="p">))</span> <span class="o">&amp;&amp;</span>		<span class="cm">/*C1*/</span>
			<span class="p">((</span><span class="n">prev_lblk</span> <span class="o">+</span> <span class="n">prev_len</span><span class="p">)</span> <span class="o">==</span> <span class="n">ee_block</span><span class="p">)</span> <span class="o">&amp;&amp;</span>		<span class="cm">/*C2*/</span>
			<span class="p">((</span><span class="n">prev_pblk</span> <span class="o">+</span> <span class="n">prev_len</span><span class="p">)</span> <span class="o">==</span> <span class="n">ee_pblk</span><span class="p">)</span> <span class="o">&amp;&amp;</span>		<span class="cm">/*C3*/</span>
			<span class="p">(</span><span class="n">prev_len</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">EXT_INIT_MAX_LEN</span> <span class="o">-</span> <span class="n">write_len</span><span class="p">)))</span> <span class="p">{</span>	<span class="cm">/*C4*/</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_get_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">depth</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="n">trace_ext4_ext_convert_to_initialized_fastpath</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
				<span class="n">map</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span> <span class="n">prev_ex</span><span class="p">);</span>

			<span class="cm">/* Shift the start of ex by &#39;write_len&#39; blocks */</span>
			<span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ee_block</span> <span class="o">+</span> <span class="n">write_len</span><span class="p">);</span>
			<span class="n">ext4_ext_store_pblock</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="n">ee_pblk</span> <span class="o">+</span> <span class="n">write_len</span><span class="p">);</span>
			<span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_len</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ee_len</span> <span class="o">-</span> <span class="n">write_len</span><span class="p">);</span>
			<span class="n">ext4_ext_mark_uninitialized</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span> <span class="cm">/* Restore the flag */</span>

			<span class="cm">/* Extend prev_ex by &#39;write_len&#39; blocks */</span>
			<span class="n">prev_ex</span><span class="o">-&gt;</span><span class="n">ee_len</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">prev_len</span> <span class="o">+</span> <span class="n">write_len</span><span class="p">);</span>

			<span class="cm">/* Mark the block containing both extents as dirty */</span>
			<span class="n">ext4_ext_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">depth</span><span class="p">);</span>

			<span class="cm">/* Update path to point to the right extent */</span>
			<span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span> <span class="o">=</span> <span class="n">prev_ex</span><span class="p">;</span>

			<span class="cm">/* Result: number of initialized blocks past m_lblk */</span>
			<span class="n">allocated</span> <span class="o">=</span> <span class="n">write_len</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">&lt;</span> <span class="n">ee_block</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * It is safe to convert extent to initialized via explicit</span>
<span class="cm">	 * zeroout only if extent is fully insde i_size or new_size.</span>
<span class="cm">	 */</span>
	<span class="n">split_flag</span> <span class="o">|=</span> <span class="n">ee_block</span> <span class="o">+</span> <span class="n">ee_len</span> <span class="o">&lt;=</span> <span class="n">eof_block</span> <span class="o">?</span> <span class="n">EXT4_EXT_MAY_ZEROOUT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If extent has less than 2*EXT4_EXT_ZERO_LEN zerout directly */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ee_len</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">EXT4_EXT_ZERO_LEN</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">EXT4_EXT_MAY_ZEROOUT</span> <span class="o">&amp;</span> <span class="n">split_flag</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_zeroout</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_get_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">depth</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">ext4_ext_mark_initialized</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
		<span class="n">ext4_ext_try_to_merge</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">ex</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">depth</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * four cases:</span>
<span class="cm">	 * 1. split the extent into three extents.</span>
<span class="cm">	 * 2. split the extent into two extents, zeroout the first half.</span>
<span class="cm">	 * 3. split the extent into two extents, zeroout the second half.</span>
<span class="cm">	 * 4. split the extent into two extents with out zeroout.</span>
<span class="cm">	 */</span>
	<span class="n">split_map</span><span class="p">.</span><span class="n">m_lblk</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">;</span>
	<span class="n">split_map</span><span class="p">.</span><span class="n">m_len</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">allocated</span> <span class="o">&gt;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">allocated</span> <span class="o">&lt;=</span> <span class="n">EXT4_EXT_ZERO_LEN</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">EXT4_EXT_MAY_ZEROOUT</span> <span class="o">&amp;</span> <span class="n">split_flag</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* case 3 */</span>
			<span class="n">zero_ex</span><span class="p">.</span><span class="n">ee_block</span> <span class="o">=</span>
					 <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">);</span>
			<span class="n">zero_ex</span><span class="p">.</span><span class="n">ee_len</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">allocated</span><span class="p">);</span>
			<span class="n">ext4_ext_store_pblock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zero_ex</span><span class="p">,</span>
				<span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">-</span> <span class="n">ee_block</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_zeroout</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zero_ex</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">split_map</span><span class="p">.</span><span class="n">m_lblk</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">;</span>
			<span class="n">split_map</span><span class="p">.</span><span class="n">m_len</span> <span class="o">=</span> <span class="n">allocated</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">-</span> <span class="n">ee_block</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span> <span class="o">&lt;</span>
			   <span class="n">EXT4_EXT_ZERO_LEN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			   <span class="p">(</span><span class="n">EXT4_EXT_MAY_ZEROOUT</span> <span class="o">&amp;</span> <span class="n">split_flag</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* case 2 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">!=</span> <span class="n">ee_block</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">zero_ex</span><span class="p">.</span><span class="n">ee_block</span> <span class="o">=</span> <span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">;</span>
				<span class="n">zero_ex</span><span class="p">.</span><span class="n">ee_len</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">-</span>
							<span class="n">ee_block</span><span class="p">);</span>
				<span class="n">ext4_ext_store_pblock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zero_ex</span><span class="p">,</span>
						      <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">ex</span><span class="p">));</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_zeroout</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zero_ex</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">split_map</span><span class="p">.</span><span class="n">m_lblk</span> <span class="o">=</span> <span class="n">ee_block</span><span class="p">;</span>
			<span class="n">split_map</span><span class="p">.</span><span class="n">m_len</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">-</span> <span class="n">ee_block</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">;</span>
			<span class="n">allocated</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">allocated</span> <span class="o">=</span> <span class="n">ext4_split_extent</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">split_map</span><span class="p">,</span> <span class="n">split_flag</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">allocated</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">allocated</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span> <span class="o">?</span> <span class="n">err</span> <span class="o">:</span> <span class="n">allocated</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is called by ext4_ext_map_blocks() from</span>
<span class="cm"> * ext4_get_blocks_dio_write() when DIO to write</span>
<span class="cm"> * to an uninitialized extent.</span>
<span class="cm"> *</span>
<span class="cm"> * Writing to an uninitialized extent may result in splitting the uninitialized</span>
<span class="cm"> * extent into multiple /initialized uninitialized extents (up to three)</span>
<span class="cm"> * There are three possibilities:</span>
<span class="cm"> *   a&gt; There is no split required: Entire extent should be uninitialized</span>
<span class="cm"> *   b&gt; Splits in two extents: Write is happening at either end of the extent</span>
<span class="cm"> *   c&gt; Splits in three extents: Somone is writing in middle of the extent</span>
<span class="cm"> *</span>
<span class="cm"> * One of more index blocks maybe needed if the extent tree grow after</span>
<span class="cm"> * the uninitialized extent split. To prevent ENOSPC occur at the IO</span>
<span class="cm"> * complete, we need to split the uninitialized extent before DIO submit</span>
<span class="cm"> * the IO. The uninitialized extent called at this time will be split</span>
<span class="cm"> * into three uninitialized extent(at most). After IO complete, the part</span>
<span class="cm"> * being filled will be convert to initialized by the end_io callback function</span>
<span class="cm"> * via ext4_convert_unwritten_extents().</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the size of uninitialized extent to be written on success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ext4_split_unwritten_extents</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext4_lblk_t</span> <span class="n">eof_block</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span> <span class="n">ee_block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ee_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">split_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">depth</span><span class="p">;</span>

	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;ext4_split_unwritten_extents: inode %lu, logical&quot;</span>
		<span class="s">&quot;block %llu, max_blocks %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">);</span>

	<span class="n">eof_block</span> <span class="o">=</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eof_block</span> <span class="o">&lt;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">)</span>
		<span class="n">eof_block</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * It is safe to convert extent to initialized via explicit</span>
<span class="cm">	 * zeroout only if extent is fully insde i_size or new_size.</span>
<span class="cm">	 */</span>
	<span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ex</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="p">;</span>
	<span class="n">ee_block</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">);</span>
	<span class="n">ee_len</span> <span class="o">=</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>

	<span class="n">split_flag</span> <span class="o">|=</span> <span class="n">ee_block</span> <span class="o">+</span> <span class="n">ee_len</span> <span class="o">&lt;=</span> <span class="n">eof_block</span> <span class="o">?</span> <span class="n">EXT4_EXT_MAY_ZEROOUT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">split_flag</span> <span class="o">|=</span> <span class="n">EXT4_EXT_MARK_UNINIT2</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">|=</span> <span class="n">EXT4_GET_BLOCKS_PRE_IO</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ext4_split_extent</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">split_flag</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ext4_convert_unwritten_extents_endio</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ex</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="p">;</span>

	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;ext4_convert_unwritten_extents_endio: inode %lu, logical&quot;</span>
		<span class="s">&quot;block %llu, max_blocks %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">),</span>
		<span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">));</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_get_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">depth</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/* first mark the extent as initialized */</span>
	<span class="n">ext4_ext_mark_initialized</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>

	<span class="cm">/* note: ext4_ext_correct_indexes() isn&#39;t needed here because</span>
<span class="cm">	 * borders are not changed</span>
<span class="cm">	 */</span>
	<span class="n">ext4_ext_try_to_merge</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">ex</span><span class="p">);</span>

	<span class="cm">/* Mark modified extent as dirty */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="n">depth</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">ext4_ext_show_leaf</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">unmap_underlying_metadata_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
			<span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">unmap_underlying_metadata</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">block</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle EOFBLOCKS_FL flag, clearing it if necessary</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">check_eofblocks_fl</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			      <span class="n">ext4_lblk_t</span> <span class="n">lblk</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">depth</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_extent_header</span> <span class="o">*</span><span class="n">eh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">last_ex</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext4_test_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_EOFBLOCKS</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">eh</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re going to remove EOFBLOCKS_FL entirely in future so we</span>
<span class="cm">	 * do not care for this case anymore. Simply remove the flag</span>
<span class="cm">	 * if there are no extents.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">eh</span><span class="o">-&gt;</span><span class="n">eh_entries</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">last_ex</span> <span class="o">=</span> <span class="n">EXT_LAST_EXTENT</span><span class="p">(</span><span class="n">eh</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We should clear the EOFBLOCKS_FL flag if we are writing the</span>
<span class="cm">	 * last block in the last extent in the file.  We test this by</span>
<span class="cm">	 * first checking to see if the caller to</span>
<span class="cm">	 * ext4_ext_get_blocks() was interested in the last block (or</span>
<span class="cm">	 * a block beyond the last block) in the current extent.  If</span>
<span class="cm">	 * this turns out to be false, we can bail out from this</span>
<span class="cm">	 * function immediately.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lblk</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">last_ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">)</span> <span class="o">+</span>
	    <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">last_ex</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the caller does appear to be planning to write at or</span>
<span class="cm">	 * beyond the end of the current extent, we then test to see</span>
<span class="cm">	 * if the current extent is the last extent in the file, by</span>
<span class="cm">	 * checking to make sure it was reached via the rightmost node</span>
<span class="cm">	 * at each level of the tree.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_idx</span> <span class="o">!=</span> <span class="n">EXT_LAST_INDEX</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_hdr</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">ext4_clear_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_EOFBLOCKS</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ext4_find_delalloc_range: find delayed allocated block in the given range.</span>
<span class="cm"> *</span>
<span class="cm"> * Goes through the buffer heads in the range [lblk_start, lblk_end] and returns</span>
<span class="cm"> * whether there are any buffers marked for delayed allocation. It returns &#39;1&#39;</span>
<span class="cm"> * on the first delalloc&#39;ed buffer head found. If no buffer head in the given</span>
<span class="cm"> * range is marked for delalloc, it returns 0.</span>
<span class="cm"> * lblk_start should always be &lt;= lblk_end.</span>
<span class="cm"> * search_hint_reverse is to indicate that searching in reverse from lblk_end to</span>
<span class="cm"> * lblk_start might be more efficient (i.e., we will likely hit the delalloc&#39;ed</span>
<span class="cm"> * block sooner). This is useful when blocks are truncated sequentially from</span>
<span class="cm"> * lblk_start towards lblk_end.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ext4_find_delalloc_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				    <span class="n">ext4_lblk_t</span> <span class="n">lblk_start</span><span class="p">,</span>
				    <span class="n">ext4_lblk_t</span> <span class="n">lblk_end</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">search_hint_reverse</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">pg_lblk</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_opt</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">DELALLOC</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* reverse search wont work if fs block size is less than page size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span> <span class="o">&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span>
		<span class="n">search_hint_reverse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">search_hint_reverse</span><span class="p">)</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">lblk_end</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">lblk_start</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">lblk_start</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">lblk_end</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">nextpage</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">nextpage</span><span class="p">;</span>

		<span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">nextpage</span><span class="p">;</span>

		<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
		<span class="n">pg_lblk</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span>
						<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">);</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pg_lblk</span> <span class="o">&lt;</span> <span class="n">lblk_start</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * This is possible when fs block size is less</span>
<span class="cm">				 * than page size and our cluster starts/ends in</span>
<span class="cm">				 * middle of the page. So we need to skip the</span>
<span class="cm">				 * initial few blocks till we reach the &#39;lblk&#39;</span>
<span class="cm">				 */</span>
				<span class="n">pg_lblk</span><span class="o">++</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Check if the buffer is delayed allocated and that it</span>
<span class="cm">			 * is not yet mapped. (when da-buffers are mapped during</span>
<span class="cm">			 * their writeout, their da_mapped bit is set.)</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">buffer_da_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">trace_ext4_find_delalloc_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
						<span class="n">lblk_start</span><span class="p">,</span> <span class="n">lblk_end</span><span class="p">,</span>
						<span class="n">search_hint_reverse</span><span class="p">,</span>
						<span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">search_hint_reverse</span><span class="p">)</span>
				<span class="n">i</span><span class="o">--</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">lblk_start</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">lblk_end</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">((</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">head</span><span class="p">));</span>
<span class="nl">nextpage:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Move to next page. &#39;i&#39; will be the first lblk in the next</span>
<span class="cm">		 * page.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">search_hint_reverse</span><span class="p">)</span>
			<span class="n">index</span><span class="o">--</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">index</span><span class="o">++</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">trace_ext4_find_delalloc_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">lblk_start</span><span class="p">,</span> <span class="n">lblk_end</span><span class="p">,</span>
					<span class="n">search_hint_reverse</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">ext4_find_delalloc_cluster</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext4_lblk_t</span> <span class="n">lblk</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">search_hint_reverse</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">ext4_lblk_t</span> <span class="n">lblk_start</span><span class="p">,</span> <span class="n">lblk_end</span><span class="p">;</span>
	<span class="n">lblk_start</span> <span class="o">=</span> <span class="n">lblk</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cluster_ratio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">lblk_end</span> <span class="o">=</span> <span class="n">lblk_start</span> <span class="o">+</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cluster_ratio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ext4_find_delalloc_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">lblk_start</span><span class="p">,</span> <span class="n">lblk_end</span><span class="p">,</span>
					<span class="n">search_hint_reverse</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Determines how many complete clusters (out of those specified by the &#39;map&#39;)</span>
<span class="cm"> * are under delalloc and were reserved quota for.</span>
<span class="cm"> * This function is called when we are writing out the blocks that were</span>
<span class="cm"> * originally written with their allocation delayed, but then the space was</span>
<span class="cm"> * allocated using fallocate() before the delayed allocation could be resolved.</span>
<span class="cm"> * The cases to look for are:</span>
<span class="cm"> * (&#39;=&#39; indicated delayed allocated blocks</span>
<span class="cm"> *  &#39;-&#39; indicates non-delayed allocated blocks)</span>
<span class="cm"> * (a) partial clusters towards beginning and/or end outside of allocated range</span>
<span class="cm"> *     are not delalloc&#39;ed.</span>
<span class="cm"> *	Ex:</span>
<span class="cm"> *	|----c---=|====c====|====c====|===-c----|</span>
<span class="cm"> *	         |++++++ allocated ++++++|</span>
<span class="cm"> *	==&gt; 4 complete clusters in above example</span>
<span class="cm"> *</span>
<span class="cm"> * (b) partial cluster (outside of allocated range) towards either end is</span>
<span class="cm"> *     marked for delayed allocation. In this case, we will exclude that</span>
<span class="cm"> *     cluster.</span>
<span class="cm"> *	Ex:</span>
<span class="cm"> *	|----====c========|========c========|</span>
<span class="cm"> *	     |++++++ allocated ++++++|</span>
<span class="cm"> *	==&gt; 1 complete clusters in above example</span>
<span class="cm"> *</span>
<span class="cm"> *	Ex:</span>
<span class="cm"> *	|================c================|</span>
<span class="cm"> *            |++++++ allocated ++++++|</span>
<span class="cm"> *	==&gt; 0 complete clusters in above example</span>
<span class="cm"> *</span>
<span class="cm"> * The ext4_da_update_reserve_space will be called only if we</span>
<span class="cm"> * determine here that there were some &quot;entire&quot; clusters that span</span>
<span class="cm"> * this &#39;allocated&#39; range.</span>
<span class="cm"> * In the non-bigalloc case, this function will just end up returning num_blks</span>
<span class="cm"> * without ever calling ext4_find_delalloc_range.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="n">get_reserved_cluster_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext4_lblk_t</span> <span class="n">lblk_start</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_blks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">ext4_lblk_t</span> <span class="n">alloc_cluster_start</span><span class="p">,</span> <span class="n">alloc_cluster_end</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span> <span class="n">lblk_from</span><span class="p">,</span> <span class="n">lblk_to</span><span class="p">,</span> <span class="n">c_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">allocated_clusters</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">alloc_cluster_start</span> <span class="o">=</span> <span class="n">EXT4_B2C</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">lblk_start</span><span class="p">);</span>
	<span class="n">alloc_cluster_end</span> <span class="o">=</span> <span class="n">EXT4_B2C</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">lblk_start</span> <span class="o">+</span> <span class="n">num_blks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* max possible clusters for this allocation */</span>
	<span class="n">allocated_clusters</span> <span class="o">=</span> <span class="n">alloc_cluster_end</span> <span class="o">-</span> <span class="n">alloc_cluster_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">trace_ext4_get_reserved_cluster_alloc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">lblk_start</span><span class="p">,</span> <span class="n">num_blks</span><span class="p">);</span>

	<span class="cm">/* Check towards left side */</span>
	<span class="n">c_offset</span> <span class="o">=</span> <span class="n">lblk_start</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cluster_ratio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c_offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lblk_from</span> <span class="o">=</span> <span class="n">lblk_start</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cluster_ratio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="n">lblk_to</span> <span class="o">=</span> <span class="n">lblk_from</span> <span class="o">+</span> <span class="n">c_offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ext4_find_delalloc_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">lblk_from</span><span class="p">,</span> <span class="n">lblk_to</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">allocated_clusters</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now check towards right. */</span>
	<span class="n">c_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">lblk_start</span> <span class="o">+</span> <span class="n">num_blks</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cluster_ratio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">allocated_clusters</span> <span class="o">&amp;&amp;</span> <span class="n">c_offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lblk_from</span> <span class="o">=</span> <span class="n">lblk_start</span> <span class="o">+</span> <span class="n">num_blks</span><span class="p">;</span>
		<span class="n">lblk_to</span> <span class="o">=</span> <span class="n">lblk_from</span> <span class="o">+</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cluster_ratio</span> <span class="o">-</span> <span class="n">c_offset</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ext4_find_delalloc_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">lblk_from</span><span class="p">,</span> <span class="n">lblk_to</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">allocated_clusters</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">allocated_clusters</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="n">ext4_ext_handle_uninitialized_extents</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">allocated</span><span class="p">,</span> <span class="n">ext4_fsblk_t</span> <span class="n">newblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ext4_io_end_t</span> <span class="o">*</span><span class="n">io</span> <span class="o">=</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cur_aio_dio</span><span class="p">;</span>

	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;ext4_ext_handle_uninitialized_extents: inode %lu, logical &quot;</span>
		  <span class="s">&quot;block %llu, max_blocks %u, flags %x, allocated %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">,</span>
		  <span class="n">flags</span><span class="p">,</span> <span class="n">allocated</span><span class="p">);</span>
	<span class="n">ext4_ext_show_leaf</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>

	<span class="n">trace_ext4_ext_handle_uninitialized_extents</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">allocated</span><span class="p">,</span>
						    <span class="n">newblock</span><span class="p">);</span>

	<span class="cm">/* get_block() before submit the IO, split the extent */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_PRE_IO</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ext4_split_unwritten_extents</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span>
						   <span class="n">path</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Flag the inode(non aio case) or end_io struct (aio case)</span>
<span class="cm">		 * that this IO needs to conversion to written when IO is</span>
<span class="cm">		 * completed</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">io</span><span class="p">)</span>
			<span class="n">ext4_set_io_unwritten_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">io</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ext4_set_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_STATE_DIO_UNWRITTEN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext4_should_dioread_nolock</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
			<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">|=</span> <span class="n">EXT4_MAP_UNINIT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* IO end_io complete, convert the filled extent to written */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_CONVERT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ext4_convert_unwritten_extents_endio</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
							<span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext4_update_inode_fsync_trans</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">check_eofblocks_fl</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span>
						 <span class="n">path</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* buffered IO case */</span>
	<span class="cm">/*</span>
<span class="cm">	 * repeat fallocate creation request</span>
<span class="cm">	 * we already have an unwritten extent</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_UNINIT_EXT</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">map_out</span><span class="p">;</span>

	<span class="cm">/* buffered READ or buffered write_begin() lookup */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_CREATE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We have blocks reserved already.  We</span>
<span class="cm">		 * return allocated blocks so that delalloc</span>
<span class="cm">		 * won&#39;t do block reservation for us.  But</span>
<span class="cm">		 * the buffer head will be unmapped so that</span>
<span class="cm">		 * a read from the block returns 0s.</span>
<span class="cm">		 */</span>
		<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">|=</span> <span class="n">EXT4_MAP_UNWRITTEN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* buffered write, writepage time, convert*/</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ext4_ext_convert_to_initialized</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ext4_update_inode_fsync_trans</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">allocated</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">|=</span> <span class="n">EXT4_MAP_NEW</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * if we allocated more blocks than requested</span>
<span class="cm">	 * we need to make sure we unmap the extra block</span>
<span class="cm">	 * allocated. The actual needed block will get</span>
<span class="cm">	 * unmapped later when we find the buffer_head marked</span>
<span class="cm">	 * new.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">allocated</span> <span class="o">&gt;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unmap_underlying_metadata_blocks</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">,</span>
					<span class="n">newblock</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">,</span>
					<span class="n">allocated</span> <span class="o">-</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">);</span>
		<span class="n">allocated</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have done fallocate with the offset that is already</span>
<span class="cm">	 * delayed allocated, we would have block reservation</span>
<span class="cm">	 * and quota reservation done in the delayed write path.</span>
<span class="cm">	 * But fallocate would have already updated quota and block</span>
<span class="cm">	 * count for this offset. So cancel these reservation</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_DELALLOC_RESERVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reserved_clusters</span><span class="p">;</span>
		<span class="n">reserved_clusters</span> <span class="o">=</span> <span class="n">get_reserved_cluster_alloc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
				<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reserved_clusters</span><span class="p">)</span>
			<span class="n">ext4_da_update_reserve_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
						     <span class="n">reserved_clusters</span><span class="p">,</span>
						     <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">map_out:</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">|=</span> <span class="n">EXT4_MAP_MAPPED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_KEEP_SIZE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">check_eofblocks_fl</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
					 <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out1:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">allocated</span> <span class="o">&gt;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">)</span>
		<span class="n">allocated</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">;</span>
	<span class="n">ext4_ext_show_leaf</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_pblk</span> <span class="o">=</span> <span class="n">newblock</span><span class="p">;</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span> <span class="o">=</span> <span class="n">allocated</span><span class="p">;</span>
<span class="nl">out2:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext4_ext_drop_refs</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span> <span class="o">?</span> <span class="n">err</span> <span class="o">:</span> <span class="n">allocated</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * get_implied_cluster_alloc - check to see if the requested</span>
<span class="cm"> * allocation (in the map structure) overlaps with a cluster already</span>
<span class="cm"> * allocated in an extent.</span>
<span class="cm"> *	@sb	The filesystem superblock structure</span>
<span class="cm"> *	@map	The requested lblk-&gt;pblk mapping</span>
<span class="cm"> *	@ex	The extent structure which might contain an implied</span>
<span class="cm"> *			cluster allocation</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by ext4_ext_map_blocks() after we failed to</span>
<span class="cm"> * find blocks that were already in the inode&#39;s extent tree.  Hence,</span>
<span class="cm"> * we know that the beginning of the requested region cannot overlap</span>
<span class="cm"> * the extent from the inode&#39;s extent tree.  There are three cases we</span>
<span class="cm"> * want to catch.  The first is this case:</span>
<span class="cm"> *</span>
<span class="cm"> *		 |--- cluster # N--|</span>
<span class="cm"> *    |--- extent ---|	|---- requested region ---|</span>
<span class="cm"> *			|==========|</span>
<span class="cm"> *</span>
<span class="cm"> * The second case that we need to test for is this one:</span>
<span class="cm"> *</span>
<span class="cm"> *   |--------- cluster # N ----------------|</span>
<span class="cm"> *	   |--- requested region --|   |------- extent ----|</span>
<span class="cm"> *	   |=======================|</span>
<span class="cm"> *</span>
<span class="cm"> * The third case is when the requested region lies between two extents</span>
<span class="cm"> * within the same cluster:</span>
<span class="cm"> *          |------------- cluster # N-------------|</span>
<span class="cm"> * |----- ex -----|                  |---- ex_right ----|</span>
<span class="cm"> *                  |------ requested region ------|</span>
<span class="cm"> *                  |================|</span>
<span class="cm"> *</span>
<span class="cm"> * In each of the above cases, we need to set the map-&gt;m_pblk and</span>
<span class="cm"> * map-&gt;m_len so it corresponds to the return the extent labelled as</span>
<span class="cm"> * &quot;|====|&quot; from cluster #N, since it is already in use for data in</span>
<span class="cm"> * cluster EXT4_B2C(sbi, map-&gt;m_lblk).	We will then return 1 to</span>
<span class="cm"> * signal to ext4_ext_map_blocks() that map-&gt;m_pblk should be treated</span>
<span class="cm"> * as a new &quot;allocated&quot; block region.  Otherwise, we will return 0 and</span>
<span class="cm"> * ext4_ext_map_blocks() will then allocate one or more new clusters</span>
<span class="cm"> * by calling ext4_mb_new_blocks().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">get_implied_cluster_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">ext4_lblk_t</span> <span class="n">c_offset</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cluster_ratio</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">ext4_lblk_t</span> <span class="n">ex_cluster_start</span><span class="p">,</span> <span class="n">ex_cluster_end</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span> <span class="n">rr_cluster_start</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span> <span class="n">ee_block</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">);</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">ee_start</span> <span class="o">=</span> <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ee_len</span> <span class="o">=</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>

	<span class="cm">/* The extent passed in that we are trying to match */</span>
	<span class="n">ex_cluster_start</span> <span class="o">=</span> <span class="n">EXT4_B2C</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">ee_block</span><span class="p">);</span>
	<span class="n">ex_cluster_end</span> <span class="o">=</span> <span class="n">EXT4_B2C</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">ee_block</span> <span class="o">+</span> <span class="n">ee_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* The requested region passed into ext4_map_blocks() */</span>
	<span class="n">rr_cluster_start</span> <span class="o">=</span> <span class="n">EXT4_B2C</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rr_cluster_start</span> <span class="o">==</span> <span class="n">ex_cluster_end</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">rr_cluster_start</span> <span class="o">==</span> <span class="n">ex_cluster_start</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rr_cluster_start</span> <span class="o">==</span> <span class="n">ex_cluster_end</span><span class="p">)</span>
			<span class="n">ee_start</span> <span class="o">+=</span> <span class="n">ee_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_pblk</span> <span class="o">=</span> <span class="p">(</span><span class="n">ee_start</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cluster_ratio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span>
			<span class="n">c_offset</span><span class="p">;</span>
		<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cluster_ratio</span> <span class="o">-</span> <span class="n">c_offset</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check for and handle this case:</span>
<span class="cm">		 *</span>
<span class="cm">		 *   |--------- cluster # N-------------|</span>
<span class="cm">		 *		       |------- extent ----|</span>
<span class="cm">		 *	   |--- requested region ---|</span>
<span class="cm">		 *	   |===========|</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">&lt;</span> <span class="n">ee_block</span><span class="p">)</span>
			<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">,</span> <span class="n">ee_block</span> <span class="o">-</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check for the case where there is already another allocated</span>
<span class="cm">		 * block to the right of &#39;ex&#39; but before the end of the cluster.</span>
<span class="cm">		 *</span>
<span class="cm">		 *          |------------- cluster # N-------------|</span>
<span class="cm">		 * |----- ex -----|                  |---- ex_right ----|</span>
<span class="cm">		 *                  |------ requested region ------|</span>
<span class="cm">		 *                  |================|</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">&gt;</span> <span class="n">ee_block</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ext4_lblk_t</span> <span class="n">next</span> <span class="o">=</span> <span class="n">ext4_ext_next_allocated_block</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">,</span> <span class="n">next</span> <span class="o">-</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">trace_ext4_get_implied_cluster_alloc_exit</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace_ext4_get_implied_cluster_alloc_exit</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Block allocation/map/preallocation routine for extents based files</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Need to be called with</span>
<span class="cm"> * down_read(&amp;EXT4_I(inode)-&gt;i_data_sem) if not allocating file system block</span>
<span class="cm"> * (ie, create is zero). Otherwise down_write(&amp;EXT4_I(inode)-&gt;i_data_sem)</span>
<span class="cm"> *</span>
<span class="cm"> * return &gt; 0, number of of blocks already mapped/allocated</span>
<span class="cm"> *          if create == 0 and these are pre-allocated blocks</span>
<span class="cm"> *          	buffer head is unmapped</span>
<span class="cm"> *          otherwise blocks are mapped</span>
<span class="cm"> *</span>
<span class="cm"> * return = 0, if plain look up failed (blocks have not been allocated)</span>
<span class="cm"> *          buffer head is unmapped</span>
<span class="cm"> *</span>
<span class="cm"> * return &lt; 0, error case.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ext4_ext_map_blocks</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_ext_path</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="n">newex</span><span class="p">,</span> <span class="o">*</span><span class="n">ex</span><span class="p">,</span> <span class="o">*</span><span class="n">ex2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">newblock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">free_on_err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">allocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">allocated_clusters</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_allocation_request</span> <span class="n">ar</span><span class="p">;</span>
	<span class="n">ext4_io_end_t</span> <span class="o">*</span><span class="n">io</span> <span class="o">=</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cur_aio_dio</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span> <span class="n">cluster_offset</span><span class="p">;</span>

	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;blocks %u/%u requested for inode %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">trace_ext4_ext_map_blocks_enter</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* check in cache */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_ext_in_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newex</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newex</span><span class="p">.</span><span class="n">ee_start_lo</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">newex</span><span class="p">.</span><span class="n">ee_start_hi</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cluster_ratio</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">ext4_find_delalloc_cluster</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
				<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">|=</span> <span class="n">EXT4_MAP_FROM_CLUSTER</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_CREATE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * block isn&#39;t allocated yet and</span>
<span class="cm">				 * user doesn&#39;t want to allocate it</span>
<span class="cm">				 */</span>
				<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* we should allocate requested block */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* block is already allocated */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cluster_ratio</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">|=</span> <span class="n">EXT4_MAP_FROM_CLUSTER</span><span class="p">;</span>
			<span class="n">newblock</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span>
				   <span class="o">-</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">newex</span><span class="p">.</span><span class="n">ee_block</span><span class="p">)</span>
				   <span class="o">+</span> <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newex</span><span class="p">);</span>
			<span class="cm">/* number of remaining blocks in the extent */</span>
			<span class="n">allocated</span> <span class="o">=</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newex</span><span class="p">)</span> <span class="o">-</span>
				<span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">-</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">newex</span><span class="p">.</span><span class="n">ee_block</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* find extent for this block */</span>
	<span class="n">path</span> <span class="o">=</span> <span class="n">ext4_ext_find_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">path</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">path</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">depth</span> <span class="o">=</span> <span class="n">ext_depth</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * consistent leaf must not be empty;</span>
<span class="cm">	 * this situation is possible, though, _during_ tree modification;</span>
<span class="cm">	 * this is why assert can&#39;t be put in ext4_ext_find_extent()</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">depth</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">EXT4_ERROR_INODE</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="s">&quot;bad extent address &quot;</span>
				 <span class="s">&quot;lblock: %lu, depth: %d pblock %lld&quot;</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span>
				 <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_block</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ex</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">depth</span><span class="p">].</span><span class="n">p_ext</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext4_lblk_t</span> <span class="n">ee_block</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ex</span><span class="o">-&gt;</span><span class="n">ee_block</span><span class="p">);</span>
		<span class="n">ext4_fsblk_t</span> <span class="n">ee_start</span> <span class="o">=</span> <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ee_len</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Uninitialized extents are treated as holes, except that</span>
<span class="cm">		 * we split out initialized portions during a write.</span>
<span class="cm">		 */</span>
		<span class="n">ee_len</span> <span class="o">=</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>

		<span class="n">trace_ext4_ext_show_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ee_block</span><span class="p">,</span> <span class="n">ee_start</span><span class="p">,</span> <span class="n">ee_len</span><span class="p">);</span>

		<span class="cm">/* if found extent covers block, simply return it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_range</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span> <span class="n">ee_block</span><span class="p">,</span> <span class="n">ee_len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">newblock</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">-</span> <span class="n">ee_block</span> <span class="o">+</span> <span class="n">ee_start</span><span class="p">;</span>
			<span class="cm">/* number of remaining blocks in the extent */</span>
			<span class="n">allocated</span> <span class="o">=</span> <span class="n">ee_len</span> <span class="o">-</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">-</span> <span class="n">ee_block</span><span class="p">);</span>
			<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;%u fit into %u:%d -&gt; %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span>
				  <span class="n">ee_block</span><span class="p">,</span> <span class="n">ee_len</span><span class="p">,</span> <span class="n">newblock</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Do not put uninitialized extent</span>
<span class="cm">			 * in the cache</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ext4_ext_is_uninitialized</span><span class="p">(</span><span class="n">ex</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ext4_ext_put_in_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ee_block</span><span class="p">,</span>
					<span class="n">ee_len</span><span class="p">,</span> <span class="n">ee_start</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ext4_ext_handle_uninitialized_extents</span><span class="p">(</span>
				<span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
				<span class="n">allocated</span><span class="p">,</span> <span class="n">newblock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cluster_ratio</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ext4_find_delalloc_cluster</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">|=</span> <span class="n">EXT4_MAP_FROM_CLUSTER</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * requested block isn&#39;t allocated yet;</span>
<span class="cm">	 * we couldn&#39;t try to create block if create flag is zero</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_CREATE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * put just found gap into cache to speed up</span>
<span class="cm">		 * subsequent requests</span>
<span class="cm">		 */</span>
		<span class="n">ext4_ext_put_gap_in_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Okay, we need to do block allocation.</span>
<span class="cm">	 */</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EXT4_MAP_FROM_CLUSTER</span><span class="p">;</span>
	<span class="n">newex</span><span class="p">.</span><span class="n">ee_block</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">);</span>
	<span class="n">cluster_offset</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cluster_ratio</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are doing bigalloc, check to see if the extent returned</span>
<span class="cm">	 * by ext4_ext_find_extent() implies a cluster we can use.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cluster_offset</span> <span class="o">&amp;&amp;</span> <span class="n">ex</span> <span class="o">&amp;&amp;</span>
	    <span class="n">get_implied_cluster_alloc</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ar</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">allocated</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">;</span>
		<span class="n">newblock</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_pblk</span><span class="p">;</span>
		<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">|=</span> <span class="n">EXT4_MAP_FROM_CLUSTER</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">got_allocated_blocks</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* find neighbour allocated blocks */</span>
	<span class="n">ar</span><span class="p">.</span><span class="n">lleft</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_search_left</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ar</span><span class="p">.</span><span class="n">lleft</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ar</span><span class="p">.</span><span class="n">pleft</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>
	<span class="n">ar</span><span class="p">.</span><span class="n">lright</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">;</span>
	<span class="n">ex2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_search_right</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ar</span><span class="p">.</span><span class="n">lright</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ar</span><span class="p">.</span><span class="n">pright</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ex2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>

	<span class="cm">/* Check if the extent after searching to the right implies a</span>
<span class="cm">	 * cluster we can use. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cluster_ratio</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ex2</span> <span class="o">&amp;&amp;</span>
	    <span class="n">get_implied_cluster_alloc</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">ex2</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ar</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">allocated</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">;</span>
		<span class="n">newblock</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_pblk</span><span class="p">;</span>
		<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">|=</span> <span class="n">EXT4_MAP_FROM_CLUSTER</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">got_allocated_blocks</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * See if request is beyond maximum number of blocks we can have in</span>
<span class="cm">	 * a single extent. For an initialized extent this limit is</span>
<span class="cm">	 * EXT_INIT_MAX_LEN and for an uninitialized extent this limit is</span>
<span class="cm">	 * EXT_UNINIT_MAX_LEN.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span> <span class="o">&gt;</span> <span class="n">EXT_INIT_MAX_LEN</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_UNINIT_EXT</span><span class="p">))</span>
		<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span> <span class="o">=</span> <span class="n">EXT_INIT_MAX_LEN</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span> <span class="o">&gt;</span> <span class="n">EXT_UNINIT_MAX_LEN</span> <span class="o">&amp;&amp;</span>
		 <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_UNINIT_EXT</span><span class="p">))</span>
		<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span> <span class="o">=</span> <span class="n">EXT_UNINIT_MAX_LEN</span><span class="p">;</span>

	<span class="cm">/* Check if we can really insert (m_lblk)::(m_lblk + m_len) extent */</span>
	<span class="n">newex</span><span class="p">.</span><span class="n">ee_len</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_check_overlap</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newex</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">allocated</span> <span class="o">=</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newex</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">allocated</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">;</span>

	<span class="cm">/* allocate new block */</span>
	<span class="n">ar</span><span class="p">.</span><span class="n">inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>
	<span class="n">ar</span><span class="p">.</span><span class="n">goal</span> <span class="o">=</span> <span class="n">ext4_ext_find_goal</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">);</span>
	<span class="n">ar</span><span class="p">.</span><span class="n">logical</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We calculate the offset from the beginning of the cluster</span>
<span class="cm">	 * for the logical block number, since when we allocate a</span>
<span class="cm">	 * physical cluster, the physical block should start at the</span>
<span class="cm">	 * same offset from the beginning of the cluster.  This is</span>
<span class="cm">	 * needed so that future calls to get_implied_cluster_alloc()</span>
<span class="cm">	 * work correctly.</span>
<span class="cm">	 */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cluster_ratio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ar</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">EXT4_NUM_B2C</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">offset</span><span class="o">+</span><span class="n">allocated</span><span class="p">);</span>
	<span class="n">ar</span><span class="p">.</span><span class="n">goal</span> <span class="o">-=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">ar</span><span class="p">.</span><span class="n">logical</span> <span class="o">-=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">ar</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">EXT4_MB_HINT_DATA</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="cm">/* disable in-core preallocation for non-regular files */</span>
		<span class="n">ar</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_NO_NORMALIZE</span><span class="p">)</span>
		<span class="n">ar</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">EXT4_MB_HINT_NOPREALLOC</span><span class="p">;</span>
	<span class="n">newblock</span> <span class="o">=</span> <span class="n">ext4_mb_new_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ar</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newblock</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>
	<span class="n">ext_debug</span><span class="p">(</span><span class="s">&quot;allocate new block: goal %llu, found %llu/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">ar</span><span class="p">.</span><span class="n">goal</span><span class="p">,</span> <span class="n">newblock</span><span class="p">,</span> <span class="n">allocated</span><span class="p">);</span>
	<span class="n">free_on_err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">allocated_clusters</span> <span class="o">=</span> <span class="n">ar</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
	<span class="n">ar</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">EXT4_C2B</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">ar</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ar</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">allocated</span><span class="p">)</span>
		<span class="n">ar</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">allocated</span><span class="p">;</span>

<span class="nl">got_allocated_blocks:</span>
	<span class="cm">/* try to insert new extent into found leaf and return */</span>
	<span class="n">ext4_ext_store_pblock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newex</span><span class="p">,</span> <span class="n">newblock</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">newex</span><span class="p">.</span><span class="n">ee_len</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ar</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="cm">/* Mark uninitialized */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_UNINIT_EXT</span><span class="p">){</span>
		<span class="n">ext4_ext_mark_uninitialized</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newex</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * io_end structure was created for every IO write to an</span>
<span class="cm">		 * uninitialized extent. To avoid unnecessary conversion,</span>
<span class="cm">		 * here we flag the IO that really needs the conversion.</span>
<span class="cm">		 * For non asycn direct IO case, flag the inode state</span>
<span class="cm">		 * that we need to perform conversion when IO is done.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_PRE_IO</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">io</span><span class="p">)</span>
				<span class="n">ext4_set_io_unwritten_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">io</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">ext4_set_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
						     <span class="n">EXT4_STATE_DIO_UNWRITTEN</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ext4_should_dioread_nolock</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
			<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">|=</span> <span class="n">EXT4_MAP_UNINIT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_KEEP_SIZE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">check_eofblocks_fl</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span>
					 <span class="n">path</span><span class="p">,</span> <span class="n">ar</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_insert_extent</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">newex</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">free_on_err</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">fb_flags</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_DELALLOC_RESERVE</span> <span class="o">?</span>
			<span class="n">EXT4_FREE_BLOCKS_NO_QUOT_UPDATE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* free data blocks we just allocated */</span>
		<span class="cm">/* not a good idea to call discard here directly,</span>
<span class="cm">		 * but otherwise we&#39;d need to call it every free() */</span>
		<span class="n">ext4_discard_preallocations</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">ext4_free_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newex</span><span class="p">),</span>
				 <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newex</span><span class="p">),</span> <span class="n">fb_flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* previous routine could use block we allocated */</span>
	<span class="n">newblock</span> <span class="o">=</span> <span class="n">ext4_ext_pblock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newex</span><span class="p">);</span>
	<span class="n">allocated</span> <span class="o">=</span> <span class="n">ext4_ext_get_actual_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">allocated</span> <span class="o">&gt;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">)</span>
		<span class="n">allocated</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">;</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">|=</span> <span class="n">EXT4_MAP_NEW</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update reserved blocks/metadata blocks after successful</span>
<span class="cm">	 * block allocation which had been deferred till now.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_DELALLOC_RESERVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">reserved_clusters</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check how many clusters we had reserved this allocated range</span>
<span class="cm">		 */</span>
		<span class="n">reserved_clusters</span> <span class="o">=</span> <span class="n">get_reserved_cluster_alloc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
						<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span> <span class="n">allocated</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">EXT4_MAP_FROM_CLUSTER</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">reserved_clusters</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * We have clusters reserved for this range.</span>
<span class="cm">				 * But since we are not doing actual allocation</span>
<span class="cm">				 * and are simply using blocks from previously</span>
<span class="cm">				 * allocated cluster, we should release the</span>
<span class="cm">				 * reservation and not claim quota.</span>
<span class="cm">				 */</span>
				<span class="n">ext4_da_update_reserve_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
						<span class="n">reserved_clusters</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">allocated_clusters</span> <span class="o">&lt;</span> <span class="n">reserved_clusters</span><span class="p">);</span>
			<span class="cm">/* We will claim quota for all newly allocated blocks.*/</span>
			<span class="n">ext4_da_update_reserve_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">allocated_clusters</span><span class="p">,</span>
							<span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">reserved_clusters</span> <span class="o">&lt;</span> <span class="n">allocated_clusters</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
				<span class="kt">int</span> <span class="n">reservation</span> <span class="o">=</span> <span class="n">allocated_clusters</span> <span class="o">-</span>
						  <span class="n">reserved_clusters</span><span class="p">;</span>
				<span class="cm">/*</span>
<span class="cm">				 * It seems we claimed few clusters outside of</span>
<span class="cm">				 * the range of this allocation. We should give</span>
<span class="cm">				 * it back to the reservation pool. This can</span>
<span class="cm">				 * happen in the following case:</span>
<span class="cm">				 *</span>
<span class="cm">				 * * Suppose s_cluster_ratio is 4 (i.e., each</span>
<span class="cm">				 *   cluster has 4 blocks. Thus, the clusters</span>
<span class="cm">				 *   are [0-3],[4-7],[8-11]...</span>
<span class="cm">				 * * First comes delayed allocation write for</span>
<span class="cm">				 *   logical blocks 10 &amp; 11. Since there were no</span>
<span class="cm">				 *   previous delayed allocated blocks in the</span>
<span class="cm">				 *   range [8-11], we would reserve 1 cluster</span>
<span class="cm">				 *   for this write.</span>
<span class="cm">				 * * Next comes write for logical blocks 3 to 8.</span>
<span class="cm">				 *   In this case, we will reserve 2 clusters</span>
<span class="cm">				 *   (for [0-3] and [4-7]; and not for [8-11] as</span>
<span class="cm">				 *   that range has a delayed allocated blocks.</span>
<span class="cm">				 *   Thus total reserved clusters now becomes 3.</span>
<span class="cm">				 * * Now, during the delayed allocation writeout</span>
<span class="cm">				 *   time, we will first write blocks [3-8] and</span>
<span class="cm">				 *   allocate 3 clusters for writing these</span>
<span class="cm">				 *   blocks. Also, we would claim all these</span>
<span class="cm">				 *   three clusters above.</span>
<span class="cm">				 * * Now when we come here to writeout the</span>
<span class="cm">				 *   blocks [10-11], we would expect to claim</span>
<span class="cm">				 *   the reservation of 1 cluster we had made</span>
<span class="cm">				 *   (and we would claim it since there are no</span>
<span class="cm">				 *   more delayed allocated blocks in the range</span>
<span class="cm">				 *   [8-11]. But our reserved cluster count had</span>
<span class="cm">				 *   already gone to 0.</span>
<span class="cm">				 *</span>
<span class="cm">				 *   Thus, at the step 4 above when we determine</span>
<span class="cm">				 *   that there are still some unwritten delayed</span>
<span class="cm">				 *   allocated blocks outside of our current</span>
<span class="cm">				 *   block range, we should increment the</span>
<span class="cm">				 *   reserved clusters count so that when the</span>
<span class="cm">				 *   remaining blocks finally gets written, we</span>
<span class="cm">				 *   could claim them.</span>
<span class="cm">				 */</span>
				<span class="n">dquot_reserve_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
						<span class="n">EXT4_C2B</span><span class="p">(</span><span class="n">sbi</span><span class="p">,</span> <span class="n">reservation</span><span class="p">));</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_block_reservation_lock</span><span class="p">);</span>
				<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_reserved_data_blocks</span> <span class="o">+=</span> <span class="n">reservation</span><span class="p">;</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_block_reservation_lock</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Cache the extent and update transaction to commit on fdatasync only</span>
<span class="cm">	 * when it is _not_ an uninitialized extent.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_GET_BLOCKS_UNINIT_EXT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext4_ext_put_in_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span> <span class="n">allocated</span><span class="p">,</span> <span class="n">newblock</span><span class="p">);</span>
		<span class="n">ext4_update_inode_fsync_trans</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ext4_update_inode_fsync_trans</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">allocated</span> <span class="o">&gt;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">)</span>
		<span class="n">allocated</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">;</span>
	<span class="n">ext4_ext_show_leaf</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">|=</span> <span class="n">EXT4_MAP_MAPPED</span><span class="p">;</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_pblk</span> <span class="o">=</span> <span class="n">newblock</span><span class="p">;</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span> <span class="o">=</span> <span class="n">allocated</span><span class="p">;</span>
<span class="nl">out2:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ext4_ext_drop_refs</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">trace_ext4_ext_map_blocks_exit</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_lblk</span><span class="p">,</span>
		<span class="n">newblock</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">m_len</span><span class="p">,</span> <span class="n">err</span> <span class="o">?</span> <span class="n">err</span> <span class="o">:</span> <span class="n">allocated</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span> <span class="o">?</span> <span class="n">err</span> <span class="o">:</span> <span class="n">allocated</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ext4_ext_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span> <span class="n">last_block</span><span class="p">;</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">page_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * finish any pending end_io work so we won&#39;t run the risk of</span>
<span class="cm">	 * converting any truncated blocks to initialized later</span>
<span class="cm">	 */</span>
	<span class="n">ext4_flush_completed_IO</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * probably first extent we&#39;re gonna free will be last in block</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_writepage_trans_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">%</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page_len</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span>
			<span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_discard_partial_page_buffers</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span>
			<span class="n">mapping</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span> <span class="n">page_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_stop</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_orphan_add</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_stop</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data_sem</span><span class="p">);</span>
	<span class="n">ext4_ext_invalidate_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">ext4_discard_preallocations</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * TODO: optimization is possible here.</span>
<span class="cm">	 * Probably we need not scan at all,</span>
<span class="cm">	 * because page truncation is enough.</span>
<span class="cm">	 */</span>

	<span class="cm">/* we have to know where to truncate from in crash case */</span>
	<span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_disksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="n">last_block</span> <span class="o">=</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="o">&gt;&gt;</span> <span class="n">EXT4_BLOCK_SIZE_BITS</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_remove_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">last_block</span><span class="p">,</span> <span class="n">EXT_MAX_BLOCKS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* In a multi-transaction truncate, we only make the final</span>
<span class="cm">	 * transaction synchronous.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_SYNC</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">ext4_handle_sync</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data_sem</span><span class="p">);</span>

<span class="nl">out_stop:</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this was a simple ftruncate() and the file will remain alive,</span>
<span class="cm">	 * then we need to clear up the orphan record which we created above.</span>
<span class="cm">	 * However, if this was a real unlink then we were called by</span>
<span class="cm">	 * ext4_delete_inode(), and we allow that function to clean up the</span>
<span class="cm">	 * orphan info for us.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span>
		<span class="n">ext4_orphan_del</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">ext4_current_time</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ext4_falloc_update_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">new_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">update_ctime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">update_ctime</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">now</span> <span class="o">=</span> <span class="n">current_fs_time</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timespec_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">))</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Update only when preallocation was requested beyond</span>
<span class="cm">	 * the file size.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FALLOC_FL_KEEP_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">&gt;</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
			<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">&gt;</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_disksize</span><span class="p">)</span>
			<span class="n">ext4_update_i_disksize</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Mark that we allocate beyond EOF so the subsequent truncate</span>
<span class="cm">		 * can proceed even if the new size is the same as i_size.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">&gt;</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
			<span class="n">ext4_set_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_EOFBLOCKS</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * preallocate space for a file. This implements ext4&#39;s fallocate file</span>
<span class="cm"> * operation, which gets called from sys_fallocate system call.</span>
<span class="cm"> * For block-mapped files, posix_fallocate should fall back to the method</span>
<span class="cm"> * of writing zeroes to the required new blocks (the same behavior which is</span>
<span class="cm"> * expected for file systems which do not support fallocate() system call).</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="n">ext4_fallocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">new_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_blocks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="n">map</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">credits</span><span class="p">,</span> <span class="n">blkbits</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * currently supporting (pre)allocate mode for extent-based</span>
<span class="cm">	 * files _only_</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ext4_test_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_EXTENTS</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="cm">/* Return error if mode is not supported */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">FALLOC_FL_KEEP_SIZE</span> <span class="o">|</span> <span class="n">FALLOC_FL_PUNCH_HOLE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FALLOC_FL_PUNCH_HOLE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ext4_punch_hole</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">trace_ext4_fallocate_enter</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="n">map</span><span class="p">.</span><span class="n">m_lblk</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We can&#39;t just convert len to max_blocks because</span>
<span class="cm">	 * If blocksize = 4096 offset = 3072 and len = 2048</span>
<span class="cm">	 */</span>
	<span class="n">max_blocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">EXT4_BLOCK_ALIGN</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">blkbits</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">)</span>
		<span class="o">-</span> <span class="n">map</span><span class="p">.</span><span class="n">m_lblk</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * credits to insert 1 extent into extent tree</span>
<span class="cm">	 */</span>
	<span class="n">credits</span> <span class="o">=</span> <span class="n">ext4_chunk_trans_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">max_blocks</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">inode_newsize_ok</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">offset</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="n">trace_ext4_fallocate_exit</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">max_blocks</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">EXT4_GET_BLOCKS_CREATE_UNINIT_EXT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FALLOC_FL_KEEP_SIZE</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">EXT4_GET_BLOCKS_KEEP_SIZE</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t normalize the request if it can fit in one extent so</span>
<span class="cm">	 * that it doesn&#39;t get unnecessarily split into multiple</span>
<span class="cm">	 * extents.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">EXT_UNINIT_MAX_LEN</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">EXT4_GET_BLOCKS_NO_NORMALIZE</span><span class="p">;</span>
<span class="nl">retry:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">&lt;</span> <span class="n">max_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">map</span><span class="p">.</span><span class="n">m_lblk</span> <span class="o">=</span> <span class="n">map</span><span class="p">.</span><span class="n">m_lblk</span> <span class="o">+</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">map</span><span class="p">.</span><span class="n">m_len</span> <span class="o">=</span> <span class="n">max_blocks</span> <span class="o">=</span> <span class="n">max_blocks</span> <span class="o">-</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">credits</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ext4_map_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef EXT4FS_DEBUG</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: ext4_ext_map_blocks &quot;</span>
				    <span class="s">&quot;returned error inode#%lu, block=%u, &quot;</span>
				    <span class="s">&quot;max_blocks=%u&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				    <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">map</span><span class="p">.</span><span class="n">m_lblk</span><span class="p">,</span> <span class="n">max_blocks</span><span class="p">);</span>
<span class="cp">#endif</span>
			<span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="n">ret2</span> <span class="o">=</span> <span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">map</span><span class="p">.</span><span class="n">m_lblk</span> <span class="o">+</span> <span class="n">ret</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">EXT4_BLOCK_ALIGN</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span>
						<span class="n">blkbits</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">))</span>
			<span class="n">new_size</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">new_size</span> <span class="o">=</span> <span class="p">((</span><span class="n">loff_t</span><span class="p">)</span> <span class="n">map</span><span class="p">.</span><span class="n">m_lblk</span> <span class="o">+</span> <span class="n">ret</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">;</span>

		<span class="n">ext4_falloc_update_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">new_size</span><span class="p">,</span>
					 <span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">m_flags</span> <span class="o">&amp;</span> <span class="n">EXT4_MAP_NEW</span><span class="p">));</span>
		<span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">ret2</span> <span class="o">=</span> <span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret2</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span> <span class="o">&amp;&amp;</span>
			<span class="n">ext4_should_retry_alloc</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retries</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">trace_ext4_fallocate_exit</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">max_blocks</span><span class="p">,</span>
				<span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">ret2</span> <span class="o">:</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">ret2</span> <span class="o">:</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function convert a range of blocks to written extents</span>
<span class="cm"> * The caller of this function will pass the start offset and the size.</span>
<span class="cm"> * all unwritten extents within this range will be converted to</span>
<span class="cm"> * written extents.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called from the direct IO end io call back</span>
<span class="cm"> * function, to convert the fallocated extents after IO is completed.</span>
<span class="cm"> * Returns 0 on success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ext4_convert_unwritten_extents</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
				    <span class="kt">ssize_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_blocks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="n">map</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">credits</span><span class="p">,</span> <span class="n">blkbits</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>

	<span class="n">map</span><span class="p">.</span><span class="n">m_lblk</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We can&#39;t just convert len to max_blocks because</span>
<span class="cm">	 * If blocksize = 4096 offset = 3072 and len = 2048</span>
<span class="cm">	 */</span>
	<span class="n">max_blocks</span> <span class="o">=</span> <span class="p">((</span><span class="n">EXT4_BLOCK_ALIGN</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">blkbits</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">)</span> <span class="o">-</span>
		      <span class="n">map</span><span class="p">.</span><span class="n">m_lblk</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * credits to insert 1 extent into extent tree</span>
<span class="cm">	 */</span>
	<span class="n">credits</span> <span class="o">=</span> <span class="n">ext4_chunk_trans_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">max_blocks</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">&lt;</span> <span class="n">max_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">map</span><span class="p">.</span><span class="n">m_lblk</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">map</span><span class="p">.</span><span class="n">m_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_blocks</span> <span class="o">-=</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">credits</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ext4_map_blocks</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">,</span>
				      <span class="n">EXT4_GET_BLOCKS_IO_CONVERT_EXT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ext4_msg</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span>
				 <span class="s">&quot;%s:%d: inode #%lu: block %u: len %u: &quot;</span>
				 <span class="s">&quot;ext4_ext_map_blocks returned %d&quot;</span><span class="p">,</span>
				 <span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">map</span><span class="p">.</span><span class="n">m_lblk</span><span class="p">,</span>
				 <span class="n">map</span><span class="p">.</span><span class="n">m_len</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">ret2</span> <span class="o">=</span> <span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ret2</span> <span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">ret2</span> <span class="o">:</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Callback function called for each extent to gather FIEMAP information.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ext4_ext_fiemap_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">ext4_lblk_t</span> <span class="n">next</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ext4_ext_cache</span> <span class="o">*</span><span class="n">newex</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext4_extent</span> <span class="o">*</span><span class="n">ex</span><span class="p">,</span>
		       <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u64</span>	<span class="n">logical</span><span class="p">;</span>
	<span class="n">__u64</span>	<span class="n">physical</span><span class="p">;</span>
	<span class="n">__u64</span>	<span class="n">length</span><span class="p">;</span>
	<span class="n">__u32</span>	<span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fiemap_extent_info</span> <span class="o">*</span><span class="n">fieinfo</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">blksize_bits</span><span class="p">;</span>

	<span class="n">blksize_bits</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>
	<span class="n">logical</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u64</span><span class="p">)</span><span class="n">newex</span><span class="o">-&gt;</span><span class="n">ec_block</span> <span class="o">&lt;&lt;</span> <span class="n">blksize_bits</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">newex</span><span class="o">-&gt;</span><span class="n">ec_start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * No extent in extent-tree contains block @newex-&gt;ec_start,</span>
<span class="cm">		 * then the block may stay in 1)a hole or 2)delayed-extent.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Holes or delayed-extents are processed as follows.</span>
<span class="cm">		 * 1. lookup dirty pages with specified range in pagecache.</span>
<span class="cm">		 *    If no page is got, then there is no delayed-extent and</span>
<span class="cm">		 *    return with EXT_CONTINUE.</span>
<span class="cm">		 * 2. find the 1st mapped buffer,</span>
<span class="cm">		 * 3. check if the mapped buffer is both in the request range</span>
<span class="cm">		 *    and a delayed buffer. If not, there is no delayed-extent,</span>
<span class="cm">		 *    then return.</span>
<span class="cm">		 * 4. a delayed-extent is found, the extent will be collected.</span>
<span class="cm">		 */</span>
		<span class="n">ext4_lblk_t</span>	<span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pgoff_t</span>		<span class="n">last_offset</span><span class="p">;</span>
		<span class="n">pgoff_t</span>		<span class="n">offset</span><span class="p">;</span>
		<span class="n">pgoff_t</span>		<span class="n">index</span><span class="p">;</span>
		<span class="n">pgoff_t</span>		<span class="n">start_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span>	<span class="o">**</span><span class="n">pages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>

		<span class="n">pages</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pages</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">offset</span> <span class="o">=</span> <span class="n">logical</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="nl">repeat:</span>
		<span class="n">last_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">find_get_pages_tag</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span>
					<span class="n">PAGECACHE_TAG_DIRTY</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FIEMAP_EXTENT_DELALLOC</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* First time, try to find a mapped buffer. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">out:</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">ret</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
					<span class="n">page_cache_release</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
				<span class="cm">/* just a hole. */</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">EXT_CONTINUE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">next_page:</span>
			<span class="cm">/* Try to find the 1st mapped buffer. */</span>
			<span class="n">end</span> <span class="o">=</span> <span class="p">((</span><span class="n">__u64</span><span class="p">)</span><span class="n">pages</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
				  <span class="n">blksize_bits</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="n">index</span><span class="o">++</span><span class="p">;</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;=</span> <span class="n">newex</span><span class="o">-&gt;</span><span class="n">ec_block</span> <span class="o">+</span>
					<span class="n">newex</span><span class="o">-&gt;</span><span class="n">ec_len</span><span class="p">)</span>
					<span class="cm">/* The buffer is out of</span>
<span class="cm">					 * the request range.</span>
<span class="cm">					 */</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="n">end</span> <span class="o">&gt;=</span> <span class="n">newex</span><span class="o">-&gt;</span><span class="n">ec_block</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">start_index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
					<span class="cm">/* get the 1st mapped buffer. */</span>
					<span class="k">goto</span> <span class="n">found_mapped_buffer</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
				<span class="n">end</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>

			<span class="cm">/* No mapped buffer in the range found in this page,</span>
<span class="cm">			 * We need to look up next page.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* There is no page left, but we need to limit</span>
<span class="cm">				 * newex-&gt;ec_len.</span>
<span class="cm">				 */</span>
				<span class="n">newex</span><span class="o">-&gt;</span><span class="n">ec_len</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">newex</span><span class="o">-&gt;</span><span class="n">ec_block</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">next_page</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*Find contiguous delayed buffers. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pages</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="n">last_offset</span><span class="p">)</span>
				<span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
			<span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">start_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

<span class="nl">found_mapped_buffer:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* 1st or contiguous delayed buffer found. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FIEMAP_EXTENT_DELALLOC</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * 1st delayed buffer found, record</span>
<span class="cm">				 * the start of extent.</span>
<span class="cm">				 */</span>
				<span class="n">flags</span> <span class="o">|=</span> <span class="n">FIEMAP_EXTENT_DELALLOC</span><span class="p">;</span>
				<span class="n">newex</span><span class="o">-&gt;</span><span class="n">ec_block</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
				<span class="n">logical</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u64</span><span class="p">)</span><span class="n">end</span> <span class="o">&lt;&lt;</span> <span class="n">blksize_bits</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Find contiguous delayed buffers. */</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">found_delayed_extent</span><span class="p">;</span>
				<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
				<span class="n">end</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>

			<span class="k">for</span> <span class="p">(;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">ret</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span> <span class="p">{</span>
					<span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">!=</span>
				    <span class="n">pages</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="n">index</span>
				    <span class="o">-</span> <span class="n">start_index</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Blocks are not contiguous. */</span>
					<span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
				<span class="k">do</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
						<span class="cm">/* Delayed-extent ends. */</span>
						<span class="k">goto</span> <span class="n">found_delayed_extent</span><span class="p">;</span>
					<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
					<span class="n">end</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FIEMAP_EXTENT_DELALLOC</span><span class="p">))</span>
			<span class="cm">/* a hole found. */</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">found_delayed_extent:</span>
		<span class="n">newex</span><span class="o">-&gt;</span><span class="n">ec_len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">newex</span><span class="o">-&gt;</span><span class="n">ec_block</span><span class="p">,</span>
						<span class="p">(</span><span class="n">ext4_lblk_t</span><span class="p">)</span><span class="n">EXT_INIT_MAX_LEN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">nr_pages</span> <span class="o">&amp;&amp;</span> <span class="n">bh</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
			<span class="n">newex</span><span class="o">-&gt;</span><span class="n">ec_len</span> <span class="o">&lt;</span> <span class="n">EXT_INIT_MAX_LEN</span> <span class="o">&amp;&amp;</span>
			<span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Have not collected an extent and continue. */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">ret</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">ret</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">physical</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u64</span><span class="p">)</span><span class="n">newex</span><span class="o">-&gt;</span><span class="n">ec_start</span> <span class="o">&lt;&lt;</span> <span class="n">blksize_bits</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span>   <span class="p">(</span><span class="n">__u64</span><span class="p">)</span><span class="n">newex</span><span class="o">-&gt;</span><span class="n">ec_len</span> <span class="o">&lt;&lt;</span> <span class="n">blksize_bits</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ex</span> <span class="o">&amp;&amp;</span> <span class="n">ext4_ext_is_uninitialized</span><span class="p">(</span><span class="n">ex</span><span class="p">))</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">FIEMAP_EXTENT_UNWRITTEN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="n">EXT_MAX_BLOCKS</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">FIEMAP_EXTENT_LAST</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">fiemap_fill_next_extent</span><span class="p">(</span><span class="n">fieinfo</span><span class="p">,</span> <span class="n">logical</span><span class="p">,</span> <span class="n">physical</span><span class="p">,</span>
					<span class="n">length</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EXT_BREAK</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">EXT_CONTINUE</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* fiemap flags we can handle specified here */</span>
<span class="cp">#define EXT4_FIEMAP_FLAGS	(FIEMAP_FLAG_SYNC|FIEMAP_FLAG_XATTR)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ext4_xattr_fiemap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">fiemap_extent_info</span> <span class="o">*</span><span class="n">fieinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u64</span> <span class="n">physical</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">FIEMAP_EXTENT_LAST</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">blockbits</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* in-inode? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ext4_test_inode_state</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_STATE_XATTR</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ext4_iloc</span> <span class="n">iloc</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>	<span class="cm">/* offset of xattr in inode */</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">ext4_get_inode_loc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iloc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">physical</span> <span class="o">=</span> <span class="n">iloc</span><span class="p">.</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">&lt;&lt;</span> <span class="n">blockbits</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">EXT4_GOOD_OLD_INODE_SIZE</span> <span class="o">+</span>
				<span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_extra_isize</span><span class="p">;</span>
		<span class="n">physical</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_inode_size</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">FIEMAP_EXTENT_DATA_INLINE</span><span class="p">;</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">iloc</span><span class="p">.</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* external block */</span>
		<span class="n">physical</span> <span class="o">=</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_file_acl</span> <span class="o">&lt;&lt;</span> <span class="n">blockbits</span><span class="p">;</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">physical</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">fiemap_fill_next_extent</span><span class="p">(</span><span class="n">fieinfo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">physical</span><span class="p">,</span>
						<span class="n">length</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">error</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ext4_ext_punch_hole</span>
<span class="cm"> *</span>
<span class="cm"> * Punches a hole of &quot;length&quot; bytes in a file starting</span>
<span class="cm"> * at byte &quot;offset&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * @inode:  The inode of the file to punch a hole in</span>
<span class="cm"> * @offset: The starting byte offset of the hole</span>
<span class="cm"> * @length: The length of the hole</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of blocks removed or negative on err</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ext4_ext_punch_hole</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span> <span class="n">first_block</span><span class="p">,</span> <span class="n">stop_block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">first_page</span><span class="p">,</span> <span class="n">last_page</span><span class="p">,</span> <span class="n">page_len</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">first_page_offset</span><span class="p">,</span> <span class="n">last_page_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">credits</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* No need to punch hole beyond i_size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the hole extends beyond i_size, set the hole</span>
<span class="cm">	 * to end after the page that contains i_size</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+</span>
		   <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span>
		   <span class="n">offset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">first_page</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">last_page</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">length</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>

	<span class="n">first_page_offset</span> <span class="o">=</span> <span class="n">first_page</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">last_page_offset</span> <span class="o">=</span> <span class="n">last_page</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write out all dirty pages to avoid race conditions</span>
<span class="cm">	 * Then release them.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span> <span class="o">&amp;&amp;</span> <span class="n">mapping_tagged</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">PAGECACHE_TAG_DIRTY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">filemap_write_and_wait_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span>
			<span class="n">offset</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now release the pages */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_page_offset</span> <span class="o">&gt;</span> <span class="n">first_page_offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">truncate_pagecache_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">first_page_offset</span><span class="p">,</span>
					 <span class="n">last_page_offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* finish any pending end_io work */</span>
	<span class="n">ext4_flush_completed_IO</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">credits</span> <span class="o">=</span> <span class="n">ext4_writepage_trans_blocks</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">handle</span> <span class="o">=</span> <span class="n">ext4_journal_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">credits</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_orphan_add</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we need to zero out the non-page-aligned data in the</span>
<span class="cm">	 * pages at the start and tail of the hole, and unmap the buffer</span>
<span class="cm">	 * heads for the block aligned regions of the page that were</span>
<span class="cm">	 * completely zeroed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first_page</span> <span class="o">&gt;</span> <span class="n">last_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the file space being truncated is contained within a page</span>
<span class="cm">		 * just zero out and unmap the middle of that page</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_discard_partial_page_buffers</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span>
			<span class="n">mapping</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * zero out and unmap the partial page that contains</span>
<span class="cm">		 * the start of the hole</span>
<span class="cm">		 */</span>
		<span class="n">page_len</span>  <span class="o">=</span> <span class="n">first_page_offset</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_discard_partial_page_buffers</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span>
						   <span class="n">offset</span><span class="p">,</span> <span class="n">page_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * zero out and unmap the partial page that contains</span>
<span class="cm">		 * the end of the hole</span>
<span class="cm">		 */</span>
		<span class="n">page_len</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">length</span> <span class="o">-</span> <span class="n">last_page_offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_discard_partial_page_buffers</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span>
					<span class="n">last_page_offset</span><span class="p">,</span> <span class="n">page_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If i_size is contained in the last page, we need to</span>
<span class="cm">	 * unmap and zero the partial page after i_size</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span> <span class="o">==</span> <span class="n">last_page</span> <span class="o">&amp;&amp;</span>
	   <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">%</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">page_len</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span>
			<span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">page_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_discard_partial_page_buffers</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span>
			  <span class="n">mapping</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span> <span class="n">page_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">first_block</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
		<span class="n">EXT4_BLOCK_SIZE_BITS</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">stop_block</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">length</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">EXT4_BLOCK_SIZE_BITS</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="cm">/* If there are no blocks to remove, return now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first_block</span> <span class="o">&gt;=</span> <span class="n">stop_block</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data_sem</span><span class="p">);</span>
	<span class="n">ext4_ext_invalidate_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ext4_discard_preallocations</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ext4_ext_remove_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">first_block</span><span class="p">,</span> <span class="n">stop_block</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">ext4_ext_invalidate_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ext4_discard_preallocations</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_SYNC</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">ext4_handle_sync</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data_sem</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">ext4_orphan_del</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">ext4_current_time</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ext4_mark_inode_dirty</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">ext4_journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">ext4_fiemap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fiemap_extent_info</span> <span class="o">*</span><span class="n">fieinfo</span><span class="p">,</span>
		<span class="n">__u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext4_lblk_t</span> <span class="n">start_blk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* fallback to generic here if not in extents fmt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ext4_test_inode_flag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">EXT4_INODE_EXTENTS</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">generic_block_fiemap</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fieinfo</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
			<span class="n">ext4_get_block</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fiemap_check_flags</span><span class="p">(</span><span class="n">fieinfo</span><span class="p">,</span> <span class="n">EXT4_FIEMAP_FLAGS</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fieinfo</span><span class="o">-&gt;</span><span class="n">fi_flags</span> <span class="o">&amp;</span> <span class="n">FIEMAP_FLAG_XATTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">ext4_xattr_fiemap</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fieinfo</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ext4_lblk_t</span> <span class="n">len_blks</span><span class="p">;</span>
		<span class="n">__u64</span> <span class="n">last_blk</span><span class="p">;</span>

		<span class="n">start_blk</span> <span class="o">=</span> <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>
		<span class="n">last_blk</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last_blk</span> <span class="o">&gt;=</span> <span class="n">EXT_MAX_BLOCKS</span><span class="p">)</span>
			<span class="n">last_blk</span> <span class="o">=</span> <span class="n">EXT_MAX_BLOCKS</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">len_blks</span> <span class="o">=</span> <span class="p">((</span><span class="n">ext4_lblk_t</span><span class="p">)</span> <span class="n">last_blk</span><span class="p">)</span> <span class="o">-</span> <span class="n">start_blk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Walk the extent tree gathering extent information.</span>
<span class="cm">		 * ext4_ext_fiemap_cb will push extents back to user.</span>
<span class="cm">		 */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">ext4_ext_walk_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start_blk</span><span class="p">,</span> <span class="n">len_blks</span><span class="p">,</span>
					  <span class="n">ext4_ext_fiemap_cb</span><span class="p">,</span> <span class="n">fieinfo</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
