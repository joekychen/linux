<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ext4 › ext4.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ext4.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  ext4.h</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1992, 1993, 1994, 1995</span>
<span class="cm"> * Remy Card (card@masi.ibp.fr)</span>
<span class="cm"> * Laboratoire MASI - Institut Blaise Pascal</span>
<span class="cm"> * Universite Pierre et Marie Curie (Paris VI)</span>
<span class="cm"> *</span>
<span class="cm"> *  from</span>
<span class="cm"> *</span>
<span class="cm"> *  linux/include/linux/minix_fs.h</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _EXT4_H</span>
<span class="cp">#define _EXT4_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/magic.h&gt;</span>
<span class="cp">#include &lt;linux/jbd2.h&gt;</span>
<span class="cp">#include &lt;linux/quota.h&gt;</span>
<span class="cp">#include &lt;linux/rwsem.h&gt;</span>
<span class="cp">#include &lt;linux/rbtree.h&gt;</span>
<span class="cp">#include &lt;linux/seqlock.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/blockgroup_lock.h&gt;</span>
<span class="cp">#include &lt;linux/percpu_counter.h&gt;</span>
<span class="cp">#include &lt;crypto/hash.h&gt;</span>
<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * The fourth extended filesystem constants/structures</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Define EXT4FS_DEBUG to produce debug messages</span>
<span class="cm"> */</span>
<span class="cp">#undef EXT4FS_DEBUG</span>

<span class="cm">/*</span>
<span class="cm"> * Debug code</span>
<span class="cm"> */</span>
<span class="cp">#ifdef EXT4FS_DEBUG</span>
<span class="cp">#define ext4_debug(f, a...)						\</span>
<span class="cp">	do {								\</span>
<span class="cp">		printk(KERN_DEBUG &quot;EXT4-fs DEBUG (%s, %d): %s:&quot;,	\</span>
<span class="cp">			__FILE__, __LINE__, __func__);			\</span>
<span class="cp">		printk(KERN_DEBUG f, ## a);				\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#else</span>
<span class="cp">#define ext4_debug(fmt, ...)	no_printk(fmt, ##__VA_ARGS__)</span>
<span class="cp">#endif</span>

<span class="cp">#define EXT4_ERROR_INODE(inode, fmt, a...) \</span>
<span class="cp">	ext4_error_inode((inode), __func__, __LINE__, 0, (fmt), ## a)</span>

<span class="cp">#define EXT4_ERROR_INODE_BLOCK(inode, block, fmt, a...)			\</span>
<span class="cp">	ext4_error_inode((inode), __func__, __LINE__, (block), (fmt), ## a)</span>

<span class="cp">#define EXT4_ERROR_FILE(file, block, fmt, a...)				\</span>
<span class="cp">	ext4_error_file((file), __func__, __LINE__, (block), (fmt), ## a)</span>

<span class="cm">/* data type for block offset of block group */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">ext4_grpblk_t</span><span class="p">;</span>

<span class="cm">/* data type for filesystem-wide blocks number */</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ext4_fsblk_t</span><span class="p">;</span>

<span class="cm">/* data type for file logical block number */</span>
<span class="k">typedef</span> <span class="n">__u32</span> <span class="n">ext4_lblk_t</span><span class="p">;</span>

<span class="cm">/* data type for block group number */</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ext4_group_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Flags used in mballoc&#39;s allocation_context flags field.</span>
<span class="cm"> *</span>
<span class="cm"> * Also used to show what&#39;s going on for debugging purposes when the</span>
<span class="cm"> * flag field is exported via the traceport interface</span>
<span class="cm"> */</span>

<span class="cm">/* prefer goal again. length */</span>
<span class="cp">#define EXT4_MB_HINT_MERGE		0x0001</span>
<span class="cm">/* blocks already reserved */</span>
<span class="cp">#define EXT4_MB_HINT_RESERVED		0x0002</span>
<span class="cm">/* metadata is being allocated */</span>
<span class="cp">#define EXT4_MB_HINT_METADATA		0x0004</span>
<span class="cm">/* first blocks in the file */</span>
<span class="cp">#define EXT4_MB_HINT_FIRST		0x0008</span>
<span class="cm">/* search for the best chunk */</span>
<span class="cp">#define EXT4_MB_HINT_BEST		0x0010</span>
<span class="cm">/* data is being allocated */</span>
<span class="cp">#define EXT4_MB_HINT_DATA		0x0020</span>
<span class="cm">/* don&#39;t preallocate (for tails) */</span>
<span class="cp">#define EXT4_MB_HINT_NOPREALLOC		0x0040</span>
<span class="cm">/* allocate for locality group */</span>
<span class="cp">#define EXT4_MB_HINT_GROUP_ALLOC	0x0080</span>
<span class="cm">/* allocate goal blocks or none */</span>
<span class="cp">#define EXT4_MB_HINT_GOAL_ONLY		0x0100</span>
<span class="cm">/* goal is meaningful */</span>
<span class="cp">#define EXT4_MB_HINT_TRY_GOAL		0x0200</span>
<span class="cm">/* blocks already pre-reserved by delayed allocation */</span>
<span class="cp">#define EXT4_MB_DELALLOC_RESERVED	0x0400</span>
<span class="cm">/* We are doing stream allocation */</span>
<span class="cp">#define EXT4_MB_STREAM_ALLOC		0x0800</span>
<span class="cm">/* Use reserved root blocks if needed */</span>
<span class="cp">#define EXT4_MB_USE_ROOT_BLOCKS		0x1000</span>

<span class="k">struct</span> <span class="n">ext4_allocation_request</span> <span class="p">{</span>
	<span class="cm">/* target inode for block we&#39;re allocating */</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="cm">/* how many blocks we want to allocate */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="cm">/* logical block in target inode */</span>
	<span class="n">ext4_lblk_t</span> <span class="n">logical</span><span class="p">;</span>
	<span class="cm">/* the closest logical allocated block to the left */</span>
	<span class="n">ext4_lblk_t</span> <span class="n">lleft</span><span class="p">;</span>
	<span class="cm">/* the closest logical allocated block to the right */</span>
	<span class="n">ext4_lblk_t</span> <span class="n">lright</span><span class="p">;</span>
	<span class="cm">/* phys. target (a hint) */</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">goal</span><span class="p">;</span>
	<span class="cm">/* phys. block for the closest logical allocated block to the left */</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">pleft</span><span class="p">;</span>
	<span class="cm">/* phys. block for the closest logical allocated block to the right */</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">pright</span><span class="p">;</span>
	<span class="cm">/* flags. see above EXT4_MB_HINT_* */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Logical to physical block mapping, used by ext4_map_blocks()</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is used to pass requests into ext4_map_blocks() as</span>
<span class="cm"> * well as to store the information returned by ext4_map_blocks().  It</span>
<span class="cm"> * takes less room on the stack than a struct buffer_head.</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_MAP_NEW		(1 &lt;&lt; BH_New)</span>
<span class="cp">#define EXT4_MAP_MAPPED		(1 &lt;&lt; BH_Mapped)</span>
<span class="cp">#define EXT4_MAP_UNWRITTEN	(1 &lt;&lt; BH_Unwritten)</span>
<span class="cp">#define EXT4_MAP_BOUNDARY	(1 &lt;&lt; BH_Boundary)</span>
<span class="cp">#define EXT4_MAP_UNINIT		(1 &lt;&lt; BH_Uninit)</span>
<span class="cm">/* Sometimes (in the bigalloc case, from ext4_da_get_block_prep) the caller of</span>
<span class="cm"> * ext4_map_blocks wants to know whether or not the underlying cluster has</span>
<span class="cm"> * already been accounted for. EXT4_MAP_FROM_CLUSTER conveys to the caller that</span>
<span class="cm"> * the requested mapping was from previously mapped (or delayed allocated)</span>
<span class="cm"> * cluster. We use BH_AllocFromCluster only for this flag. BH_AllocFromCluster</span>
<span class="cm"> * should never appear on buffer_head&#39;s state flags.</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_MAP_FROM_CLUSTER	(1 &lt;&lt; BH_AllocFromCluster)</span>
<span class="cp">#define EXT4_MAP_FLAGS		(EXT4_MAP_NEW | EXT4_MAP_MAPPED |\</span>
<span class="cp">				 EXT4_MAP_UNWRITTEN | EXT4_MAP_BOUNDARY |\</span>
<span class="cp">				 EXT4_MAP_UNINIT | EXT4_MAP_FROM_CLUSTER)</span>

<span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="p">{</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">m_pblk</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span> <span class="n">m_lblk</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m_flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * For delayed allocation tracking</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mpage_da_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">b_blocknr</span><span class="p">;</span>		<span class="cm">/* start block number of extent */</span>
	<span class="kt">size_t</span> <span class="n">b_size</span><span class="p">;</span>			<span class="cm">/* size of extent */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">b_state</span><span class="p">;</span>		<span class="cm">/* state of the extent */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first_page</span><span class="p">,</span> <span class="n">next_page</span><span class="p">;</span>	<span class="cm">/* extent of pages */</span>
	<span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">io_done</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pages_written</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Flags for ext4_io_end-&gt;flags</span>
<span class="cm"> */</span>
<span class="cp">#define	EXT4_IO_END_UNWRITTEN	0x0001</span>
<span class="cp">#define EXT4_IO_END_ERROR	0x0002</span>
<span class="cp">#define EXT4_IO_END_QUEUED	0x0004</span>
<span class="cp">#define EXT4_IO_END_DIRECT	0x0008</span>
<span class="cp">#define EXT4_IO_END_IN_FSYNC	0x0010</span>

<span class="k">struct</span> <span class="n">ext4_io_page</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span>	<span class="o">*</span><span class="n">p_page</span><span class="p">;</span>
	<span class="n">atomic_t</span>	<span class="n">p_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define MAX_IO_PAGES 128</span>

<span class="cm">/*</span>
<span class="cm"> * For converting uninitialized extents on a work queue.</span>
<span class="cm"> *</span>
<span class="cm"> * &#39;page&#39; is only used from the writepage() path; &#39;pages&#39; is only used for</span>
<span class="cm"> * buffered writes; they are used to keep page references until conversion</span>
<span class="cm"> * takes place.  For AIO/DIO, neither field is filled in.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ext4_io_end</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>		<span class="cm">/* per-file finished IO list */</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">inode</span><span class="p">;</span>		<span class="cm">/* file being written to */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">flag</span><span class="p">;</span>		<span class="cm">/* unwritten or not */</span>
	<span class="k">struct</span> <span class="n">page</span>		<span class="o">*</span><span class="n">page</span><span class="p">;</span>		<span class="cm">/* for writepage() path */</span>
	<span class="n">loff_t</span>			<span class="n">offset</span><span class="p">;</span>		<span class="cm">/* offset in the file */</span>
	<span class="kt">ssize_t</span>			<span class="n">size</span><span class="p">;</span>		<span class="cm">/* size of the extent */</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">work</span><span class="p">;</span>		<span class="cm">/* data work queue */</span>
	<span class="k">struct</span> <span class="n">kiocb</span>		<span class="o">*</span><span class="n">iocb</span><span class="p">;</span>		<span class="cm">/* iocb struct for AIO */</span>
	<span class="kt">int</span>			<span class="n">result</span><span class="p">;</span>		<span class="cm">/* error value for AIO */</span>
	<span class="kt">int</span>			<span class="n">num_io_pages</span><span class="p">;</span>   <span class="cm">/* for writepages() */</span>
	<span class="k">struct</span> <span class="n">ext4_io_page</span>	<span class="o">*</span><span class="n">pages</span><span class="p">[</span><span class="n">MAX_IO_PAGES</span><span class="p">];</span> <span class="cm">/* for writepages() */</span>
<span class="p">}</span> <span class="n">ext4_io_end_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ext4_io_submit</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="n">io_op</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span>		<span class="o">*</span><span class="n">io_bio</span><span class="p">;</span>
	<span class="n">ext4_io_end_t</span>		<span class="o">*</span><span class="n">io_end</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_io_page</span>	<span class="o">*</span><span class="n">io_page</span><span class="p">;</span>
	<span class="n">sector_t</span>		<span class="n">io_next_block</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Special inodes numbers</span>
<span class="cm"> */</span>
<span class="cp">#define	EXT4_BAD_INO		 1	</span><span class="cm">/* Bad blocks inode */</span><span class="cp"></span>
<span class="cp">#define EXT4_ROOT_INO		 2	</span><span class="cm">/* Root inode */</span><span class="cp"></span>
<span class="cp">#define EXT4_USR_QUOTA_INO	 3	</span><span class="cm">/* User quota inode */</span><span class="cp"></span>
<span class="cp">#define EXT4_GRP_QUOTA_INO	 4	</span><span class="cm">/* Group quota inode */</span><span class="cp"></span>
<span class="cp">#define EXT4_BOOT_LOADER_INO	 5	</span><span class="cm">/* Boot loader inode */</span><span class="cp"></span>
<span class="cp">#define EXT4_UNDEL_DIR_INO	 6	</span><span class="cm">/* Undelete directory inode */</span><span class="cp"></span>
<span class="cp">#define EXT4_RESIZE_INO		 7	</span><span class="cm">/* Reserved group descriptors inode */</span><span class="cp"></span>
<span class="cp">#define EXT4_JOURNAL_INO	 8	</span><span class="cm">/* Journal inode */</span><span class="cp"></span>

<span class="cm">/* First non-reserved inode for old ext4 filesystems */</span>
<span class="cp">#define EXT4_GOOD_OLD_FIRST_INO	11</span>

<span class="cm">/*</span>
<span class="cm"> * Maximal count of links to a file</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_LINK_MAX		65000</span>

<span class="cm">/*</span>
<span class="cm"> * Macro-instructions used to manage several block sizes</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_MIN_BLOCK_SIZE		1024</span>
<span class="cp">#define	EXT4_MAX_BLOCK_SIZE		65536</span>
<span class="cp">#define EXT4_MIN_BLOCK_LOG_SIZE		10</span>
<span class="cp">#define EXT4_MAX_BLOCK_LOG_SIZE		16</span>
<span class="cp">#ifdef __KERNEL__</span>
<span class="cp"># define EXT4_BLOCK_SIZE(s)		((s)-&gt;s_blocksize)</span>
<span class="cp">#else</span>
<span class="cp"># define EXT4_BLOCK_SIZE(s)		(EXT4_MIN_BLOCK_SIZE &lt;&lt; (s)-&gt;s_log_block_size)</span>
<span class="cp">#endif</span>
<span class="cp">#define	EXT4_ADDR_PER_BLOCK(s)		(EXT4_BLOCK_SIZE(s) / sizeof(__u32))</span>
<span class="cp">#define EXT4_CLUSTER_SIZE(s)		(EXT4_BLOCK_SIZE(s) &lt;&lt; \</span>
<span class="cp">					 EXT4_SB(s)-&gt;s_cluster_bits)</span>
<span class="cp">#ifdef __KERNEL__</span>
<span class="cp"># define EXT4_BLOCK_SIZE_BITS(s)	((s)-&gt;s_blocksize_bits)</span>
<span class="cp"># define EXT4_CLUSTER_BITS(s)		(EXT4_SB(s)-&gt;s_cluster_bits)</span>
<span class="cp">#else</span>
<span class="cp"># define EXT4_BLOCK_SIZE_BITS(s)	((s)-&gt;s_log_block_size + 10)</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef __KERNEL__</span>
<span class="cp">#define	EXT4_ADDR_PER_BLOCK_BITS(s)	(EXT4_SB(s)-&gt;s_addr_per_block_bits)</span>
<span class="cp">#define EXT4_INODE_SIZE(s)		(EXT4_SB(s)-&gt;s_inode_size)</span>
<span class="cp">#define EXT4_FIRST_INO(s)		(EXT4_SB(s)-&gt;s_first_ino)</span>
<span class="cp">#else</span>
<span class="cp">#define EXT4_INODE_SIZE(s)	(((s)-&gt;s_rev_level == EXT4_GOOD_OLD_REV) ? \</span>
<span class="cp">				 EXT4_GOOD_OLD_INODE_SIZE : \</span>
<span class="cp">				 (s)-&gt;s_inode_size)</span>
<span class="cp">#define EXT4_FIRST_INO(s)	(((s)-&gt;s_rev_level == EXT4_GOOD_OLD_REV) ? \</span>
<span class="cp">				 EXT4_GOOD_OLD_FIRST_INO : \</span>
<span class="cp">				 (s)-&gt;s_first_ino)</span>
<span class="cp">#endif</span>
<span class="cp">#define EXT4_BLOCK_ALIGN(size, blkbits)		ALIGN((size), (1 &lt;&lt; (blkbits)))</span>

<span class="cm">/* Translate a block number to a cluster number */</span>
<span class="cp">#define EXT4_B2C(sbi, blk)	((blk) &gt;&gt; (sbi)-&gt;s_cluster_bits)</span>
<span class="cm">/* Translate a cluster number to a block number */</span>
<span class="cp">#define EXT4_C2B(sbi, cluster)	((cluster) &lt;&lt; (sbi)-&gt;s_cluster_bits)</span>
<span class="cm">/* Translate # of blks to # of clusters */</span>
<span class="cp">#define EXT4_NUM_B2C(sbi, blks)	(((blks) + (sbi)-&gt;s_cluster_ratio - 1) &gt;&gt; \</span>
<span class="cp">				 (sbi)-&gt;s_cluster_bits)</span>

<span class="cm">/*</span>
<span class="cm"> * Structure of a blocks group descriptor</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext4_group_desc</span>
<span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">bg_block_bitmap_lo</span><span class="p">;</span>	<span class="cm">/* Blocks bitmap block */</span>
	<span class="n">__le32</span>	<span class="n">bg_inode_bitmap_lo</span><span class="p">;</span>	<span class="cm">/* Inodes bitmap block */</span>
	<span class="n">__le32</span>	<span class="n">bg_inode_table_lo</span><span class="p">;</span>	<span class="cm">/* Inodes table block */</span>
	<span class="n">__le16</span>	<span class="n">bg_free_blocks_count_lo</span><span class="p">;</span><span class="cm">/* Free blocks count */</span>
	<span class="n">__le16</span>	<span class="n">bg_free_inodes_count_lo</span><span class="p">;</span><span class="cm">/* Free inodes count */</span>
	<span class="n">__le16</span>	<span class="n">bg_used_dirs_count_lo</span><span class="p">;</span>	<span class="cm">/* Directories count */</span>
	<span class="n">__le16</span>	<span class="n">bg_flags</span><span class="p">;</span>		<span class="cm">/* EXT4_BG_flags (INODE_UNINIT, etc) */</span>
	<span class="n">__le32</span>  <span class="n">bg_exclude_bitmap_lo</span><span class="p">;</span>   <span class="cm">/* Exclude bitmap for snapshots */</span>
	<span class="n">__le16</span>  <span class="n">bg_block_bitmap_csum_lo</span><span class="p">;</span><span class="cm">/* crc32c(s_uuid+grp_num+bbitmap) LE */</span>
	<span class="n">__le16</span>  <span class="n">bg_inode_bitmap_csum_lo</span><span class="p">;</span><span class="cm">/* crc32c(s_uuid+grp_num+ibitmap) LE */</span>
	<span class="n">__le16</span>  <span class="n">bg_itable_unused_lo</span><span class="p">;</span>	<span class="cm">/* Unused inodes count */</span>
	<span class="n">__le16</span>  <span class="n">bg_checksum</span><span class="p">;</span>		<span class="cm">/* crc16(sb_uuid+group+desc) */</span>
	<span class="n">__le32</span>	<span class="n">bg_block_bitmap_hi</span><span class="p">;</span>	<span class="cm">/* Blocks bitmap block MSB */</span>
	<span class="n">__le32</span>	<span class="n">bg_inode_bitmap_hi</span><span class="p">;</span>	<span class="cm">/* Inodes bitmap block MSB */</span>
	<span class="n">__le32</span>	<span class="n">bg_inode_table_hi</span><span class="p">;</span>	<span class="cm">/* Inodes table block MSB */</span>
	<span class="n">__le16</span>	<span class="n">bg_free_blocks_count_hi</span><span class="p">;</span><span class="cm">/* Free blocks count MSB */</span>
	<span class="n">__le16</span>	<span class="n">bg_free_inodes_count_hi</span><span class="p">;</span><span class="cm">/* Free inodes count MSB */</span>
	<span class="n">__le16</span>	<span class="n">bg_used_dirs_count_hi</span><span class="p">;</span>	<span class="cm">/* Directories count MSB */</span>
	<span class="n">__le16</span>  <span class="n">bg_itable_unused_hi</span><span class="p">;</span>    <span class="cm">/* Unused inodes count MSB */</span>
	<span class="n">__le32</span>  <span class="n">bg_exclude_bitmap_hi</span><span class="p">;</span>   <span class="cm">/* Exclude bitmap block MSB */</span>
	<span class="n">__le16</span>  <span class="n">bg_block_bitmap_csum_hi</span><span class="p">;</span><span class="cm">/* crc32c(s_uuid+grp_num+bbitmap) BE */</span>
	<span class="n">__le16</span>  <span class="n">bg_inode_bitmap_csum_hi</span><span class="p">;</span><span class="cm">/* crc32c(s_uuid+grp_num+ibitmap) BE */</span>
	<span class="n">__u32</span>   <span class="n">bg_reserved</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define EXT4_BG_INODE_BITMAP_CSUM_HI_END	\</span>
<span class="cp">	(offsetof(struct ext4_group_desc, bg_inode_bitmap_csum_hi) + \</span>
<span class="cp">	 sizeof(__le16))</span>
<span class="cp">#define EXT4_BG_BLOCK_BITMAP_CSUM_HI_END	\</span>
<span class="cp">	(offsetof(struct ext4_group_desc, bg_block_bitmap_csum_hi) + \</span>
<span class="cp">	 sizeof(__le16))</span>

<span class="cm">/*</span>
<span class="cm"> * Structure of a flex block group info</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">flex_groups</span> <span class="p">{</span>
	<span class="n">atomic_t</span> <span class="n">free_inodes</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">free_clusters</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">used_dirs</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define EXT4_BG_INODE_UNINIT	0x0001 </span><span class="cm">/* Inode table/bitmap not in use */</span><span class="cp"></span>
<span class="cp">#define EXT4_BG_BLOCK_UNINIT	0x0002 </span><span class="cm">/* Block bitmap not in use */</span><span class="cp"></span>
<span class="cp">#define EXT4_BG_INODE_ZEROED	0x0004 </span><span class="cm">/* On-disk itable initialized to zero */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Macro-instructions used to manage group descriptors</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_MIN_DESC_SIZE		32</span>
<span class="cp">#define EXT4_MIN_DESC_SIZE_64BIT	64</span>
<span class="cp">#define	EXT4_MAX_DESC_SIZE		EXT4_MIN_BLOCK_SIZE</span>
<span class="cp">#define EXT4_DESC_SIZE(s)		(EXT4_SB(s)-&gt;s_desc_size)</span>
<span class="cp">#ifdef __KERNEL__</span>
<span class="cp"># define EXT4_BLOCKS_PER_GROUP(s)	(EXT4_SB(s)-&gt;s_blocks_per_group)</span>
<span class="cp"># define EXT4_CLUSTERS_PER_GROUP(s)	(EXT4_SB(s)-&gt;s_clusters_per_group)</span>
<span class="cp"># define EXT4_DESC_PER_BLOCK(s)		(EXT4_SB(s)-&gt;s_desc_per_block)</span>
<span class="cp"># define EXT4_INODES_PER_GROUP(s)	(EXT4_SB(s)-&gt;s_inodes_per_group)</span>
<span class="cp"># define EXT4_DESC_PER_BLOCK_BITS(s)	(EXT4_SB(s)-&gt;s_desc_per_block_bits)</span>
<span class="cp">#else</span>
<span class="cp"># define EXT4_BLOCKS_PER_GROUP(s)	((s)-&gt;s_blocks_per_group)</span>
<span class="cp"># define EXT4_DESC_PER_BLOCK(s)		(EXT4_BLOCK_SIZE(s) / EXT4_DESC_SIZE(s))</span>
<span class="cp"># define EXT4_INODES_PER_GROUP(s)	((s)-&gt;s_inodes_per_group)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Constants relative to the data blocks</span>
<span class="cm"> */</span>
<span class="cp">#define	EXT4_NDIR_BLOCKS		12</span>
<span class="cp">#define	EXT4_IND_BLOCK			EXT4_NDIR_BLOCKS</span>
<span class="cp">#define	EXT4_DIND_BLOCK			(EXT4_IND_BLOCK + 1)</span>
<span class="cp">#define	EXT4_TIND_BLOCK			(EXT4_DIND_BLOCK + 1)</span>
<span class="cp">#define	EXT4_N_BLOCKS			(EXT4_TIND_BLOCK + 1)</span>

<span class="cm">/*</span>
<span class="cm"> * Inode flags</span>
<span class="cm"> */</span>
<span class="cp">#define	EXT4_SECRM_FL			0x00000001 </span><span class="cm">/* Secure deletion */</span><span class="cp"></span>
<span class="cp">#define	EXT4_UNRM_FL			0x00000002 </span><span class="cm">/* Undelete */</span><span class="cp"></span>
<span class="cp">#define	EXT4_COMPR_FL			0x00000004 </span><span class="cm">/* Compress file */</span><span class="cp"></span>
<span class="cp">#define EXT4_SYNC_FL			0x00000008 </span><span class="cm">/* Synchronous updates */</span><span class="cp"></span>
<span class="cp">#define EXT4_IMMUTABLE_FL		0x00000010 </span><span class="cm">/* Immutable file */</span><span class="cp"></span>
<span class="cp">#define EXT4_APPEND_FL			0x00000020 </span><span class="cm">/* writes to file may only append */</span><span class="cp"></span>
<span class="cp">#define EXT4_NODUMP_FL			0x00000040 </span><span class="cm">/* do not dump file */</span><span class="cp"></span>
<span class="cp">#define EXT4_NOATIME_FL			0x00000080 </span><span class="cm">/* do not update atime */</span><span class="cp"></span>
<span class="cm">/* Reserved for compression usage... */</span>
<span class="cp">#define EXT4_DIRTY_FL			0x00000100</span>
<span class="cp">#define EXT4_COMPRBLK_FL		0x00000200 </span><span class="cm">/* One or more compressed clusters */</span><span class="cp"></span>
<span class="cp">#define EXT4_NOCOMPR_FL			0x00000400 </span><span class="cm">/* Don&#39;t compress */</span><span class="cp"></span>
<span class="cp">#define EXT4_ECOMPR_FL			0x00000800 </span><span class="cm">/* Compression error */</span><span class="cp"></span>
<span class="cm">/* End compression flags --- maybe not all used */</span>
<span class="cp">#define EXT4_INDEX_FL			0x00001000 </span><span class="cm">/* hash-indexed directory */</span><span class="cp"></span>
<span class="cp">#define EXT4_IMAGIC_FL			0x00002000 </span><span class="cm">/* AFS directory */</span><span class="cp"></span>
<span class="cp">#define EXT4_JOURNAL_DATA_FL		0x00004000 </span><span class="cm">/* file data should be journaled */</span><span class="cp"></span>
<span class="cp">#define EXT4_NOTAIL_FL			0x00008000 </span><span class="cm">/* file tail should not be merged */</span><span class="cp"></span>
<span class="cp">#define EXT4_DIRSYNC_FL			0x00010000 </span><span class="cm">/* dirsync behaviour (directories only) */</span><span class="cp"></span>
<span class="cp">#define EXT4_TOPDIR_FL			0x00020000 </span><span class="cm">/* Top of directory hierarchies*/</span><span class="cp"></span>
<span class="cp">#define EXT4_HUGE_FILE_FL               0x00040000 </span><span class="cm">/* Set to each huge file */</span><span class="cp"></span>
<span class="cp">#define EXT4_EXTENTS_FL			0x00080000 </span><span class="cm">/* Inode uses extents */</span><span class="cp"></span>
<span class="cp">#define EXT4_EA_INODE_FL	        0x00200000 </span><span class="cm">/* Inode used for large EA */</span><span class="cp"></span>
<span class="cp">#define EXT4_EOFBLOCKS_FL		0x00400000 </span><span class="cm">/* Blocks allocated beyond EOF */</span><span class="cp"></span>
<span class="cp">#define EXT4_RESERVED_FL		0x80000000 </span><span class="cm">/* reserved for ext4 lib */</span><span class="cp"></span>

<span class="cp">#define EXT4_FL_USER_VISIBLE		0x004BDFFF </span><span class="cm">/* User visible flags */</span><span class="cp"></span>
<span class="cp">#define EXT4_FL_USER_MODIFIABLE		0x004B80FF </span><span class="cm">/* User modifiable flags */</span><span class="cp"></span>

<span class="cm">/* Flags that should be inherited by new inodes from their parent. */</span>
<span class="cp">#define EXT4_FL_INHERITED (EXT4_SECRM_FL | EXT4_UNRM_FL | EXT4_COMPR_FL |\</span>
<span class="cp">			   EXT4_SYNC_FL | EXT4_NODUMP_FL | EXT4_NOATIME_FL |\</span>
<span class="cp">			   EXT4_NOCOMPR_FL | EXT4_JOURNAL_DATA_FL |\</span>
<span class="cp">			   EXT4_NOTAIL_FL | EXT4_DIRSYNC_FL)</span>

<span class="cm">/* Flags that are appropriate for regular files (all but dir-specific ones). */</span>
<span class="cp">#define EXT4_REG_FLMASK (~(EXT4_DIRSYNC_FL | EXT4_TOPDIR_FL))</span>

<span class="cm">/* Flags that are appropriate for non-directories/regular files. */</span>
<span class="cp">#define EXT4_OTHER_FLMASK (EXT4_NODUMP_FL | EXT4_NOATIME_FL)</span>

<span class="cm">/* Mask out flags that are inappropriate for the given type of inode. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">ext4_mask_flags</span><span class="p">(</span><span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_REG_FLMASK</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EXT4_OTHER_FLMASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Inode flags used for atomic set/get</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">EXT4_INODE_SECRM</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* Secure deletion */</span>
	<span class="n">EXT4_INODE_UNRM</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* Undelete */</span>
	<span class="n">EXT4_INODE_COMPR</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>	<span class="cm">/* Compress file */</span>
	<span class="n">EXT4_INODE_SYNC</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>	<span class="cm">/* Synchronous updates */</span>
	<span class="n">EXT4_INODE_IMMUTABLE</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">,</span>	<span class="cm">/* Immutable file */</span>
	<span class="n">EXT4_INODE_APPEND</span>	<span class="o">=</span> <span class="mi">5</span><span class="p">,</span>	<span class="cm">/* writes to file may only append */</span>
	<span class="n">EXT4_INODE_NODUMP</span>	<span class="o">=</span> <span class="mi">6</span><span class="p">,</span>	<span class="cm">/* do not dump file */</span>
	<span class="n">EXT4_INODE_NOATIME</span>	<span class="o">=</span> <span class="mi">7</span><span class="p">,</span>	<span class="cm">/* do not update atime */</span>
<span class="cm">/* Reserved for compression usage... */</span>
	<span class="n">EXT4_INODE_DIRTY</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">EXT4_INODE_COMPRBLK</span>	<span class="o">=</span> <span class="mi">9</span><span class="p">,</span>	<span class="cm">/* One or more compressed clusters */</span>
	<span class="n">EXT4_INODE_NOCOMPR</span>	<span class="o">=</span> <span class="mi">10</span><span class="p">,</span>	<span class="cm">/* Don&#39;t compress */</span>
	<span class="n">EXT4_INODE_ECOMPR</span>	<span class="o">=</span> <span class="mi">11</span><span class="p">,</span>	<span class="cm">/* Compression error */</span>
<span class="cm">/* End compression flags --- maybe not all used */</span>
	<span class="n">EXT4_INODE_INDEX</span>	<span class="o">=</span> <span class="mi">12</span><span class="p">,</span>	<span class="cm">/* hash-indexed directory */</span>
	<span class="n">EXT4_INODE_IMAGIC</span>	<span class="o">=</span> <span class="mi">13</span><span class="p">,</span>	<span class="cm">/* AFS directory */</span>
	<span class="n">EXT4_INODE_JOURNAL_DATA</span>	<span class="o">=</span> <span class="mi">14</span><span class="p">,</span>	<span class="cm">/* file data should be journaled */</span>
	<span class="n">EXT4_INODE_NOTAIL</span>	<span class="o">=</span> <span class="mi">15</span><span class="p">,</span>	<span class="cm">/* file tail should not be merged */</span>
	<span class="n">EXT4_INODE_DIRSYNC</span>	<span class="o">=</span> <span class="mi">16</span><span class="p">,</span>	<span class="cm">/* dirsync behaviour (directories only) */</span>
	<span class="n">EXT4_INODE_TOPDIR</span>	<span class="o">=</span> <span class="mi">17</span><span class="p">,</span>	<span class="cm">/* Top of directory hierarchies*/</span>
	<span class="n">EXT4_INODE_HUGE_FILE</span>	<span class="o">=</span> <span class="mi">18</span><span class="p">,</span>	<span class="cm">/* Set to each huge file */</span>
	<span class="n">EXT4_INODE_EXTENTS</span>	<span class="o">=</span> <span class="mi">19</span><span class="p">,</span>	<span class="cm">/* Inode uses extents */</span>
	<span class="n">EXT4_INODE_EA_INODE</span>	<span class="o">=</span> <span class="mi">21</span><span class="p">,</span>	<span class="cm">/* Inode used for large EA */</span>
	<span class="n">EXT4_INODE_EOFBLOCKS</span>	<span class="o">=</span> <span class="mi">22</span><span class="p">,</span>	<span class="cm">/* Blocks allocated beyond EOF */</span>
	<span class="n">EXT4_INODE_RESERVED</span>	<span class="o">=</span> <span class="mi">31</span><span class="p">,</span>	<span class="cm">/* reserved for ext4 lib */</span>
<span class="p">};</span>

<span class="cp">#define TEST_FLAG_VALUE(FLAG) (EXT4_##FLAG##_FL == (1 &lt;&lt; EXT4_INODE_##FLAG))</span>
<span class="cp">#define CHECK_FLAG_VALUE(FLAG) if (!TEST_FLAG_VALUE(FLAG)) { \</span>
<span class="cp">	printk(KERN_EMERG &quot;EXT4 flag fail: &quot; #FLAG &quot;: %d %d\n&quot;, \</span>
<span class="cp">		EXT4_##FLAG##_FL, EXT4_INODE_##FLAG); BUG_ON(1); }</span>

<span class="cm">/*</span>
<span class="cm"> * Since it&#39;s pretty easy to mix up bit numbers and hex values, and we</span>
<span class="cm"> * can&#39;t do a compile-time test for ENUM values, we use a run-time</span>
<span class="cm"> * test to make sure that EXT4_XXX_FL is consistent with respect to</span>
<span class="cm"> * EXT4_INODE_XXX.  If all is well the printk and BUG_ON will all drop</span>
<span class="cm"> * out so it won&#39;t cost any extra space in the compiled kernel image.</span>
<span class="cm"> * But it&#39;s important that these values are the same, since we are</span>
<span class="cm"> * using EXT4_INODE_XXX to test for the flag values, but EXT4_XX_FL</span>
<span class="cm"> * must be consistent with the values of FS_XXX_FL defined in</span>
<span class="cm"> * include/linux/fs.h and the on-disk values found in ext2, ext3, and</span>
<span class="cm"> * ext4 filesystems, and of course the values defined in e2fsprogs.</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s not paranoia if the Murphy&#39;s Law really *is* out to get you.  :-)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ext4_check_flag_values</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">CHECK_FLAG_VALUE</span><span class="p">(</span><span class="n">SECRM</span><span class="p">);</span>
	<span class="n">CHECK_FLAG_VALUE</span><span class="p">(</span><span class="n">UNRM</span><span class="p">);</span>
	<span class="n">CHECK_FLAG_VALUE</span><span class="p">(</span><span class="n">COMPR</span><span class="p">);</span>
	<span class="n">CHECK_FLAG_VALUE</span><span class="p">(</span><span class="n">SYNC</span><span class="p">);</span>
	<span class="n">CHECK_FLAG_VALUE</span><span class="p">(</span><span class="n">IMMUTABLE</span><span class="p">);</span>
	<span class="n">CHECK_FLAG_VALUE</span><span class="p">(</span><span class="n">APPEND</span><span class="p">);</span>
	<span class="n">CHECK_FLAG_VALUE</span><span class="p">(</span><span class="n">NODUMP</span><span class="p">);</span>
	<span class="n">CHECK_FLAG_VALUE</span><span class="p">(</span><span class="n">NOATIME</span><span class="p">);</span>
	<span class="n">CHECK_FLAG_VALUE</span><span class="p">(</span><span class="n">DIRTY</span><span class="p">);</span>
	<span class="n">CHECK_FLAG_VALUE</span><span class="p">(</span><span class="n">COMPRBLK</span><span class="p">);</span>
	<span class="n">CHECK_FLAG_VALUE</span><span class="p">(</span><span class="n">NOCOMPR</span><span class="p">);</span>
	<span class="n">CHECK_FLAG_VALUE</span><span class="p">(</span><span class="n">ECOMPR</span><span class="p">);</span>
	<span class="n">CHECK_FLAG_VALUE</span><span class="p">(</span><span class="n">INDEX</span><span class="p">);</span>
	<span class="n">CHECK_FLAG_VALUE</span><span class="p">(</span><span class="n">IMAGIC</span><span class="p">);</span>
	<span class="n">CHECK_FLAG_VALUE</span><span class="p">(</span><span class="n">JOURNAL_DATA</span><span class="p">);</span>
	<span class="n">CHECK_FLAG_VALUE</span><span class="p">(</span><span class="n">NOTAIL</span><span class="p">);</span>
	<span class="n">CHECK_FLAG_VALUE</span><span class="p">(</span><span class="n">DIRSYNC</span><span class="p">);</span>
	<span class="n">CHECK_FLAG_VALUE</span><span class="p">(</span><span class="n">TOPDIR</span><span class="p">);</span>
	<span class="n">CHECK_FLAG_VALUE</span><span class="p">(</span><span class="n">HUGE_FILE</span><span class="p">);</span>
	<span class="n">CHECK_FLAG_VALUE</span><span class="p">(</span><span class="n">EXTENTS</span><span class="p">);</span>
	<span class="n">CHECK_FLAG_VALUE</span><span class="p">(</span><span class="n">EA_INODE</span><span class="p">);</span>
	<span class="n">CHECK_FLAG_VALUE</span><span class="p">(</span><span class="n">EOFBLOCKS</span><span class="p">);</span>
	<span class="n">CHECK_FLAG_VALUE</span><span class="p">(</span><span class="n">RESERVED</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Used to pass group descriptor data when online resize is done */</span>
<span class="k">struct</span> <span class="n">ext4_new_group_input</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">group</span><span class="p">;</span>		<span class="cm">/* Group number for this data */</span>
	<span class="n">__u64</span> <span class="n">block_bitmap</span><span class="p">;</span>	<span class="cm">/* Absolute block number of block bitmap */</span>
	<span class="n">__u64</span> <span class="n">inode_bitmap</span><span class="p">;</span>	<span class="cm">/* Absolute block number of inode bitmap */</span>
	<span class="n">__u64</span> <span class="n">inode_table</span><span class="p">;</span>	<span class="cm">/* Absolute block number of inode table start */</span>
	<span class="n">__u32</span> <span class="n">blocks_count</span><span class="p">;</span>	<span class="cm">/* Total number of blocks in this group */</span>
	<span class="n">__u16</span> <span class="n">reserved_blocks</span><span class="p">;</span>	<span class="cm">/* Number of reserved blocks in this group */</span>
	<span class="n">__u16</span> <span class="n">unused</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#if defined(__KERNEL__) &amp;&amp; defined(CONFIG_COMPAT)</span>
<span class="k">struct</span> <span class="n">compat_ext4_new_group_input</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">group</span><span class="p">;</span>
	<span class="n">compat_u64</span> <span class="n">block_bitmap</span><span class="p">;</span>
	<span class="n">compat_u64</span> <span class="n">inode_bitmap</span><span class="p">;</span>
	<span class="n">compat_u64</span> <span class="n">inode_table</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">blocks_count</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">reserved_blocks</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">unused</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/* The struct ext4_new_group_input in kernel space, with free_blocks_count */</span>
<span class="k">struct</span> <span class="n">ext4_new_group_data</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">group</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">block_bitmap</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">inode_bitmap</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">inode_table</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">blocks_count</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">reserved_blocks</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">unused</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">free_blocks_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Indexes used to index group tables in ext4_new_group_data */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">BLOCK_BITMAP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* block bitmap */</span>
	<span class="n">INODE_BITMAP</span><span class="p">,</span>		<span class="cm">/* inode bitmap */</span>
	<span class="n">INODE_TABLE</span><span class="p">,</span>		<span class="cm">/* inode tables */</span>
	<span class="n">GROUP_TABLE_COUNT</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Flags used by ext4_map_blocks()</span>
<span class="cm"> */</span>
	<span class="cm">/* Allocate any needed blocks and/or convert an unitialized</span>
<span class="cm">	   extent to be an initialized ext4 */</span>
<span class="cp">#define EXT4_GET_BLOCKS_CREATE			0x0001</span>
	<span class="cm">/* Request the creation of an unitialized extent */</span>
<span class="cp">#define EXT4_GET_BLOCKS_UNINIT_EXT		0x0002</span>
<span class="cp">#define EXT4_GET_BLOCKS_CREATE_UNINIT_EXT	(EXT4_GET_BLOCKS_UNINIT_EXT|\</span>
<span class="cp">						 EXT4_GET_BLOCKS_CREATE)</span>
	<span class="cm">/* Caller is from the delayed allocation writeout path,</span>
<span class="cm">	   so set the magic i_delalloc_reserve_flag after taking the</span>
<span class="cm">	   inode allocation semaphore for */</span>
<span class="cp">#define EXT4_GET_BLOCKS_DELALLOC_RESERVE	0x0004</span>
	<span class="cm">/* caller is from the direct IO path, request to creation of an</span>
<span class="cm">	unitialized extents if not allocated, split the uninitialized</span>
<span class="cm">	extent if blocks has been preallocated already*/</span>
<span class="cp">#define EXT4_GET_BLOCKS_PRE_IO			0x0008</span>
<span class="cp">#define EXT4_GET_BLOCKS_CONVERT			0x0010</span>
<span class="cp">#define EXT4_GET_BLOCKS_IO_CREATE_EXT		(EXT4_GET_BLOCKS_PRE_IO|\</span>
<span class="cp">					 EXT4_GET_BLOCKS_CREATE_UNINIT_EXT)</span>
	<span class="cm">/* Convert extent to initialized after IO complete */</span>
<span class="cp">#define EXT4_GET_BLOCKS_IO_CONVERT_EXT		(EXT4_GET_BLOCKS_CONVERT|\</span>
<span class="cp">					 EXT4_GET_BLOCKS_CREATE_UNINIT_EXT)</span>
	<span class="cm">/* Punch out blocks of an extent */</span>
<span class="cp">#define EXT4_GET_BLOCKS_PUNCH_OUT_EXT		0x0020</span>
	<span class="cm">/* Don&#39;t normalize allocation size (used for fallocate) */</span>
<span class="cp">#define EXT4_GET_BLOCKS_NO_NORMALIZE		0x0040</span>
	<span class="cm">/* Request will not result in inode size update (user for fallocate) */</span>
<span class="cp">#define EXT4_GET_BLOCKS_KEEP_SIZE		0x0080</span>

<span class="cm">/*</span>
<span class="cm"> * Flags used by ext4_free_blocks</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_FREE_BLOCKS_METADATA	0x0001</span>
<span class="cp">#define EXT4_FREE_BLOCKS_FORGET		0x0002</span>
<span class="cp">#define EXT4_FREE_BLOCKS_VALIDATED	0x0004</span>
<span class="cp">#define EXT4_FREE_BLOCKS_NO_QUOT_UPDATE	0x0008</span>
<span class="cp">#define EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER	0x0010</span>
<span class="cp">#define EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER	0x0020</span>

<span class="cm">/*</span>
<span class="cm"> * Flags used by ext4_discard_partial_page_buffers</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_DISCARD_PARTIAL_PG_ZERO_UNMAPPED	0x0001</span>

<span class="cm">/*</span>
<span class="cm"> * ioctl commands</span>
<span class="cm"> */</span>
<span class="cp">#define	EXT4_IOC_GETFLAGS		FS_IOC_GETFLAGS</span>
<span class="cp">#define	EXT4_IOC_SETFLAGS		FS_IOC_SETFLAGS</span>
<span class="cp">#define	EXT4_IOC_GETVERSION		_IOR(&#39;f&#39;, 3, long)</span>
<span class="cp">#define	EXT4_IOC_SETVERSION		_IOW(&#39;f&#39;, 4, long)</span>
<span class="cp">#define	EXT4_IOC_GETVERSION_OLD		FS_IOC_GETVERSION</span>
<span class="cp">#define	EXT4_IOC_SETVERSION_OLD		FS_IOC_SETVERSION</span>
<span class="cp">#define EXT4_IOC_GETRSVSZ		_IOR(&#39;f&#39;, 5, long)</span>
<span class="cp">#define EXT4_IOC_SETRSVSZ		_IOW(&#39;f&#39;, 6, long)</span>
<span class="cp">#define EXT4_IOC_GROUP_EXTEND		_IOW(&#39;f&#39;, 7, unsigned long)</span>
<span class="cp">#define EXT4_IOC_GROUP_ADD		_IOW(&#39;f&#39;, 8, struct ext4_new_group_input)</span>
<span class="cp">#define EXT4_IOC_MIGRATE		_IO(&#39;f&#39;, 9)</span>
 <span class="cm">/* note ioctl 10 reserved for an early version of the FIEMAP ioctl */</span>
 <span class="cm">/* note ioctl 11 reserved for filesystem-independent FIEMAP ioctl */</span>
<span class="cp">#define EXT4_IOC_ALLOC_DA_BLKS		_IO(&#39;f&#39;, 12)</span>
<span class="cp">#define EXT4_IOC_MOVE_EXT		_IOWR(&#39;f&#39;, 15, struct move_extent)</span>
<span class="cp">#define EXT4_IOC_RESIZE_FS		_IOW(&#39;f&#39;, 16, __u64)</span>

<span class="cp">#if defined(__KERNEL__) &amp;&amp; defined(CONFIG_COMPAT)</span>
<span class="cm">/*</span>
<span class="cm"> * ioctl commands in 32 bit emulation</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_IOC32_GETFLAGS		FS_IOC32_GETFLAGS</span>
<span class="cp">#define EXT4_IOC32_SETFLAGS		FS_IOC32_SETFLAGS</span>
<span class="cp">#define EXT4_IOC32_GETVERSION		_IOR(&#39;f&#39;, 3, int)</span>
<span class="cp">#define EXT4_IOC32_SETVERSION		_IOW(&#39;f&#39;, 4, int)</span>
<span class="cp">#define EXT4_IOC32_GETRSVSZ		_IOR(&#39;f&#39;, 5, int)</span>
<span class="cp">#define EXT4_IOC32_SETRSVSZ		_IOW(&#39;f&#39;, 6, int)</span>
<span class="cp">#define EXT4_IOC32_GROUP_EXTEND		_IOW(&#39;f&#39;, 7, unsigned int)</span>
<span class="cp">#define EXT4_IOC32_GROUP_ADD		_IOW(&#39;f&#39;, 8, struct compat_ext4_new_group_input)</span>
<span class="cp">#define EXT4_IOC32_GETVERSION_OLD	FS_IOC32_GETVERSION</span>
<span class="cp">#define EXT4_IOC32_SETVERSION_OLD	FS_IOC32_SETVERSION</span>
<span class="cp">#endif</span>

<span class="cm">/* Max physical block we can address w/o extents */</span>
<span class="cp">#define EXT4_MAX_BLOCK_FILE_PHYS	0xFFFFFFFF</span>

<span class="cm">/*</span>
<span class="cm"> * Structure of an inode on the disk</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext4_inode</span> <span class="p">{</span>
	<span class="n">__le16</span>	<span class="n">i_mode</span><span class="p">;</span>		<span class="cm">/* File mode */</span>
	<span class="n">__le16</span>	<span class="n">i_uid</span><span class="p">;</span>		<span class="cm">/* Low 16 bits of Owner Uid */</span>
	<span class="n">__le32</span>	<span class="n">i_size_lo</span><span class="p">;</span>	<span class="cm">/* Size in bytes */</span>
	<span class="n">__le32</span>	<span class="n">i_atime</span><span class="p">;</span>	<span class="cm">/* Access time */</span>
	<span class="n">__le32</span>	<span class="n">i_ctime</span><span class="p">;</span>	<span class="cm">/* Inode Change time */</span>
	<span class="n">__le32</span>	<span class="n">i_mtime</span><span class="p">;</span>	<span class="cm">/* Modification time */</span>
	<span class="n">__le32</span>	<span class="n">i_dtime</span><span class="p">;</span>	<span class="cm">/* Deletion Time */</span>
	<span class="n">__le16</span>	<span class="n">i_gid</span><span class="p">;</span>		<span class="cm">/* Low 16 bits of Group Id */</span>
	<span class="n">__le16</span>	<span class="n">i_links_count</span><span class="p">;</span>	<span class="cm">/* Links count */</span>
	<span class="n">__le32</span>	<span class="n">i_blocks_lo</span><span class="p">;</span>	<span class="cm">/* Blocks count */</span>
	<span class="n">__le32</span>	<span class="n">i_flags</span><span class="p">;</span>	<span class="cm">/* File flags */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__le32</span>  <span class="n">l_i_version</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">linux1</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__u32</span>  <span class="n">h_i_translator</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">hurd1</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__u32</span>  <span class="n">m_i_reserved1</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">masix1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">osd1</span><span class="p">;</span>				<span class="cm">/* OS dependent 1 */</span>
	<span class="n">__le32</span>	<span class="n">i_block</span><span class="p">[</span><span class="n">EXT4_N_BLOCKS</span><span class="p">];</span><span class="cm">/* Pointers to blocks */</span>
	<span class="n">__le32</span>	<span class="n">i_generation</span><span class="p">;</span>	<span class="cm">/* File version (for NFS) */</span>
	<span class="n">__le32</span>	<span class="n">i_file_acl_lo</span><span class="p">;</span>	<span class="cm">/* File ACL */</span>
	<span class="n">__le32</span>	<span class="n">i_size_high</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">i_obso_faddr</span><span class="p">;</span>	<span class="cm">/* Obsoleted fragment address */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__le16</span>	<span class="n">l_i_blocks_high</span><span class="p">;</span> <span class="cm">/* were l_i_reserved1 */</span>
			<span class="n">__le16</span>	<span class="n">l_i_file_acl_high</span><span class="p">;</span>
			<span class="n">__le16</span>	<span class="n">l_i_uid_high</span><span class="p">;</span>	<span class="cm">/* these 2 fields */</span>
			<span class="n">__le16</span>	<span class="n">l_i_gid_high</span><span class="p">;</span>	<span class="cm">/* were reserved2[0] */</span>
			<span class="n">__le16</span>	<span class="n">l_i_checksum_lo</span><span class="p">;</span><span class="cm">/* crc32c(uuid+inum+inode) LE */</span>
			<span class="n">__le16</span>	<span class="n">l_i_reserved</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">linux2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__le16</span>	<span class="n">h_i_reserved1</span><span class="p">;</span>	<span class="cm">/* Obsoleted fragment number/size which are removed in ext4 */</span>
			<span class="n">__u16</span>	<span class="n">h_i_mode_high</span><span class="p">;</span>
			<span class="n">__u16</span>	<span class="n">h_i_uid_high</span><span class="p">;</span>
			<span class="n">__u16</span>	<span class="n">h_i_gid_high</span><span class="p">;</span>
			<span class="n">__u32</span>	<span class="n">h_i_author</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">hurd2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__le16</span>	<span class="n">h_i_reserved1</span><span class="p">;</span>	<span class="cm">/* Obsoleted fragment number/size which are removed in ext4 */</span>
			<span class="n">__le16</span>	<span class="n">m_i_file_acl_high</span><span class="p">;</span>
			<span class="n">__u32</span>	<span class="n">m_i_reserved2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="p">}</span> <span class="n">masix2</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">osd2</span><span class="p">;</span>				<span class="cm">/* OS dependent 2 */</span>
	<span class="n">__le16</span>	<span class="n">i_extra_isize</span><span class="p">;</span>
	<span class="n">__le16</span>	<span class="n">i_checksum_hi</span><span class="p">;</span>	<span class="cm">/* crc32c(uuid+inum+inode) BE */</span>
	<span class="n">__le32</span>  <span class="n">i_ctime_extra</span><span class="p">;</span>  <span class="cm">/* extra Change time      (nsec &lt;&lt; 2 | epoch) */</span>
	<span class="n">__le32</span>  <span class="n">i_mtime_extra</span><span class="p">;</span>  <span class="cm">/* extra Modification time(nsec &lt;&lt; 2 | epoch) */</span>
	<span class="n">__le32</span>  <span class="n">i_atime_extra</span><span class="p">;</span>  <span class="cm">/* extra Access time      (nsec &lt;&lt; 2 | epoch) */</span>
	<span class="n">__le32</span>  <span class="n">i_crtime</span><span class="p">;</span>       <span class="cm">/* File Creation time */</span>
	<span class="n">__le32</span>  <span class="n">i_crtime_extra</span><span class="p">;</span> <span class="cm">/* extra FileCreationtime (nsec &lt;&lt; 2 | epoch) */</span>
	<span class="n">__le32</span>  <span class="n">i_version_hi</span><span class="p">;</span>	<span class="cm">/* high 32 bits for 64-bit version */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">move_extent</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">reserved</span><span class="p">;</span>		<span class="cm">/* should be zero */</span>
	<span class="n">__u32</span> <span class="n">donor_fd</span><span class="p">;</span>		<span class="cm">/* donor file descriptor */</span>
	<span class="n">__u64</span> <span class="n">orig_start</span><span class="p">;</span>	<span class="cm">/* logical start offset in block for orig */</span>
	<span class="n">__u64</span> <span class="n">donor_start</span><span class="p">;</span>	<span class="cm">/* logical start offset in block for donor */</span>
	<span class="n">__u64</span> <span class="n">len</span><span class="p">;</span>		<span class="cm">/* block length to be moved */</span>
	<span class="n">__u64</span> <span class="n">moved_len</span><span class="p">;</span>	<span class="cm">/* moved block length */</span>
<span class="p">};</span>

<span class="cp">#define EXT4_EPOCH_BITS 2</span>
<span class="cp">#define EXT4_EPOCH_MASK ((1 &lt;&lt; EXT4_EPOCH_BITS) - 1)</span>
<span class="cp">#define EXT4_NSEC_MASK  (~0UL &lt;&lt; EXT4_EPOCH_BITS)</span>

<span class="cm">/*</span>
<span class="cm"> * Extended fields will fit into an inode if the filesystem was formatted</span>
<span class="cm"> * with large inodes (-I 256 or larger) and there are not currently any EAs</span>
<span class="cm"> * consuming all of the available space. For new inodes we always reserve</span>
<span class="cm"> * enough space for the kernel&#39;s known extended fields, but for inodes</span>
<span class="cm"> * created with an old kernel this might not have been the case. None of</span>
<span class="cm"> * the extended inode fields is critical for correct filesystem operation.</span>
<span class="cm"> * This macro checks if a certain field fits in the inode. Note that</span>
<span class="cm"> * inode-size = GOOD_OLD_INODE_SIZE + i_extra_isize</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_FITS_IN_INODE(ext4_inode, einode, field)	\</span>
<span class="cp">	((offsetof(typeof(*ext4_inode), field) +	\</span>
<span class="cp">	  sizeof((ext4_inode)-&gt;field))			\</span>
<span class="cp">	&lt;= (EXT4_GOOD_OLD_INODE_SIZE +			\</span>
<span class="cp">	    (einode)-&gt;i_extra_isize))			\</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__le32</span> <span class="nf">ext4_encode_extra_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">time</span><span class="p">)</span>
<span class="p">{</span>
       <span class="k">return</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="n">time</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="o">?</span>
			   <span class="p">(</span><span class="n">time</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EXT4_EPOCH_MASK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
                          <span class="p">((</span><span class="n">time</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">&lt;&lt;</span> <span class="n">EXT4_EPOCH_BITS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EXT4_NSEC_MASK</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ext4_decode_extra_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">time</span><span class="p">,</span> <span class="n">__le32</span> <span class="n">extra</span><span class="p">)</span>
<span class="p">{</span>
       <span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">time</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
	       <span class="n">time</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">|=</span> <span class="p">(</span><span class="n">__u64</span><span class="p">)(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">extra</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EXT4_EPOCH_MASK</span><span class="p">)</span>
			       <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
       <span class="n">time</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">extra</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">EXT4_NSEC_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">EXT4_EPOCH_BITS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define EXT4_INODE_SET_XTIME(xtime, inode, raw_inode)			       \</span>
<span class="cp">do {									       \</span>
<span class="cp">	(raw_inode)-&gt;xtime = cpu_to_le32((inode)-&gt;xtime.tv_sec);	       \</span>
<span class="cp">	if (EXT4_FITS_IN_INODE(raw_inode, EXT4_I(inode), xtime ## _extra))     \</span>
<span class="cp">		(raw_inode)-&gt;xtime ## _extra =				       \</span>
<span class="cp">				ext4_encode_extra_time(&amp;(inode)-&gt;xtime);       \</span>
<span class="cp">} while (0)</span>

<span class="cp">#define EXT4_EINODE_SET_XTIME(xtime, einode, raw_inode)			       \</span>
<span class="cp">do {									       \</span>
<span class="cp">	if (EXT4_FITS_IN_INODE(raw_inode, einode, xtime))		       \</span>
<span class="cp">		(raw_inode)-&gt;xtime = cpu_to_le32((einode)-&gt;xtime.tv_sec);      \</span>
<span class="cp">	if (EXT4_FITS_IN_INODE(raw_inode, einode, xtime ## _extra))	       \</span>
<span class="cp">		(raw_inode)-&gt;xtime ## _extra =				       \</span>
<span class="cp">				ext4_encode_extra_time(&amp;(einode)-&gt;xtime);      \</span>
<span class="cp">} while (0)</span>

<span class="cp">#define EXT4_INODE_GET_XTIME(xtime, inode, raw_inode)			       \</span>
<span class="cp">do {									       \</span>
<span class="cp">	(inode)-&gt;xtime.tv_sec = (signed)le32_to_cpu((raw_inode)-&gt;xtime);       \</span>
<span class="cp">	if (EXT4_FITS_IN_INODE(raw_inode, EXT4_I(inode), xtime ## _extra))     \</span>
<span class="cp">		ext4_decode_extra_time(&amp;(inode)-&gt;xtime,			       \</span>
<span class="cp">				       raw_inode-&gt;xtime ## _extra);	       \</span>
<span class="cp">	else								       \</span>
<span class="cp">		(inode)-&gt;xtime.tv_nsec = 0;				       \</span>
<span class="cp">} while (0)</span>

<span class="cp">#define EXT4_EINODE_GET_XTIME(xtime, einode, raw_inode)			       \</span>
<span class="cp">do {									       \</span>
<span class="cp">	if (EXT4_FITS_IN_INODE(raw_inode, einode, xtime))		       \</span>
<span class="cp">		(einode)-&gt;xtime.tv_sec = 				       \</span>
<span class="cp">			(signed)le32_to_cpu((raw_inode)-&gt;xtime);	       \</span>
<span class="cp">	if (EXT4_FITS_IN_INODE(raw_inode, einode, xtime ## _extra))	       \</span>
<span class="cp">		ext4_decode_extra_time(&amp;(einode)-&gt;xtime,		       \</span>
<span class="cp">				       raw_inode-&gt;xtime ## _extra);	       \</span>
<span class="cp">	else								       \</span>
<span class="cp">		(einode)-&gt;xtime.tv_nsec = 0;				       \</span>
<span class="cp">} while (0)</span>

<span class="cp">#define i_disk_version osd1.linux1.l_i_version</span>

<span class="cp">#if defined(__KERNEL__) || defined(__linux__)</span>
<span class="cp">#define i_reserved1	osd1.linux1.l_i_reserved1</span>
<span class="cp">#define i_file_acl_high	osd2.linux2.l_i_file_acl_high</span>
<span class="cp">#define i_blocks_high	osd2.linux2.l_i_blocks_high</span>
<span class="cp">#define i_uid_low	i_uid</span>
<span class="cp">#define i_gid_low	i_gid</span>
<span class="cp">#define i_uid_high	osd2.linux2.l_i_uid_high</span>
<span class="cp">#define i_gid_high	osd2.linux2.l_i_gid_high</span>
<span class="cp">#define i_checksum_lo	osd2.linux2.l_i_checksum_lo</span>

<span class="cp">#elif defined(__GNU__)</span>

<span class="cp">#define i_translator	osd1.hurd1.h_i_translator</span>
<span class="cp">#define i_uid_high	osd2.hurd2.h_i_uid_high</span>
<span class="cp">#define i_gid_high	osd2.hurd2.h_i_gid_high</span>
<span class="cp">#define i_author	osd2.hurd2.h_i_author</span>

<span class="cp">#elif defined(__masix__)</span>

<span class="cp">#define i_reserved1	osd1.masix1.m_i_reserved1</span>
<span class="cp">#define i_file_acl_high	osd2.masix2.m_i_file_acl_high</span>
<span class="cp">#define i_reserved2	osd2.masix2.m_i_reserved2</span>

<span class="cp">#endif </span><span class="cm">/* defined(__KERNEL__) || defined(__linux__) */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * storage for cached extent</span>
<span class="cm"> * If ec_len == 0, then the cache is invalid.</span>
<span class="cm"> * If ec_start == 0, then the cache represents a gap (null mapping)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext4_ext_cache</span> <span class="p">{</span>
	<span class="n">ext4_fsblk_t</span>	<span class="n">ec_start</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span>	<span class="n">ec_block</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">ec_len</span><span class="p">;</span> <span class="cm">/* must be 32bit to return holes */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * fourth extended file system inode data in memory</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">i_data</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>	<span class="cm">/* unconverted */</span>
	<span class="n">__u32</span>	<span class="n">i_dtime</span><span class="p">;</span>
	<span class="n">ext4_fsblk_t</span>	<span class="n">i_file_acl</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * i_block_group is the number of the block group which contains</span>
<span class="cm">	 * this file&#39;s inode.  Constant across the lifetime of the inode,</span>
<span class="cm">	 * it is ued for making block allocation decisions - we try to</span>
<span class="cm">	 * place a file&#39;s data blocks near its inode block, and new inodes</span>
<span class="cm">	 * near to their parent directory&#39;s inode.</span>
<span class="cm">	 */</span>
	<span class="n">ext4_group_t</span>	<span class="n">i_block_group</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span>	<span class="n">i_dir_start_lookup</span><span class="p">;</span>
<span class="cp">#if (BITS_PER_LONG &lt; 64)</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">i_state_flags</span><span class="p">;</span>		<span class="cm">/* Dynamic state flags */</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">i_flags</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_EXT4_FS_XATTR</span>
	<span class="cm">/*</span>
<span class="cm">	 * Extended attributes can be read independently of the main file</span>
<span class="cm">	 * data. Taking i_mutex even when reading would cause contention</span>
<span class="cm">	 * between readers of EAs and writers of regular file data, so</span>
<span class="cm">	 * instead we synchronize on xattr_sem when reading or changing</span>
<span class="cm">	 * EAs.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">xattr_sem</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">i_orphan</span><span class="p">;</span>	<span class="cm">/* unlinked but open inodes */</span>

	<span class="cm">/*</span>
<span class="cm">	 * i_disksize keeps track of what the inode size is ON DISK, not</span>
<span class="cm">	 * in memory.  During truncate, i_size is set to the new size by</span>
<span class="cm">	 * the VFS prior to calling ext4_truncate(), but the filesystem won&#39;t</span>
<span class="cm">	 * set i_disksize to 0 until the truncate is actually under way.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The intent is that i_disksize always represents the blocks which</span>
<span class="cm">	 * are used by this file.  This allows recovery to restart truncate</span>
<span class="cm">	 * on orphans if we crash during truncate.  We actually write i_disksize</span>
<span class="cm">	 * into the on-disk inode when writing inodes out, instead of i_size.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The only time when i_disksize and i_size may be different is when</span>
<span class="cm">	 * a truncate is in progress.  The only things which change i_disksize</span>
<span class="cm">	 * are ext4_get_block (growth) and ext4_truncate (shrinkth).</span>
<span class="cm">	 */</span>
	<span class="n">loff_t</span>	<span class="n">i_disksize</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * i_data_sem is for serialising ext4_truncate() against</span>
<span class="cm">	 * ext4_getblock().  In the 2.4 ext2 design, great chunks of inode&#39;s</span>
<span class="cm">	 * data tree are chopped off during truncate. We can&#39;t do that in</span>
<span class="cm">	 * ext4 because whenever we perform intermediate commits during</span>
<span class="cm">	 * truncate, the inode and all the metadata blocks *must* be in a</span>
<span class="cm">	 * consistent state which allows truncation of the orphans to restart</span>
<span class="cm">	 * during recovery.  Hence we must fix the get_block-vs-truncate race</span>
<span class="cm">	 * by other means, so we have i_data_sem.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">i_data_sem</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="n">vfs_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jbd2_inode</span> <span class="o">*</span><span class="n">jinode</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ext4_ext_cache</span> <span class="n">i_cached_extent</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * File creation time. Its function is same as that of</span>
<span class="cm">	 * struct timespec i_{a,c,m}time in the generic inode.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">i_crtime</span><span class="p">;</span>

	<span class="cm">/* mballoc */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">i_prealloc_list</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">i_prealloc_lock</span><span class="p">;</span>

	<span class="cm">/* ialloc */</span>
	<span class="n">ext4_group_t</span>	<span class="n">i_last_alloc_group</span><span class="p">;</span>

	<span class="cm">/* allocation reservation info for delalloc */</span>
	<span class="cm">/* In case of bigalloc, these refer to clusters rather than blocks */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i_reserved_data_blocks</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i_reserved_meta_blocks</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i_allocated_meta_blocks</span><span class="p">;</span>
	<span class="n">ext4_lblk_t</span> <span class="n">i_da_metadata_calc_last_lblock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i_da_metadata_calc_len</span><span class="p">;</span>

	<span class="cm">/* on-disk additional length */</span>
	<span class="n">__u16</span> <span class="n">i_extra_isize</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_QUOTA</span>
	<span class="cm">/* quota space reservation, managed internally by quota code */</span>
	<span class="n">qsize_t</span> <span class="n">i_reserved_quota</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* completed IOs that might need unwritten extents handling */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">i_completed_io_list</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">i_completed_io_lock</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">i_ioend_count</span><span class="p">;</span>	<span class="cm">/* Number of outstanding io_end structs */</span>
	<span class="cm">/* current io_end structure for async DIO write*/</span>
	<span class="n">ext4_io_end_t</span> <span class="o">*</span><span class="n">cur_aio_dio</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">i_aiodio_unwritten</span><span class="p">;</span> <span class="cm">/* Nr. of inflight conversions pending */</span>

	<span class="n">spinlock_t</span> <span class="n">i_block_reservation_lock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Transactions that contain inode&#39;s metadata needed to complete</span>
<span class="cm">	 * fsync and fdatasync, respectively.</span>
<span class="cm">	 */</span>
	<span class="n">tid_t</span> <span class="n">i_sync_tid</span><span class="p">;</span>
	<span class="n">tid_t</span> <span class="n">i_datasync_tid</span><span class="p">;</span>

	<span class="cm">/* Precomputed uuid+inum+igen checksum for seeding inode checksums */</span>
	<span class="n">__u32</span> <span class="n">i_csum_seed</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * File system states</span>
<span class="cm"> */</span>
<span class="cp">#define	EXT4_VALID_FS			0x0001	</span><span class="cm">/* Unmounted cleanly */</span><span class="cp"></span>
<span class="cp">#define	EXT4_ERROR_FS			0x0002	</span><span class="cm">/* Errors detected */</span><span class="cp"></span>
<span class="cp">#define	EXT4_ORPHAN_FS			0x0004	</span><span class="cm">/* Orphans being recovered */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Misc. filesystem flags</span>
<span class="cm"> */</span>
<span class="cp">#define EXT2_FLAGS_SIGNED_HASH		0x0001  </span><span class="cm">/* Signed dirhash in use */</span><span class="cp"></span>
<span class="cp">#define EXT2_FLAGS_UNSIGNED_HASH	0x0002  </span><span class="cm">/* Unsigned dirhash in use */</span><span class="cp"></span>
<span class="cp">#define EXT2_FLAGS_TEST_FILESYS		0x0004	</span><span class="cm">/* to test development code */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Mount flags</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_MOUNT_GRPID		0x00004	</span><span class="cm">/* Create files with directory&#39;s group */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_DEBUG		0x00008	</span><span class="cm">/* Some debugging messages */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_ERRORS_CONT		0x00010	</span><span class="cm">/* Continue on errors */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_ERRORS_RO		0x00020	</span><span class="cm">/* Remount fs ro on errors */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_ERRORS_PANIC		0x00040	</span><span class="cm">/* Panic on errors */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_ERRORS_MASK		0x00070</span>
<span class="cp">#define EXT4_MOUNT_MINIX_DF		0x00080	</span><span class="cm">/* Mimics the Minix statfs */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_NOLOAD		0x00100	</span><span class="cm">/* Don&#39;t use existing journal*/</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_DATA_FLAGS		0x00C00	</span><span class="cm">/* Mode for data writes: */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_JOURNAL_DATA		0x00400	</span><span class="cm">/* Write data to journal */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_ORDERED_DATA		0x00800	</span><span class="cm">/* Flush data before commit */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_WRITEBACK_DATA	0x00C00	</span><span class="cm">/* No data ordering */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_UPDATE_JOURNAL	0x01000	</span><span class="cm">/* Update the journal format */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_NO_UID32		0x02000  </span><span class="cm">/* Disable 32-bit UIDs */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_XATTR_USER		0x04000	</span><span class="cm">/* Extended user attributes */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_POSIX_ACL		0x08000	</span><span class="cm">/* POSIX Access Control Lists */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_NO_AUTO_DA_ALLOC	0x10000	</span><span class="cm">/* No auto delalloc mapping */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_BARRIER		0x20000 </span><span class="cm">/* Use block barriers */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_QUOTA		0x80000 </span><span class="cm">/* Some quota option set */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_USRQUOTA		0x100000 </span><span class="cm">/* &quot;old&quot; user quota */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_GRPQUOTA		0x200000 </span><span class="cm">/* &quot;old&quot; group quota */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_DIOREAD_NOLOCK	0x400000 </span><span class="cm">/* Enable support for dio read nolocking */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_JOURNAL_CHECKSUM	0x800000 </span><span class="cm">/* Journal checksums */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_JOURNAL_ASYNC_COMMIT	0x1000000 </span><span class="cm">/* Journal Async Commit */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_MBLK_IO_SUBMIT	0x4000000 </span><span class="cm">/* multi-block io submits */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_DELALLOC		0x8000000 </span><span class="cm">/* Delalloc support */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_DATA_ERR_ABORT	0x10000000 </span><span class="cm">/* Abort on file data write */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_BLOCK_VALIDITY	0x20000000 </span><span class="cm">/* Block validity checking */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_DISCARD		0x40000000 </span><span class="cm">/* Issue DISCARD requests */</span><span class="cp"></span>
<span class="cp">#define EXT4_MOUNT_INIT_INODE_TABLE	0x80000000 </span><span class="cm">/* Initialize uninitialized itables */</span><span class="cp"></span>

<span class="cp">#define EXT4_MOUNT2_EXPLICIT_DELALLOC	0x00000001 </span><span class="cm">/* User explicitly</span>
<span class="cm">						      specified delalloc */</span><span class="cp"></span>

<span class="cp">#define clear_opt(sb, opt)		EXT4_SB(sb)-&gt;s_mount_opt &amp;= \</span>
<span class="cp">						~EXT4_MOUNT_##opt</span>
<span class="cp">#define set_opt(sb, opt)		EXT4_SB(sb)-&gt;s_mount_opt |= \</span>
<span class="cp">						EXT4_MOUNT_##opt</span>
<span class="cp">#define test_opt(sb, opt)		(EXT4_SB(sb)-&gt;s_mount_opt &amp; \</span>
<span class="cp">					 EXT4_MOUNT_##opt)</span>

<span class="cp">#define clear_opt2(sb, opt)		EXT4_SB(sb)-&gt;s_mount_opt2 &amp;= \</span>
<span class="cp">						~EXT4_MOUNT2_##opt</span>
<span class="cp">#define set_opt2(sb, opt)		EXT4_SB(sb)-&gt;s_mount_opt2 |= \</span>
<span class="cp">						EXT4_MOUNT2_##opt</span>
<span class="cp">#define test_opt2(sb, opt)		(EXT4_SB(sb)-&gt;s_mount_opt2 &amp; \</span>
<span class="cp">					 EXT4_MOUNT2_##opt)</span>

<span class="cp">#define ext4_test_and_set_bit		__test_and_set_bit_le</span>
<span class="cp">#define ext4_set_bit			__set_bit_le</span>
<span class="cp">#define ext4_set_bit_atomic		ext2_set_bit_atomic</span>
<span class="cp">#define ext4_test_and_clear_bit		__test_and_clear_bit_le</span>
<span class="cp">#define ext4_clear_bit			__clear_bit_le</span>
<span class="cp">#define ext4_clear_bit_atomic		ext2_clear_bit_atomic</span>
<span class="cp">#define ext4_test_bit			test_bit_le</span>
<span class="cp">#define ext4_find_next_zero_bit		find_next_zero_bit_le</span>
<span class="cp">#define ext4_find_next_bit		find_next_bit_le</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_set_bits</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cur</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Maximal mount counts between two filesystem checks</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_DFL_MAX_MNT_COUNT		20	</span><span class="cm">/* Allow 20 mounts */</span><span class="cp"></span>
<span class="cp">#define EXT4_DFL_CHECKINTERVAL		0	</span><span class="cm">/* Don&#39;t use interval check */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Behaviour when detecting errors</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_ERRORS_CONTINUE		1	</span><span class="cm">/* Continue execution */</span><span class="cp"></span>
<span class="cp">#define EXT4_ERRORS_RO			2	</span><span class="cm">/* Remount fs read-only */</span><span class="cp"></span>
<span class="cp">#define EXT4_ERRORS_PANIC		3	</span><span class="cm">/* Panic */</span><span class="cp"></span>
<span class="cp">#define EXT4_ERRORS_DEFAULT		EXT4_ERRORS_CONTINUE</span>

<span class="cm">/* Metadata checksum algorithm codes */</span>
<span class="cp">#define EXT4_CRC32C_CHKSUM		1</span>

<span class="cm">/*</span>
<span class="cm"> * Structure of the super block</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext4_super_block</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__le32</span>	<span class="n">s_inodes_count</span><span class="p">;</span>		<span class="cm">/* Inodes count */</span>
	<span class="n">__le32</span>	<span class="n">s_blocks_count_lo</span><span class="p">;</span>	<span class="cm">/* Blocks count */</span>
	<span class="n">__le32</span>	<span class="n">s_r_blocks_count_lo</span><span class="p">;</span>	<span class="cm">/* Reserved blocks count */</span>
	<span class="n">__le32</span>	<span class="n">s_free_blocks_count_lo</span><span class="p">;</span>	<span class="cm">/* Free blocks count */</span>
<span class="cm">/*10*/</span>	<span class="n">__le32</span>	<span class="n">s_free_inodes_count</span><span class="p">;</span>	<span class="cm">/* Free inodes count */</span>
	<span class="n">__le32</span>	<span class="n">s_first_data_block</span><span class="p">;</span>	<span class="cm">/* First Data Block */</span>
	<span class="n">__le32</span>	<span class="n">s_log_block_size</span><span class="p">;</span>	<span class="cm">/* Block size */</span>
	<span class="n">__le32</span>	<span class="n">s_log_cluster_size</span><span class="p">;</span>	<span class="cm">/* Allocation cluster size */</span>
<span class="cm">/*20*/</span>	<span class="n">__le32</span>	<span class="n">s_blocks_per_group</span><span class="p">;</span>	<span class="cm">/* # Blocks per group */</span>
	<span class="n">__le32</span>	<span class="n">s_clusters_per_group</span><span class="p">;</span>	<span class="cm">/* # Clusters per group */</span>
	<span class="n">__le32</span>	<span class="n">s_inodes_per_group</span><span class="p">;</span>	<span class="cm">/* # Inodes per group */</span>
	<span class="n">__le32</span>	<span class="n">s_mtime</span><span class="p">;</span>		<span class="cm">/* Mount time */</span>
<span class="cm">/*30*/</span>	<span class="n">__le32</span>	<span class="n">s_wtime</span><span class="p">;</span>		<span class="cm">/* Write time */</span>
	<span class="n">__le16</span>	<span class="n">s_mnt_count</span><span class="p">;</span>		<span class="cm">/* Mount count */</span>
	<span class="n">__le16</span>	<span class="n">s_max_mnt_count</span><span class="p">;</span>	<span class="cm">/* Maximal mount count */</span>
	<span class="n">__le16</span>	<span class="n">s_magic</span><span class="p">;</span>		<span class="cm">/* Magic signature */</span>
	<span class="n">__le16</span>	<span class="n">s_state</span><span class="p">;</span>		<span class="cm">/* File system state */</span>
	<span class="n">__le16</span>	<span class="n">s_errors</span><span class="p">;</span>		<span class="cm">/* Behaviour when detecting errors */</span>
	<span class="n">__le16</span>	<span class="n">s_minor_rev_level</span><span class="p">;</span>	<span class="cm">/* minor revision level */</span>
<span class="cm">/*40*/</span>	<span class="n">__le32</span>	<span class="n">s_lastcheck</span><span class="p">;</span>		<span class="cm">/* time of last check */</span>
	<span class="n">__le32</span>	<span class="n">s_checkinterval</span><span class="p">;</span>	<span class="cm">/* max. time between checks */</span>
	<span class="n">__le32</span>	<span class="n">s_creator_os</span><span class="p">;</span>		<span class="cm">/* OS */</span>
	<span class="n">__le32</span>	<span class="n">s_rev_level</span><span class="p">;</span>		<span class="cm">/* Revision level */</span>
<span class="cm">/*50*/</span>	<span class="n">__le16</span>	<span class="n">s_def_resuid</span><span class="p">;</span>		<span class="cm">/* Default uid for reserved blocks */</span>
	<span class="n">__le16</span>	<span class="n">s_def_resgid</span><span class="p">;</span>		<span class="cm">/* Default gid for reserved blocks */</span>
	<span class="cm">/*</span>
<span class="cm">	 * These fields are for EXT4_DYNAMIC_REV superblocks only.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: the difference between the compatible feature set and</span>
<span class="cm">	 * the incompatible feature set is that if there is a bit set</span>
<span class="cm">	 * in the incompatible feature set that the kernel doesn&#39;t</span>
<span class="cm">	 * know about, it should refuse to mount the filesystem.</span>
<span class="cm">	 *</span>
<span class="cm">	 * e2fsck&#39;s requirements are more strict; if it doesn&#39;t know</span>
<span class="cm">	 * about a feature in either the compatible or incompatible</span>
<span class="cm">	 * feature set, it must abort and not try to meddle with</span>
<span class="cm">	 * things it doesn&#39;t understand...</span>
<span class="cm">	 */</span>
	<span class="n">__le32</span>	<span class="n">s_first_ino</span><span class="p">;</span>		<span class="cm">/* First non-reserved inode */</span>
	<span class="n">__le16</span>  <span class="n">s_inode_size</span><span class="p">;</span>		<span class="cm">/* size of inode structure */</span>
	<span class="n">__le16</span>	<span class="n">s_block_group_nr</span><span class="p">;</span>	<span class="cm">/* block group # of this superblock */</span>
	<span class="n">__le32</span>	<span class="n">s_feature_compat</span><span class="p">;</span>	<span class="cm">/* compatible feature set */</span>
<span class="cm">/*60*/</span>	<span class="n">__le32</span>	<span class="n">s_feature_incompat</span><span class="p">;</span>	<span class="cm">/* incompatible feature set */</span>
	<span class="n">__le32</span>	<span class="n">s_feature_ro_compat</span><span class="p">;</span>	<span class="cm">/* readonly-compatible feature set */</span>
<span class="cm">/*68*/</span>	<span class="n">__u8</span>	<span class="n">s_uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>		<span class="cm">/* 128-bit uuid for volume */</span>
<span class="cm">/*78*/</span>	<span class="kt">char</span>	<span class="n">s_volume_name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* volume name */</span>
<span class="cm">/*88*/</span>	<span class="kt">char</span>	<span class="n">s_last_mounted</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>	<span class="cm">/* directory where last mounted */</span>
<span class="cm">/*C8*/</span>	<span class="n">__le32</span>	<span class="n">s_algorithm_usage_bitmap</span><span class="p">;</span> <span class="cm">/* For compression */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Performance hints.  Directory preallocation should only</span>
<span class="cm">	 * happen if the EXT4_FEATURE_COMPAT_DIR_PREALLOC flag is on.</span>
<span class="cm">	 */</span>
	<span class="n">__u8</span>	<span class="n">s_prealloc_blocks</span><span class="p">;</span>	<span class="cm">/* Nr of blocks to try to preallocate*/</span>
	<span class="n">__u8</span>	<span class="n">s_prealloc_dir_blocks</span><span class="p">;</span>	<span class="cm">/* Nr to preallocate for dirs */</span>
	<span class="n">__le16</span>	<span class="n">s_reserved_gdt_blocks</span><span class="p">;</span>	<span class="cm">/* Per group desc for online growth */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Journaling support valid if EXT4_FEATURE_COMPAT_HAS_JOURNAL set.</span>
<span class="cm">	 */</span>
<span class="cm">/*D0*/</span>	<span class="n">__u8</span>	<span class="n">s_journal_uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>	<span class="cm">/* uuid of journal superblock */</span>
<span class="cm">/*E0*/</span>	<span class="n">__le32</span>	<span class="n">s_journal_inum</span><span class="p">;</span>		<span class="cm">/* inode number of journal file */</span>
	<span class="n">__le32</span>	<span class="n">s_journal_dev</span><span class="p">;</span>		<span class="cm">/* device number of journal file */</span>
	<span class="n">__le32</span>	<span class="n">s_last_orphan</span><span class="p">;</span>		<span class="cm">/* start of list of inodes to delete */</span>
	<span class="n">__le32</span>	<span class="n">s_hash_seed</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>		<span class="cm">/* HTREE hash seed */</span>
	<span class="n">__u8</span>	<span class="n">s_def_hash_version</span><span class="p">;</span>	<span class="cm">/* Default hash version to use */</span>
	<span class="n">__u8</span>	<span class="n">s_jnl_backup_type</span><span class="p">;</span>
	<span class="n">__le16</span>  <span class="n">s_desc_size</span><span class="p">;</span>		<span class="cm">/* size of group descriptor */</span>
<span class="cm">/*100*/</span>	<span class="n">__le32</span>	<span class="n">s_default_mount_opts</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">s_first_meta_bg</span><span class="p">;</span>	<span class="cm">/* First metablock block group */</span>
	<span class="n">__le32</span>	<span class="n">s_mkfs_time</span><span class="p">;</span>		<span class="cm">/* When the filesystem was created */</span>
	<span class="n">__le32</span>	<span class="n">s_jnl_blocks</span><span class="p">[</span><span class="mi">17</span><span class="p">];</span>	<span class="cm">/* Backup of the journal inode */</span>
	<span class="cm">/* 64bit support valid if EXT4_FEATURE_COMPAT_64BIT */</span>
<span class="cm">/*150*/</span>	<span class="n">__le32</span>	<span class="n">s_blocks_count_hi</span><span class="p">;</span>	<span class="cm">/* Blocks count */</span>
	<span class="n">__le32</span>	<span class="n">s_r_blocks_count_hi</span><span class="p">;</span>	<span class="cm">/* Reserved blocks count */</span>
	<span class="n">__le32</span>	<span class="n">s_free_blocks_count_hi</span><span class="p">;</span>	<span class="cm">/* Free blocks count */</span>
	<span class="n">__le16</span>	<span class="n">s_min_extra_isize</span><span class="p">;</span>	<span class="cm">/* All inodes have at least # bytes */</span>
	<span class="n">__le16</span>	<span class="n">s_want_extra_isize</span><span class="p">;</span> 	<span class="cm">/* New inodes should reserve # bytes */</span>
	<span class="n">__le32</span>	<span class="n">s_flags</span><span class="p">;</span>		<span class="cm">/* Miscellaneous flags */</span>
	<span class="n">__le16</span>  <span class="n">s_raid_stride</span><span class="p">;</span>		<span class="cm">/* RAID stride */</span>
	<span class="n">__le16</span>  <span class="n">s_mmp_update_interval</span><span class="p">;</span>  <span class="cm">/* # seconds to wait in MMP checking */</span>
	<span class="n">__le64</span>  <span class="n">s_mmp_block</span><span class="p">;</span>            <span class="cm">/* Block for multi-mount protection */</span>
	<span class="n">__le32</span>  <span class="n">s_raid_stripe_width</span><span class="p">;</span>    <span class="cm">/* blocks on all data disks (N*stride)*/</span>
	<span class="n">__u8</span>	<span class="n">s_log_groups_per_flex</span><span class="p">;</span>  <span class="cm">/* FLEX_BG group size */</span>
	<span class="n">__u8</span>	<span class="n">s_checksum_type</span><span class="p">;</span>	<span class="cm">/* metadata checksum algorithm used */</span>
	<span class="n">__le16</span>  <span class="n">s_reserved_pad</span><span class="p">;</span>
	<span class="n">__le64</span>	<span class="n">s_kbytes_written</span><span class="p">;</span>	<span class="cm">/* nr of lifetime kilobytes written */</span>
	<span class="n">__le32</span>	<span class="n">s_snapshot_inum</span><span class="p">;</span>	<span class="cm">/* Inode number of active snapshot */</span>
	<span class="n">__le32</span>	<span class="n">s_snapshot_id</span><span class="p">;</span>		<span class="cm">/* sequential ID of active snapshot */</span>
	<span class="n">__le64</span>	<span class="n">s_snapshot_r_blocks_count</span><span class="p">;</span> <span class="cm">/* reserved blocks for active</span>
<span class="cm">					      snapshot&#39;s future use */</span>
	<span class="n">__le32</span>	<span class="n">s_snapshot_list</span><span class="p">;</span>	<span class="cm">/* inode number of the head of the</span>
<span class="cm">					   on-disk snapshot list */</span>
<span class="cp">#define EXT4_S_ERR_START offsetof(struct ext4_super_block, s_error_count)</span>
	<span class="n">__le32</span>	<span class="n">s_error_count</span><span class="p">;</span>		<span class="cm">/* number of fs errors */</span>
	<span class="n">__le32</span>	<span class="n">s_first_error_time</span><span class="p">;</span>	<span class="cm">/* first time an error happened */</span>
	<span class="n">__le32</span>	<span class="n">s_first_error_ino</span><span class="p">;</span>	<span class="cm">/* inode involved in first error */</span>
	<span class="n">__le64</span>	<span class="n">s_first_error_block</span><span class="p">;</span>	<span class="cm">/* block involved of first error */</span>
	<span class="n">__u8</span>	<span class="n">s_first_error_func</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>	<span class="cm">/* function where the error happened */</span>
	<span class="n">__le32</span>	<span class="n">s_first_error_line</span><span class="p">;</span>	<span class="cm">/* line number where error happened */</span>
	<span class="n">__le32</span>	<span class="n">s_last_error_time</span><span class="p">;</span>	<span class="cm">/* most recent time of an error */</span>
	<span class="n">__le32</span>	<span class="n">s_last_error_ino</span><span class="p">;</span>	<span class="cm">/* inode involved in last error */</span>
	<span class="n">__le32</span>	<span class="n">s_last_error_line</span><span class="p">;</span>	<span class="cm">/* line number where error happened */</span>
	<span class="n">__le64</span>	<span class="n">s_last_error_block</span><span class="p">;</span>	<span class="cm">/* block involved of last error */</span>
	<span class="n">__u8</span>	<span class="n">s_last_error_func</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>	<span class="cm">/* function where the error happened */</span>
<span class="cp">#define EXT4_S_ERR_END offsetof(struct ext4_super_block, s_mount_opts)</span>
	<span class="n">__u8</span>	<span class="n">s_mount_opts</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="n">__le32</span>	<span class="n">s_usr_quota_inum</span><span class="p">;</span>	<span class="cm">/* inode for tracking user quota */</span>
	<span class="n">__le32</span>	<span class="n">s_grp_quota_inum</span><span class="p">;</span>	<span class="cm">/* inode for tracking group quota */</span>
	<span class="n">__le32</span>	<span class="n">s_overhead_clusters</span><span class="p">;</span>	<span class="cm">/* overhead blocks/clusters in fs */</span>
	<span class="n">__le32</span>	<span class="n">s_reserved</span><span class="p">[</span><span class="mi">108</span><span class="p">];</span>	<span class="cm">/* Padding to the end of the block */</span>
	<span class="n">__le32</span>	<span class="n">s_checksum</span><span class="p">;</span>		<span class="cm">/* crc32c(superblock) */</span>
<span class="p">};</span>

<span class="cp">#define EXT4_S_ERR_LEN (EXT4_S_ERR_END - EXT4_S_ERR_START)</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cm">/*</span>
<span class="cm"> * run-time mount flags</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_MF_MNTDIR_SAMPLED	0x0001</span>
<span class="cp">#define EXT4_MF_FS_ABORTED	0x0002	</span><span class="cm">/* Fatal error detected */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * fourth extended-fs super-block data in memory</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_desc_size</span><span class="p">;</span>	<span class="cm">/* Size of a group descriptor in bytes */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_inodes_per_block</span><span class="p">;</span><span class="cm">/* Number of inodes per block */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_blocks_per_group</span><span class="p">;</span><span class="cm">/* Number of blocks in a group */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_clusters_per_group</span><span class="p">;</span> <span class="cm">/* Number of clusters in a group */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_inodes_per_group</span><span class="p">;</span><span class="cm">/* Number of inodes in a group */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_itb_per_group</span><span class="p">;</span>	<span class="cm">/* Number of inode table blocks per group */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_gdb_count</span><span class="p">;</span>	<span class="cm">/* Number of group descriptor blocks */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_desc_per_block</span><span class="p">;</span>	<span class="cm">/* Number of group descriptors per block */</span>
	<span class="n">ext4_group_t</span> <span class="n">s_groups_count</span><span class="p">;</span>	<span class="cm">/* Number of groups in the fs */</span>
	<span class="n">ext4_group_t</span> <span class="n">s_blockfile_groups</span><span class="p">;</span><span class="cm">/* Groups acceptable for non-extent files */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_overhead_last</span><span class="p">;</span>  <span class="cm">/* Last calculated overhead */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_blocks_last</span><span class="p">;</span>    <span class="cm">/* Last seen block count */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">s_cluster_ratio</span><span class="p">;</span>	<span class="cm">/* Number of blocks per cluster */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">s_cluster_bits</span><span class="p">;</span>	<span class="cm">/* log2 of s_cluster_ratio */</span>
	<span class="n">loff_t</span> <span class="n">s_bitmap_maxbytes</span><span class="p">;</span>	<span class="cm">/* max bytes for bitmap files */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">s_sbh</span><span class="p">;</span>	<span class="cm">/* Buffer containing the super block */</span>
	<span class="k">struct</span> <span class="n">ext4_super_block</span> <span class="o">*</span><span class="n">s_es</span><span class="p">;</span>	<span class="cm">/* Pointer to the super block in the buffer */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">s_group_desc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">s_mount_opt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">s_mount_opt2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">s_mount_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">s_def_mount_opt</span><span class="p">;</span>
	<span class="n">ext4_fsblk_t</span> <span class="n">s_sb_block</span><span class="p">;</span>
	<span class="n">kuid_t</span> <span class="n">s_resuid</span><span class="p">;</span>
	<span class="n">kgid_t</span> <span class="n">s_resgid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">s_mount_state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">s_pad</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_addr_per_block_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_desc_per_block_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_inode_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_first_ino</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">s_inode_readahead_blks</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">s_inode_goal</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">s_next_gen_lock</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">s_next_generation</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">s_hash_seed</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">s_def_hash_version</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_hash_unsigned</span><span class="p">;</span>	<span class="cm">/* 3 if hash should be signed, 0 if not */</span>
	<span class="k">struct</span> <span class="n">percpu_counter</span> <span class="n">s_freeclusters_counter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">percpu_counter</span> <span class="n">s_freeinodes_counter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">percpu_counter</span> <span class="n">s_dirs_counter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">percpu_counter</span> <span class="n">s_dirtyclusters_counter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blockgroup_lock</span> <span class="o">*</span><span class="n">s_blockgroup_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">s_proc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="n">s_kobj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">s_kobj_unregister</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s_sb</span><span class="p">;</span>

	<span class="cm">/* Journaling */</span>
	<span class="k">struct</span> <span class="n">journal_s</span> <span class="o">*</span><span class="n">s_journal</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">s_orphan</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">s_orphan_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_resize_flags</span><span class="p">;</span>		<span class="cm">/* Flags indicating if there</span>
<span class="cm">						   is a resizer */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_commit_interval</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">s_max_batch_time</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">s_min_batch_time</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">journal_bdev</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_QUOTA</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s_qf_names</span><span class="p">[</span><span class="n">MAXQUOTAS</span><span class="p">];</span>		<span class="cm">/* Names of quota files with journalled quota */</span>
	<span class="kt">int</span> <span class="n">s_jquota_fmt</span><span class="p">;</span>			<span class="cm">/* Format of quota to use */</span>
<span class="cp">#endif</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">s_want_extra_isize</span><span class="p">;</span> <span class="cm">/* New inodes should reserve # bytes */</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">system_blks</span><span class="p">;</span>

<span class="cp">#ifdef EXTENTS_STATS</span>
	<span class="cm">/* ext4 extents stats */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_ext_min</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_ext_max</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_depth_max</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">s_ext_stats_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_ext_blocks</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_ext_extents</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* for buddy allocator */</span>
	<span class="k">struct</span> <span class="n">ext4_group_info</span> <span class="o">***</span><span class="n">s_group_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">s_buddy_cache</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">s_md_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="n">s_mb_offsets</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">s_mb_maxs</span><span class="p">;</span>

	<span class="cm">/* tunables */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_stripe</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">s_mb_stream_request</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">s_mb_max_to_scan</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">s_mb_min_to_scan</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">s_mb_stats</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">s_mb_order2_reqs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">s_mb_group_prealloc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">s_max_writeback_mb_bump</span><span class="p">;</span>
	<span class="cm">/* where last allocation was done - for stream allocation */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_mb_last_group</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_mb_last_start</span><span class="p">;</span>

	<span class="cm">/* stats for buddy allocator */</span>
	<span class="n">atomic_t</span> <span class="n">s_bal_reqs</span><span class="p">;</span>	<span class="cm">/* number of reqs with len &gt; 1 */</span>
	<span class="n">atomic_t</span> <span class="n">s_bal_success</span><span class="p">;</span>	<span class="cm">/* we found long enough chunks */</span>
	<span class="n">atomic_t</span> <span class="n">s_bal_allocated</span><span class="p">;</span>	<span class="cm">/* in blocks */</span>
	<span class="n">atomic_t</span> <span class="n">s_bal_ex_scanned</span><span class="p">;</span>	<span class="cm">/* total extents scanned */</span>
	<span class="n">atomic_t</span> <span class="n">s_bal_goals</span><span class="p">;</span>	<span class="cm">/* goal hits */</span>
	<span class="n">atomic_t</span> <span class="n">s_bal_breaks</span><span class="p">;</span>	<span class="cm">/* too long searches */</span>
	<span class="n">atomic_t</span> <span class="n">s_bal_2orders</span><span class="p">;</span>	<span class="cm">/* 2^order hits */</span>
	<span class="n">spinlock_t</span> <span class="n">s_bal_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_mb_buddies_generated</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">s_mb_generation_time</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">s_mb_lost_chunks</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">s_mb_preallocated</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">s_mb_discarded</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">s_lock_busy</span><span class="p">;</span>

	<span class="cm">/* locality groups */</span>
	<span class="k">struct</span> <span class="n">ext4_locality_group</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">s_locality_groups</span><span class="p">;</span>

	<span class="cm">/* for write statistics */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_sectors_written_start</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">s_kbytes_written</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">s_log_groups_per_flex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flex_groups</span> <span class="o">*</span><span class="n">s_flex_groups</span><span class="p">;</span>

	<span class="cm">/* workqueue for dio unwritten */</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">dio_unwritten_wq</span><span class="p">;</span>

	<span class="cm">/* timer for periodic error stats printing */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">s_err_report</span><span class="p">;</span>

	<span class="cm">/* Lazy inode table initialization info */</span>
	<span class="k">struct</span> <span class="n">ext4_li_request</span> <span class="o">*</span><span class="n">s_li_request</span><span class="p">;</span>
	<span class="cm">/* Wait multiplier for lazy initialization thread */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">s_li_wait_mult</span><span class="p">;</span>

	<span class="cm">/* Kernel thread for multiple mount protection */</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">s_mmp_tsk</span><span class="p">;</span>

	<span class="cm">/* record the last minlen when FITRIM is called. */</span>
	<span class="n">atomic_t</span> <span class="n">s_last_trim_minblks</span><span class="p">;</span>

	<span class="cm">/* Reference to checksum algorithm driver via cryptoapi */</span>
	<span class="k">struct</span> <span class="n">crypto_shash</span> <span class="o">*</span><span class="n">s_chksum_driver</span><span class="p">;</span>

	<span class="cm">/* Precomputed FS UUID checksum for seeding other checksums */</span>
	<span class="n">__u32</span> <span class="n">s_csum_seed</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="nf">EXT4_SB</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="nf">EXT4_I</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext4_inode_info</span><span class="p">,</span> <span class="n">vfs_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="nf">ext4_current_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_time_gran</span> <span class="o">&lt;</span> <span class="n">NSEC_PER_SEC</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">current_fs_time</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="o">:</span> <span class="n">CURRENT_TIME_SEC</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext4_valid_inum</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ino</span> <span class="o">==</span> <span class="n">EXT4_ROOT_INO</span> <span class="o">||</span>
		<span class="n">ino</span> <span class="o">==</span> <span class="n">EXT4_JOURNAL_INO</span> <span class="o">||</span>
		<span class="n">ino</span> <span class="o">==</span> <span class="n">EXT4_RESIZE_INO</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">ino</span> <span class="o">&gt;=</span> <span class="n">EXT4_FIRST_INO</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		 <span class="n">ino</span> <span class="o">&lt;=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="o">-&gt;</span><span class="n">s_inodes_count</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ext4_set_io_unwritten_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">ext4_io_end</span> <span class="o">*</span><span class="n">io_end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">io_end</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">EXT4_IO_END_UNWRITTEN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">io_end</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">EXT4_IO_END_UNWRITTEN</span><span class="p">;</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_aiodio_unwritten</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Inode dynamic state flags</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">EXT4_STATE_JDATA</span><span class="p">,</span>		<span class="cm">/* journaled data exists */</span>
	<span class="n">EXT4_STATE_NEW</span><span class="p">,</span>			<span class="cm">/* inode is newly created */</span>
	<span class="n">EXT4_STATE_XATTR</span><span class="p">,</span>		<span class="cm">/* has in-inode xattrs */</span>
	<span class="n">EXT4_STATE_NO_EXPAND</span><span class="p">,</span>		<span class="cm">/* No space for expansion */</span>
	<span class="n">EXT4_STATE_DA_ALLOC_CLOSE</span><span class="p">,</span>	<span class="cm">/* Alloc DA blks on close */</span>
	<span class="n">EXT4_STATE_EXT_MIGRATE</span><span class="p">,</span>		<span class="cm">/* Inode is migrating */</span>
	<span class="n">EXT4_STATE_DIO_UNWRITTEN</span><span class="p">,</span>	<span class="cm">/* need convert on dio done*/</span>
	<span class="n">EXT4_STATE_NEWENTRY</span><span class="p">,</span>		<span class="cm">/* File just added to dir */</span>
	<span class="n">EXT4_STATE_DELALLOC_RESERVED</span><span class="p">,</span>	<span class="cm">/* blks already reserved for delalloc */</span>
<span class="p">};</span>

<span class="cp">#define EXT4_INODE_BIT_FNS(name, field, offset)				\</span>
<span class="cp">static inline int ext4_test_inode_##name(struct inode *inode, int bit)	\</span>
<span class="cp">{									\</span>
<span class="cp">	return test_bit(bit + (offset), &amp;EXT4_I(inode)-&gt;i_##field);	\</span>
<span class="cp">}									\</span>
<span class="cp">static inline void ext4_set_inode_##name(struct inode *inode, int bit)	\</span>
<span class="cp">{									\</span>
<span class="cp">	set_bit(bit + (offset), &amp;EXT4_I(inode)-&gt;i_##field);		\</span>
<span class="cp">}									\</span>
<span class="cp">static inline void ext4_clear_inode_##name(struct inode *inode, int bit) \</span>
<span class="cp">{									\</span>
<span class="cp">	clear_bit(bit + (offset), &amp;EXT4_I(inode)-&gt;i_##field);		\</span>
<span class="cp">}</span>

<span class="n">EXT4_INODE_BIT_FNS</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="cp">#if (BITS_PER_LONG &lt; 64)</span>
<span class="n">EXT4_INODE_BIT_FNS</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">state_flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">ext4_clear_state_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="n">ei</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">(</span><span class="n">ei</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_state_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="n">EXT4_INODE_BIT_FNS</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">ext4_clear_state_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="n">ei</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We depend on the fact that callers will set i_flags */</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#else</span>
<span class="cm">/* Assume that user mode programs are passing in an ext4fs superblock, not</span>
<span class="cm"> * a kernel struct super_block.  This will allow us to call the feature-test</span>
<span class="cm"> * macros from user land. */</span>
<span class="cp">#define EXT4_SB(sb)	(sb)</span>
<span class="cp">#endif</span>

<span class="cp">#define NEXT_ORPHAN(inode) EXT4_I(inode)-&gt;i_dtime</span>

<span class="cm">/*</span>
<span class="cm"> * Codes for operating systems</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_OS_LINUX		0</span>
<span class="cp">#define EXT4_OS_HURD		1</span>
<span class="cp">#define EXT4_OS_MASIX		2</span>
<span class="cp">#define EXT4_OS_FREEBSD		3</span>
<span class="cp">#define EXT4_OS_LITES		4</span>

<span class="cm">/*</span>
<span class="cm"> * Revision levels</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_GOOD_OLD_REV	0	</span><span class="cm">/* The good old (original) format */</span><span class="cp"></span>
<span class="cp">#define EXT4_DYNAMIC_REV	1	</span><span class="cm">/* V2 format w/ dynamic inode sizes */</span><span class="cp"></span>

<span class="cp">#define EXT4_CURRENT_REV	EXT4_GOOD_OLD_REV</span>
<span class="cp">#define EXT4_MAX_SUPP_REV	EXT4_DYNAMIC_REV</span>

<span class="cp">#define EXT4_GOOD_OLD_INODE_SIZE 128</span>

<span class="cm">/*</span>
<span class="cm"> * Feature set definitions</span>
<span class="cm"> */</span>

<span class="cp">#define EXT4_HAS_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	((EXT4_SB(sb)-&gt;s_es-&gt;s_feature_compat &amp; cpu_to_le32(mask)) != 0)</span>
<span class="cp">#define EXT4_HAS_RO_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	((EXT4_SB(sb)-&gt;s_es-&gt;s_feature_ro_compat &amp; cpu_to_le32(mask)) != 0)</span>
<span class="cp">#define EXT4_HAS_INCOMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	((EXT4_SB(sb)-&gt;s_es-&gt;s_feature_incompat &amp; cpu_to_le32(mask)) != 0)</span>
<span class="cp">#define EXT4_SET_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	EXT4_SB(sb)-&gt;s_es-&gt;s_feature_compat |= cpu_to_le32(mask)</span>
<span class="cp">#define EXT4_SET_RO_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	EXT4_SB(sb)-&gt;s_es-&gt;s_feature_ro_compat |= cpu_to_le32(mask)</span>
<span class="cp">#define EXT4_SET_INCOMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	EXT4_SB(sb)-&gt;s_es-&gt;s_feature_incompat |= cpu_to_le32(mask)</span>
<span class="cp">#define EXT4_CLEAR_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	EXT4_SB(sb)-&gt;s_es-&gt;s_feature_compat &amp;= ~cpu_to_le32(mask)</span>
<span class="cp">#define EXT4_CLEAR_RO_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	EXT4_SB(sb)-&gt;s_es-&gt;s_feature_ro_compat &amp;= ~cpu_to_le32(mask)</span>
<span class="cp">#define EXT4_CLEAR_INCOMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	EXT4_SB(sb)-&gt;s_es-&gt;s_feature_incompat &amp;= ~cpu_to_le32(mask)</span>

<span class="cp">#define EXT4_FEATURE_COMPAT_DIR_PREALLOC	0x0001</span>
<span class="cp">#define EXT4_FEATURE_COMPAT_IMAGIC_INODES	0x0002</span>
<span class="cp">#define EXT4_FEATURE_COMPAT_HAS_JOURNAL		0x0004</span>
<span class="cp">#define EXT4_FEATURE_COMPAT_EXT_ATTR		0x0008</span>
<span class="cp">#define EXT4_FEATURE_COMPAT_RESIZE_INODE	0x0010</span>
<span class="cp">#define EXT4_FEATURE_COMPAT_DIR_INDEX		0x0020</span>

<span class="cp">#define EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER	0x0001</span>
<span class="cp">#define EXT4_FEATURE_RO_COMPAT_LARGE_FILE	0x0002</span>
<span class="cp">#define EXT4_FEATURE_RO_COMPAT_BTREE_DIR	0x0004</span>
<span class="cp">#define EXT4_FEATURE_RO_COMPAT_HUGE_FILE        0x0008</span>
<span class="cp">#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM		0x0010</span>
<span class="cp">#define EXT4_FEATURE_RO_COMPAT_DIR_NLINK	0x0020</span>
<span class="cp">#define EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE	0x0040</span>
<span class="cp">#define EXT4_FEATURE_RO_COMPAT_QUOTA		0x0100</span>
<span class="cp">#define EXT4_FEATURE_RO_COMPAT_BIGALLOC		0x0200</span>
<span class="cm">/*</span>
<span class="cm"> * METADATA_CSUM also enables group descriptor checksums (GDT_CSUM).  When</span>
<span class="cm"> * METADATA_CSUM is set, group descriptor checksums use the same algorithm as</span>
<span class="cm"> * all other data structures&#39; checksums.  However, the METADATA_CSUM and</span>
<span class="cm"> * GDT_CSUM bits are mutually exclusive.</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM	0x0400</span>

<span class="cp">#define EXT4_FEATURE_INCOMPAT_COMPRESSION	0x0001</span>
<span class="cp">#define EXT4_FEATURE_INCOMPAT_FILETYPE		0x0002</span>
<span class="cp">#define EXT4_FEATURE_INCOMPAT_RECOVER		0x0004 </span><span class="cm">/* Needs recovery */</span><span class="cp"></span>
<span class="cp">#define EXT4_FEATURE_INCOMPAT_JOURNAL_DEV	0x0008 </span><span class="cm">/* Journal device */</span><span class="cp"></span>
<span class="cp">#define EXT4_FEATURE_INCOMPAT_META_BG		0x0010</span>
<span class="cp">#define EXT4_FEATURE_INCOMPAT_EXTENTS		0x0040 </span><span class="cm">/* extents support */</span><span class="cp"></span>
<span class="cp">#define EXT4_FEATURE_INCOMPAT_64BIT		0x0080</span>
<span class="cp">#define EXT4_FEATURE_INCOMPAT_MMP               0x0100</span>
<span class="cp">#define EXT4_FEATURE_INCOMPAT_FLEX_BG		0x0200</span>
<span class="cp">#define EXT4_FEATURE_INCOMPAT_EA_INODE		0x0400 </span><span class="cm">/* EA in inode */</span><span class="cp"></span>
<span class="cp">#define EXT4_FEATURE_INCOMPAT_DIRDATA		0x1000 </span><span class="cm">/* data in dirent */</span><span class="cp"></span>
<span class="cp">#define EXT4_FEATURE_INCOMPAT_BG_USE_META_CSUM	0x2000 </span><span class="cm">/* use crc32c for bg */</span><span class="cp"></span>
<span class="cp">#define EXT4_FEATURE_INCOMPAT_LARGEDIR		0x4000 </span><span class="cm">/* &gt;2GB or 3-lvl htree */</span><span class="cp"></span>
<span class="cp">#define EXT4_FEATURE_INCOMPAT_INLINEDATA	0x8000 </span><span class="cm">/* data in inode */</span><span class="cp"></span>

<span class="cp">#define EXT2_FEATURE_COMPAT_SUPP	EXT4_FEATURE_COMPAT_EXT_ATTR</span>
<span class="cp">#define EXT2_FEATURE_INCOMPAT_SUPP	(EXT4_FEATURE_INCOMPAT_FILETYPE| \</span>
<span class="cp">					 EXT4_FEATURE_INCOMPAT_META_BG)</span>
<span class="cp">#define EXT2_FEATURE_RO_COMPAT_SUPP	(EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER| \</span>
<span class="cp">					 EXT4_FEATURE_RO_COMPAT_LARGE_FILE| \</span>
<span class="cp">					 EXT4_FEATURE_RO_COMPAT_BTREE_DIR)</span>

<span class="cp">#define EXT3_FEATURE_COMPAT_SUPP	EXT4_FEATURE_COMPAT_EXT_ATTR</span>
<span class="cp">#define EXT3_FEATURE_INCOMPAT_SUPP	(EXT4_FEATURE_INCOMPAT_FILETYPE| \</span>
<span class="cp">					 EXT4_FEATURE_INCOMPAT_RECOVER| \</span>
<span class="cp">					 EXT4_FEATURE_INCOMPAT_META_BG)</span>
<span class="cp">#define EXT3_FEATURE_RO_COMPAT_SUPP	(EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER| \</span>
<span class="cp">					 EXT4_FEATURE_RO_COMPAT_LARGE_FILE| \</span>
<span class="cp">					 EXT4_FEATURE_RO_COMPAT_BTREE_DIR)</span>

<span class="cp">#define EXT4_FEATURE_COMPAT_SUPP	EXT2_FEATURE_COMPAT_EXT_ATTR</span>
<span class="cp">#define EXT4_FEATURE_INCOMPAT_SUPP	(EXT4_FEATURE_INCOMPAT_FILETYPE| \</span>
<span class="cp">					 EXT4_FEATURE_INCOMPAT_RECOVER| \</span>
<span class="cp">					 EXT4_FEATURE_INCOMPAT_META_BG| \</span>
<span class="cp">					 EXT4_FEATURE_INCOMPAT_EXTENTS| \</span>
<span class="cp">					 EXT4_FEATURE_INCOMPAT_64BIT| \</span>
<span class="cp">					 EXT4_FEATURE_INCOMPAT_FLEX_BG| \</span>
<span class="cp">					 EXT4_FEATURE_INCOMPAT_MMP)</span>
<span class="cp">#define EXT4_FEATURE_RO_COMPAT_SUPP	(EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER| \</span>
<span class="cp">					 EXT4_FEATURE_RO_COMPAT_LARGE_FILE| \</span>
<span class="cp">					 EXT4_FEATURE_RO_COMPAT_GDT_CSUM| \</span>
<span class="cp">					 EXT4_FEATURE_RO_COMPAT_DIR_NLINK | \</span>
<span class="cp">					 EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE | \</span>
<span class="cp">					 EXT4_FEATURE_RO_COMPAT_BTREE_DIR |\</span>
<span class="cp">					 EXT4_FEATURE_RO_COMPAT_HUGE_FILE |\</span>
<span class="cp">					 EXT4_FEATURE_RO_COMPAT_BIGALLOC |\</span>
<span class="cp">					 EXT4_FEATURE_RO_COMPAT_METADATA_CSUM)</span>

<span class="cm">/*</span>
<span class="cm"> * Default values for user and/or group using reserved blocks</span>
<span class="cm"> */</span>
<span class="cp">#define	EXT4_DEF_RESUID		0</span>
<span class="cp">#define	EXT4_DEF_RESGID		0</span>

<span class="cp">#define EXT4_DEF_INODE_READAHEAD_BLKS	32</span>

<span class="cm">/*</span>
<span class="cm"> * Default mount options</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_DEFM_DEBUG		0x0001</span>
<span class="cp">#define EXT4_DEFM_BSDGROUPS	0x0002</span>
<span class="cp">#define EXT4_DEFM_XATTR_USER	0x0004</span>
<span class="cp">#define EXT4_DEFM_ACL		0x0008</span>
<span class="cp">#define EXT4_DEFM_UID16		0x0010</span>
<span class="cp">#define EXT4_DEFM_JMODE		0x0060</span>
<span class="cp">#define EXT4_DEFM_JMODE_DATA	0x0020</span>
<span class="cp">#define EXT4_DEFM_JMODE_ORDERED	0x0040</span>
<span class="cp">#define EXT4_DEFM_JMODE_WBACK	0x0060</span>
<span class="cp">#define EXT4_DEFM_NOBARRIER	0x0100</span>
<span class="cp">#define EXT4_DEFM_BLOCK_VALIDITY 0x0200</span>
<span class="cp">#define EXT4_DEFM_DISCARD	0x0400</span>
<span class="cp">#define EXT4_DEFM_NODELALLOC	0x0800</span>

<span class="cm">/*</span>
<span class="cm"> * Default journal batch times</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_DEF_MIN_BATCH_TIME	0</span>
<span class="cp">#define EXT4_DEF_MAX_BATCH_TIME	15000 </span><span class="cm">/* 15ms */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Minimum number of groups in a flexgroup before we separate out</span>
<span class="cm"> * directories into the first block group of a flexgroup</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME	4</span>

<span class="cm">/*</span>
<span class="cm"> * Structure of a directory entry</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_NAME_LEN 255</span>

<span class="k">struct</span> <span class="n">ext4_dir_entry</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">inode</span><span class="p">;</span>			<span class="cm">/* Inode number */</span>
	<span class="n">__le16</span>	<span class="n">rec_len</span><span class="p">;</span>		<span class="cm">/* Directory entry length */</span>
	<span class="n">__le16</span>	<span class="n">name_len</span><span class="p">;</span>		<span class="cm">/* Name length */</span>
	<span class="kt">char</span>	<span class="n">name</span><span class="p">[</span><span class="n">EXT4_NAME_LEN</span><span class="p">];</span>	<span class="cm">/* File name */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The new version of the directory entry.  Since EXT4 structures are</span>
<span class="cm"> * stored in intel byte order, and the name_len field could never be</span>
<span class="cm"> * bigger than 255 chars, it&#39;s safe to reclaim the extra byte for the</span>
<span class="cm"> * file_type field.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext4_dir_entry_2</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">inode</span><span class="p">;</span>			<span class="cm">/* Inode number */</span>
	<span class="n">__le16</span>	<span class="n">rec_len</span><span class="p">;</span>		<span class="cm">/* Directory entry length */</span>
	<span class="n">__u8</span>	<span class="n">name_len</span><span class="p">;</span>		<span class="cm">/* Name length */</span>
	<span class="n">__u8</span>	<span class="n">file_type</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">name</span><span class="p">[</span><span class="n">EXT4_NAME_LEN</span><span class="p">];</span>	<span class="cm">/* File name */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This is a bogus directory entry at the end of each leaf block that</span>
<span class="cm"> * records checksums.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext4_dir_entry_tail</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">det_reserved_zero1</span><span class="p">;</span>	<span class="cm">/* Pretend to be unused */</span>
	<span class="n">__le16</span>	<span class="n">det_rec_len</span><span class="p">;</span>		<span class="cm">/* 12 */</span>
	<span class="n">__u8</span>	<span class="n">det_reserved_zero2</span><span class="p">;</span>	<span class="cm">/* Zero name length */</span>
	<span class="n">__u8</span>	<span class="n">det_reserved_ft</span><span class="p">;</span>	<span class="cm">/* 0xDE, fake file type */</span>
	<span class="n">__le32</span>	<span class="n">det_checksum</span><span class="p">;</span>		<span class="cm">/* crc32c(uuid+inum+dirblock) */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Ext4 directory file types.  Only the low 3 bits are used.  The</span>
<span class="cm"> * other bits are reserved for now.</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_FT_UNKNOWN		0</span>
<span class="cp">#define EXT4_FT_REG_FILE	1</span>
<span class="cp">#define EXT4_FT_DIR		2</span>
<span class="cp">#define EXT4_FT_CHRDEV		3</span>
<span class="cp">#define EXT4_FT_BLKDEV		4</span>
<span class="cp">#define EXT4_FT_FIFO		5</span>
<span class="cp">#define EXT4_FT_SOCK		6</span>
<span class="cp">#define EXT4_FT_SYMLINK		7</span>

<span class="cp">#define EXT4_FT_MAX		8</span>

<span class="cp">#define EXT4_FT_DIR_CSUM	0xDE</span>

<span class="cm">/*</span>
<span class="cm"> * EXT4_DIR_PAD defines the directory entries boundaries</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: It must be a multiple of 4</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_DIR_PAD			4</span>
<span class="cp">#define EXT4_DIR_ROUND			(EXT4_DIR_PAD - 1)</span>
<span class="cp">#define EXT4_DIR_REC_LEN(name_len)	(((name_len) + 8 + EXT4_DIR_ROUND) &amp; \</span>
<span class="cp">					 ~EXT4_DIR_ROUND)</span>
<span class="cp">#define EXT4_MAX_REC_LEN		((1&lt;&lt;16)-1)</span>

<span class="cm">/*</span>
<span class="cm"> * If we ever get support for fs block sizes &gt; page_size, we&#39;ll need</span>
<span class="cm"> * to remove the #if statements in the next two functions...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">ext4_rec_len_from_disk</span><span class="p">(</span><span class="n">__le16</span> <span class="n">dlen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">blocksize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">len</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dlen</span><span class="p">);</span>

<span class="cp">#if (PAGE_CACHE_SIZE &gt;= 65536)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="n">EXT4_MAX_REC_LEN</span> <span class="o">||</span> <span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="mi">65532</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">len</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__le16</span> <span class="nf">ext4_rec_len_to_disk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">blocksize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">blocksize</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">blocksize</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
<span class="cp">#if (PAGE_CACHE_SIZE &gt;= 65536)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">65536</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="n">blocksize</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blocksize</span> <span class="o">==</span> <span class="mi">65536</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">EXT4_MAX_REC_LEN</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">len</span> <span class="o">&amp;</span> <span class="mi">65532</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">));</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Hash Tree Directory indexing</span>
<span class="cm"> * (c) Daniel Phillips, 2001</span>
<span class="cm"> */</span>

<span class="cp">#define is_dx(dir) (EXT4_HAS_COMPAT_FEATURE(dir-&gt;i_sb, \</span>
<span class="cp">				      EXT4_FEATURE_COMPAT_DIR_INDEX) &amp;&amp; \</span>
<span class="cp">		    ext4_test_inode_flag((dir), EXT4_INODE_INDEX))</span>
<span class="cp">#define EXT4_DIR_LINK_MAX(dir) (!is_dx(dir) &amp;&amp; (dir)-&gt;i_nlink &gt;= EXT4_LINK_MAX)</span>
<span class="cp">#define EXT4_DIR_LINK_EMPTY(dir) ((dir)-&gt;i_nlink == 2 || (dir)-&gt;i_nlink == 1)</span>

<span class="cm">/* Legal values for the dx_root hash_version field: */</span>

<span class="cp">#define DX_HASH_LEGACY		0</span>
<span class="cp">#define DX_HASH_HALF_MD4	1</span>
<span class="cp">#define DX_HASH_TEA		2</span>
<span class="cp">#define DX_HASH_LEGACY_UNSIGNED	3</span>
<span class="cp">#define DX_HASH_HALF_MD4_UNSIGNED	4</span>
<span class="cp">#define DX_HASH_TEA_UNSIGNED		5</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">ext4_chksum</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">,</span> <span class="n">u32</span> <span class="n">crc</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">shash_desc</span> <span class="n">shash</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">ctx</span><span class="p">[</span><span class="n">crypto_shash_descsize</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_chksum_driver</span><span class="p">)];</span>
	<span class="p">}</span> <span class="n">desc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">desc</span><span class="p">.</span><span class="n">shash</span><span class="p">.</span><span class="n">tfm</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_chksum_driver</span><span class="p">;</span>
	<span class="n">desc</span><span class="p">.</span><span class="n">shash</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">desc</span><span class="p">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">crc</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">crypto_shash_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">.</span><span class="n">shash</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">desc</span><span class="p">.</span><span class="n">ctx</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cm">/* hash info structure used by the directory hash */</span>
<span class="k">struct</span> <span class="n">dx_hash_info</span>
<span class="p">{</span>
	<span class="n">u32</span>		<span class="n">hash</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">minor_hash</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">hash_version</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="o">*</span><span class="n">seed</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/* 32 and 64 bit signed EOF for dx directories */</span>
<span class="cp">#define EXT4_HTREE_EOF_32BIT   ((1UL  &lt;&lt; (32 - 1)) - 1)</span>
<span class="cp">#define EXT4_HTREE_EOF_64BIT   ((1ULL &lt;&lt; (64 - 1)) - 1)</span>


<span class="cm">/*</span>
<span class="cm"> * Control parameters used by ext4_htree_next_block</span>
<span class="cm"> */</span>
<span class="cp">#define HASH_NB_ALWAYS		1</span>


<span class="cm">/*</span>
<span class="cm"> * Describe an inode&#39;s exact location on disk and in memory</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext4_iloc</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">ext4_group_t</span> <span class="n">block_group</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ext4_inode</span> <span class="o">*</span><span class="nf">ext4_raw_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_iloc</span> <span class="o">*</span><span class="n">iloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ext4_inode</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">iloc</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">iloc</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This structure is stuffed into the struct file&#39;s private_data field</span>
<span class="cm"> * for directories.  It is where we put information so that we can do</span>
<span class="cm"> * readdir operations in hash tree order.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dir_private_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_root</span>	<span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span>	<span class="o">*</span><span class="n">curr_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fname</span>	<span class="o">*</span><span class="n">extra_fname</span><span class="p">;</span>
	<span class="n">loff_t</span>		<span class="n">last_pos</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">curr_hash</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">curr_minor_hash</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">next_hash</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* calculate the first block number of the group */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">ext4_fsblk_t</span>
<span class="nf">ext4_group_first_block_no</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">ext4_group_t</span> <span class="n">group_no</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">group_no</span> <span class="o">*</span> <span class="p">(</span><span class="n">ext4_fsblk_t</span><span class="p">)</span><span class="n">EXT4_BLOCKS_PER_GROUP</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="o">-&gt;</span><span class="n">s_first_data_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Special error return code only used by dx_probe() and its callers.</span>
<span class="cm"> */</span>
<span class="cp">#define ERR_BAD_DX_DIR	-75000</span>

<span class="kt">void</span> <span class="n">ext4_get_group_no_and_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">ext4_fsblk_t</span> <span class="n">blocknr</span><span class="p">,</span>
			<span class="n">ext4_group_t</span> <span class="o">*</span><span class="n">blockgrpp</span><span class="p">,</span> <span class="n">ext4_grpblk_t</span> <span class="o">*</span><span class="n">offsetp</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Timeout and state flag for lazy initialization inode thread.</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_DEF_LI_WAIT_MULT			10</span>
<span class="cp">#define EXT4_DEF_LI_MAX_START_DELAY		5</span>
<span class="cp">#define EXT4_LAZYINIT_QUIT			0x0001</span>
<span class="cp">#define EXT4_LAZYINIT_RUNNING			0x0002</span>

<span class="cm">/*</span>
<span class="cm"> * Lazy inode table initialization info</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext4_lazy_init</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">li_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">li_request_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">li_list_mtx</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ext4_li_request</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span>	<span class="o">*</span><span class="n">lr_super</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ext4_sb_info</span>	<span class="o">*</span><span class="n">lr_sbi</span><span class="p">;</span>
	<span class="n">ext4_group_t</span>		<span class="n">lr_next_group</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">lr_request</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">lr_next_sched</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">lr_timeout</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ext4_features</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="n">f_kobj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">f_kobj_unregister</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This structure will be used for multiple mount protection. It will be</span>
<span class="cm"> * written into the block number saved in the s_mmp_block field in the</span>
<span class="cm"> * superblock. Programs that check MMP should assume that if</span>
<span class="cm"> * SEQ_FSCK (or any unknown code above SEQ_MAX) is present then it is NOT safe</span>
<span class="cm"> * to use the filesystem, regardless of how old the timestamp is.</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_MMP_MAGIC     0x004D4D50U </span><span class="cm">/* ASCII for MMP */</span><span class="cp"></span>
<span class="cp">#define EXT4_MMP_SEQ_CLEAN 0xFF4D4D50U </span><span class="cm">/* mmp_seq value for clean unmount */</span><span class="cp"></span>
<span class="cp">#define EXT4_MMP_SEQ_FSCK  0xE24D4D50U </span><span class="cm">/* mmp_seq value when being fscked */</span><span class="cp"></span>
<span class="cp">#define EXT4_MMP_SEQ_MAX   0xE24D4D4FU </span><span class="cm">/* maximum valid mmp_seq value */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">mmp_struct</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">mmp_magic</span><span class="p">;</span>		<span class="cm">/* Magic number for MMP */</span>
	<span class="n">__le32</span>	<span class="n">mmp_seq</span><span class="p">;</span>		<span class="cm">/* Sequence no. updated periodically */</span>

	<span class="cm">/*</span>
<span class="cm">	 * mmp_time, mmp_nodename &amp; mmp_bdevname are only used for information</span>
<span class="cm">	 * purposes and do not affect the correctness of the algorithm</span>
<span class="cm">	 */</span>
	<span class="n">__le64</span>	<span class="n">mmp_time</span><span class="p">;</span>		<span class="cm">/* Time last updated */</span>
	<span class="kt">char</span>	<span class="n">mmp_nodename</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>	<span class="cm">/* Node which last updated MMP block */</span>
	<span class="kt">char</span>	<span class="n">mmp_bdevname</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>	<span class="cm">/* Bdev which last updated MMP block */</span>

	<span class="cm">/*</span>
<span class="cm">	 * mmp_check_interval is used to verify if the MMP block has been</span>
<span class="cm">	 * updated on the block device. The value is updated based on the</span>
<span class="cm">	 * maximum time to write the MMP block during an update cycle.</span>
<span class="cm">	 */</span>
	<span class="n">__le16</span>	<span class="n">mmp_check_interval</span><span class="p">;</span>

	<span class="n">__le16</span>	<span class="n">mmp_pad1</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">mmp_pad2</span><span class="p">[</span><span class="mi">226</span><span class="p">];</span>
	<span class="n">__le32</span>	<span class="n">mmp_checksum</span><span class="p">;</span>		<span class="cm">/* crc32c(uuid+mmp_block) */</span>
<span class="p">};</span>

<span class="cm">/* arguments passed to the mmp thread */</span>
<span class="k">struct</span> <span class="n">mmpd_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span> <span class="cm">/* bh from initial read_mmp_block() */</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>  <span class="cm">/* super block of the fs */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Check interval multiplier</span>
<span class="cm"> * The MMP block is written every update interval and initially checked every</span>
<span class="cm"> * update interval x the multiplier (the value is then adapted based on the</span>
<span class="cm"> * write latency). The reason is that writes can be delayed under load and we</span>
<span class="cm"> * don&#39;t want readers to incorrectly assume that the filesystem is no longer</span>
<span class="cm"> * in use.</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_MMP_CHECK_MULT		2UL</span>

<span class="cm">/*</span>
<span class="cm"> * Minimum interval for MMP checking in seconds.</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_MMP_MIN_CHECK_INTERVAL	5UL</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum interval for MMP checking in seconds.</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_MMP_MAX_CHECK_INTERVAL	300UL</span>

<span class="cm">/*</span>
<span class="cm"> * Function prototypes</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Ok, these declarations are also in &lt;linux/kernel.h&gt; but none of the</span>
<span class="cm"> * ext4 source programs needs to include it so they are duplicated here.</span>
<span class="cm"> */</span>
<span class="cp"># define NORET_TYPE	</span><span class="cm">/**/</span><span class="cp"></span>
<span class="cp"># define ATTRIB_NORET	__attribute__((noreturn))</span>
<span class="cp"># define NORET_AND	noreturn,</span>

<span class="cm">/* bitmap.c */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ext4_count_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ext4_inode_bitmap_csum_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">ext4_group_t</span> <span class="n">group</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">gdp</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ext4_inode_bitmap_csum_verify</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">ext4_group_t</span> <span class="n">group</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">gdp</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ext4_block_bitmap_csum_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">ext4_group_t</span> <span class="n">group</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">gdp</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ext4_block_bitmap_csum_verify</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">ext4_group_t</span> <span class="n">group</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">gdp</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">);</span>

<span class="cm">/* balloc.c */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_validate_block_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_group</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ext4_block_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			<span class="n">ext4_fsblk_t</span> <span class="n">blocknr</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">ext4_grpblk_t</span> <span class="n">ext4_block_group_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			<span class="n">ext4_fsblk_t</span> <span class="n">blocknr</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_bg_has_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">ext4_group_t</span> <span class="n">group</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ext4_bg_num_gdb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			<span class="n">ext4_group_t</span> <span class="n">group</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">ext4_fsblk_t</span> <span class="n">ext4_new_meta_blocks</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					 <span class="n">ext4_fsblk_t</span> <span class="n">goal</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="o">*</span><span class="n">errp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_claim_free_clusters</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">,</span>
				    <span class="n">s64</span> <span class="n">nclusters</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">ext4_fsblk_t</span> <span class="n">ext4_count_free_clusters</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_check_blocks_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span> <span class="n">ext4_get_group_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span><span class="p">,</span>
						    <span class="n">ext4_group_t</span> <span class="n">block_group</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span> <span class="n">bh</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_should_retry_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">retries</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">ext4_read_block_bitmap_nowait</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
						<span class="n">ext4_group_t</span> <span class="n">block_group</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_wait_block_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				  <span class="n">ext4_group_t</span> <span class="n">block_group</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">ext4_read_block_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
						  <span class="n">ext4_group_t</span> <span class="n">block_group</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_init_block_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
				   <span class="n">ext4_group_t</span> <span class="n">group</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="n">ext4_free_clusters_after_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					      <span class="n">ext4_group_t</span> <span class="n">block_group</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">gdp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="n">ext4_num_overhead_clusters</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					   <span class="n">ext4_group_t</span> <span class="n">block_group</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">gdp</span><span class="p">);</span>
<span class="n">ext4_fsblk_t</span> <span class="n">ext4_inode_to_goal_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* dir.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__ext4_check_dir_entry</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ext4_dir_entry_2</span> <span class="o">*</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
<span class="cp">#define ext4_check_dir_entry(dir, filp, de, bh, offset)			\</span>
<span class="cp">	unlikely(__ext4_check_dir_entry(__func__, __LINE__, (dir), (filp), \</span>
<span class="cp">					(de), (bh), (offset)))</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_htree_store_dirent</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">dir_file</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">hash</span><span class="p">,</span>
				    <span class="n">__u32</span> <span class="n">minor_hash</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ext4_dir_entry_2</span> <span class="o">*</span><span class="n">dirent</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_htree_free_dir_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">dir_private_info</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="cm">/* fsync.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_sync_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_flush_completed_IO</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* hash.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4fs_dirhash</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">struct</span>
			  <span class="n">dx_hash_info</span> <span class="o">*</span><span class="n">hinfo</span><span class="p">);</span>

<span class="cm">/* ialloc.c */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ext4_new_inode</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="n">umode_t</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">qstr</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">goal</span><span class="p">,</span>
				    <span class="n">uid_t</span> <span class="o">*</span><span class="n">owner</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_free_inode</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">ext4_orphan_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ext4_count_free_inodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ext4_count_dirs</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_check_inodes_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_mark_bitmap_end</span><span class="p">(</span><span class="kt">int</span> <span class="n">start_bit</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end_bit</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_init_inode_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				 <span class="n">ext4_group_t</span> <span class="n">group</span><span class="p">,</span> <span class="kt">int</span> <span class="n">barrier</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_end_bitmap_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">);</span>

<span class="cm">/* mballoc.c */</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">ext4_mb_stats</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">ext4_mb_max_to_scan</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_mb_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_mb_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">ext4_fsblk_t</span> <span class="n">ext4_mb_new_blocks</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_allocation_request</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_mb_reserve_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_discard_preallocations</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">ext4_init_mballoc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_exit_mballoc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_free_blocks</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="n">ext4_fsblk_t</span> <span class="n">block</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_mb_add_groupinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
		<span class="n">ext4_group_t</span> <span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_group_add_blocks</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				<span class="n">ext4_fsblk_t</span> <span class="n">block</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_trim_fs</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fstrim_range</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* inode.c */</span>
<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">ext4_getblk</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span>
						<span class="n">ext4_lblk_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">ext4_bread</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span>
						<span class="n">ext4_lblk_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ext4_get_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">iblock</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ext4_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">ext4_write_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">ext4_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">ext4_getattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">kstat</span> <span class="o">*</span><span class="n">stat</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_evict_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_clear_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span>  <span class="n">ext4_sync_inode</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_dirty_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_change_inode_journal_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_get_inode_loc</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ext4_iloc</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_can_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_punch_hole</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">length</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_truncate_restart_trans</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_set_inode_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_get_inode_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_inode_info</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_alloc_da_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_set_aops</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_writepage_trans_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_chunk_trans_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nrblocks</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_discard_partial_page_buffers</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">from</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_page_mkwrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">qsize_t</span> <span class="o">*</span><span class="n">ext4_get_reserved_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_da_update_reserve_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">used</span><span class="p">,</span> <span class="kt">int</span> <span class="n">quota_claim</span><span class="p">);</span>

<span class="cm">/* indirect.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_ind_map_blocks</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">ssize_t</span> <span class="n">ext4_ind_direct_IO</span><span class="p">(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_ind_calc_metadata_amount</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">lblock</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_ind_trans_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nrblocks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">chunk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_ind_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="cm">/* ioctl.c */</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">ext4_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">ext4_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="cm">/* migrate.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_ext_migrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* namei.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_dirent_csum_verify</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">ext4_dir_entry</span> <span class="o">*</span><span class="n">dirent</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_orphan_add</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_orphan_del</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_htree_fill_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">dir_file</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">start_hash</span><span class="p">,</span>
				<span class="n">__u32</span> <span class="n">start_minor_hash</span><span class="p">,</span> <span class="n">__u32</span> <span class="o">*</span><span class="n">next_hash</span><span class="p">);</span>

<span class="cm">/* resize.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_group_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_new_group_data</span> <span class="o">*</span><span class="n">input</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_group_extend</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_super_block</span> <span class="o">*</span><span class="n">es</span><span class="p">,</span>
				<span class="n">ext4_fsblk_t</span> <span class="n">n_blocks_count</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_resize_fs</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">ext4_fsblk_t</span> <span class="n">n_blocks_count</span><span class="p">);</span>

<span class="cm">/* super.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_superblock_csum_verify</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">ext4_super_block</span> <span class="o">*</span><span class="n">es</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_superblock_csum_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ext4_super_block</span> <span class="o">*</span><span class="n">es</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ext4_kvmalloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ext4_kvzalloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_kvfree</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">__ext4_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
		  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="p">...);</span>
<span class="cp">#define ext4_error(sb, message...)	__ext4_error(sb, __func__,	\</span>
<span class="cp">						     __LINE__, ## message)</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">ext4_error_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">ext4_fsblk_t</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">ext4_error_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">ext4_fsblk_t</span><span class="p">,</span>
		     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__ext4_std_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">__ext4_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
		  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="p">...);</span>
<span class="cp">#define ext4_abort(sb, message...)	__ext4_abort(sb, __func__, \</span>
<span class="cp">						       __LINE__, ## message)</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">__ext4_warning</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
		    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="p">...);</span>
<span class="cp">#define ext4_warning(sb, message...)	__ext4_warning(sb, __func__, \</span>
<span class="cp">						       __LINE__, ## message)</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">ext4_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">__dump_mmp_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mmp_struct</span> <span class="o">*</span><span class="n">mmp</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#define dump_mmp_msg(sb, mmp, msg)	__dump_mmp_msg(sb, mmp, __func__, \</span>
<span class="cp">						       __LINE__, msg)</span>
<span class="k">extern</span> <span class="n">__printf</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">__ext4_grp_locked_error</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="n">ext4_group_t</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">ext4_fsblk_t</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="p">...);</span>
<span class="cp">#define ext4_grp_locked_error(sb, grp, message...) \</span>
<span class="cp">	__ext4_grp_locked_error(__func__, __LINE__, (sb), (grp), ## message)</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_update_dynamic_rev</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_update_compat_feature</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					<span class="n">__u32</span> <span class="n">compat</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_update_rocompat_feature</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>	<span class="n">__u32</span> <span class="n">rocompat</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_update_incompat_feature</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>	<span class="n">__u32</span> <span class="n">incompat</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">ext4_fsblk_t</span> <span class="n">ext4_block_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">bg</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">ext4_fsblk_t</span> <span class="n">ext4_inode_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">bg</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">ext4_fsblk_t</span> <span class="n">ext4_inode_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">bg</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">__u32</span> <span class="n">ext4_free_group_clusters</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">bg</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">__u32</span> <span class="n">ext4_free_inodes_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">bg</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">__u32</span> <span class="n">ext4_used_dirs_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">bg</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">__u32</span> <span class="n">ext4_itable_unused_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">bg</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_block_bitmap_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">bg</span><span class="p">,</span> <span class="n">ext4_fsblk_t</span> <span class="n">blk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_inode_bitmap_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">bg</span><span class="p">,</span> <span class="n">ext4_fsblk_t</span> <span class="n">blk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_inode_table_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">bg</span><span class="p">,</span> <span class="n">ext4_fsblk_t</span> <span class="n">blk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_free_group_clusters_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">bg</span><span class="p">,</span>
					 <span class="n">__u32</span> <span class="n">count</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_free_inodes_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">bg</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">count</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_used_dirs_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">bg</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">count</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_itable_unused_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">bg</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">count</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_group_desc_csum_verify</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">group</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">gdp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_group_desc_csum_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">group</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ext4_group_desc</span> <span class="o">*</span><span class="n">gdp</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext4_has_group_desc_csum</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">EXT4_HAS_RO_COMPAT_FEATURE</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
					  <span class="n">EXT4_FEATURE_RO_COMPAT_GDT_CSUM</span> <span class="o">|</span>
					  <span class="n">EXT4_FEATURE_RO_COMPAT_METADATA_CSUM</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">ext4_fsblk_t</span> <span class="nf">ext4_blocks_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_super_block</span> <span class="o">*</span><span class="n">es</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">ext4_fsblk_t</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_blocks_count_hi</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_blocks_count_lo</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">ext4_fsblk_t</span> <span class="nf">ext4_r_blocks_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_super_block</span> <span class="o">*</span><span class="n">es</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">ext4_fsblk_t</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_r_blocks_count_hi</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_r_blocks_count_lo</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">ext4_fsblk_t</span> <span class="nf">ext4_free_blocks_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_super_block</span> <span class="o">*</span><span class="n">es</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">ext4_fsblk_t</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_free_blocks_count_hi</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span>
		<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">es</span><span class="o">-&gt;</span><span class="n">s_free_blocks_count_lo</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ext4_blocks_count_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_super_block</span> <span class="o">*</span><span class="n">es</span><span class="p">,</span>
					 <span class="n">ext4_fsblk_t</span> <span class="n">blk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">es</span><span class="o">-&gt;</span><span class="n">s_blocks_count_lo</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">blk</span><span class="p">);</span>
	<span class="n">es</span><span class="o">-&gt;</span><span class="n">s_blocks_count_hi</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">blk</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ext4_free_blocks_count_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_super_block</span> <span class="o">*</span><span class="n">es</span><span class="p">,</span>
					      <span class="n">ext4_fsblk_t</span> <span class="n">blk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">es</span><span class="o">-&gt;</span><span class="n">s_free_blocks_count_lo</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">blk</span><span class="p">);</span>
	<span class="n">es</span><span class="o">-&gt;</span><span class="n">s_free_blocks_count_hi</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">blk</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ext4_r_blocks_count_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_super_block</span> <span class="o">*</span><span class="n">es</span><span class="p">,</span>
					   <span class="n">ext4_fsblk_t</span> <span class="n">blk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">es</span><span class="o">-&gt;</span><span class="n">s_r_blocks_count_lo</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">blk</span><span class="p">);</span>
	<span class="n">es</span><span class="o">-&gt;</span><span class="n">s_r_blocks_count_hi</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">blk</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">loff_t</span> <span class="nf">ext4_isize</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_inode</span> <span class="o">*</span><span class="n">raw_inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)))</span>
		<span class="k">return</span> <span class="p">((</span><span class="n">loff_t</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_size_high</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_size_lo</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_size_lo</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ext4_isize_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_inode</span> <span class="o">*</span><span class="n">raw_inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">i_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_size_lo</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">i_size</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_size_high</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">ext4_group_info</span> <span class="o">*</span><span class="nf">ext4_get_group_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					    <span class="n">ext4_group_t</span> <span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	 <span class="k">struct</span> <span class="n">ext4_group_info</span> <span class="o">***</span><span class="n">grp_info</span><span class="p">;</span>
	 <span class="kt">long</span> <span class="n">indexv</span><span class="p">,</span> <span class="n">indexh</span><span class="p">;</span>
	 <span class="n">grp_info</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_group_info</span><span class="p">;</span>
	 <span class="n">indexv</span> <span class="o">=</span> <span class="n">group</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">EXT4_DESC_PER_BLOCK_BITS</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>
	 <span class="n">indexh</span> <span class="o">=</span> <span class="n">group</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">EXT4_DESC_PER_BLOCK</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	 <span class="k">return</span> <span class="n">grp_info</span><span class="p">[</span><span class="n">indexv</span><span class="p">][</span><span class="n">indexh</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Reading s_groups_count requires using smp_rmb() afterwards.  See</span>
<span class="cm"> * the locking protocol documented in the comments of ext4_group_add()</span>
<span class="cm"> * in resize.c</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">ext4_group_t</span> <span class="nf">ext4_get_groups_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ext4_group_t</span>	<span class="n">ngroups</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_groups_count</span><span class="p">;</span>

	<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ngroups</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">ext4_group_t</span> <span class="nf">ext4_flex_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">,</span>
					     <span class="n">ext4_group_t</span> <span class="n">block_group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">block_group</span> <span class="o">&gt;&gt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_log_groups_per_flex</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ext4_flex_bg_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_log_groups_per_flex</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define ext4_std_error(sb, errno)				\</span>
<span class="cp">do {								\</span>
<span class="cp">	if ((errno))						\</span>
<span class="cp">		__ext4_std_error((sb), __func__, __LINE__, (errno));	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/* Each CPU can accumulate percpu_counter_batch clusters in their local</span>
<span class="cm"> * counters. So we need to make sure we have free clusters more</span>
<span class="cm"> * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.</span>
<span class="cm"> */</span>
<span class="cp">#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))</span>
<span class="cp">#else</span>
<span class="cp">#define EXT4_FREECLUSTERS_WATERMARK 0</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ext4_update_i_disksize</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">newsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * XXX: replace with spinlock if seen contended -bzzz</span>
<span class="cm">	 */</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data_sem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newsize</span> <span class="o">&gt;</span> <span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_disksize</span><span class="p">)</span>
		<span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_disksize</span> <span class="o">=</span> <span class="n">newsize</span><span class="p">;</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_data_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ext4_group_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">bb_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_root</span>  <span class="n">bb_free_root</span><span class="p">;</span>
	<span class="n">ext4_grpblk_t</span>	<span class="n">bb_first_free</span><span class="p">;</span>	<span class="cm">/* first free block */</span>
	<span class="n">ext4_grpblk_t</span>	<span class="n">bb_free</span><span class="p">;</span>	<span class="cm">/* total free blocks */</span>
	<span class="n">ext4_grpblk_t</span>	<span class="n">bb_fragments</span><span class="p">;</span>	<span class="cm">/* nr of freespace fragments */</span>
	<span class="n">ext4_grpblk_t</span>	<span class="n">bb_largest_free_order</span><span class="p">;</span><span class="cm">/* order of largest frag in BG */</span>
	<span class="k">struct</span>          <span class="n">list_head</span> <span class="n">bb_prealloc_list</span><span class="p">;</span>
<span class="cp">#ifdef DOUBLE_CHECK</span>
	<span class="kt">void</span>            <span class="o">*</span><span class="n">bb_bitmap</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">alloc_sem</span><span class="p">;</span>
	<span class="n">ext4_grpblk_t</span>	<span class="n">bb_counters</span><span class="p">[];</span>	<span class="cm">/* Nr of free power-of-two-block</span>
<span class="cm">					 * regions, index is order.</span>
<span class="cm">					 * bb_counters[3] = 5 means</span>
<span class="cm">					 * 5 free 8-block regions. */</span>
<span class="p">};</span>

<span class="cp">#define EXT4_GROUP_INFO_NEED_INIT_BIT		0</span>
<span class="cp">#define EXT4_GROUP_INFO_WAS_TRIMMED_BIT		1</span>

<span class="cp">#define EXT4_MB_GRP_NEED_INIT(grp)	\</span>
<span class="cp">	(test_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &amp;((grp)-&gt;bb_state)))</span>

<span class="cp">#define EXT4_MB_GRP_WAS_TRIMMED(grp)	\</span>
<span class="cp">	(test_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &amp;((grp)-&gt;bb_state)))</span>
<span class="cp">#define EXT4_MB_GRP_SET_TRIMMED(grp)	\</span>
<span class="cp">	(set_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &amp;((grp)-&gt;bb_state)))</span>
<span class="cp">#define EXT4_MB_GRP_CLEAR_TRIMMED(grp)	\</span>
<span class="cp">	(clear_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &amp;((grp)-&gt;bb_state)))</span>

<span class="cp">#define EXT4_MAX_CONTENTION		8</span>
<span class="cp">#define EXT4_CONTENTION_THRESHOLD	2</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">spinlock_t</span> <span class="o">*</span><span class="nf">ext4_group_lock_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					      <span class="n">ext4_group_t</span> <span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bgl_lock_ptr</span><span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_blockgroup_lock</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns true if the filesystem is busy enough that attempts to</span>
<span class="cm"> * access the block group locks has run into contention.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ext4_fs_is_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_lock_busy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">EXT4_CONTENTION_THRESHOLD</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ext4_lock_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">ext4_group_t</span> <span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="n">ext4_group_lock_ptr</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spin_trylock</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span>
		<span class="cm">/*</span>
<span class="cm">		 * We&#39;re able to grab the lock right away, so drop the</span>
<span class="cm">		 * lock contention counter.</span>
<span class="cm">		 */</span>
		<span class="n">atomic_add_unless</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_lock_busy</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The lock is busy, so bump the contention counter,</span>
<span class="cm">		 * and then wait on the spin lock.</span>
<span class="cm">		 */</span>
		<span class="n">atomic_add_unless</span><span class="p">(</span><span class="o">&amp;</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_lock_busy</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
				  <span class="n">EXT4_MAX_CONTENTION</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ext4_unlock_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					<span class="n">ext4_group_t</span> <span class="n">group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">ext4_group_lock_ptr</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">group</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ext4_mark_super_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ext4_super_block</span> <span class="o">*</span><span class="n">es</span> <span class="o">=</span> <span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_es</span><span class="p">;</span>

	<span class="n">ext4_superblock_csum_set</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">es</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EXT4_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_journal</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_dirt</span> <span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Block validity checking</span>
<span class="cm"> */</span>
<span class="cp">#define ext4_check_indirect_blockref(inode, bh)				\</span>
<span class="cp">	ext4_check_blockref(__func__, __LINE__, inode,			\</span>
<span class="cp">			    (__le32 *)(bh)-&gt;b_data,			\</span>
<span class="cp">			    EXT4_ADDR_PER_BLOCK((inode)-&gt;i_sb))</span>

<span class="cp">#define ext4_ind_check_inode(inode)					\</span>
<span class="cp">	ext4_check_blockref(__func__, __LINE__, inode,			\</span>
<span class="cp">			    EXT4_I(inode)-&gt;i_data,			\</span>
<span class="cp">			    EXT4_NDIR_BLOCKS)</span>

<span class="cm">/*</span>
<span class="cm"> * Inodes and files operations</span>
<span class="cm"> */</span>

<span class="cm">/* dir.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ext4_dir_operations</span><span class="p">;</span>

<span class="cm">/* file.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ext4_file_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ext4_file_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">loff_t</span> <span class="n">ext4_llseek</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="p">);</span>

<span class="cm">/* namei.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ext4_dir_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ext4_special_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">ext4_get_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">child</span><span class="p">);</span>

<span class="cm">/* symlink.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ext4_symlink_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ext4_fast_symlink_inode_operations</span><span class="p">;</span>

<span class="cm">/* block_validity */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_release_system_zone</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_setup_system_zone</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">ext4_init_system_zone</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_exit_system_zone</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_data_block_valid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">,</span>
				 <span class="n">ext4_fsblk_t</span> <span class="n">start_blk</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_check_blockref</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>

<span class="cm">/* extents.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_ext_tree_init</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_ext_writepage_trans_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_ext_index_trans_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nrblocks</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">chunk</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_ext_map_blocks</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_ext_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_ext_punch_hole</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
				<span class="n">loff_t</span> <span class="n">length</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_ext_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_ext_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">long</span> <span class="n">ext4_fallocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
			  <span class="n">loff_t</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_convert_unwritten_extents</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
			  <span class="kt">ssize_t</span> <span class="n">len</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_map_blocks</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">ext4_map_blocks</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_fiemap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fiemap_extent_info</span> <span class="o">*</span><span class="n">fieinfo</span><span class="p">,</span>
			<span class="n">__u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">len</span><span class="p">);</span>
<span class="cm">/* move_extent.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_move_extents</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">o_filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">d_filp</span><span class="p">,</span>
			     <span class="n">__u64</span> <span class="n">start_orig</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">start_donor</span><span class="p">,</span>
			     <span class="n">__u64</span> <span class="n">len</span><span class="p">,</span> <span class="n">__u64</span> <span class="o">*</span><span class="n">moved_len</span><span class="p">);</span>

<span class="cm">/* page-io.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">ext4_init_pageio</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_exit_pageio</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_ioend_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_free_io_end</span><span class="p">(</span><span class="n">ext4_io_end_t</span> <span class="o">*</span><span class="n">io</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">ext4_io_end_t</span> <span class="o">*</span><span class="n">ext4_init_io_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_end_io_nolock</span><span class="p">(</span><span class="n">ext4_io_end_t</span> <span class="o">*</span><span class="n">io</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_io_submit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_io_submit</span> <span class="o">*</span><span class="n">io</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_bio_write_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext4_io_submit</span> <span class="o">*</span><span class="n">io</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">);</span>

<span class="cm">/* mmp.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_multi_mount_protect</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="n">ext4_fsblk_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_mmp_csum_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mmp_struct</span> <span class="o">*</span><span class="n">mmp</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_mmp_csum_verify</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">mmp_struct</span> <span class="o">*</span><span class="n">mmp</span><span class="p">);</span>

<span class="cm">/* BH_Uninit flag: blocks are allocated but uninitialized on disk */</span>
<span class="k">enum</span> <span class="n">ext4_state_bits</span> <span class="p">{</span>
	<span class="n">BH_Uninit</span>	<span class="cm">/* blocks are allocated but uninitialized on disk */</span>
	  <span class="o">=</span> <span class="n">BH_JBDPrivateStart</span><span class="p">,</span>
	<span class="n">BH_AllocFromCluster</span><span class="p">,</span>	<span class="cm">/* allocated blocks were part of already</span>
<span class="cm">				 * allocated cluster. Note that this flag will</span>
<span class="cm">				 * never, ever appear in a buffer_head&#39;s state</span>
<span class="cm">				 * flag. See EXT4_MAP_FROM_CLUSTER to see where</span>
<span class="cm">				 * this is used. */</span>
	<span class="n">BH_Da_Mapped</span><span class="p">,</span>	<span class="cm">/* Delayed allocated block that now has a mapping. This</span>
<span class="cm">			 * flag is set when ext4_map_blocks is called on a</span>
<span class="cm">			 * delayed allocated block to get its real mapping. */</span>
<span class="p">};</span>

<span class="n">BUFFER_FNS</span><span class="p">(</span><span class="n">Uninit</span><span class="p">,</span> <span class="n">uninit</span><span class="p">)</span>
<span class="n">TAS_BUFFER_FNS</span><span class="p">(</span><span class="n">Uninit</span><span class="p">,</span> <span class="n">uninit</span><span class="p">)</span>
<span class="n">BUFFER_FNS</span><span class="p">(</span><span class="n">Da_Mapped</span><span class="p">,</span> <span class="n">da_mapped</span><span class="p">)</span>

<span class="cm">/*</span>
<span class="cm"> * Add new method to test wether block and inode bitmaps are properly</span>
<span class="cm"> * initialized. With uninit_bg reading the block from disk is not enough</span>
<span class="cm"> * to mark the bitmap uptodate. We need to also zero-out the bitmap</span>
<span class="cm"> */</span>
<span class="cp">#define BH_BITMAP_UPTODATE BH_JBDPrivateStart</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">bitmap_uptodate</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">test_bit</span><span class="p">(</span><span class="n">BH_BITMAP_UPTODATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">set_bitmap_uptodate</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">BH_BITMAP_UPTODATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define in_range(b, first, len)	((b) &gt;= (first) &amp;&amp; (b) &lt;= (first) + (len) - 1)</span>

<span class="cm">/* For ioend &amp; aio unwritten conversion wait queues */</span>
<span class="cp">#define EXT4_WQ_HASH_SZ		37</span>
<span class="cp">#define ext4_ioend_wq(v)   (&amp;ext4__ioend_wq[((unsigned long)(v)) %\</span>
<span class="cp">					    EXT4_WQ_HASH_SZ])</span>
<span class="cp">#define ext4_aio_mutex(v)  (&amp;ext4__aio_mutex[((unsigned long)(v)) %\</span>
<span class="cp">					     EXT4_WQ_HASH_SZ])</span>
<span class="k">extern</span> <span class="n">wait_queue_head_t</span> <span class="n">ext4__ioend_wq</span><span class="p">[</span><span class="n">EXT4_WQ_HASH_SZ</span><span class="p">];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">mutex</span> <span class="n">ext4__aio_mutex</span><span class="p">[</span><span class="n">EXT4_WQ_HASH_SZ</span><span class="p">];</span>

<span class="cp">#define EXT4_RESIZING	0</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">ext4_resize_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">ext4_resize_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>

<span class="cp">#endif	</span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>

<span class="cp">#include &quot;ext4_extents.h&quot;</span>

<span class="cp">#endif	</span><span class="cm">/* _EXT4_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
