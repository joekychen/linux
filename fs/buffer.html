<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › buffer.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>buffer.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/fs/buffer.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992, 2002  Linus Torvalds</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Start bdflush() with kernel_thread not syscall - Paul Gortmaker, 12/95</span>
<span class="cm"> *</span>
<span class="cm"> * Removed a lot of unnecessary code and simplified things now that</span>
<span class="cm"> * the buffer cache isn&#39;t our primary cache - Andrew Tridgell 12/96</span>
<span class="cm"> *</span>
<span class="cm"> * Speed up hash, lru, and free list operations.  Use gfp() for allocating</span>
<span class="cm"> * hash table, use SLAB cache for buffer heads. SMP threading.  -DaveM</span>
<span class="cm"> *</span>
<span class="cm"> * Added 32k buffer block sizes - these are required older ARM systems. - RMK</span>
<span class="cm"> *</span>
<span class="cm"> * async buffer flushing, 1999 Andrea Arcangeli &lt;andrea@suse.de&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/quotaops.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/hash.h&gt;</span>
<span class="cp">#include &lt;linux/suspend.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/task_io_accounting_ops.h&gt;</span>
<span class="cp">#include &lt;linux/bio.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/mpage.h&gt;</span>
<span class="cp">#include &lt;linux/bit_spinlock.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">fsync_buffers_list</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>

<span class="cp">#define BH_ENTRY(list) list_entry((list), struct buffer_head, b_assoc_buffers)</span>

<span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">init_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="n">bh_end_io_t</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">handler</span><span class="p">;</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span> <span class="o">=</span> <span class="n">private</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">init_buffer</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sleep_on_buffer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">word</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">io_schedule</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__lock_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wait_on_bit_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">,</span> <span class="n">BH_Lock</span><span class="p">,</span> <span class="n">sleep_on_buffer</span><span class="p">,</span>
							<span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__lock_buffer</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">unlock_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit_unlock</span><span class="p">(</span><span class="n">BH_Lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">);</span>
	<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>
	<span class="n">wake_up_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">,</span> <span class="n">BH_Lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unlock_buffer</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Block until a buffer comes unlocked.  This doesn&#39;t stop it</span>
<span class="cm"> * from becoming locked again - you have to lock it yourself</span>
<span class="cm"> * if you want to preserve its state.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__wait_on_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wait_on_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">,</span> <span class="n">BH_Lock</span><span class="p">,</span> <span class="n">sleep_on_buffer</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__wait_on_buffer</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__clear_page_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ClearPagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">set_page_private</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">quiet_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BH_Quiet</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">printk_ratelimit</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">buffer_io_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Buffer I/O error on device %s, logical block %Lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">bdevname</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * End-of-IO handler helper function which does not touch the bh after</span>
<span class="cm"> * unlocking it.</span>
<span class="cm"> * Note: unlock_buffer() sort-of does touch the bh after unlocking it, but</span>
<span class="cm"> * a race there is benign: unlock_buffer() only use the bh&#39;s address for</span>
<span class="cm"> * hashing after unlocking the buffer, so it doesn&#39;t actually touch the bh</span>
<span class="cm"> * itself.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__end_buffer_read_notouch</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uptodate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* This happens, due to failed READA attempts. */</span>
		<span class="n">clear_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Default synchronous end-of-IO handler..  Just mark it up-to-date and</span>
<span class="cm"> * unlock the buffer. This is what ll_rw_block uses too.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">end_buffer_read_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__end_buffer_read_notouch</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">uptodate</span><span class="p">);</span>
	<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">end_buffer_read_sync</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">end_buffer_write_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uptodate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">quiet_error</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">buffer_io_error</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;lost page write due to &quot;</span>
					<span class="s">&quot;I/O error on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">bdevname</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">set_buffer_write_io_error</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">clear_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">end_buffer_write_sync</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Various filesystems appear to want __find_get_block to be non-blocking.</span>
<span class="cm"> * But it&#39;s the page lock which protects the buffers.  To get around this,</span>
<span class="cm"> * we get exclusion from try_to_free_buffers with the blockdev mapping&#39;s</span>
<span class="cm"> * private_lock.</span>
<span class="cm"> *</span>
<span class="cm"> * Hack idea: for the blockdev mapping, i_bufferlist_lock contention</span>
<span class="cm"> * may be quite high.  This code could TryLock the page, and if that</span>
<span class="cm"> * succeeds, there is no need to take private_lock. (But if</span>
<span class="cm"> * private_lock is contended then so is mapping-&gt;tree_lock).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span>
<span class="nf">__find_get_block_slow</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">bd_inode</span> <span class="o">=</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">bd_mapping</span> <span class="o">=</span> <span class="n">bd_inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">all_mapped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">bd_inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">);</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="n">bd_mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bd_mapping</span><span class="o">-&gt;</span><span class="n">private_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="n">all_mapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">==</span> <span class="n">block</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
			<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>

	<span class="cm">/* we might be here because some of the buffers on this page are</span>
<span class="cm">	 * not mapped.  This is due to various races between</span>
<span class="cm">	 * file io on the block device and getblk.  It gets dealt with</span>
<span class="cm">	 * elsewhere, don&#39;t buffer_error if we had some unmapped buffers</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">all_mapped</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>

		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;__find_get_block_slow() failed. &quot;</span>
			<span class="s">&quot;block=%llu, b_blocknr=%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;b_state=0x%08lx, b_size=%zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;device %s blocksize: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bdevname</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
			<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bd_inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bd_mapping</span><span class="o">-&gt;</span><span class="n">private_lock</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Kick the writeback threads then try to free up some ZONE_NORMAL memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_more_memory</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

	<span class="n">wakeup_flusher_threads</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="n">WB_REASON_FREE_MORE_MEM</span><span class="p">);</span>
	<span class="n">yield</span><span class="p">();</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">first_zones_zonelist</span><span class="p">(</span><span class="n">node_zonelist</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">),</span>
						<span class="n">gfp_zone</span><span class="p">(</span><span class="n">GFP_NOFS</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">zone</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zone</span><span class="p">)</span>
			<span class="n">try_to_free_pages</span><span class="p">(</span><span class="n">node_zonelist</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
						<span class="n">GFP_NOFS</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * I/O completion handler for block_read_full_page() - pages</span>
<span class="cm"> * which come unlocked at the end of I/O.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">end_buffer_async_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">page_uptodate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_async_read</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uptodate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">clear_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">quiet_error</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="n">buffer_io_error</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">SetPageError</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Be _very_ careful from here on. Bad things can happen if</span>
<span class="cm">	 * two buffer heads end IO at almost the same time and both</span>
<span class="cm">	 * decide that the page is now completely done.</span>
<span class="cm">	 */</span>
	<span class="n">first</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">bit_spin_lock</span><span class="p">(</span><span class="n">BH_Uptodate_Lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">);</span>
	<span class="n">clear_buffer_async_read</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
			<span class="n">page_uptodate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_async_read</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">still_busy</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">bh</span><span class="p">);</span>
	<span class="n">bit_spin_unlock</span><span class="p">(</span><span class="n">BH_Uptodate_Lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If none of the buffers had errors and they are all</span>
<span class="cm">	 * uptodate then we can set the page uptodate.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_uptodate</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageError</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">still_busy:</span>
	<span class="n">bit_spin_unlock</span><span class="p">(</span><span class="n">BH_Uptodate_Lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Completion handler for block_write_full_page() - pages which are unlocked</span>
<span class="cm"> * during I/O, and which have PageWriteback cleared upon I/O completion.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">end_buffer_async_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">first</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_async_write</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uptodate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">quiet_error</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">buffer_io_error</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;lost page write due to &quot;</span>
					<span class="s">&quot;I/O error on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">bdevname</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">AS_EIO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">set_buffer_write_io_error</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">clear_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">SetPageError</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">first</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">bit_spin_lock</span><span class="p">(</span><span class="n">BH_Uptodate_Lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">);</span>

	<span class="n">clear_buffer_async_write</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_async_write</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">still_busy</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bit_spin_unlock</span><span class="p">(</span><span class="n">BH_Uptodate_Lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">end_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">still_busy:</span>
	<span class="n">bit_spin_unlock</span><span class="p">(</span><span class="n">BH_Uptodate_Lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">end_buffer_async_write</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * If a page&#39;s buffers are under async readin (end_buffer_async_read</span>
<span class="cm"> * completion) then there is a possibility that another thread of</span>
<span class="cm"> * control could lock one of the buffers after it has completed</span>
<span class="cm"> * but while some of the other buffers have not completed.  This</span>
<span class="cm"> * locked buffer would confuse end_buffer_async_read() into not unlocking</span>
<span class="cm"> * the page.  So the absence of BH_Async_Read tells end_buffer_async_read()</span>
<span class="cm"> * that this buffer is not under async I/O.</span>
<span class="cm"> *</span>
<span class="cm"> * The page comes unlocked when it has no locked buffer_async buffers</span>
<span class="cm"> * left.</span>
<span class="cm"> *</span>
<span class="cm"> * PageLocked prevents anyone starting new async I/O reads any of</span>
<span class="cm"> * the buffers.</span>
<span class="cm"> *</span>
<span class="cm"> * PageWriteback is used to prevent simultaneous writeout of the same</span>
<span class="cm"> * page.</span>
<span class="cm"> *</span>
<span class="cm"> * PageLocked prevents anyone from starting writeback of a page which is</span>
<span class="cm"> * under read I/O (PageWriteback is only ever set against a locked page).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mark_buffer_async_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">end_buffer_async_read</span><span class="p">;</span>
	<span class="n">set_buffer_async_read</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mark_buffer_async_write_endio</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
					  <span class="n">bh_end_io_t</span> <span class="o">*</span><span class="n">handler</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">handler</span><span class="p">;</span>
	<span class="n">set_buffer_async_write</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mark_buffer_async_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mark_buffer_async_write_endio</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">end_buffer_async_write</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mark_buffer_async_write</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * fs/buffer.c contains helper functions for buffer-backed address space&#39;s</span>
<span class="cm"> * fsync functions.  A common requirement for buffer-based filesystems is</span>
<span class="cm"> * that certain data from the backing blockdev needs to be written out for</span>
<span class="cm"> * a successful fsync().  For example, ext2 indirect blocks need to be</span>
<span class="cm"> * written back and waited upon before fsync() returns.</span>
<span class="cm"> *</span>
<span class="cm"> * The functions mark_buffer_inode_dirty(), fsync_inode_buffers(),</span>
<span class="cm"> * inode_has_buffers() and invalidate_inode_buffers() are provided for the</span>
<span class="cm"> * management of a list of dependent buffers at -&gt;i_mapping-&gt;private_list.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking is a little subtle: try_to_free_buffers() will remove buffers</span>
<span class="cm"> * from their controlling inode&#39;s queue when they are being freed.  But</span>
<span class="cm"> * try_to_free_buffers() will be operating against the *blockdev* mapping</span>
<span class="cm"> * at the time, not against the S_ISREG file which depends on those buffers.</span>
<span class="cm"> * So the locking for private_list is via the private_lock in the address_space</span>
<span class="cm"> * which backs the buffers.  Which is different from the address_space </span>
<span class="cm"> * against which the buffers are listed.  So for a particular address_space,</span>
<span class="cm"> * mapping-&gt;private_lock does *not* protect mapping-&gt;private_list!  In fact,</span>
<span class="cm"> * mapping-&gt;private_list will always be protected by the backing blockdev&#39;s</span>
<span class="cm"> * -&gt;private_lock.</span>
<span class="cm"> *</span>
<span class="cm"> * Which introduces a requirement: all buffers on an address_space&#39;s</span>
<span class="cm"> * -&gt;private_list must be from the same address_space: the blockdev&#39;s.</span>
<span class="cm"> *</span>
<span class="cm"> * address_spaces which do not place buffers at -&gt;private_list via these</span>
<span class="cm"> * utility functions are free to use private_lock and private_list for</span>
<span class="cm"> * whatever they want.  The only requirement is that list_empty(private_list)</span>
<span class="cm"> * be true at clear_inode() time.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: clear_inode should not call invalidate_inode_buffers().  The</span>
<span class="cm"> * filesystems should do that.  invalidate_inode_buffers() should just go</span>
<span class="cm"> * BUG_ON(!list_empty).</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: mark_buffer_dirty_inode() is a data-plane operation.  It should</span>
<span class="cm"> * take an address_space, not an inode.  And it should be called</span>
<span class="cm"> * mark_buffer_dirty_fsync() to clearly define why those buffers are being</span>
<span class="cm"> * queued up.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: mark_buffer_dirty_inode() doesn&#39;t need to add the buffer to the</span>
<span class="cm"> * list if it is already on a list.  Because if the buffer is on a list,</span>
<span class="cm"> * it *must* already be on the right one.  If not, the filesystem is being</span>
<span class="cm"> * silly.  This will save a ton of locking.  But first we have to ensure</span>
<span class="cm"> * that buffers are taken *off* the old inode&#39;s list when they are freed</span>
<span class="cm"> * (presumably in truncate).  That requires careful auditing of all</span>
<span class="cm"> * filesystems (do it inside bforget()).  It could also be done by bringing</span>
<span class="cm"> * b_inode back.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The buffer&#39;s backing address_space&#39;s private_lock must be held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__remove_assoc_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_buffers</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_map</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_write_io_error</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">AS_EIO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_map</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_map</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">inode_has_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">.</span><span class="n">private_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * osync is designed to support O_SYNC io.  It waits synchronously for</span>
<span class="cm"> * all already-submitted IO to complete, but does not queue any new</span>
<span class="cm"> * writes to the disk.</span>
<span class="cm"> *</span>
<span class="cm"> * To do O_SYNC writes, just queue the buffer writes with ll_rw_block as</span>
<span class="cm"> * you dirty the buffers, and then use osync_inode_buffers to wait for</span>
<span class="cm"> * completion.  Any other dirty buffers which are not yet queued for</span>
<span class="cm"> * write will not be flushed to disk by the osync.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">osync_buffers_list</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">repeat:</span>
	<span class="n">list_for_each_prev</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">BH_ENTRY</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_thaw_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">thaw_bdev</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">,</span> <span class="n">sb</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Emergency Thaw on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">bdevname</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_thaw_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iterate_supers</span><span class="p">(</span><span class="n">do_thaw_one</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Emergency Thaw complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * emergency_thaw_all -- forcibly thaw every frozen filesystem</span>
<span class="cm"> *</span>
<span class="cm"> * Used for emergency unfreeze of all filesystems via SysRq</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">emergency_thaw_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">;</span>

	<span class="n">work</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">work</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">work</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">do_thaw_all</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sync_mapping_buffers - write out &amp; wait upon a mapping&#39;s &quot;associated&quot; buffers</span>
<span class="cm"> * @mapping: the mapping which wants those buffers written</span>
<span class="cm"> *</span>
<span class="cm"> * Starts I/O against the buffers at mapping-&gt;private_list, and waits upon</span>
<span class="cm"> * that I/O.</span>
<span class="cm"> *</span>
<span class="cm"> * Basically, this is a convenience function for fsync().</span>
<span class="cm"> * @mapping is a file or directory which needs those buffers to be written for</span>
<span class="cm"> * a successful fsync().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sync_mapping_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">buffer_mapping</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">assoc_mapping</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_mapping</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">private_list</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">fsync_buffers_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer_mapping</span><span class="o">-&gt;</span><span class="n">private_lock</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">private_list</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sync_mapping_buffers</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Called when we&#39;ve recently written block `bblock&#39;, and it is known that</span>
<span class="cm"> * `bblock&#39; was for a buffer_boundary() buffer.  This means that the block at</span>
<span class="cm"> * `bblock + 1&#39; is probably a dirty indirect block.  Hunt it down and, if it&#39;s</span>
<span class="cm"> * dirty, schedule it for IO.  So that indirects merge nicely with their data.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">write_boundary_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
			<span class="n">sector_t</span> <span class="n">bblock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">blocksize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">__find_get_block</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">bblock</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="n">ll_rw_block</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mark_buffer_dirty_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">buffer_mapping</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>

	<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">assoc_mapping</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">assoc_mapping</span> <span class="o">=</span> <span class="n">buffer_mapping</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">assoc_mapping</span> <span class="o">!=</span> <span class="n">buffer_mapping</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_map</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer_mapping</span><span class="o">-&gt;</span><span class="n">private_lock</span><span class="p">);</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_buffers</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">private_list</span><span class="p">);</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_map</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer_mapping</span><span class="o">-&gt;</span><span class="n">private_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mark_buffer_dirty_inode</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Mark the page dirty, and set it dirty in the radix tree, and mark the inode</span>
<span class="cm"> * dirty.</span>
<span class="cm"> *</span>
<span class="cm"> * If warn is true, then emit a warning if the page is not uptodate and has</span>
<span class="cm"> * not been truncated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__set_page_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="kt">int</span> <span class="n">warn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Race with truncate? */</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">warn</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="n">account_page_dirtied</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mapping</span><span class="p">);</span>
		<span class="n">radix_tree_tag_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">page_tree</span><span class="p">,</span>
				<span class="n">page_index</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="n">PAGECACHE_TAG_DIRTY</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
	<span class="n">__mark_inode_dirty</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">I_DIRTY_PAGES</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add a page to the dirty page list.</span>
<span class="cm"> *</span>
<span class="cm"> * It is a sad fact of life that this function is called from several places</span>
<span class="cm"> * deeply under spinlocking.  It may not sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * If the page has buffers, the uptodate buffers are set dirty, to preserve</span>
<span class="cm"> * dirty-state coherency between the page and the buffers.  It the page does</span>
<span class="cm"> * not have buffers then when they are later attached they will all be set</span>
<span class="cm"> * dirty.</span>
<span class="cm"> *</span>
<span class="cm"> * The buffers are dirtied before the page is dirtied.  There&#39;s a small race</span>
<span class="cm"> * window in which a writepage caller may see the page cleanness but not the</span>
<span class="cm"> * buffer dirtiness.  That&#39;s fine.  If this code were to set the page dirty</span>
<span class="cm"> * before the buffers, a concurrent writepage caller could clear the page dirty</span>
<span class="cm"> * bit, see a bunch of clean buffers and we&#39;d end up with dirty buffers/clean</span>
<span class="cm"> * page on the dirty page list.</span>
<span class="cm"> *</span>
<span class="cm"> * We use private_lock to lock against try_to_free_buffers while using the</span>
<span class="cm"> * page&#39;s buffer list.  Also use this to protect against clean buffers being</span>
<span class="cm"> * added to the page after it was set dirty.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: may need to call -&gt;reservepage here as well.  That&#39;s rather up to the</span>
<span class="cm"> * address_space though.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__set_page_dirty_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">newly_dirty</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">mapping</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">!</span><span class="n">TestSetPageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">private_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">set_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">newly_dirty</span> <span class="o">=</span> <span class="o">!</span><span class="n">TestSetPageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">private_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">newly_dirty</span><span class="p">)</span>
		<span class="n">__set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">newly_dirty</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__set_page_dirty_buffers</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Write out and wait upon a list of buffers.</span>
<span class="cm"> *</span>
<span class="cm"> * We have conflicting pressures: we want to make sure that all</span>
<span class="cm"> * initially dirty buffers get waited on, but that any subsequently</span>
<span class="cm"> * dirtied buffers don&#39;t.  After all, we don&#39;t want fsync to last</span>
<span class="cm"> * forever if somebody is actively writing to the file.</span>
<span class="cm"> *</span>
<span class="cm"> * Do this in two main stages: first we copy dirty buffers to a</span>
<span class="cm"> * temporary inode list, queueing the writes as we go.  Then we clean</span>
<span class="cm"> * up, waiting for those writes to complete.</span>
<span class="cm"> * </span>
<span class="cm"> * During this second stage, any subsequent updates to the file may end</span>
<span class="cm"> * up refiling the buffer on the original inode&#39;s dirty list again, so</span>
<span class="cm"> * there is a chance we will end up with a buffer queued for write but</span>
<span class="cm"> * not yet completed on that list.  So, as a final cleanup we go through</span>
<span class="cm"> * the osync code to catch these locked, dirty buffers without requeuing</span>
<span class="cm"> * any newly dirty buffers for write.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsync_buffers_list</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blk_plug</span> <span class="n">plug</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
	<span class="n">blk_start_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">BH_ENTRY</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
		<span class="n">mapping</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_map</span><span class="p">;</span>
		<span class="n">__remove_assoc_queue</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="cm">/* Avoid race with mark_buffer_dirty_inode() which does</span>
<span class="cm">		 * a lockless check and we rely on seeing the dirty bit */</span>
		<span class="n">smp_mb</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">||</span> <span class="n">buffer_locked</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_buffers</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_map</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * Ensure any pending I/O completes so that</span>
<span class="cm">				 * write_dirty_buffer() actually writes the</span>
<span class="cm">				 * current contents - it is a noop if I/O is</span>
<span class="cm">				 * still in flight on potentially older</span>
<span class="cm">				 * contents.</span>
<span class="cm">				 */</span>
				<span class="n">write_dirty_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">WRITE_SYNC</span><span class="p">);</span>

				<span class="cm">/*</span>
<span class="cm">				 * Kick off IO for the previous mapping. Note</span>
<span class="cm">				 * that we will not run the very last mapping,</span>
<span class="cm">				 * wait_on_buffer() will do that for us</span>
<span class="cm">				 * through sync_buffer().</span>
<span class="cm">				 */</span>
				<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">blk_finish_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">BH_ENTRY</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">prev</span><span class="p">);</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">mapping</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_map</span><span class="p">;</span>
		<span class="n">__remove_assoc_queue</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="cm">/* Avoid race with mark_buffer_dirty_inode() which does</span>
<span class="cm">		 * a lockless check and we rely on seeing the dirty bit */</span>
		<span class="n">smp_mb</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_buffers</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">private_list</span><span class="p">);</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_map</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">err2</span> <span class="o">=</span> <span class="n">osync_buffers_list</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">err2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Invalidate any and all dirty buffers on a given inode.  We are</span>
<span class="cm"> * probably unmounting the fs, but that doesn&#39;t mean we have already</span>
<span class="cm"> * done a sync().  Just drop the buffers from the inode list.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: we take the inode&#39;s blockdev&#39;s mapping&#39;s private_lock.  Which</span>
<span class="cm"> * assumes that all the buffers are against the blockdev.  Not true</span>
<span class="cm"> * for reiserfs.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">invalidate_inode_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode_has_buffers</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">private_list</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">buffer_mapping</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">assoc_mapping</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer_mapping</span><span class="o">-&gt;</span><span class="n">private_lock</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">list</span><span class="p">))</span>
			<span class="n">__remove_assoc_queue</span><span class="p">(</span><span class="n">BH_ENTRY</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer_mapping</span><span class="o">-&gt;</span><span class="n">private_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">invalidate_inode_buffers</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Remove any clean buffers from the inode&#39;s buffer list.  This is called</span>
<span class="cm"> * when we&#39;re trying to free the inode itself.  Those buffers can pin it.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if all buffers were removed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">remove_inode_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode_has_buffers</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">private_list</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">buffer_mapping</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">assoc_mapping</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer_mapping</span><span class="o">-&gt;</span><span class="n">private_lock</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">BH_ENTRY</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">__remove_assoc_queue</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer_mapping</span><span class="o">-&gt;</span><span class="n">private_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create the appropriate buffers when given a page for data area and</span>
<span class="cm"> * the size of each buffer.. Use the bh-&gt;b_this_page linked list to</span>
<span class="cm"> * follow the buffers created.  Return NULL if unable to create more</span>
<span class="cm"> * buffers.</span>
<span class="cm"> *</span>
<span class="cm"> * The retry flag is used to differentiate async IO (paging, swapping)</span>
<span class="cm"> * which may not fail from ordinary buffer allocations.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="nf">alloc_page_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">retry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>

<span class="nl">try_again:</span>
	<span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">offset</span> <span class="o">-=</span> <span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">alloc_buffer_head</span><span class="p">(</span><span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">no_grow</span><span class="p">;</span>

		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">head</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>

		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

		<span class="cm">/* Link the buffer to its page */</span>
		<span class="n">set_bh_page</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

		<span class="n">init_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * In case anything failed, we just free everything we got.</span>
<span class="cm"> */</span>
<span class="nl">no_grow:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
			<span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
			<span class="n">free_buffer_head</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">head</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Return failure for non-async IO requests.  Async IO requests</span>
<span class="cm">	 * are not allowed to fail, so we have to wait until buffer heads</span>
<span class="cm">	 * become available.  But we don&#39;t want tasks sleeping with </span>
<span class="cm">	 * partially complete buffers, so all were released above.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retry</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* We&#39;re _really_ low on memory. Now we just</span>
<span class="cm">	 * wait for old buffer heads to become free due to</span>
<span class="cm">	 * finishing IO.  Since this is an async request and</span>
<span class="cm">	 * the reserve list is empty, we&#39;re sure there are </span>
<span class="cm">	 * async buffer heads in use.</span>
<span class="cm">	 */</span>
	<span class="n">free_more_memory</span><span class="p">();</span>
	<span class="k">goto</span> <span class="n">try_again</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">alloc_page_buffers</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">link_dev_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">tail</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">tail</span><span class="o">-&gt;</span><span class="n">b_this_page</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">attach_page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialise the state of a blockdev page&#39;s buffers.</span>
<span class="cm"> */</span> 
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">init_page_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
			<span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">uptodate</span> <span class="o">=</span> <span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">sector_t</span> <span class="n">end_block</span> <span class="o">=</span> <span class="n">blkdev_max_block</span><span class="p">(</span><span class="n">I_BDEV</span><span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_inode</span><span class="p">));</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">init_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span> <span class="o">=</span> <span class="n">bdev</span><span class="p">;</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">uptodate</span><span class="p">)</span>
				<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&lt;</span> <span class="n">end_block</span><span class="p">)</span>
				<span class="n">set_buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">block</span><span class="o">++</span><span class="p">;</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create the page-cache page that contains the requested block.</span>
<span class="cm"> *</span>
<span class="cm"> * This is user purely for blockdev mappings.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span>
<span class="nf">grow_dev_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span>
		<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">find_or_create_page</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
		<span class="p">(</span><span class="n">mapping_gfp_mask</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">__GFP_FS</span><span class="p">)</span><span class="o">|</span><span class="n">__GFP_MOVABLE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">==</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">init_page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">bdev</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_to_free_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate some buffers for this page</span>
<span class="cm">	 */</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">alloc_page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Link the page to the buffers and initialise them.  Take the</span>
<span class="cm">	 * lock to be atomic wrt __find_get_block(), which does not</span>
<span class="cm">	 * run under the page lock.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">private_lock</span><span class="p">);</span>
	<span class="n">link_dev_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="n">init_page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">bdev</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">private_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>

<span class="nl">failed:</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create buffers for the specified block device block&#39;s page.  If</span>
<span class="cm"> * that page was dirty, the buffers are set dirty also.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">grow_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sizebits</span><span class="p">;</span>

	<span class="n">sizebits</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">sizebits</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">size</span> <span class="o">&lt;&lt;</span> <span class="n">sizebits</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="n">sizebits</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for a block which wants to lie outside our maximum possible</span>
<span class="cm">	 * pagecache index.  (this comparison is done using sector_t types).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">index</span> <span class="o">!=</span> <span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="n">sizebits</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: requested out-of-range block %llu for &quot;</span>
			<span class="s">&quot;device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block</span><span class="p">,</span>
			<span class="n">bdevname</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">sizebits</span><span class="p">;</span>
	<span class="cm">/* Create a page with the proper size buffers.. */</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">grow_dev_page</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span>
<span class="nf">__getblk_slow</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Size must be multiple of hard sectorsize */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">bdev_logical_block_size</span><span class="p">(</span><span class="n">bdev</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">512</span> <span class="o">||</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;getblk(): invalid block size %d requested</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">size</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;logical block size: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">bdev_logical_block_size</span><span class="p">(</span><span class="n">bdev</span><span class="p">));</span>

		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">bh</span> <span class="o">=</span> <span class="n">__find_get_block</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">grow_buffers</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">free_more_memory</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The relationship between dirty buffers and dirty pages:</span>
<span class="cm"> *</span>
<span class="cm"> * Whenever a page has any dirty buffers, the page&#39;s dirty bit is set, and</span>
<span class="cm"> * the page is tagged dirty in its radix tree.</span>
<span class="cm"> *</span>
<span class="cm"> * At all times, the dirtiness of the buffers represents the dirtiness of</span>
<span class="cm"> * subsections of the page.  If the page has buffers, the page dirty bit is</span>
<span class="cm"> * merely a hint about the true dirty state.</span>
<span class="cm"> *</span>
<span class="cm"> * When a page is set dirty in its entirety, all its buffers are marked dirty</span>
<span class="cm"> * (if the page has buffers).</span>
<span class="cm"> *</span>
<span class="cm"> * When a buffer is marked dirty, its page is dirtied, but the page&#39;s other</span>
<span class="cm"> * buffers are not.</span>
<span class="cm"> *</span>
<span class="cm"> * Also.  When blockdev buffers are explicitly read with bread(), they</span>
<span class="cm"> * individually become uptodate.  But their backing page remains not</span>
<span class="cm"> * uptodate - even if all of its buffers are uptodate.  A subsequent</span>
<span class="cm"> * block_read_full_page() against that page will discover all the uptodate</span>
<span class="cm"> * buffers, will set the page uptodate and will perform no I/O.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * mark_buffer_dirty - mark a buffer_head as needing writeout</span>
<span class="cm"> * @bh: the buffer_head to mark dirty</span>
<span class="cm"> *</span>
<span class="cm"> * mark_buffer_dirty() will set the dirty bit against the buffer, then set its</span>
<span class="cm"> * backing page dirty, then tag the page as dirty in its address_space&#39;s radix</span>
<span class="cm"> * tree and then attach the address_space&#39;s inode to its superblock&#39;s dirty</span>
<span class="cm"> * inode list.</span>
<span class="cm"> *</span>
<span class="cm"> * mark_buffer_dirty() is atomic.  It takes bh-&gt;b_page-&gt;mapping-&gt;private_lock,</span>
<span class="cm"> * mapping-&gt;tree_lock and mapping-&gt;host-&gt;i_lock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">mark_buffer_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Very *carefully* optimize the it-is-already-dirty case.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Don&#39;t let the final &quot;is it dirty&quot; escape to before we</span>
<span class="cm">	 * perhaps modified the buffer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">smp_mb</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_set_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TestSetPageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="p">)</span>
				<span class="n">__set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mark_buffer_dirty</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Decrement a buffer_head&#39;s reference count.  If all buffers against a page</span>
<span class="cm"> * have zero reference count, are clean and unlocked, and if the page is clean</span>
<span class="cm"> * and unlocked then try_to_free_buffers() may strip the buffers from the page</span>
<span class="cm"> * in preparation for freeing it (sometimes, rarely, buffers are removed from</span>
<span class="cm"> * a page but it ends up not being freed, and buffers may later be reattached).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__brelse</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">b_count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">put_bh</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">KERN_ERR</span> <span class="s">&quot;VFS: brelse: Trying to free free buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__brelse</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * bforget() is like brelse(), except it discards any</span>
<span class="cm"> * potentially dirty data.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__bforget</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_map</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">buffer_mapping</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer_mapping</span><span class="o">-&gt;</span><span class="n">private_lock</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_buffers</span><span class="p">);</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_map</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer_mapping</span><span class="o">-&gt;</span><span class="n">private_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">__brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__bforget</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="nf">__bread_slow</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">end_buffer_read_sync</span><span class="p">;</span>
		<span class="n">submit_bh</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Per-cpu buffer LRU implementation.  To reduce the cost of __find_get_block().</span>
<span class="cm"> * The bhs[] array is sorted - newest buffer is at bhs[0].  Buffers have their</span>
<span class="cm"> * refcount elevated by one when they&#39;re in an LRU.  A buffer can only appear</span>
<span class="cm"> * once in a particular CPU&#39;s LRU.  A single buffer can be present in multiple</span>
<span class="cm"> * CPU&#39;s LRUs at the same time.</span>
<span class="cm"> *</span>
<span class="cm"> * This is a transparent caching front-end to sb_bread(), sb_getblk() and</span>
<span class="cm"> * sb_find_get_block().</span>
<span class="cm"> *</span>
<span class="cm"> * The LRUs themselves only need locking against invalidate_bh_lrus.  We use</span>
<span class="cm"> * a local interrupt disable for that.</span>
<span class="cm"> */</span>

<span class="cp">#define BH_LRU_SIZE	8</span>

<span class="k">struct</span> <span class="n">bh_lru</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bhs</span><span class="p">[</span><span class="n">BH_LRU_SIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">bh_lru</span><span class="p">,</span> <span class="n">bh_lrus</span><span class="p">)</span> <span class="o">=</span> <span class="p">{{</span> <span class="nb">NULL</span> <span class="p">}};</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cp">#define bh_lru_lock()	local_irq_disable()</span>
<span class="cp">#define bh_lru_unlock()	local_irq_enable()</span>
<span class="cp">#else</span>
<span class="cp">#define bh_lru_lock()	preempt_disable()</span>
<span class="cp">#define bh_lru_unlock()	preempt_enable()</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">check_irqs_on</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef irqs_disabled</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">irqs_disabled</span><span class="p">());</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The LRU management algorithm is dopey-but-simple.  Sorry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bh_lru_install</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">evictee</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">check_irqs_on</span><span class="p">();</span>
	<span class="n">bh_lru_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">bh_lrus</span><span class="p">.</span><span class="n">bhs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bhs</span><span class="p">[</span><span class="n">BH_LRU_SIZE</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">in</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">bhs</span><span class="p">[</span><span class="n">out</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">in</span> <span class="o">&lt;</span> <span class="n">BH_LRU_SIZE</span><span class="p">;</span> <span class="n">in</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh2</span> <span class="o">=</span>
				<span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">bh_lrus</span><span class="p">.</span><span class="n">bhs</span><span class="p">[</span><span class="n">in</span><span class="p">]);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bh2</span> <span class="o">==</span> <span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">__brelse</span><span class="p">(</span><span class="n">bh2</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">out</span> <span class="o">&gt;=</span> <span class="n">BH_LRU_SIZE</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">BUG_ON</span><span class="p">(</span><span class="n">evictee</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
					<span class="n">evictee</span> <span class="o">=</span> <span class="n">bh2</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">bhs</span><span class="p">[</span><span class="n">out</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh2</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">out</span> <span class="o">&lt;</span> <span class="n">BH_LRU_SIZE</span><span class="p">)</span>
			<span class="n">bhs</span><span class="p">[</span><span class="n">out</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">__this_cpu_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh_lrus</span><span class="p">.</span><span class="n">bhs</span><span class="p">),</span> <span class="n">bhs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bhs</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">bh_lru_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">evictee</span><span class="p">)</span>
		<span class="n">__brelse</span><span class="p">(</span><span class="n">evictee</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look up the bh in this cpu&#39;s LRU.  If it&#39;s there, move it to the head.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span>
<span class="nf">lookup_bh_lru</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">check_irqs_on</span><span class="p">();</span>
	<span class="n">bh_lru_lock</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BH_LRU_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">bh_lrus</span><span class="p">.</span><span class="n">bhs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span> <span class="o">&amp;&amp;</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span> <span class="o">==</span> <span class="n">bdev</span> <span class="o">&amp;&amp;</span>
				<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">==</span> <span class="n">block</span> <span class="o">&amp;&amp;</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">==</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">bh_lrus</span><span class="p">.</span><span class="n">bhs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						<span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">bh_lrus</span><span class="p">.</span><span class="n">bhs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span>
					<span class="n">i</span><span class="o">--</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">bh_lrus</span><span class="p">.</span><span class="n">bhs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bh</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">bh_lru_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Perform a pagecache lookup for the matching buffer.  If it&#39;s there, refresh</span>
<span class="cm"> * it in the LRU and mark it as accessed.  If it is not present then return</span>
<span class="cm"> * NULL</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span>
<span class="nf">__find_get_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">lookup_bh_lru</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">__find_get_block_slow</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span>
			<span class="n">bh_lru_install</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span>
		<span class="n">touch_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__find_get_block</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * __getblk will locate (and, if necessary, create) the buffer_head</span>
<span class="cm"> * which corresponds to the passed block_device, block and size. The</span>
<span class="cm"> * returned buffer has its reference count incremented.</span>
<span class="cm"> *</span>
<span class="cm"> * __getblk() cannot fail - it just keeps trying.  If you pass it an</span>
<span class="cm"> * illegal block number, __getblk() will happily return a buffer_head</span>
<span class="cm"> * which represents the non-existent block.  Very weird.</span>
<span class="cm"> *</span>
<span class="cm"> * __getblk() will lock up the machine if grow_dev_page&#39;s try_to_free_buffers()</span>
<span class="cm"> * attempt is failing.  FIXME, perhaps?</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span>
<span class="nf">__getblk</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">__find_get_block</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">__getblk_slow</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__getblk</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Do async read-ahead on a buffer..</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__breadahead</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">__getblk</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ll_rw_block</span><span class="p">(</span><span class="n">READA</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__breadahead</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *  __bread() - reads a specified block and returns the bh</span>
<span class="cm"> *  @bdev: the block_device to read from</span>
<span class="cm"> *  @block: number of block</span>
<span class="cm"> *  @size: size (in bytes) to read</span>
<span class="cm"> * </span>
<span class="cm"> *  Reads a specified block, and returns buffer head that contains it.</span>
<span class="cm"> *  It returns NULL if the block was unreadable.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span>
<span class="nf">__bread</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">__getblk</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">__bread_slow</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__bread</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * invalidate_bh_lrus() is called rarely - but not only at unmount.</span>
<span class="cm"> * This doesn&#39;t race because it runs in each cpu either in irq</span>
<span class="cm"> * or with preempt disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">invalidate_bh_lru</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bh_lru</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">get_cpu_var</span><span class="p">(</span><span class="n">bh_lrus</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BH_LRU_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bhs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">bhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">put_cpu_var</span><span class="p">(</span><span class="n">bh_lrus</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">has_bh_in_lru</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bh_lru</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh_lrus</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BH_LRU_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bhs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">invalidate_bh_lrus</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">on_each_cpu_cond</span><span class="p">(</span><span class="n">has_bh_in_lru</span><span class="p">,</span> <span class="n">invalidate_bh_lru</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">invalidate_bh_lrus</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">set_bh_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="cm">/*</span>
<span class="cm">		 * This catches illegal uses and preserves the offset:</span>
<span class="cm">		 */</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="mi">0</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_bh_page</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Called when truncating a buffer on a page completely.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">discard_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">clear_buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">clear_buffer_req</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">clear_buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">clear_buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">clear_buffer_unwritten</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * block_invalidatepage - invalidate part or all of a buffer-backed page</span>
<span class="cm"> *</span>
<span class="cm"> * @page: the page which is affected</span>
<span class="cm"> * @offset: the index of the truncation point</span>
<span class="cm"> *</span>
<span class="cm"> * block_invalidatepage() is called when all or part of the page has become</span>
<span class="cm"> * invalidated by a truncate operation.</span>
<span class="cm"> *</span>
<span class="cm"> * block_invalidatepage() does not have to release all buffers, but it must</span>
<span class="cm"> * ensure that no dirty buffer is left outside @offset and that no I/O</span>
<span class="cm"> * is underway against any of the blocks which are outside the truncation</span>
<span class="cm"> * point.  Because the caller is about to free (and possibly reuse) those</span>
<span class="cm"> * blocks on-disk.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">block_invalidatepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">curr_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">next_off</span> <span class="o">=</span> <span class="n">curr_off</span> <span class="o">+</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * is this block fully invalidated?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;=</span> <span class="n">curr_off</span><span class="p">)</span>
			<span class="n">discard_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">curr_off</span> <span class="o">=</span> <span class="n">next_off</span><span class="p">;</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We release buffers only if the entire page is being invalidated.</span>
<span class="cm">	 * The get_block cached value has been unconditionally invalidated,</span>
<span class="cm">	 * so real IO is not possible anymore.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">try_to_release_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">block_invalidatepage</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * We attach and possibly dirty the buffers atomically wrt</span>
<span class="cm"> * __set_page_dirty_buffers() via private_lock.  try_to_free_buffers</span>
<span class="cm"> * is already excluded via the page lock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">create_empty_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">blocksize</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">b_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>

	<span class="n">head</span> <span class="o">=</span> <span class="n">alloc_page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_state</span> <span class="o">|=</span> <span class="n">b_state</span><span class="p">;</span>
		<span class="n">tail</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">tail</span><span class="o">-&gt;</span><span class="n">b_this_page</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">private_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">set_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">attach_page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">private_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">create_empty_buffers</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * We are taking a block for data and we don&#39;t want any output from any</span>
<span class="cm"> * buffer-cache aliases starting from return from that function and</span>
<span class="cm"> * until the moment when something will explicitly mark the buffer</span>
<span class="cm"> * dirty (hopefully that will not happen until we will free that block ;-)</span>
<span class="cm"> * We don&#39;t even need to mark it not-uptodate - nobody can expect</span>
<span class="cm"> * anything from a newly allocated buffer anyway. We used to used</span>
<span class="cm"> * unmap_buffer() for such invalidation, but that was wrong. We definitely</span>
<span class="cm"> * don&#39;t want to mark the alias unmapped, for example - it would confuse</span>
<span class="cm"> * anyone who might pick it with bread() afterwards...</span>
<span class="cm"> *</span>
<span class="cm"> * Also..  Note that bforget() doesn&#39;t lock the buffer.  So there can</span>
<span class="cm"> * be writeout I/O going on against recently-freed buffers.  We don&#39;t</span>
<span class="cm"> * wait on that I/O in bforget() - it&#39;s more efficient to wait on the I/O</span>
<span class="cm"> * only if we really need to.  That happens here.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">unmap_underlying_metadata</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">old_bh</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="n">old_bh</span> <span class="o">=</span> <span class="n">__find_get_block_slow</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">old_bh</span><span class="p">);</span>
		<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">old_bh</span><span class="p">);</span>
		<span class="n">clear_buffer_req</span><span class="p">(</span><span class="n">old_bh</span><span class="p">);</span>
		<span class="n">__brelse</span><span class="p">(</span><span class="n">old_bh</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unmap_underlying_metadata</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE! All mapped/uptodate combinations are valid:</span>
<span class="cm"> *</span>
<span class="cm"> *	Mapped	Uptodate	Meaning</span>
<span class="cm"> *</span>
<span class="cm"> *	No	No		&quot;unknown&quot; - must do get_block()</span>
<span class="cm"> *	No	Yes		&quot;hole&quot; - zero-filled</span>
<span class="cm"> *	Yes	No		&quot;allocated&quot; - allocated on disk, not read in</span>
<span class="cm"> *	Yes	Yes		&quot;valid&quot; - allocated and up-to-date in memory.</span>
<span class="cm"> *</span>
<span class="cm"> * &quot;Dirty&quot; is valid only with the last case (mapped+uptodate).</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * While block_write_full_page is writing back the dirty buffers under</span>
<span class="cm"> * the page lock, whoever dirtied the buffers may decide to clean them</span>
<span class="cm"> * again at any time.  We handle that by only looking at the buffer</span>
<span class="cm"> * state inside lock_buffer().</span>
<span class="cm"> *</span>
<span class="cm"> * If block_write_full_page() is called for regular writeback</span>
<span class="cm"> * (wbc-&gt;sync_mode == WB_SYNC_NONE) then it will redirty a page which has a</span>
<span class="cm"> * locked buffer.   This only can happen if someone has written the buffer</span>
<span class="cm"> * directly, with submit_bh().  At the address_space level PageWriteback</span>
<span class="cm"> * prevents this contention from occurring.</span>
<span class="cm"> *</span>
<span class="cm"> * If block_write_full_page() is called with wbc-&gt;sync_mode ==</span>
<span class="cm"> * WB_SYNC_ALL, the writes are posted using WRITE_SYNC; this</span>
<span class="cm"> * causes the writes to be flagged as synchronous writes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__block_write_full_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			<span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">,</span>
			<span class="n">bh_end_io_t</span> <span class="o">*</span><span class="n">handler</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">block</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">last_block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_underway</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">write_op</span> <span class="o">=</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_ALL</span> <span class="o">?</span>
			<span class="n">WRITE_SYNC</span> <span class="o">:</span> <span class="n">WRITE</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="n">last_block</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">create_empty_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span>
					<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">BH_Dirty</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">BH_Uptodate</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Be very careful.  We have no exclusion from __set_page_dirty_buffers</span>
<span class="cm">	 * here, and the (potentially unmapped) buffers may become dirty at</span>
<span class="cm">	 * any time.  If a buffer becomes dirty here after we&#39;ve inspected it</span>
<span class="cm">	 * then we just miss that fact, and the page stays dirty.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Buffers outside i_size may be dirtied by __set_page_dirty_buffers;</span>
<span class="cm">	 * handle that here by just cleaning them.</span>
<span class="cm">	 */</span>

	<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="n">sector_t</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">);</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get all the dirty buffers mapped to disk addresses and</span>
<span class="cm">	 * handle any aliases from the underlying blockdev&#39;s mapping.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;</span> <span class="n">last_block</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * mapped buffers outside i_size will occur, because</span>
<span class="cm">			 * this page can be outside i_size when there is a</span>
<span class="cm">			 * truncate in progress.</span>
<span class="cm">			 */</span>
			<span class="cm">/*</span>
<span class="cm">			 * The buffer was zeroed by block_write_full_page()</span>
<span class="cm">			 */</span>
			<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">||</span> <span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			   <span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">!=</span> <span class="n">blocksize</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">get_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">recover</span><span class="p">;</span>
			<span class="n">clear_buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* blockdev mappings never come here */</span>
				<span class="n">clear_buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">unmap_underlying_metadata</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">,</span>
							<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
		<span class="n">block</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If it&#39;s a fully non-blocking write attempt and we cannot</span>
<span class="cm">		 * lock the buffer then redirty the page.  Note that this can</span>
<span class="cm">		 * potentially cause a busy-wait loop from writeback threads</span>
<span class="cm">		 * and kswapd activity, but those code paths have their own</span>
<span class="cm">		 * higher-level throttling.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">!=</span> <span class="n">WB_SYNC_NONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">redirty_page_for_writepage</span><span class="p">(</span><span class="n">wbc</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mark_buffer_async_write_endio</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The page and its buffers are protected by PageWriteback(), so we can</span>
<span class="cm">	 * drop the bh refcounts early.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">set_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_async_write</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">submit_bh</span><span class="p">(</span><span class="n">write_op</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
			<span class="n">nr_underway</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_underway</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The page was marked dirty, but the buffers were</span>
<span class="cm">		 * clean.  Someone wrote them back by hand with</span>
<span class="cm">		 * ll_rw_block/submit_bh.  A rare case.</span>
<span class="cm">		 */</span>
		<span class="n">end_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The page and buffer_heads can be released at any time from</span>
<span class="cm">		 * here on.</span>
<span class="cm">		 */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">recover:</span>
	<span class="cm">/*</span>
<span class="cm">	 * ENOSPC, or some other error.  We may already have added some</span>
<span class="cm">	 * blocks to the file, so we need to write these out to avoid</span>
<span class="cm">	 * exposing stale data.</span>
<span class="cm">	 * The page is currently locked and not marked for writeback</span>
<span class="cm">	 */</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="cm">/* Recovery: lock and submit the mapped buffers */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">mark_buffer_async_write_endio</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The buffer may have been set dirty during</span>
<span class="cm">			 * attachment to a dirty page.</span>
<span class="cm">			 */</span>
			<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
	<span class="n">SetPageError</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">mapping_set_error</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">set_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_async_write</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">submit_bh</span><span class="p">(</span><span class="n">write_op</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
			<span class="n">nr_underway</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If a page has any new buffers, zero them out here, and mark them uptodate</span>
<span class="cm"> * and dirty so they&#39;ll be written out (in order to prevent uninitialised</span>
<span class="cm"> * block data from leaking). And clear the new bit.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">page_zero_new_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_start</span><span class="p">,</span> <span class="n">block_end</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">block_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">block_end</span> <span class="o">=</span> <span class="n">block_start</span> <span class="o">+</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">block_end</span> <span class="o">&gt;</span> <span class="n">from</span> <span class="o">&amp;&amp;</span> <span class="n">block_start</span> <span class="o">&lt;</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
					<span class="kt">unsigned</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

					<span class="n">start</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">block_start</span><span class="p">);</span>
					<span class="n">size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">block_end</span><span class="p">)</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>

					<span class="n">zero_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
					<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="n">clear_buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">block_start</span> <span class="o">=</span> <span class="n">block_end</span><span class="p">;</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">page_zero_new_buffers</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">__block_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span>
		<span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">from</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">to</span> <span class="o">=</span> <span class="n">from</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">block_start</span><span class="p">,</span> <span class="n">block_end</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">block</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blocksize</span><span class="p">,</span> <span class="n">bbits</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">wait</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">**</span><span class="n">wait_bh</span><span class="o">=</span><span class="n">wait</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">from</span> <span class="o">&gt;</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">to</span> <span class="o">&gt;</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">from</span> <span class="o">&gt;</span> <span class="n">to</span><span class="p">);</span>

	<span class="n">blocksize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">create_empty_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">bbits</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="n">sector_t</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">bbits</span><span class="p">);</span>

	<span class="k">for</span><span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="n">block_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span> <span class="o">||</span> <span class="o">!</span><span class="n">block_start</span><span class="p">;</span>
	    <span class="n">block</span><span class="o">++</span><span class="p">,</span> <span class="n">block_start</span><span class="o">=</span><span class="n">block_end</span><span class="p">,</span> <span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block_end</span> <span class="o">=</span> <span class="n">block_start</span> <span class="o">+</span> <span class="n">blocksize</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block_end</span> <span class="o">&lt;=</span> <span class="n">from</span> <span class="o">||</span> <span class="n">block_start</span> <span class="o">&gt;=</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
					<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="n">clear_buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">!=</span> <span class="n">blocksize</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">get_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">unmap_underlying_metadata</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">,</span>
							<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">clear_buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
					<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
					<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">block_end</span> <span class="o">&gt;</span> <span class="n">to</span> <span class="o">||</span> <span class="n">block_start</span> <span class="o">&lt;</span> <span class="n">from</span><span class="p">)</span>
					<span class="n">zero_user_segments</span><span class="p">(</span><span class="n">page</span><span class="p">,</span>
						<span class="n">to</span><span class="p">,</span> <span class="n">block_end</span><span class="p">,</span>
						<span class="n">block_start</span><span class="p">,</span> <span class="n">from</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
				<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span> 
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">buffer_unwritten</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="p">(</span><span class="n">block_start</span> <span class="o">&lt;</span> <span class="n">from</span> <span class="o">||</span> <span class="n">block_end</span> <span class="o">&gt;</span> <span class="n">to</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ll_rw_block</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="p">);</span>
			<span class="o">*</span><span class="n">wait_bh</span><span class="o">++=</span><span class="n">bh</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we issued read requests - let them complete.</span>
<span class="cm">	 */</span>
	<span class="k">while</span><span class="p">(</span><span class="n">wait_bh</span> <span class="o">&gt;</span> <span class="n">wait</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wait_on_buffer</span><span class="p">(</span><span class="o">*--</span><span class="n">wait_bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="o">*</span><span class="n">wait_bh</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
		<span class="n">page_zero_new_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__block_write_begin</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__block_commit_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">block_start</span><span class="p">,</span> <span class="n">block_end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">partial</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

	<span class="n">blocksize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>

	<span class="k">for</span><span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="n">block_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	    <span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span> <span class="o">||</span> <span class="o">!</span><span class="n">block_start</span><span class="p">;</span>
	    <span class="n">block_start</span><span class="o">=</span><span class="n">block_end</span><span class="p">,</span> <span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block_end</span> <span class="o">=</span> <span class="n">block_start</span> <span class="o">+</span> <span class="n">blocksize</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block_end</span> <span class="o">&lt;=</span> <span class="n">from</span> <span class="o">||</span> <span class="n">block_start</span> <span class="o">&gt;=</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
				<span class="n">partial</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">clear_buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is a partial write which happened to make all buffers</span>
<span class="cm">	 * uptodate then we can optimize away a bogus readpage() for</span>
<span class="cm">	 * the next read(). Here we &#39;discover&#39; whether the page went</span>
<span class="cm">	 * uptodate as a result of this (potentially partial) write.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">partial</span><span class="p">)</span>
		<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * block_write_begin takes care of the basic task of block allocation and</span>
<span class="cm"> * bringing partial write blocks uptodate first.</span>
<span class="cm"> *</span>
<span class="cm"> * The filesystem needs to handle block truncation upon failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">block_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgoff_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">grab_cache_page_write_begin</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">__block_write_begin</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">get_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">pagep</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">block_write_begin</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">block_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">start</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">copied</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The buffers that were written will now be uptodate, so we</span>
<span class="cm">		 * don&#39;t have to worry about a readpage reading them and</span>
<span class="cm">		 * overwriting a partial write. However if we have encountered</span>
<span class="cm">		 * a short write and only partially written into a buffer, it</span>
<span class="cm">		 * will not be marked uptodate, so a readpage might come in and</span>
<span class="cm">		 * destroy our partial write.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Do the simplest thing, and just treat any short write to a</span>
<span class="cm">		 * non uptodate page as a zero-length write, and force the</span>
<span class="cm">		 * caller to redo the whole thing.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">page_zero_new_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">start</span><span class="o">+</span><span class="n">copied</span><span class="p">,</span> <span class="n">start</span><span class="o">+</span><span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="cm">/* This could be a short (even 0-length) commit */</span>
	<span class="n">__block_commit_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">start</span><span class="o">+</span><span class="n">copied</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">block_write_end</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">generic_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i_size_changed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">copied</span> <span class="o">=</span> <span class="n">block_write_end</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">copied</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">fsdata</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * No need to use i_size_read() here, the i_size</span>
<span class="cm">	 * cannot change under us because we hold i_mutex.</span>
<span class="cm">	 *</span>
<span class="cm">	 * But it&#39;s important to update i_size while still holding page lock:</span>
<span class="cm">	 * page writeout could otherwise come in and zero beyond i_size.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="o">+</span><span class="n">copied</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pos</span><span class="o">+</span><span class="n">copied</span><span class="p">);</span>
		<span class="n">i_size_changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t mark the inode dirty under page lock. First, it unnecessarily</span>
<span class="cm">	 * makes the holding time of page lock longer. Second, it forces lock</span>
<span class="cm">	 * ordering of page lock and transaction start for journaling</span>
<span class="cm">	 * filesystems.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_size_changed</span><span class="p">)</span>
		<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_write_end</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * block_is_partially_uptodate checks whether buffers within a page are</span>
<span class="cm"> * uptodate or not.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if all buffers which correspond to a file portion</span>
<span class="cm"> * we want to read are uptodate.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">block_is_partially_uptodate</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">read_descriptor_t</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">block_start</span><span class="p">,</span> <span class="n">block_end</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">to</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">blocksize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="n">to</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">from</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="n">to</span> <span class="o">=</span> <span class="n">from</span> <span class="o">+</span> <span class="n">to</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">from</span> <span class="o">&lt;</span> <span class="n">blocksize</span> <span class="o">&amp;&amp;</span> <span class="n">to</span> <span class="o">&gt;</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">blocksize</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">block_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">block_end</span> <span class="o">=</span> <span class="n">block_start</span> <span class="o">+</span> <span class="n">blocksize</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block_end</span> <span class="o">&gt;</span> <span class="n">from</span> <span class="o">&amp;&amp;</span> <span class="n">block_start</span> <span class="o">&lt;</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">block_end</span> <span class="o">&gt;=</span> <span class="n">to</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">block_start</span> <span class="o">=</span> <span class="n">block_end</span><span class="p">;</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">block_is_partially_uptodate</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Generic &quot;read page&quot; function for block devices that have the normal</span>
<span class="cm"> * get_block functionality. This is most of the block device filesystems.</span>
<span class="cm"> * Reads the page asynchronously --- the unlock_buffer() and</span>
<span class="cm"> * set/clear_buffer_uptodate() functions propagate buffer state into the</span>
<span class="cm"> * page struct once IO has completed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">block_read_full_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">iblock</span><span class="p">,</span> <span class="n">lblock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">arr</span><span class="p">[</span><span class="n">MAX_BUF_PER_PAGE</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fully_mapped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">blocksize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">create_empty_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">iblock</span> <span class="o">=</span> <span class="p">(</span><span class="n">sector_t</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">);</span>
	<span class="n">lblock</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">+</span><span class="n">blocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">fully_mapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iblock</span> <span class="o">&lt;</span> <span class="n">lblock</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">WARN_ON</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">!=</span> <span class="n">blocksize</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">get_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iblock</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="n">SetPageError</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">zero_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="n">blocksize</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
					<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * get_block() might have updated the buffer</span>
<span class="cm">			 * synchronously</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">arr</span><span class="p">[</span><span class="n">nr</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">iblock</span><span class="o">++</span><span class="p">,</span> <span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fully_mapped</span><span class="p">)</span>
		<span class="n">SetPageMappedToDisk</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * All buffers are uptodate - we can set the page uptodate</span>
<span class="cm">		 * as well. But not if get_block() returned an error.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageError</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Stage two: lock the buffers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">mark_buffer_async_read</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Stage 3: start the IO.  Check for uptodateness</span>
<span class="cm">	 * inside the buffer lock in case another process reading</span>
<span class="cm">	 * the underlying blockdev brought it uptodate (the sct fix).</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="n">end_buffer_async_read</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">submit_bh</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">block_read_full_page</span><span class="p">);</span>

<span class="cm">/* utility function for filesystems that need to do work on expanding</span>
<span class="cm"> * truncates.  Uses filesystem pagecache writes to allow the filesystem to</span>
<span class="cm"> * deal with the hole.  </span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">generic_cont_expand_simple</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">inode_newsize_ok</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pagecache_write_begin</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">AOP_FLAG_UNINTERRUPTIBLE</span><span class="o">|</span><span class="n">AOP_FLAG_CONT_EXPAND</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsdata</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pagecache_write_end</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">fsdata</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_cont_expand_simple</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cont_expand_zero</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			    <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">curidx</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">curpos</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">zerofrom</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">curidx</span> <span class="o">=</span> <span class="p">(</span><span class="n">curpos</span> <span class="o">=</span> <span class="o">*</span><span class="n">bytes</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="n">PAGE_CACHE_SHIFT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">zerofrom</span> <span class="o">=</span> <span class="n">curpos</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zerofrom</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">blocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">bytes</span> <span class="o">|=</span> <span class="p">(</span><span class="n">blocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="p">(</span><span class="o">*</span><span class="n">bytes</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">zerofrom</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">pagecache_write_begin</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">curpos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
						<span class="n">AOP_FLAG_UNINTERRUPTIBLE</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsdata</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">zero_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">zerofrom</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pagecache_write_end</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">curpos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
						<span class="n">page</span><span class="p">,</span> <span class="n">fsdata</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">balance_dirty_pages_ratelimited</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* page covers the boundary, find the boundary offset */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">curidx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">zerofrom</span> <span class="o">=</span> <span class="n">curpos</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>
		<span class="cm">/* if we will expand the thing last block will be filled */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;=</span> <span class="n">zerofrom</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zerofrom</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">blocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">bytes</span> <span class="o">|=</span> <span class="p">(</span><span class="n">blocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="p">(</span><span class="o">*</span><span class="n">bytes</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">zerofrom</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">pagecache_write_begin</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">curpos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
						<span class="n">AOP_FLAG_UNINTERRUPTIBLE</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsdata</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">zero_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">zerofrom</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pagecache_write_end</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">curpos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
						<span class="n">page</span><span class="p">,</span> <span class="n">fsdata</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * For moronic filesystems that do not allow holes in file.</span>
<span class="cm"> * We may have to extend the file.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cont_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">fsdata</span><span class="p">,</span>
			<span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">zerofrom</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">cont_expand_zero</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">zerofrom</span> <span class="o">=</span> <span class="o">*</span><span class="n">bytes</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="o">+</span><span class="n">len</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">bytes</span> <span class="o">&amp;&amp;</span> <span class="n">zerofrom</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">blocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">bytes</span> <span class="o">|=</span> <span class="p">(</span><span class="n">blocksize</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">(</span><span class="o">*</span><span class="n">bytes</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">block_write_begin</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pagep</span><span class="p">,</span> <span class="n">get_block</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cont_write_begin</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">block_commit_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">__block_commit_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span><span class="n">page</span><span class="p">,</span><span class="n">from</span><span class="p">,</span><span class="n">to</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">block_commit_write</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * block_page_mkwrite() is not allowed to change the file size as it gets</span>
<span class="cm"> * called from a page fault handler when a page is first dirtied. Hence we must</span>
<span class="cm"> * be careful to check for EOF conditions here. We set the page up correctly</span>
<span class="cm"> * for a written page which means we get ENOSPC checking when writing into</span>
<span class="cm"> * holes and correct delalloc and unwritten extent mapping on filesystems that</span>
<span class="cm"> * support these features.</span>
<span class="cm"> *</span>
<span class="cm"> * We are not allowed to take the i_mutex here so we have to play games to</span>
<span class="cm"> * protect against truncate races as the page could now be beyond EOF.  Because</span>
<span class="cm"> * truncate writes the inode size before removing pages, once we have the</span>
<span class="cm"> * page lock we can determine safely if the page is beyond EOF. If it is not</span>
<span class="cm"> * beyond EOF, then the page is guaranteed safe against truncation until we</span>
<span class="cm"> * unlock the page.</span>
<span class="cm"> *</span>
<span class="cm"> * Direct callers of this function should call vfs_check_frozen() so that page</span>
<span class="cm"> * fault does not busyloop until the fs is thawed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__block_page_mkwrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">,</span>
			 <span class="n">get_block_t</span> <span class="n">get_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">page_offset</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* We overload EFAULT to mean page got truncated */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* page is wholly or partially inside EOF */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__block_write_begin</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">get_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">block_commit_write</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Freezing in progress? We check after the page is marked dirty and</span>
<span class="cm">	 * with page lock held so if the test here fails, we are sure freezing</span>
<span class="cm">	 * code will wait during syncing until the page fault is done - at that</span>
<span class="cm">	 * point page will be dirty and unlocked so freezing code will write it</span>
<span class="cm">	 * and writeprotect it again.</span>
<span class="cm">	 */</span>
	<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_frozen</span> <span class="o">!=</span> <span class="n">SB_UNFROZEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">wait_on_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_unlock:</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__block_page_mkwrite</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">block_page_mkwrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">,</span>
		   <span class="n">get_block_t</span> <span class="n">get_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This check is racy but catches the common case. The check in</span>
<span class="cm">	 * __block_page_mkwrite() is reliable.</span>
<span class="cm">	 */</span>
	<span class="n">vfs_check_frozen</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">SB_FREEZE_WRITE</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__block_page_mkwrite</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">vmf</span><span class="p">,</span> <span class="n">get_block</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">block_page_mkwrite_return</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">block_page_mkwrite</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * nobh_write_begin()&#39;s prereads are special: the buffer_heads are freed</span>
<span class="cm"> * immediately, while under the page lock.  So it needs a special end_io</span>
<span class="cm"> * handler which does not touch the bh after unlocking it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">end_buffer_read_nobh</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__end_buffer_read_notouch</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">uptodate</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Attach the singly-linked list of buffers created by nobh_write_begin, to</span>
<span class="cm"> * the page (converting it to circular linked list and taking care of page</span>
<span class="cm"> * dirty races).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">attach_nobh_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">private_lock</span><span class="p">);</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">set_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
	<span class="n">attach_page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">private_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * On entry, the page is fully not uptodate.</span>
<span class="cm"> * On exit the page is fully uptodate in the areas outside (from,to)</span>
<span class="cm"> * The filesystem needs to handle block truncation upon failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nobh_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">fsdata</span><span class="p">,</span>
			<span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">blkbits</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">block_in_page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">block_start</span><span class="p">,</span> <span class="n">block_end</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">block_in_file</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_reads</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_mapped_to_disk</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">from</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">to</span> <span class="o">=</span> <span class="n">from</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">grab_cache_page_write_begin</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="o">*</span><span class="n">pagep</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="o">*</span><span class="n">fsdata</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__block_write_begin</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">get_block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageMappedToDisk</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate buffers so that we can keep track of state, and potentially</span>
<span class="cm">	 * attach them to the page if an error occurs. In the common case of</span>
<span class="cm">	 * no error, they will just be freed again without ever being attached</span>
<span class="cm">	 * to the page (which is all OK, because we&#39;re under the page lock).</span>
<span class="cm">	 *</span>
<span class="cm">	 * Be careful: the buffer linked list is a NULL terminated one, rather</span>
<span class="cm">	 * than the circular one we&#39;re used to.</span>
<span class="cm">	 */</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">alloc_page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">block_in_file</span> <span class="o">=</span> <span class="p">(</span><span class="n">sector_t</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">blkbits</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We loop across all blocks in the page, whether or not they are</span>
<span class="cm">	 * part of the affected region.  This is so we can discover if the</span>
<span class="cm">	 * page is fully mapped-to-disk.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">block_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">block_in_page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
		  <span class="n">block_start</span> <span class="o">&lt;</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
		  <span class="n">block_in_page</span><span class="o">++</span><span class="p">,</span> <span class="n">block_start</span> <span class="o">+=</span> <span class="n">blocksize</span><span class="p">,</span> <span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">create</span><span class="p">;</span>

		<span class="n">block_end</span> <span class="o">=</span> <span class="n">block_start</span> <span class="o">+</span> <span class="n">blocksize</span><span class="p">;</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">create</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block_start</span> <span class="o">&gt;=</span> <span class="n">to</span><span class="p">)</span>
			<span class="n">create</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">get_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block_in_file</span> <span class="o">+</span> <span class="n">block_in_page</span><span class="p">,</span>
					<span class="n">bh</span><span class="p">,</span> <span class="n">create</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="n">is_mapped_to_disk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="n">unmap_underlying_metadata</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">zero_user_segments</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">block_start</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span>
							<span class="n">to</span><span class="p">,</span> <span class="n">block_end</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>	<span class="cm">/* reiserfs does this */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block_start</span> <span class="o">&lt;</span> <span class="n">from</span> <span class="o">||</span> <span class="n">block_end</span> <span class="o">&gt;</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">end_buffer_read_nobh</span><span class="p">;</span>
			<span class="n">submit_bh</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
			<span class="n">nr_reads</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_reads</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The page is locked, so these buffers are protected from</span>
<span class="cm">		 * any VM or truncate activity.  Hence we don&#39;t need to care</span>
<span class="cm">		 * for the buffer_head refcounts.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span> <span class="n">bh</span><span class="p">;</span> <span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_mapped_to_disk</span><span class="p">)</span>
		<span class="n">SetPageMappedToDisk</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="o">*</span><span class="n">fsdata</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span> <span class="cm">/* to be released by nobh_write_end */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">failed:</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Error recovery is a bit difficult. We need to zero out blocks that</span>
<span class="cm">	 * were newly allocated, and dirty them to ensure they get written out.</span>
<span class="cm">	 * Buffers need to be attached to the page at this point, otherwise</span>
<span class="cm">	 * the handling of potential IO errors during writeout would be hard</span>
<span class="cm">	 * (could try doing synchronous writeout, but what if that fails too?)</span>
<span class="cm">	 */</span>
	<span class="n">attach_nobh_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="n">page_zero_new_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>

<span class="nl">out_release:</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="o">*</span><span class="n">pagep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">nobh_write_begin</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">nobh_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">fsdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">fsdata</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">copied</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">head</span><span class="p">)</span>
		<span class="n">attach_nobh_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">generic_write_end</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
					<span class="n">copied</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">fsdata</span><span class="p">);</span>

	<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="o">+</span><span class="n">copied</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pos</span><span class="o">+</span><span class="n">copied</span><span class="p">);</span>
		<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
		<span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
		<span class="n">free_buffer_head</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">nobh_write_end</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * nobh_writepage() - based on block_full_write_page() except</span>
<span class="cm"> * that it tries to operate without attaching bufferheads to</span>
<span class="cm"> * the page.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nobh_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="k">const</span> <span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">i_size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">const</span> <span class="n">pgoff_t</span> <span class="n">end_index</span> <span class="o">=</span> <span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Is the page fully inside i_size? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">end_index</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Is the page fully outside i_size? (truncate in progress) */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">i_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">end_index</span><span class="o">+</span><span class="mi">1</span> <span class="o">||</span> <span class="o">!</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The page may have dirty, unmapped buffers.  For example,</span>
<span class="cm">		 * they may have been added in ext3_writepage().  Make them</span>
<span class="cm">		 * freeable here, so the page does not leak.</span>
<span class="cm">		 */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		/* Not really sure about this  - do we need this ? */</span>
<span class="c">		if (page-&gt;mapping-&gt;a_ops-&gt;invalidatepage)</span>
<span class="c">			page-&gt;mapping-&gt;a_ops-&gt;invalidatepage(page, offset);</span>
<span class="cp">#endif</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* don&#39;t care */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The page straddles i_size.  It must be zeroed out on each and every</span>
<span class="cm">	 * writepage invocation because it may be mmapped.  &quot;A file is mapped</span>
<span class="cm">	 * in multiples of the page size.  For a file that is not a multiple of</span>
<span class="cm">	 * the  page size, the remaining memory is zeroed when mapped, and</span>
<span class="cm">	 * writes to that region are not written out to the file.&quot;</span>
<span class="cm">	 */</span>
	<span class="n">zero_user_segment</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">mpage_writepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">get_block</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__block_write_full_page</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">get_block</span><span class="p">,</span> <span class="n">wbc</span><span class="p">,</span>
					      <span class="n">end_buffer_async_write</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">nobh_writepage</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">nobh_truncate_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">from</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgoff_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">from</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">from</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">iblock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">length</span><span class="p">,</span> <span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="n">map_bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">blocksize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Block boundary? Nothing to do */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">length</span> <span class="o">=</span> <span class="n">blocksize</span> <span class="o">-</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">iblock</span> <span class="o">=</span> <span class="p">(</span><span class="n">sector_t</span><span class="p">)</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">);</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">grab_cache_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
<span class="nl">has_buffers:</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">block_truncate_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">get_block</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Find the buffer that contains &quot;offset&quot; */</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iblock</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">map_bh</span><span class="p">.</span><span class="n">b_size</span> <span class="o">=</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="n">map_bh</span><span class="p">.</span><span class="n">b_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">get_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iblock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map_bh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="cm">/* unmapped? It&#39;s a hole - nothing to do */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map_bh</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="cm">/* Ok, it&#39;s mapped. Make sure it&#39;s up-to-date */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">readpage</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">has_buffers</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">zero_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">unlock:</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">nobh_truncate_page</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">block_truncate_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">from</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgoff_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">from</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">from</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">iblock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">length</span><span class="p">,</span> <span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">blocksize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Block boundary? Nothing to do */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">length</span> <span class="o">=</span> <span class="n">blocksize</span> <span class="o">-</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">iblock</span> <span class="o">=</span> <span class="p">(</span><span class="n">sector_t</span><span class="p">)</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">);</span>
	
	<span class="n">page</span> <span class="o">=</span> <span class="n">grab_cache_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">create_empty_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Find the buffer that contains &quot;offset&quot; */</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
		<span class="n">iblock</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">!=</span> <span class="n">blocksize</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">get_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iblock</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="cm">/* unmapped? It&#39;s a hole - nothing to do */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Ok, it&#39;s mapped. Make sure it&#39;s up-to-date */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">buffer_unwritten</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">ll_rw_block</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="cm">/* Uhhuh. Read error. Complain and punt. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">zero_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">unlock:</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">block_truncate_page</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The generic -&gt;writepage function for buffer-backed address_spaces</span>
<span class="cm"> * this form passes in the end_io handler used to finish the IO.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">block_write_full_page_endio</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">,</span> <span class="n">bh_end_io_t</span> <span class="o">*</span><span class="n">handler</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="k">const</span> <span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">i_size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">const</span> <span class="n">pgoff_t</span> <span class="n">end_index</span> <span class="o">=</span> <span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">offset</span><span class="p">;</span>

	<span class="cm">/* Is the page fully inside i_size? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">end_index</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">__block_write_full_page</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">get_block</span><span class="p">,</span> <span class="n">wbc</span><span class="p">,</span>
					       <span class="n">handler</span><span class="p">);</span>

	<span class="cm">/* Is the page fully outside i_size? (truncate in progress) */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">i_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">end_index</span><span class="o">+</span><span class="mi">1</span> <span class="o">||</span> <span class="o">!</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The page may have dirty, unmapped buffers.  For example,</span>
<span class="cm">		 * they may have been added in ext3_writepage().  Make them</span>
<span class="cm">		 * freeable here, so the page does not leak.</span>
<span class="cm">		 */</span>
		<span class="n">do_invalidatepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* don&#39;t care */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The page straddles i_size.  It must be zeroed out on each and every</span>
<span class="cm">	 * writepage invocation because it may be mmapped.  &quot;A file is mapped</span>
<span class="cm">	 * in multiples of the page size.  For a file that is not a multiple of</span>
<span class="cm">	 * the  page size, the remaining memory is zeroed when mapped, and</span>
<span class="cm">	 * writes to that region are not written out to the file.&quot;</span>
<span class="cm">	 */</span>
	<span class="n">zero_user_segment</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__block_write_full_page</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">get_block</span><span class="p">,</span> <span class="n">wbc</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">block_write_full_page_endio</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The generic -&gt;writepage function for buffer-backed address_spaces</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">block_write_full_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">block_write_full_page_endio</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">get_block</span><span class="p">,</span> <span class="n">wbc</span><span class="p">,</span>
					   <span class="n">end_buffer_async_write</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">block_write_full_page</span><span class="p">);</span>

<span class="n">sector_t</span> <span class="nf">generic_block_bmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span>
			    <span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">tmp</span><span class="p">.</span><span class="n">b_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tmp</span><span class="p">.</span><span class="n">b_blocknr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tmp</span><span class="p">.</span><span class="n">b_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="n">get_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tmp</span><span class="p">.</span><span class="n">b_blocknr</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_block_bmap</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">end_bio_bh_io_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">BIO_EOPNOTSUPP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BIO_QUIET</span><span class="p">,</span><span class="o">&amp;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span><span class="p">)))</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">BH_Quiet</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">);</span>

	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">BIO_UPTODATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span><span class="p">));</span>
	<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">submit_bh</span><span class="p">(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">buffer_unwritten</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only clear out a write error when rewriting</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_set_buffer_req</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">WRITE</span><span class="p">))</span>
		<span class="n">clear_buffer_write_io_error</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * from here on down, it&#39;s all bio -- do the initial mapping,</span>
<span class="cm">	 * submit_bio -&gt; generic_make_request may further map this bio around</span>
<span class="cm">	 */</span>
	<span class="n">bio</span> <span class="o">=</span> <span class="n">bio_alloc</span><span class="p">(</span><span class="n">GFP_NOIO</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">*</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">);</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bv_page</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bv_len</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bv_offset</span> <span class="o">=</span> <span class="n">bh_offset</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>

	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">end_bio_bh_io_sync</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>

	<span class="n">bio_get</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="n">submit_bio</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_flagged</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">BIO_EOPNOTSUPP</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">submit_bh</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ll_rw_block: low-level access to block devices (DEPRECATED)</span>
<span class="cm"> * @rw: whether to %READ or %WRITE or maybe %READA (readahead)</span>
<span class="cm"> * @nr: number of &amp;struct buffer_heads in the array</span>
<span class="cm"> * @bhs: array of pointers to &amp;struct buffer_head</span>
<span class="cm"> *</span>
<span class="cm"> * ll_rw_block() takes an array of pointers to &amp;struct buffer_heads, and</span>
<span class="cm"> * requests an I/O operation on them, either a %READ or a %WRITE.  The third</span>
<span class="cm"> * %READA option is described in the documentation for generic_make_request()</span>
<span class="cm"> * which ll_rw_block() calls.</span>
<span class="cm"> *</span>
<span class="cm"> * This function drops any buffer that it cannot get a lock on (with the</span>
<span class="cm"> * BH_Lock state bit), any buffer that appears to be clean when doing a write</span>
<span class="cm"> * request, and any buffer that appears to be up-to-date when doing read</span>
<span class="cm"> * request.  Further it marks as clean buffers that are processed for</span>
<span class="cm"> * writing (the buffer cache won&#39;t assume that they are actually clean</span>
<span class="cm"> * until the buffer gets unlocked).</span>
<span class="cm"> *</span>
<span class="cm"> * ll_rw_block sets b_end_io to simple completion handler that marks</span>
<span class="cm"> * the buffer up-to-date (if approriate), unlocks the buffer and wakes</span>
<span class="cm"> * any waiters. </span>
<span class="cm"> *</span>
<span class="cm"> * All of the buffers must be for the same device, and must also be a</span>
<span class="cm"> * multiple of the current approved size for the device.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ll_rw_block</span><span class="p">(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bhs</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bhs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">end_buffer_write_sync</span><span class="p">;</span>
				<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">submit_bh</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">end_buffer_read_sync</span><span class="p">;</span>
				<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">submit_bh</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ll_rw_block</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">write_dirty_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">end_buffer_write_sync</span><span class="p">;</span>
	<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">submit_bh</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">write_dirty_buffer</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * For a data-integrity writeout, we need to wait upon any in-progress I/O</span>
<span class="cm"> * and then start new I/O and then wait upon it.  The caller must have a ref on</span>
<span class="cm"> * the buffer_head.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__sync_dirty_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_count</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">end_buffer_write_sync</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">submit_bh</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__sync_dirty_buffer</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sync_dirty_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__sync_dirty_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">WRITE_SYNC</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sync_dirty_buffer</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * try_to_free_buffers() checks if all the buffers on this particular page</span>
<span class="cm"> * are unused, and releases them if so.</span>
<span class="cm"> *</span>
<span class="cm"> * Exclusion against try_to_free_buffers may be obtained by either</span>
<span class="cm"> * locking the page or by holding its mapping&#39;s private_lock.</span>
<span class="cm"> *</span>
<span class="cm"> * If the page is dirty but all the buffers are clean then we need to</span>
<span class="cm"> * be sure to mark the page clean as well.  This is because the page</span>
<span class="cm"> * may be against a block device, and a later reattachment of buffers</span>
<span class="cm"> * to a dirty page will set *all* buffers dirty.  Which would corrupt</span>
<span class="cm"> * filesystem data on the same device.</span>
<span class="cm"> *</span>
<span class="cm"> * The same applies to regular filesystem pages: if all the buffers are</span>
<span class="cm"> * clean then we set the page clean and proceed.  To do that, we require</span>
<span class="cm"> * total exclusion from __set_page_dirty_buffers().  That is obtained with</span>
<span class="cm"> * private_lock.</span>
<span class="cm"> *</span>
<span class="cm"> * try_to_free_buffers() is non-blocking.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">buffer_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_count</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_state</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">BH_Dirty</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">BH_Lock</span><span class="p">)));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">drop_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">buffers_to_free</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_write_io_error</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">AS_EIO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_busy</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_map</span><span class="p">)</span>
			<span class="n">__remove_assoc_queue</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
	<span class="o">*</span><span class="n">buffers_to_free</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">__clear_page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">failed:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">try_to_free_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span> <span class="k">const</span> <span class="n">mapping</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">buffers_to_free</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* can this still happen? */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">drop_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffers_to_free</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">private_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">drop_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffers_to_free</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the filesystem writes its buffers by hand (eg ext3)</span>
<span class="cm">	 * then we can have clean buffers against a dirty page.  We</span>
<span class="cm">	 * clean the page here; otherwise the VM will never notice</span>
<span class="cm">	 * that the filesystem did any IO at all.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Also, during truncate, discard_buffer will have marked all</span>
<span class="cm">	 * the page&#39;s buffers clean.  We discover that here and clean</span>
<span class="cm">	 * the page also.</span>
<span class="cm">	 *</span>
<span class="cm">	 * private_lock must be held over this entire operation in order</span>
<span class="cm">	 * to synchronise against __set_page_dirty_buffers and prevent the</span>
<span class="cm">	 * dirty bit from being lost.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">cancel_dirty_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">private_lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffers_to_free</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">buffers_to_free</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
			<span class="n">free_buffer_head</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">buffers_to_free</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">try_to_free_buffers</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * There are no bdflush tunables left.  But distributions are</span>
<span class="cm"> * still running obsolete flush daemons, so we terminate them here.</span>
<span class="cm"> *</span>
<span class="cm"> * Use of bdflush() is deprecated and will be removed in a future kernel.</span>
<span class="cm"> * The `flush-X&#39; kernel threads fully replace bdflush daemons and this call.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">bdflush</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="kt">long</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">msg_count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg_count</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msg_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			<span class="s">&quot;warning: process `%s&#39; used the obsolete bdflush&quot;</span>
			<span class="s">&quot; system call</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Fix your initscripts?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">func</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">do_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Buffer-head allocation</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">bh_cachep</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Once the number of bh&#39;s in the machine exceeds this level, we start</span>
<span class="cm"> * stripping them in writeback.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">max_buffer_heads</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">buffer_heads_over_limit</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">bh_accounting</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>			<span class="cm">/* Number of live bh&#39;s */</span>
	<span class="kt">int</span> <span class="n">ratelimit</span><span class="p">;</span>		<span class="cm">/* Limit cacheline bouncing */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">bh_accounting</span><span class="p">,</span> <span class="n">bh_accounting</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">recalc_bh_state</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__this_cpu_inc_return</span><span class="p">(</span><span class="n">bh_accounting</span><span class="p">.</span><span class="n">ratelimit</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">4096</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">bh_accounting</span><span class="p">.</span><span class="n">ratelimit</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">tot</span> <span class="o">+=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">bh_accounting</span><span class="p">,</span> <span class="n">i</span><span class="p">).</span><span class="n">nr</span><span class="p">;</span>
	<span class="n">buffer_heads_over_limit</span> <span class="o">=</span> <span class="p">(</span><span class="n">tot</span> <span class="o">&gt;</span> <span class="n">max_buffer_heads</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="nf">alloc_buffer_head</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">bh_cachep</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret</span><span class="o">-&gt;</span><span class="n">b_assoc_buffers</span><span class="p">);</span>
		<span class="n">preempt_disable</span><span class="p">();</span>
		<span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">bh_accounting</span><span class="p">.</span><span class="n">nr</span><span class="p">);</span>
		<span class="n">recalc_bh_state</span><span class="p">();</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">alloc_buffer_head</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">free_buffer_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_buffers</span><span class="p">));</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">bh_cachep</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">__this_cpu_dec</span><span class="p">(</span><span class="n">bh_accounting</span><span class="p">.</span><span class="n">nr</span><span class="p">);</span>
	<span class="n">recalc_bh_state</span><span class="p">();</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">free_buffer_head</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">buffer_exit_cpu</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bh_lru</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">bh_lrus</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BH_LRU_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bhs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">b</span><span class="o">-&gt;</span><span class="n">bhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">this_cpu_add</span><span class="p">(</span><span class="n">bh_accounting</span><span class="p">.</span><span class="n">nr</span><span class="p">,</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">bh_accounting</span><span class="p">,</span> <span class="n">cpu</span><span class="p">).</span><span class="n">nr</span><span class="p">);</span>
	<span class="n">per_cpu</span><span class="p">(</span><span class="n">bh_accounting</span><span class="p">,</span> <span class="n">cpu</span><span class="p">).</span><span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">buffer_cpu_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">CPU_DEAD</span> <span class="o">||</span> <span class="n">action</span> <span class="o">==</span> <span class="n">CPU_DEAD_FROZEN</span><span class="p">)</span>
		<span class="n">buffer_exit_cpu</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bh_uptodate_or_lock - Test whether the buffer is uptodate</span>
<span class="cm"> * @bh: struct buffer_head</span>
<span class="cm"> *</span>
<span class="cm"> * Return true if the buffer is up-to-date and false,</span>
<span class="cm"> * with the buffer locked, if not.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bh_uptodate_or_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bh_uptodate_or_lock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bh_submit_read - Submit a locked buffer for reading</span>
<span class="cm"> * @bh: struct buffer_head</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success and -EIO on error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bh_submit_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">end_buffer_read_sync</span><span class="p">;</span>
	<span class="n">submit_bh</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bh_submit_read</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">buffer_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nrpages</span><span class="p">;</span>

	<span class="n">bh_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;buffer_head&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				<span class="p">(</span><span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="o">|</span><span class="n">SLAB_PANIC</span><span class="o">|</span>
				<span class="n">SLAB_MEM_SPREAD</span><span class="p">),</span>
				<span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Limit the bh occupancy to 10% of ZONE_NORMAL</span>
<span class="cm">	 */</span>
	<span class="n">nrpages</span> <span class="o">=</span> <span class="p">(</span><span class="n">nr_free_buffer_pages</span><span class="p">()</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
	<span class="n">max_buffer_heads</span> <span class="o">=</span> <span class="n">nrpages</span> <span class="o">*</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span><span class="p">));</span>
	<span class="n">hotcpu_notifier</span><span class="p">(</span><span class="n">buffer_cpu_notify</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
