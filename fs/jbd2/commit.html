<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › jbd2 › commit.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>commit.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/fs/jbd2/commit.c</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Stephen C. Tweedie &lt;sct@redhat.com&gt;, 1998</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 1998 Red Hat corp --- All Rights Reserved</span>
<span class="cm"> *</span>
<span class="cm"> * This file is part of the Linux kernel and is made available under</span>
<span class="cm"> * the terms of the GNU General Public License, version 2, or at your</span>
<span class="cm"> * option, any later version, incorporated herein by reference.</span>
<span class="cm"> *</span>
<span class="cm"> * Journal commit routines for the generic filesystem journaling code;</span>
<span class="cm"> * part of the ext2fs journaling system.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/jbd2.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/bio.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;trace/events/jbd2.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Default IO end handler for temporary BJ_IO buffer_heads.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">journal_end_buffer_io_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uptodate</span><span class="p">)</span>
		<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clear_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When an ext4 file is truncated, it is possible that some pages are not</span>
<span class="cm"> * successfully freed, because they are attached to a committing transaction.</span>
<span class="cm"> * After the transaction commits, these pages are left on the LRU, with no</span>
<span class="cm"> * -&gt;mapping, and with attached buffers.  These pages are trivially reclaimable</span>
<span class="cm"> * by the VM, but their apparent absence upsets the VM accounting, and it makes</span>
<span class="cm"> * the numbers in /proc/meminfo look odd.</span>
<span class="cm"> *</span>
<span class="cm"> * So here, we have a buffer which has just come off the forget list.  Look to</span>
<span class="cm"> * see if we can strip all buffers from the backing page.</span>
<span class="cm"> *</span>
<span class="cm"> * Called under lock_journal(), and possibly under journal_datalist_lock.  The</span>
<span class="cm"> * caller provided us with a ref against the buffer, and we drop that here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_buffer_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">nope</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_count</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nope</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nope</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nope</span><span class="p">;</span>

	<span class="cm">/* OK, it&#39;s a truncated page */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">nope</span><span class="p">;</span>

	<span class="n">page_cache_get</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">__brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">try_to_free_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">nope:</span>
	<span class="n">__brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">jbd2_commit_block_csum_set</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">j</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">descriptor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">commit_header</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">csum</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">JBD2_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">JBD2_FEATURE_INCOMPAT_CSUM_V2</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">commit_header</span> <span class="o">*</span><span class="p">)(</span><span class="n">jh2bh</span><span class="p">(</span><span class="n">descriptor</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">h_chksum_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">h_chksum_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">h_chksum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">csum</span> <span class="o">=</span> <span class="n">jbd2_chksum</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="o">-&gt;</span><span class="n">j_csum_seed</span><span class="p">,</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">descriptor</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span>
			   <span class="n">j</span><span class="o">-&gt;</span><span class="n">j_blocksize</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">h_chksum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">csum</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Done it all: now submit the commit record.  We should have</span>
<span class="cm"> * cleaned up our previous buffers by now, so if we are in abort</span>
<span class="cm"> * mode we can now just skip the rest of the journal write</span>
<span class="cm"> * entirely.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if the journal needs to be aborted or 0 on success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">journal_submit_commit_record</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span>
					<span class="n">transaction_t</span> <span class="o">*</span><span class="n">commit_transaction</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">cbh</span><span class="p">,</span>
					<span class="n">__u32</span> <span class="n">crc32_sum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">descriptor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">commit_header</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span> <span class="o">=</span> <span class="n">current_kernel_time</span><span class="p">();</span>

	<span class="o">*</span><span class="n">cbh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_journal_aborted</span><span class="p">(</span><span class="n">journal</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">descriptor</span> <span class="o">=</span> <span class="n">jbd2_journal_get_descriptor_buffer</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">descriptor</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">descriptor</span><span class="p">);</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">commit_header</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">h_magic</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">JBD2_MAGIC_NUMBER</span><span class="p">);</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">h_blocktype</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">JBD2_COMMIT_BLOCK</span><span class="p">);</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">h_sequence</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">);</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">h_commit_sec</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">h_commit_nsec</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">now</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">JBD2_HAS_COMPAT_FEATURE</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span>
				    <span class="n">JBD2_FEATURE_COMPAT_CHECKSUM</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">h_chksum_type</span> 	<span class="o">=</span> <span class="n">JBD2_CRC32_CHKSUM</span><span class="p">;</span>
		<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">h_chksum_size</span> 	<span class="o">=</span> <span class="n">JBD2_CRC32_CHKSUM_SIZE</span><span class="p">;</span>
		<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">h_chksum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 	<span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">crc32_sum</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">jbd2_commit_block_csum_set</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">descriptor</span><span class="p">);</span>

	<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">descriptor</span><span class="p">,</span> <span class="s">&quot;submit commit block&quot;</span><span class="p">);</span>
	<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">journal_end_buffer_io_sync</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">&amp;</span> <span class="n">JBD2_BARRIER</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">JBD2_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span>
				       <span class="n">JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">submit_bh</span><span class="p">(</span><span class="n">WRITE_SYNC</span> <span class="o">|</span> <span class="n">WRITE_FLUSH_FUA</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">submit_bh</span><span class="p">(</span><span class="n">WRITE_SYNC</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>

	<span class="o">*</span><span class="n">cbh</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function along with journal_submit_commit_record</span>
<span class="cm"> * allows to write the commit record asynchronously.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">journal_wait_on_commit_record</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">)))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>            <span class="cm">/* One for getblk() */</span>
	<span class="n">jbd2_journal_put_journal_head</span><span class="p">(</span><span class="n">bh2jh</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * write the filemap data using writepage() address_space_operations.</span>
<span class="cm"> * We don&#39;t do block allocation here even for delalloc. We don&#39;t</span>
<span class="cm"> * use writepages() because with dealyed allocation we may be doing</span>
<span class="cm"> * block allocation in writepages().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">journal_submit_inode_data_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">writeback_control</span> <span class="n">wbc</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">sync_mode</span> <span class="o">=</span>  <span class="n">WB_SYNC_ALL</span><span class="p">,</span>
		<span class="p">.</span><span class="n">nr_to_write</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
		<span class="p">.</span><span class="n">range_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">range_end</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">),</span>
	<span class="p">};</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">generic_writepages</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wbc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Submit all the data buffers of inode associated with the transaction to</span>
<span class="cm"> * disk.</span>
<span class="cm"> *</span>
<span class="cm"> * We are in a committing transaction. Therefore no new inode can be added to</span>
<span class="cm"> * our inode list. We use JI_COMMIT_RUNNING flag to protect inode we currently</span>
<span class="cm"> * operate on from being released while we write out pages.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">journal_submit_data_buffers</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span>
		<span class="n">transaction_t</span> <span class="o">*</span><span class="n">commit_transaction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jbd2_inode</span> <span class="o">*</span><span class="n">jinode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">jinode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_inode_list</span><span class="p">,</span> <span class="n">i_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mapping</span> <span class="o">=</span> <span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_vfs_inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">__JI_COMMIT_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * submit the inode data buffers. We use writepage</span>
<span class="cm">		 * instead of writepages. Because writepages can do</span>
<span class="cm">		 * block allocation  with delalloc. We need to write</span>
<span class="cm">		 * only allocated blocks here.</span>
<span class="cm">		 */</span>
		<span class="n">trace_jbd2_submit_inode_data</span><span class="p">(</span><span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_vfs_inode</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">journal_submit_inode_data_buffers</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
		<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_transaction</span> <span class="o">==</span> <span class="n">commit_transaction</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">__JI_COMMIT_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">);</span>
		<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>
		<span class="n">wake_up_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">,</span> <span class="n">__JI_COMMIT_RUNNING</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wait for data submitted for writeout, refile inodes to proper</span>
<span class="cm"> * transaction if needed.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">journal_finish_inode_data_buffers</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span>
		<span class="n">transaction_t</span> <span class="o">*</span><span class="n">commit_transaction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jbd2_inode</span> <span class="o">*</span><span class="n">jinode</span><span class="p">,</span> <span class="o">*</span><span class="n">next_i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* For locking, see the comment in journal_submit_data_buffers() */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">jinode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_inode_list</span><span class="p">,</span> <span class="n">i_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">__JI_COMMIT_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">filemap_fdatawait</span><span class="p">(</span><span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_vfs_inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Because AS_EIO is cleared by</span>
<span class="cm">			 * filemap_fdatawait_range(), set it again so</span>
<span class="cm">			 * that user process can get -EIO from fsync().</span>
<span class="cm">			 */</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">AS_EIO</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_vfs_inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">__JI_COMMIT_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">);</span>
		<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>
		<span class="n">wake_up_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">,</span> <span class="n">__JI_COMMIT_RUNNING</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Now refile inode to proper lists */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">jinode</span><span class="p">,</span> <span class="n">next_i</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_inode_list</span><span class="p">,</span> <span class="n">i_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_next_transaction</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_transaction</span> <span class="o">=</span> <span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_next_transaction</span><span class="p">;</span>
			<span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_next_transaction</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_list</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_transaction</span><span class="o">-&gt;</span><span class="n">t_inode_list</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_transaction</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__u32</span> <span class="nf">jbd2_checksum_data</span><span class="p">(</span><span class="n">__u32</span> <span class="n">crc32_sum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">checksum</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">checksum</span> <span class="o">=</span> <span class="n">crc32_be</span><span class="p">(</span><span class="n">crc32_sum</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">offset_in_page</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">)),</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">checksum</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_tag_block</span><span class="p">(</span><span class="kt">int</span> <span class="n">tag_bytes</span><span class="p">,</span> <span class="n">journal_block_tag_t</span> <span class="o">*</span><span class="n">tag</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tag</span><span class="o">-&gt;</span><span class="n">t_blocknr</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">block</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tag_bytes</span> <span class="o">&gt;</span> <span class="n">JBD2_TAG_SIZE32</span><span class="p">)</span>
		<span class="n">tag</span><span class="o">-&gt;</span><span class="n">t_blocknr_high</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">((</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">jbd2_descr_block_csum_set</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">j</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">descriptor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jbd2_journal_block_tail</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">csum</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">JBD2_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">JBD2_FEATURE_INCOMPAT_CSUM_V2</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">tail</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">jbd2_journal_block_tail</span> <span class="o">*</span><span class="p">)</span>
			<span class="p">(</span><span class="n">jh2bh</span><span class="p">(</span><span class="n">descriptor</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">j</span><span class="o">-&gt;</span><span class="n">j_blocksize</span> <span class="o">-</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">jbd2_journal_block_tail</span><span class="p">));</span>
	<span class="n">tail</span><span class="o">-&gt;</span><span class="n">t_checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">csum</span> <span class="o">=</span> <span class="n">jbd2_chksum</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="o">-&gt;</span><span class="n">j_csum_seed</span><span class="p">,</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">descriptor</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span>
			   <span class="n">j</span><span class="o">-&gt;</span><span class="n">j_blocksize</span><span class="p">);</span>
	<span class="n">tail</span><span class="o">-&gt;</span><span class="n">t_checksum</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">csum</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">jbd2_block_tag_csum_set</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">j</span><span class="p">,</span> <span class="n">journal_block_tag_t</span> <span class="o">*</span><span class="n">tag</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">sequence</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">csum</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">JBD2_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">JBD2_FEATURE_INCOMPAT_CSUM_V2</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sequence</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">sequence</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">KM_USER0</span><span class="p">);</span>
	<span class="n">csum</span> <span class="o">=</span> <span class="n">jbd2_chksum</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="o">-&gt;</span><span class="n">j_csum_seed</span><span class="p">,</span> <span class="p">(</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sequence</span><span class="p">,</span>
			  <span class="k">sizeof</span><span class="p">(</span><span class="n">sequence</span><span class="p">));</span>
	<span class="n">csum</span> <span class="o">=</span> <span class="n">jbd2_chksum</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">csum</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">offset_in_page</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">),</span>
			  <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">KM_USER0</span><span class="p">);</span>

	<span class="n">tag</span><span class="o">-&gt;</span><span class="n">t_checksum</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">csum</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * jbd2_journal_commit_transaction</span>
<span class="cm"> *</span>
<span class="cm"> * The primary function for committing a transaction to the log.  This</span>
<span class="cm"> * function is called by the journal thread to begin a complete commit.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">jbd2_journal_commit_transaction</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">transaction_stats_s</span> <span class="n">stats</span><span class="p">;</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">commit_transaction</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">,</span> <span class="o">*</span><span class="n">new_jh</span><span class="p">,</span> <span class="o">*</span><span class="n">descriptor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">wbuf</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wbuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bufs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">blocknr</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">start_time</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">commit_time</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tagp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">journal_header_t</span> <span class="o">*</span><span class="n">header</span><span class="p">;</span>
	<span class="n">journal_block_tag_t</span> <span class="o">*</span><span class="n">tag</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">space_left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">first_tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tag_flag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">to_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tag_bytes</span> <span class="o">=</span> <span class="n">journal_tag_bytes</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">cbh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* For transactional checksums */</span>
	<span class="n">__u32</span> <span class="n">crc32_sum</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blk_plug</span> <span class="n">plug</span><span class="p">;</span>
	<span class="cm">/* Tail of the journal */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first_block</span><span class="p">;</span>
	<span class="n">tid_t</span> <span class="n">first_tid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">update_tail</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">csum_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">JBD2_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">JBD2_FEATURE_INCOMPAT_CSUM_V2</span><span class="p">))</span>
		<span class="n">csum_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">jbd2_journal_block_tail</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * First job: lock down the current transaction and wait for</span>
<span class="cm">	 * all outstanding updates to complete.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Do we need to erase the effects of a prior jbd2_journal_flush? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">&amp;</span> <span class="n">JBD2_FLUSHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;super block updated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_mutex</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We hold j_checkpoint_mutex so tail cannot change under us.</span>
<span class="cm">		 * We don&#39;t need any special data guarantees for writing sb</span>
<span class="cm">		 * since journal is empty and it is ok for write to be</span>
<span class="cm">		 * flushed only with transaction commit.</span>
<span class="cm">		 */</span>
		<span class="n">jbd2_journal_update_sb_log_tail</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span>
						<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail_sequence</span><span class="p">,</span>
						<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail</span><span class="p">,</span>
						<span class="n">WRITE_SYNC</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_mutex</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;superblock not updated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">commit_transaction</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">;</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">==</span> <span class="n">T_RUNNING</span><span class="p">);</span>

	<span class="n">trace_jbd2_start_commit</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">commit_transaction</span><span class="p">);</span>
	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;JBD2: starting commit of transaction %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">);</span>

	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">=</span> <span class="n">T_LOCKED</span><span class="p">;</span>

	<span class="n">trace_jbd2_commit_locking</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">commit_transaction</span><span class="p">);</span>
	<span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_wait</span> <span class="o">=</span> <span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_max_wait</span><span class="p">;</span>
	<span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_locked</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_running</span> <span class="o">=</span> <span class="n">jbd2_time_diff</span><span class="p">(</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_start</span><span class="p">,</span>
					      <span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_locked</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_handle_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_updates</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

		<span class="n">prepare_to_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_updates</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span>
					<span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_updates</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_handle_lock</span><span class="p">);</span>
			<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_handle_lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_updates</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_handle_lock</span><span class="p">);</span>

	<span class="n">J_ASSERT</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_outstanding_credits</span><span class="p">)</span> <span class="o">&lt;=</span>
			<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_transaction_buffers</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * First thing we are allowed to do is to discard any remaining</span>
<span class="cm">	 * BJ_Reserved buffers.  Note, it is _not_ permissible to assume</span>
<span class="cm">	 * that there are no such buffers: if a large filesystem</span>
<span class="cm">	 * operation like a truncate needs to split itself over multiple</span>
<span class="cm">	 * transactions, then it may try to do a jbd2_journal_restart() while</span>
<span class="cm">	 * there are still BJ_Reserved buffers outstanding.  These must</span>
<span class="cm">	 * be released cleanly from the current transaction.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In this case, the filesystem must still reserve write access</span>
<span class="cm">	 * again before modifying the buffer in the new transaction, but</span>
<span class="cm">	 * we do not require it to remember exactly which old buffers it</span>
<span class="cm">	 * has reserved.  This is consistent with the existing behaviour</span>
<span class="cm">	 * that multiple jbd2_journal_get_write_access() calls to the same</span>
<span class="cm">	 * buffer are perfectly permissible.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_reserved_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jh</span> <span class="o">=</span> <span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_reserved_list</span><span class="p">;</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;reserved, unused: refile&quot;</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * A jbd2_journal_get_undo_access()+jbd2_journal_release_buffer() may</span>
<span class="cm">		 * leave undo-committed data.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_committed_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>

			<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">jbd2_free</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_committed_data</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
			<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_committed_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">jbd2_journal_refile_buffer</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">jh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now try to drop any written-back buffers from the journal&#39;s</span>
<span class="cm">	 * checkpoint lists.  We do this *before* commit because it potentially</span>
<span class="cm">	 * frees some memory</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="n">__jbd2_journal_clean_checkpoint_list</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;JBD2: commit phase 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear revoked flag to reflect there is no revoked buffers</span>
<span class="cm">	 * in the next transaction which is going to be started.</span>
<span class="cm">	 */</span>
	<span class="n">jbd2_clear_buffer_revoked_flags</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Switch to a new revoke table.</span>
<span class="cm">	 */</span>
	<span class="n">jbd2_journal_switch_revoke_table</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>

	<span class="n">trace_jbd2_commit_flushing</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">commit_transaction</span><span class="p">);</span>
	<span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_flushing</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_locked</span> <span class="o">=</span> <span class="n">jbd2_time_diff</span><span class="p">(</span><span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_locked</span><span class="p">,</span>
					     <span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_flushing</span><span class="p">);</span>

	<span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">=</span> <span class="n">T_FLUSH</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span> <span class="o">=</span> <span class="n">commit_transaction</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">start_time</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
	<span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_log_start</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_head</span><span class="p">;</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_transaction_locked</span><span class="p">);</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;JBD2: commit phase 2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now start flushing things to disk, in the order they appear</span>
<span class="cm">	 * on the transaction lists.  Data blocks go first.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">journal_submit_data_buffers</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">commit_transaction</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">jbd2_journal_abort</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

	<span class="n">blk_start_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>
	<span class="n">jbd2_journal_write_revoke_records</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">commit_transaction</span><span class="p">,</span>
					  <span class="n">WRITE_SYNC</span><span class="p">);</span>
	<span class="n">blk_finish_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;JBD2: commit phase 2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Way to go: we have now written out all of the data for a</span>
<span class="cm">	 * transaction!  Now comes the tricky part: we need to write out</span>
<span class="cm">	 * metadata.  Loop over the transaction&#39;s entire buffer list:</span>
<span class="cm">	 */</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">=</span> <span class="n">T_COMMIT</span><span class="p">;</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>

	<span class="n">trace_jbd2_commit_logging</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">commit_transaction</span><span class="p">);</span>
	<span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_logging</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_flushing</span> <span class="o">=</span> <span class="n">jbd2_time_diff</span><span class="p">(</span><span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_flushing</span><span class="p">,</span>
					       <span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_logging</span><span class="p">);</span>
	<span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_blocks</span> <span class="o">=</span>
		<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_outstanding_credits</span><span class="p">);</span>
	<span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_blocks_logged</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_nr_buffers</span> <span class="o">&lt;=</span>
		 <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_outstanding_credits</span><span class="p">));</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">descriptor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bufs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">blk_start_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_buffers</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Find the next buffer to be journaled... */</span>

		<span class="n">jh</span> <span class="o">=</span> <span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_buffers</span><span class="p">;</span>

		<span class="cm">/* If we&#39;re in abort mode, we just un-journal the buffer and</span>
<span class="cm">		   release it. */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_journal_aborted</span><span class="p">(</span><span class="n">journal</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">clear_buffer_jbddirty</span><span class="p">(</span><span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">));</span>
			<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;journal is aborting: refile&quot;</span><span class="p">);</span>
			<span class="n">jbd2_buffer_abort_trigger</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span>
						  <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_frozen_data</span> <span class="o">?</span>
						  <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_frozen_triggers</span> <span class="o">:</span>
						  <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_triggers</span><span class="p">);</span>
			<span class="n">jbd2_journal_refile_buffer</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">jh</span><span class="p">);</span>
			<span class="cm">/* If that was the last one, we need to clean up</span>
<span class="cm">			 * any descriptor buffers which may have been</span>
<span class="cm">			 * already allocated, even if we are now</span>
<span class="cm">			 * aborting. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_buffers</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">start_journal_io</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Make sure we have a descriptor block in which to</span>
<span class="cm">		   record the metadata buffer. */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">descriptor</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

			<span class="n">J_ASSERT</span> <span class="p">(</span><span class="n">bufs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

			<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;JBD2: get descriptor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="n">descriptor</span> <span class="o">=</span> <span class="n">jbd2_journal_get_descriptor_buffer</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">descriptor</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">jbd2_journal_abort</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">bh</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">descriptor</span><span class="p">);</span>
			<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;JBD2: got buffer %llu (%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">);</span>
			<span class="n">header</span> <span class="o">=</span> <span class="p">(</span><span class="n">journal_header_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">header</span><span class="o">-&gt;</span><span class="n">h_magic</span>     <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">JBD2_MAGIC_NUMBER</span><span class="p">);</span>
			<span class="n">header</span><span class="o">-&gt;</span><span class="n">h_blocktype</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">JBD2_DESCRIPTOR_BLOCK</span><span class="p">);</span>
			<span class="n">header</span><span class="o">-&gt;</span><span class="n">h_sequence</span>  <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">);</span>

			<span class="n">tagp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">journal_header_t</span><span class="p">)];</span>
			<span class="n">space_left</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">journal_header_t</span><span class="p">);</span>
			<span class="n">first_tag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">set_buffer_jwrite</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">set_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">wbuf</span><span class="p">[</span><span class="n">bufs</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>

			<span class="cm">/* Record it so that we can wait for IO</span>
<span class="cm">                           completion later */</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;ph3: file as descriptor&quot;</span><span class="p">);</span>
			<span class="n">jbd2_journal_file_buffer</span><span class="p">(</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">commit_transaction</span><span class="p">,</span>
					<span class="n">BJ_LogCtl</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Where is the buffer to be written? */</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">jbd2_journal_next_log_block</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blocknr</span><span class="p">);</span>
		<span class="cm">/* If the block mapping failed, just abandon the buffer</span>
<span class="cm">		   and repeat this loop: we&#39;ll fall into the</span>
<span class="cm">		   refile-on-abort condition above. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jbd2_journal_abort</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * start_this_handle() uses t_outstanding_credits to determine</span>
<span class="cm">		 * the free space in the log, but this counter is changed</span>
<span class="cm">		 * by jbd2_journal_next_log_block() also.</span>
<span class="cm">		 */</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_outstanding_credits</span><span class="p">);</span>

		<span class="cm">/* Bump b_count to prevent truncate from stumbling over</span>
<span class="cm">                   the shadowed buffer!  @@@ This can go if we ever get</span>
<span class="cm">                   rid of the BJ_IO/BJ_Shadow pairing of buffers. */</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_count</span><span class="p">);</span>

		<span class="cm">/* Make a temporary IO buffer with which to write it out</span>
<span class="cm">                   (this will requeue both the metadata buffer and the</span>
<span class="cm">                   temporary IO buffer). new_bh goes on BJ_IO*/</span>

		<span class="n">set_bit</span><span class="p">(</span><span class="n">BH_JWrite</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * akpm: jbd2_journal_write_metadata_buffer() sets</span>
<span class="cm">		 * new_bh-&gt;b_transaction to commit_transaction.</span>
<span class="cm">		 * We need to clean this up before we release new_bh</span>
<span class="cm">		 * (which is of type BJ_IO)</span>
<span class="cm">		 */</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;ph3: write metadata&quot;</span><span class="p">);</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">jbd2_journal_write_metadata_buffer</span><span class="p">(</span><span class="n">commit_transaction</span><span class="p">,</span>
						      <span class="n">jh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_jh</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jbd2_journal_abort</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">BH_JWrite</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">jh2bh</span><span class="p">(</span><span class="n">new_jh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">);</span>
		<span class="n">wbuf</span><span class="p">[</span><span class="n">bufs</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">new_jh</span><span class="p">);</span>

		<span class="cm">/* Record the new block&#39;s tag in the current descriptor</span>
<span class="cm">                   buffer */</span>

		<span class="n">tag_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">tag_flag</span> <span class="o">|=</span> <span class="n">JBD2_FLAG_ESCAPE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first_tag</span><span class="p">)</span>
			<span class="n">tag_flag</span> <span class="o">|=</span> <span class="n">JBD2_FLAG_SAME_UUID</span><span class="p">;</span>

		<span class="n">tag</span> <span class="o">=</span> <span class="p">(</span><span class="n">journal_block_tag_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">tagp</span><span class="p">;</span>
		<span class="n">write_tag_block</span><span class="p">(</span><span class="n">tag_bytes</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
		<span class="n">tag</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">tag_flag</span><span class="p">);</span>
		<span class="n">jbd2_block_tag_csum_set</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">new_jh</span><span class="p">),</span>
					<span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">);</span>
		<span class="n">tagp</span> <span class="o">+=</span> <span class="n">tag_bytes</span><span class="p">;</span>
		<span class="n">space_left</span> <span class="o">-=</span> <span class="n">tag_bytes</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">first_tag</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span> <span class="p">(</span><span class="n">tagp</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_uuid</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">tagp</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">space_left</span> <span class="o">-=</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">first_tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* If there&#39;s no more to do, or if the descriptor is full,</span>
<span class="cm">		   let the IO rip! */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bufs</span> <span class="o">==</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wbufsize</span> <span class="o">||</span>
		    <span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_buffers</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
		    <span class="n">space_left</span> <span class="o">&lt;</span> <span class="n">tag_bytes</span> <span class="o">+</span> <span class="mi">16</span> <span class="o">+</span> <span class="n">csum_size</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;JBD2: Submit %d IOs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bufs</span><span class="p">);</span>

			<span class="cm">/* Write an end-of-descriptor marker before</span>
<span class="cm">                           submitting the IOs.  &quot;tag&quot; still points to</span>
<span class="cm">                           the last tag we set up. */</span>

			<span class="n">tag</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">|=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">JBD2_FLAG_LAST_TAG</span><span class="p">);</span>

			<span class="n">jbd2_descr_block_csum_set</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">descriptor</span><span class="p">);</span>
<span class="nl">start_journal_io:</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bufs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">wbuf</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="cm">/*</span>
<span class="cm">				 * Compute checksum.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">JBD2_HAS_COMPAT_FEATURE</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span>
					<span class="n">JBD2_FEATURE_COMPAT_CHECKSUM</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">crc32_sum</span> <span class="o">=</span>
					    <span class="n">jbd2_checksum_data</span><span class="p">(</span><span class="n">crc32_sum</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">journal_end_buffer_io_sync</span><span class="p">;</span>
				<span class="n">submit_bh</span><span class="p">(</span><span class="n">WRITE_SYNC</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_blocks_logged</span> <span class="o">+=</span> <span class="n">bufs</span><span class="p">;</span>

			<span class="cm">/* Force a new descriptor to be generated next</span>
<span class="cm">                           time round the loop. */</span>
			<span class="n">descriptor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">bufs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">journal_finish_inode_data_buffers</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">commit_transaction</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;JBD2: Detected IO errors while flushing file data &quot;</span>
		       <span class="s">&quot;on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_devname</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">&amp;</span> <span class="n">JBD2_ABORT_ON_SYNCDATA_ERR</span><span class="p">)</span>
			<span class="n">jbd2_journal_abort</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get current oldest transaction in the log before we issue flush</span>
<span class="cm">	 * to the filesystem device. After the flush we can be sure that</span>
<span class="cm">	 * blocks of all older transactions are checkpointed to persistent</span>
<span class="cm">	 * storage and we will be safe to update journal start in the</span>
<span class="cm">	 * superblock with the numbers we get here.</span>
<span class="cm">	 */</span>
	<span class="n">update_tail</span> <span class="o">=</span>
		<span class="n">jbd2_journal_get_log_tail</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first_tid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first_block</span><span class="p">);</span>

	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">update_tail</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="n">freed</span> <span class="o">=</span> <span class="n">first_block</span> <span class="o">-</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">first_block</span> <span class="o">&lt;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail</span><span class="p">)</span>
			<span class="n">freed</span> <span class="o">+=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last</span> <span class="o">-</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_first</span><span class="p">;</span>
		<span class="cm">/* Update tail only if we free significant amount of space */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">freed</span> <span class="o">&lt;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_maxlen</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">update_tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">==</span> <span class="n">T_COMMIT</span><span class="p">);</span>
	<span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">=</span> <span class="n">T_COMMIT_DFLUSH</span><span class="p">;</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>

	<span class="cm">/* </span>
<span class="cm">	 * If the journal is not located on the file system device,</span>
<span class="cm">	 * then we must flush the file system device before we issue</span>
<span class="cm">	 * the commit record</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_need_data_flush</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_fs_dev</span> <span class="o">!=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">&amp;</span> <span class="n">JBD2_BARRIER</span><span class="p">))</span>
		<span class="n">blkdev_issue_flush</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_fs_dev</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Done it all: now write the commit record asynchronously. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">JBD2_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span>
				      <span class="n">JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">journal_submit_commit_record</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">commit_transaction</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">cbh</span><span class="p">,</span> <span class="n">crc32_sum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">__jbd2_journal_abort_hard</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">blk_finish_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>

	<span class="cm">/* Lo and behold: we have just managed to send a transaction to</span>
<span class="cm">           the log.  Before we can commit it, wait for the IO so far to</span>
<span class="cm">           complete.  Control buffers being written are on the</span>
<span class="cm">           transaction&#39;s t_log_list queue, and metadata buffers are on</span>
<span class="cm">           the t_iobuf_list queue.</span>

<span class="cm">	   Wait for the buffers in reverse order.  That way we are</span>
<span class="cm">	   less likely to be woken up until all IOs have completed, and</span>
<span class="cm">	   so we incur less scheduling load.</span>
<span class="cm">	*/</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;JBD2: commit phase 3</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * akpm: these are BJ_IO, and j_list_lock is not needed.</span>
<span class="cm">	 * See __journal_try_to_free_buffer.</span>
<span class="cm">	 */</span>
<span class="nl">wait_for_iobuf:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_iobuf_list</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

		<span class="n">jh</span> <span class="o">=</span> <span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_iobuf_list</span><span class="o">-&gt;</span><span class="n">b_tprev</span><span class="p">;</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">wait_for_iobuf</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cond_resched</span><span class="p">())</span>
			<span class="k">goto</span> <span class="n">wait_for_iobuf</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">)))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

		<span class="n">clear_buffer_jwrite</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;ph4: unfile after journal write&quot;</span><span class="p">);</span>
		<span class="n">jbd2_journal_unfile_buffer</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">jh</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * -&gt;t_iobuf_list should contain only dummy buffer_heads</span>
<span class="cm">		 * which were created by jbd2_journal_write_metadata_buffer().</span>
<span class="cm">		 */</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;dumping temporary bh&quot;</span><span class="p">);</span>
		<span class="n">jbd2_journal_put_journal_head</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
		<span class="n">__brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">J_ASSERT_BH</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_count</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">free_buffer_head</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

		<span class="cm">/* We also have to unlock and free the corresponding</span>
<span class="cm">                   shadowed buffer */</span>
		<span class="n">jh</span> <span class="o">=</span> <span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_shadow_list</span><span class="o">-&gt;</span><span class="n">b_tprev</span><span class="p">;</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">BH_JWrite</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">);</span>
		<span class="n">J_ASSERT_BH</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">buffer_jbddirty</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>

		<span class="cm">/* The metadata is now released for reuse, but we need</span>
<span class="cm">                   to remember it against this transaction so that when</span>
<span class="cm">                   we finally commit, we can do any checkpointing</span>
<span class="cm">                   required. */</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;file as BJ_Forget&quot;</span><span class="p">);</span>
		<span class="n">jbd2_journal_file_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">commit_transaction</span><span class="p">,</span> <span class="n">BJ_Forget</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Wake up any transactions which were waiting for this IO to</span>
<span class="cm">		 * complete. The barrier must be here so that changes by</span>
<span class="cm">		 * jbd2_journal_file_buffer() take effect before wake_up_bit()</span>
<span class="cm">		 * does the waitqueue check.</span>
<span class="cm">		 */</span>
		<span class="n">smp_mb</span><span class="p">();</span>
		<span class="n">wake_up_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">,</span> <span class="n">BH_Unshadow</span><span class="p">);</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;brelse shadowed buffer&quot;</span><span class="p">);</span>
		<span class="n">__brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">J_ASSERT</span> <span class="p">(</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_shadow_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;JBD2: commit phase 4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Here we wait for the revoke record and descriptor record buffers */</span>
 <span class="nl">wait_for_ctlbuf:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_log_list</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

		<span class="n">jh</span> <span class="o">=</span> <span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_log_list</span><span class="o">-&gt;</span><span class="n">b_tprev</span><span class="p">;</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">wait_for_ctlbuf</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cond_resched</span><span class="p">())</span>
			<span class="k">goto</span> <span class="n">wait_for_ctlbuf</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">)))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;ph5: control buffer writeout done: unfile&quot;</span><span class="p">);</span>
		<span class="n">clear_buffer_jwrite</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">jbd2_journal_unfile_buffer</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">jh</span><span class="p">);</span>
		<span class="n">jbd2_journal_put_journal_head</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
		<span class="n">__brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>		<span class="cm">/* One for getblk */</span>
		<span class="cm">/* AKPM: bforget here */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">jbd2_journal_abort</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;JBD2: commit phase 5</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">==</span> <span class="n">T_COMMIT_DFLUSH</span><span class="p">);</span>
	<span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">=</span> <span class="n">T_COMMIT_JFLUSH</span><span class="p">;</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">JBD2_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span>
				       <span class="n">JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">journal_submit_commit_record</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">commit_transaction</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">cbh</span><span class="p">,</span> <span class="n">crc32_sum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">__jbd2_journal_abort_hard</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cbh</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">journal_wait_on_commit_record</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">cbh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">JBD2_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span>
				      <span class="n">JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">&amp;</span> <span class="n">JBD2_BARRIER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">blkdev_issue_flush</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">jbd2_journal_abort</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now disk caches for filesystem device are flushed so we are safe to</span>
<span class="cm">	 * erase checkpointed transactions from the log by updating journal</span>
<span class="cm">	 * superblock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">update_tail</span><span class="p">)</span>
		<span class="n">jbd2_update_log_tail</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">first_tid</span><span class="p">,</span> <span class="n">first_block</span><span class="p">);</span>

	<span class="cm">/* End of a transaction!  Finally, we can do checkpoint</span>
<span class="cm">           processing: any buffers committed as a result of this</span>
<span class="cm">           transaction can be removed from any checkpoint list it was on</span>
<span class="cm">           before. */</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;JBD2: commit phase 6</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_inode_list</span><span class="p">));</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_buffers</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_iobuf_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_shadow_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_log_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="nl">restart_loop:</span>
	<span class="cm">/*</span>
<span class="cm">	 * As there are other places (journal_unmap_buffer()) adding buffers</span>
<span class="cm">	 * to this list we have to be careful and hold the j_list_lock.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_forget</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transaction_t</span> <span class="o">*</span><span class="n">cp_transaction</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">try_to_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">jh</span> <span class="o">=</span> <span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_forget</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Get a reference so that bh cannot be freed before we are</span>
<span class="cm">		 * done with it.</span>
<span class="cm">		 */</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span>	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">==</span> <span class="n">commit_transaction</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If there is undo-protected committed data against</span>
<span class="cm">		 * this buffer, then we can remove it now.  If it is a</span>
<span class="cm">		 * buffer needing such protection, the old frozen_data</span>
<span class="cm">		 * field now points to a committed version of the</span>
<span class="cm">		 * buffer, so rotate that field to the new committed</span>
<span class="cm">		 * data.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Otherwise, we can just throw away the frozen data now.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We also know that the frozen data has already fired</span>
<span class="cm">		 * its triggers if they exist, so we can clear that too.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_committed_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jbd2_free</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_committed_data</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
			<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_committed_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_frozen_data</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_committed_data</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_frozen_data</span><span class="p">;</span>
				<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_frozen_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_frozen_triggers</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_frozen_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jbd2_free</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_frozen_data</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
			<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_frozen_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_frozen_triggers</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
		<span class="n">cp_transaction</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cp_transaction</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp_transaction</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;remove from old cp transaction&quot;</span><span class="p">);</span>
			<span class="n">cp_transaction</span><span class="o">-&gt;</span><span class="n">t_chp_stats</span><span class="p">.</span><span class="n">cs_dropped</span><span class="o">++</span><span class="p">;</span>
			<span class="n">__jbd2_journal_remove_checkpoint</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Only re-checkpoint the buffer_head if it is marked</span>
<span class="cm">		 * dirty.  If the buffer was added to the BJ_Forget list</span>
<span class="cm">		 * by jbd2_journal_forget, it may no longer be dirty and</span>
<span class="cm">		 * there&#39;s no point in keeping a checkpoint record for</span>
<span class="cm">		 * it. */</span>

		<span class="cm">/* A buffer which has been freed while still being</span>
<span class="cm">		 * journaled by a previous transaction may end up still</span>
<span class="cm">		 * being dirty here, but we want to avoid writing back</span>
<span class="cm">		 * that buffer in the future after the &quot;add to orphan&quot;</span>
<span class="cm">		 * operation been committed,  That&#39;s not only a performance</span>
<span class="cm">		 * gain, it also stops aliasing problems if the buffer is</span>
<span class="cm">		 * left behind for writeback and gets reallocated for another</span>
<span class="cm">		 * use in a different page. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_freed</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_next_transaction</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clear_buffer_freed</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">clear_buffer_jbddirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_jbddirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;add to new checkpointing trans&quot;</span><span class="p">);</span>
			<span class="n">__jbd2_journal_insert_checkpoint</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">commit_transaction</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_journal_aborted</span><span class="p">(</span><span class="n">journal</span><span class="p">))</span>
				<span class="n">clear_buffer_jbddirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">J_ASSERT_BH</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="o">!</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>
			<span class="cm">/*</span>
<span class="cm">			 * The buffer on BJ_Forget list and not jbddirty means</span>
<span class="cm">			 * it has been freed by this transaction and hence it</span>
<span class="cm">			 * could not have been reallocated until this</span>
<span class="cm">			 * transaction has committed. *BUT* it could be</span>
<span class="cm">			 * reallocated once we have written all the data to</span>
<span class="cm">			 * disk and before we process the buffer on BJ_Forget</span>
<span class="cm">			 * list.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_next_transaction</span><span class="p">)</span>
				<span class="n">try_to_free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;refile or unfile buffer&quot;</span><span class="p">);</span>
		<span class="n">__jbd2_journal_refile_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
		<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">try_to_free</span><span class="p">)</span>
			<span class="n">release_buffer_page</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>	<span class="cm">/* Drops bh reference */</span>
		<span class="k">else</span>
			<span class="n">__brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">cond_resched_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * This is a bit sleazy.  We use j_list_lock to protect transition</span>
<span class="cm">	 * of a transaction into T_FINISHED state and calling</span>
<span class="cm">	 * __jbd2_journal_drop_transaction(). Otherwise we could race with</span>
<span class="cm">	 * other checkpointing code processing the transaction...</span>
<span class="cm">	 */</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Now recheck if some buffers did not get attached to the transaction</span>
<span class="cm">	 * while the lock was dropped...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_forget</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">restart_loop</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Done with this transaction! */</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;JBD2: commit phase 7</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">==</span> <span class="n">T_COMMIT_JFLUSH</span><span class="p">);</span>

	<span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_logging</span> <span class="o">=</span> <span class="n">jbd2_time_diff</span><span class="p">(</span><span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_logging</span><span class="p">,</span>
					      <span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_start</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * File the transaction statistics</span>
<span class="cm">	 */</span>
	<span class="n">stats</span><span class="p">.</span><span class="n">ts_tid</span> <span class="o">=</span> <span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>
	<span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_handle_count</span> <span class="o">=</span>
		<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_handle_count</span><span class="p">);</span>
	<span class="n">trace_jbd2_run_stats</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_fs_dev</span><span class="o">-&gt;</span><span class="n">bd_dev</span><span class="p">,</span>
			     <span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate overall stats</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_history_lock</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_stats</span><span class="p">.</span><span class="n">ts_tid</span><span class="o">++</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_wait</span> <span class="o">+=</span> <span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_wait</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_running</span> <span class="o">+=</span> <span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_running</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_locked</span> <span class="o">+=</span> <span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_locked</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_flushing</span> <span class="o">+=</span> <span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_flushing</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_logging</span> <span class="o">+=</span> <span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_logging</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_handle_count</span> <span class="o">+=</span> <span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_handle_count</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_blocks</span> <span class="o">+=</span> <span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_blocks</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_blocks_logged</span> <span class="o">+=</span> <span class="n">stats</span><span class="p">.</span><span class="n">run</span><span class="p">.</span><span class="n">rs_blocks_logged</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_history_lock</span><span class="p">);</span>

	<span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">=</span> <span class="n">T_FINISHED</span><span class="p">;</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">commit_transaction</span> <span class="o">==</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_sequence</span> <span class="o">=</span> <span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">commit_time</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">ktime_sub</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">(),</span> <span class="n">start_time</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * weight the commit time higher than the average time so we don&#39;t</span>
<span class="cm">	 * react too strongly to vast changes in the commit time</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_average_commit_time</span><span class="p">))</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_average_commit_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">commit_time</span> <span class="o">+</span>
				<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_average_commit_time</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_average_commit_time</span> <span class="o">=</span> <span class="n">commit_time</span><span class="p">;</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_list</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
	    <span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_io_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__jbd2_journal_drop_transaction</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">commit_transaction</span><span class="p">);</span>
		<span class="n">to_free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_transactions</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_transactions</span> <span class="o">=</span> <span class="n">commit_transaction</span><span class="p">;</span>
			<span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_cpnext</span> <span class="o">=</span> <span class="n">commit_transaction</span><span class="p">;</span>
			<span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_cpprev</span> <span class="o">=</span> <span class="n">commit_transaction</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_cpnext</span> <span class="o">=</span>
				<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_transactions</span><span class="p">;</span>
			<span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_cpprev</span> <span class="o">=</span>
				<span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_cpnext</span><span class="o">-&gt;</span><span class="n">t_cpprev</span><span class="p">;</span>
			<span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_cpnext</span><span class="o">-&gt;</span><span class="n">t_cpprev</span> <span class="o">=</span>
				<span class="n">commit_transaction</span><span class="p">;</span>
			<span class="n">commit_transaction</span><span class="o">-&gt;</span><span class="n">t_cpprev</span><span class="o">-&gt;</span><span class="n">t_cpnext</span> <span class="o">=</span>
				<span class="n">commit_transaction</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_callback</span><span class="p">)</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_callback</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">commit_transaction</span><span class="p">);</span>

	<span class="n">trace_jbd2_end_commit</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">commit_transaction</span><span class="p">);</span>
	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;JBD2: commit %d complete, head %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_sequence</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail_sequence</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">to_free</span><span class="p">)</span>
		<span class="n">jbd2_journal_free_transaction</span><span class="p">(</span><span class="n">commit_transaction</span><span class="p">);</span>

	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_done_commit</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
