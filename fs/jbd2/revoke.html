<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › jbd2 › revoke.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>revoke.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/fs/jbd2/revoke.c</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Stephen C. Tweedie &lt;sct@redhat.com&gt;, 2000</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2000 Red Hat corp --- All Rights Reserved</span>
<span class="cm"> *</span>
<span class="cm"> * This file is part of the Linux kernel and is made available under</span>
<span class="cm"> * the terms of the GNU General Public License, version 2, or at your</span>
<span class="cm"> * option, any later version, incorporated herein by reference.</span>
<span class="cm"> *</span>
<span class="cm"> * Journal revoke routines for the generic filesystem journaling code;</span>
<span class="cm"> * part of the ext2fs journaling system.</span>
<span class="cm"> *</span>
<span class="cm"> * Revoke is the mechanism used to prevent old log records for deleted</span>
<span class="cm"> * metadata from being replayed on top of newer data using the same</span>
<span class="cm"> * blocks.  The revoke mechanism is used in two separate places:</span>
<span class="cm"> *</span>
<span class="cm"> * + Commit: during commit we write the entire list of the current</span>
<span class="cm"> *   transaction&#39;s revoked blocks to the journal</span>
<span class="cm"> *</span>
<span class="cm"> * + Recovery: during recovery we record the transaction ID of all</span>
<span class="cm"> *   revoked blocks.  If there are multiple revoke records in the log</span>
<span class="cm"> *   for a single block, only the last one counts, and if there is a log</span>
<span class="cm"> *   entry for a block beyond the last revoke, then that log entry still</span>
<span class="cm"> *   gets replayed.</span>
<span class="cm"> *</span>
<span class="cm"> * We can get interactions between revokes and new log data within a</span>
<span class="cm"> * single transaction:</span>
<span class="cm"> *</span>
<span class="cm"> * Block is revoked and then journaled:</span>
<span class="cm"> *   The desired end result is the journaling of the new block, so we</span>
<span class="cm"> *   cancel the revoke before the transaction commits.</span>
<span class="cm"> *</span>
<span class="cm"> * Block is journaled and then revoked:</span>
<span class="cm"> *   The revoke must take precedence over the write of the block, so we</span>
<span class="cm"> *   need either to cancel the journal entry or to write the revoke</span>
<span class="cm"> *   later in the log than the log block.  In this case, we choose the</span>
<span class="cm"> *   latter: journaling a block cancels any revoke record for that block</span>
<span class="cm"> *   in the current transaction, so any revoke for that block in the</span>
<span class="cm"> *   transaction must have happened after the block was journaled and so</span>
<span class="cm"> *   the revoke must take precedence.</span>
<span class="cm"> *</span>
<span class="cm"> * Block is revoked and then written as data:</span>
<span class="cm"> *   The data write is allowed to succeed, but the revoke is _not_</span>
<span class="cm"> *   cancelled.  We still need to prevent old log records from</span>
<span class="cm"> *   overwriting the new data.  We don&#39;t even need to clear the revoke</span>
<span class="cm"> *   bit here.</span>
<span class="cm"> *</span>
<span class="cm"> * We cache revoke status of a buffer in the current transaction in b_states</span>
<span class="cm"> * bits.  As the name says, revokevalid flag indicates that the cached revoke</span>
<span class="cm"> * status of a buffer is valid and we can rely on the cached status.</span>
<span class="cm"> *</span>
<span class="cm"> * Revoke information on buffers is a tri-state value:</span>
<span class="cm"> *</span>
<span class="cm"> * RevokeValid clear:	no cached revoke status, need to look it up</span>
<span class="cm"> * RevokeValid set, Revoked clear:</span>
<span class="cm"> *			buffer has not been revoked, and cancel_revoke</span>
<span class="cm"> *			need do nothing.</span>
<span class="cm"> * RevokeValid set, Revoked set:</span>
<span class="cm"> *			buffer has been revoked.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking rules:</span>
<span class="cm"> * We keep two hash tables of revoke records. One hashtable belongs to the</span>
<span class="cm"> * running transaction (is pointed to by journal-&gt;j_revoke), the other one</span>
<span class="cm"> * belongs to the committing transaction. Accesses to the second hash table</span>
<span class="cm"> * happen only from the kjournald and no other thread touches this table.  Also</span>
<span class="cm"> * journal_switch_revoke_table() which switches which hashtable belongs to the</span>
<span class="cm"> * running and which to the committing transaction is called only from</span>
<span class="cm"> * kjournald. Therefore we need no locks when accessing the hashtable belonging</span>
<span class="cm"> * to the committing transaction.</span>
<span class="cm"> *</span>
<span class="cm"> * All users operating on the hash table belonging to the running transaction</span>
<span class="cm"> * have a handle to the transaction. Therefore they are safe from kjournald</span>
<span class="cm"> * switching hash tables under them. For operations on the lists of entries in</span>
<span class="cm"> * the hash table j_revoke_lock is used.</span>
<span class="cm"> *</span>
<span class="cm"> * Finally, also replay code uses the hash tables but at this moment no one else</span>
<span class="cm"> * can touch them (filesystem isn&#39;t mounted yet) and hence no locking is</span>
<span class="cm"> * needed.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __KERNEL__</span>
<span class="cp">#include &quot;jfs_user.h&quot;</span>
<span class="cp">#else</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/jbd2.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/bio.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;linux/log2.h&gt;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">jbd2_revoke_record_cache</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">jbd2_revoke_table_cache</span><span class="p">;</span>

<span class="cm">/* Each revoke record represents one single revoked block.  During</span>
<span class="cm">   journal replay, this involves recording the transaction ID of the</span>
<span class="cm">   last transaction to revoke this block. */</span>

<span class="k">struct</span> <span class="n">jbd2_revoke_record_s</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>  <span class="n">hash</span><span class="p">;</span>
	<span class="n">tid_t</span>		  <span class="n">sequence</span><span class="p">;</span>	<span class="cm">/* Used for recovery only */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span>	  <span class="n">blocknr</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/* The revoke table is just a simple hash table of revoke records. */</span>
<span class="k">struct</span> <span class="n">jbd2_revoke_table_s</span>
<span class="p">{</span>
	<span class="cm">/* It is conceivable that we might want a larger hash table</span>
<span class="cm">	 * for recovery.  Must be a power of two. */</span>
	<span class="kt">int</span>		  <span class="n">hash_size</span><span class="p">;</span>
	<span class="kt">int</span>		  <span class="n">hash_shift</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">hash_table</span><span class="p">;</span>
<span class="p">};</span>


<span class="cp">#ifdef __KERNEL__</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">write_one_revoke_record</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">transaction_t</span> <span class="o">*</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">**</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">jbd2_revoke_record_s</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">flush_descriptor</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* Utility functions to maintain the revoke table */</span>

<span class="cm">/* Borrowed from buffer.c: this is a tried and tested block hash function */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">hash</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jbd2_revoke_table_s</span> <span class="o">*</span><span class="n">table</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hash_shift</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">hash_shift</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">block</span> <span class="o">^</span> <span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">hash_shift</span> <span class="o">-</span> <span class="mi">6</span><span class="p">))</span> <span class="o">^</span>
		<span class="p">(</span><span class="n">hash</span> <span class="o">&gt;&gt;</span> <span class="mi">13</span><span class="p">)</span> <span class="o">^</span>
		<span class="p">(</span><span class="n">hash</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">hash_shift</span> <span class="o">-</span> <span class="mi">12</span><span class="p">)))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">hash_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">insert_revoke_hash</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">blocknr</span><span class="p">,</span>
			      <span class="n">tid_t</span> <span class="n">seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">hash_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jbd2_revoke_record_s</span> <span class="o">*</span><span class="n">record</span><span class="p">;</span>

<span class="nl">repeat:</span>
	<span class="n">record</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">jbd2_revoke_record_cache</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">record</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">oom</span><span class="p">;</span>

	<span class="n">record</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
	<span class="n">record</span><span class="o">-&gt;</span><span class="n">blocknr</span> <span class="o">=</span> <span class="n">blocknr</span><span class="p">;</span>
	<span class="n">hash_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke</span><span class="o">-&gt;</span><span class="n">hash_table</span><span class="p">[</span><span class="n">hash</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">)];</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">record</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">,</span> <span class="n">hash_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">oom:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal_oom_retry</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;ENOMEM in %s, retrying</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">yield</span><span class="p">();</span>
	<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Find a revoke record in the journal&#39;s hash table. */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">jbd2_revoke_record_s</span> <span class="o">*</span><span class="nf">find_revoke_record</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span>
						      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">blocknr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">hash_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jbd2_revoke_record_s</span> <span class="o">*</span><span class="n">record</span><span class="p">;</span>

	<span class="n">hash_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke</span><span class="o">-&gt;</span><span class="n">hash_table</span><span class="p">[</span><span class="n">hash</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">)];</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_lock</span><span class="p">);</span>
	<span class="n">record</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">jbd2_revoke_record_s</span> <span class="o">*</span><span class="p">)</span> <span class="n">hash_list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">record</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">)</span> <span class="o">!=</span> <span class="n">hash_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">record</span><span class="o">-&gt;</span><span class="n">blocknr</span> <span class="o">==</span> <span class="n">blocknr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">record</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">record</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">jbd2_revoke_record_s</span> <span class="o">*</span><span class="p">)</span> <span class="n">record</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">jbd2_journal_destroy_revoke_caches</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jbd2_revoke_record_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">jbd2_revoke_record_cache</span><span class="p">);</span>
		<span class="n">jbd2_revoke_record_cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jbd2_revoke_table_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">jbd2_revoke_table_cache</span><span class="p">);</span>
		<span class="n">jbd2_revoke_table_cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">jbd2_journal_init_revoke_caches</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">jbd2_revoke_record_cache</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">jbd2_revoke_table_cache</span><span class="p">);</span>

	<span class="n">jbd2_revoke_record_cache</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">jbd2_revoke_record_s</span><span class="p">,</span>
					<span class="n">SLAB_HWCACHE_ALIGN</span><span class="o">|</span><span class="n">SLAB_TEMPORARY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jbd2_revoke_record_cache</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">record_cache_failure</span><span class="p">;</span>

	<span class="n">jbd2_revoke_table_cache</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">jbd2_revoke_table_s</span><span class="p">,</span>
					     <span class="n">SLAB_TEMPORARY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jbd2_revoke_table_cache</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">table_cache_failure</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">table_cache_failure:</span>
	<span class="n">jbd2_journal_destroy_revoke_caches</span><span class="p">();</span>
<span class="nl">record_cache_failure:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">jbd2_revoke_table_s</span> <span class="o">*</span><span class="nf">jbd2_journal_init_revoke_table</span><span class="p">(</span><span class="kt">int</span> <span class="n">hash_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">hash_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jbd2_revoke_table_s</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>

	<span class="n">table</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">jbd2_revoke_table_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">while</span><span class="p">((</span><span class="n">tmp</span> <span class="o">&gt;&gt;=</span> <span class="mi">1UL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0UL</span><span class="p">)</span>
		<span class="n">shift</span><span class="o">++</span><span class="p">;</span>

	<span class="n">table</span><span class="o">-&gt;</span><span class="n">hash_size</span> <span class="o">=</span> <span class="n">hash_size</span><span class="p">;</span>
	<span class="n">table</span><span class="o">-&gt;</span><span class="n">hash_shift</span> <span class="o">=</span> <span class="n">shift</span><span class="p">;</span>
	<span class="n">table</span><span class="o">-&gt;</span><span class="n">hash_table</span> <span class="o">=</span>
		<span class="n">kmalloc</span><span class="p">(</span><span class="n">hash_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">hash_table</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">jbd2_revoke_table_cache</span><span class="p">,</span> <span class="n">table</span><span class="p">);</span>
		<span class="n">table</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">hash_size</span><span class="p">;</span> <span class="n">tmp</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">hash_table</span><span class="p">[</span><span class="n">tmp</span><span class="p">]);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">table</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">jbd2_journal_destroy_revoke_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">jbd2_revoke_table_s</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">hash_list</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">hash_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hash_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">hash_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">hash_list</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">hash_table</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">jbd2_revoke_table_cache</span><span class="p">,</span> <span class="n">table</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Initialise the revoke table for a given journal to a given size. */</span>
<span class="kt">int</span> <span class="nf">jbd2_journal_init_revoke</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hash_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_table</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">hash_size</span><span class="p">));</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_table</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">jbd2_journal_init_revoke_table</span><span class="p">(</span><span class="n">hash_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_table</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">goto</span> <span class="n">fail0</span><span class="p">;</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_table</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">jbd2_journal_init_revoke_table</span><span class="p">(</span><span class="n">hash_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_table</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">goto</span> <span class="n">fail1</span><span class="p">;</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_table</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail1:</span>
	<span class="n">jbd2_journal_destroy_revoke_table</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_table</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="nl">fail0:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Destroy a journal&#39;s revoke table.  The table must already be empty! */</span>
<span class="kt">void</span> <span class="nf">jbd2_journal_destroy_revoke</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_table</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">jbd2_journal_destroy_revoke_table</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_table</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_table</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">jbd2_journal_destroy_revoke_table</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_table</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>


<span class="cp">#ifdef __KERNEL__</span>

<span class="cm">/*</span>
<span class="cm"> * jbd2_journal_revoke: revoke a given buffer_head from the journal.  This</span>
<span class="cm"> * prevents the block from being replayed during recovery if we take a</span>
<span class="cm"> * crash after this current transaction commits.  Any subsequent</span>
<span class="cm"> * metadata writes of the buffer in this transaction cancel the</span>
<span class="cm"> * revoke.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this call may block --- it is up to the caller to make</span>
<span class="cm"> * sure that there are no further calls to journal_write_metadata</span>
<span class="cm"> * before the revoke is complete.  In ext3, this implies calling the</span>
<span class="cm"> * revoke before clearing the block bitmap when we are deleting</span>
<span class="cm"> * metadata.</span>
<span class="cm"> *</span>
<span class="cm"> * Revoke performs a jbd2_journal_forget on any buffer_head passed in as a</span>
<span class="cm"> * parameter, but does _not_ forget the buffer_head if the bh was only</span>
<span class="cm"> * found implicitly.</span>
<span class="cm"> *</span>
<span class="cm"> * bh_in may not be a journalled buffer - it may have come off</span>
<span class="cm"> * the hash tables without an attached journal_head.</span>
<span class="cm"> *</span>
<span class="cm"> * If bh_in is non-zero, jbd2_journal_revoke() will decrement its b_count</span>
<span class="cm"> * by one.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">jbd2_journal_revoke</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">blocknr</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_in</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh_in</span><span class="p">)</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh_in</span><span class="p">,</span> <span class="s">&quot;enter&quot;</span><span class="p">);</span>

	<span class="n">journal</span> <span class="o">=</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jbd2_journal_set_features</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">JBD2_FEATURE_INCOMPAT_REVOKE</span><span class="p">)){</span>
		<span class="n">J_ASSERT</span> <span class="p">(</span><span class="o">!</span><span class="s">&quot;Cannot set revoke feature!&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bdev</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_fs_dev</span><span class="p">;</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">bh_in</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">__find_get_block</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_blocksize</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;found on hash&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#ifdef JBD2_EXPENSIVE_CHECKING</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh2</span><span class="p">;</span>

		<span class="cm">/* If there is a different buffer_head lying around in</span>
<span class="cm">		 * memory anywhere... */</span>
		<span class="n">bh2</span> <span class="o">=</span> <span class="n">__find_get_block</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_blocksize</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh2</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* ... and it has RevokeValid status... */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh2</span> <span class="o">!=</span> <span class="n">bh</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_revokevalid</span><span class="p">(</span><span class="n">bh2</span><span class="p">))</span>
				<span class="cm">/* ...then it better be revoked too,</span>
<span class="cm">				 * since it&#39;s illegal to create a revoke</span>
<span class="cm">				 * record against a buffer_head which is</span>
<span class="cm">				 * not marked revoked --- that would</span>
<span class="cm">				 * risk missing a subsequent revoke</span>
<span class="cm">				 * cancel. */</span>
				<span class="n">J_ASSERT_BH</span><span class="p">(</span><span class="n">bh2</span><span class="p">,</span> <span class="n">buffer_revoked</span><span class="p">(</span><span class="n">bh2</span><span class="p">));</span>
			<span class="n">put_bh</span><span class="p">(</span><span class="n">bh2</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* We really ought not ever to revoke twice in a row without</span>
<span class="cm">           first having the revoke cancelled: it&#39;s illegal to free a</span>
<span class="cm">           block twice without allocating it in between! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">J_EXPECT_BH</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="o">!</span><span class="n">buffer_revoked</span><span class="p">(</span><span class="n">bh</span><span class="p">),</span>
				 <span class="s">&quot;inconsistent data on disk&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh_in</span><span class="p">)</span>
				<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">set_buffer_revoked</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">set_buffer_revokevalid</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh_in</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh_in</span><span class="p">,</span> <span class="s">&quot;call jbd2_journal_forget&quot;</span><span class="p">);</span>
			<span class="n">jbd2_journal_forget</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">bh_in</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;call brelse&quot;</span><span class="p">);</span>
			<span class="n">__brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;insert revoke for block %llu, bh_in=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">blocknr</span><span class="p">,</span> <span class="n">bh_in</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">insert_revoke_hash</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span>
				<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">);</span>
	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh_in</span><span class="p">,</span> <span class="s">&quot;exit&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Cancel an outstanding revoke.  For use only internally by the</span>
<span class="cm"> * journaling code (called from jbd2_journal_get_write_access).</span>
<span class="cm"> *</span>
<span class="cm"> * We trust buffer_revoked() on the buffer if the buffer is already</span>
<span class="cm"> * being journaled: if there is no revoke pending on the buffer, then we</span>
<span class="cm"> * don&#39;t do anything here.</span>
<span class="cm"> *</span>
<span class="cm"> * This would break if it were possible for a buffer to be revoked and</span>
<span class="cm"> * discarded, and then reallocated within the same transaction.  In such</span>
<span class="cm"> * a case we would have lost the revoked bit, but when we arrived here</span>
<span class="cm"> * the second time we would still have a pending revoke to cancel.  So,</span>
<span class="cm"> * do not trust the Revoked bit on buffers unless RevokeValid is also</span>
<span class="cm"> * set.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">jbd2_journal_cancel_revoke</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jbd2_revoke_record_s</span> <span class="o">*</span><span class="n">record</span><span class="p">;</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">need_cancel</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">did_revoke</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* akpm: debug */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;journal_head %p, cancelling revoke</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">jh</span><span class="p">);</span>

	<span class="cm">/* Is the existing Revoke bit valid?  If so, we trust it, and</span>
<span class="cm">	 * only perform the full cancel if the revoke bit is set.  If</span>
<span class="cm">	 * not, we can&#39;t trust the revoke bit, and we need to do the</span>
<span class="cm">	 * full search for a revoke record. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_set_buffer_revokevalid</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">need_cancel</span> <span class="o">=</span> <span class="n">test_clear_buffer_revoked</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">need_cancel</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">clear_buffer_revoked</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">need_cancel</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">record</span> <span class="o">=</span> <span class="n">find_revoke_record</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">record</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;cancelled existing revoke on &quot;</span>
				  <span class="s">&quot;blocknr %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_lock</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">record</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_lock</span><span class="p">);</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">jbd2_revoke_record_cache</span><span class="p">,</span> <span class="n">record</span><span class="p">);</span>
			<span class="n">did_revoke</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="cp">#ifdef JBD2_EXPENSIVE_CHECKING</span>
	<span class="cm">/* There better not be one left behind by now! */</span>
	<span class="n">record</span> <span class="o">=</span> <span class="n">find_revoke_record</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
	<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">record</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Finally, have we just cleared revoke on an unhashed</span>
<span class="cm">	 * buffer_head?  If so, we&#39;d better make sure we clear the</span>
<span class="cm">	 * revoked status on any hashed alias too, otherwise the revoke</span>
<span class="cm">	 * state machine will get very upset later on. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_cancel</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh2</span><span class="p">;</span>
		<span class="n">bh2</span> <span class="o">=</span> <span class="n">__find_get_block</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh2</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh2</span> <span class="o">!=</span> <span class="n">bh</span><span class="p">)</span>
				<span class="n">clear_buffer_revoked</span><span class="p">(</span><span class="n">bh2</span><span class="p">);</span>
			<span class="n">__brelse</span><span class="p">(</span><span class="n">bh2</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">did_revoke</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * journal_clear_revoked_flag clears revoked flag of buffers in</span>
<span class="cm"> * revoke table to reflect there is no revoked buffers in the next</span>
<span class="cm"> * transaction which is going to be started.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">jbd2_clear_buffer_revoked_flags</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jbd2_revoke_table_s</span> <span class="o">*</span><span class="n">revoke</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">revoke</span><span class="o">-&gt;</span><span class="n">hash_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">hash_list</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list_entry</span><span class="p">;</span>
		<span class="n">hash_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">revoke</span><span class="o">-&gt;</span><span class="n">hash_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">list_for_each</span><span class="p">(</span><span class="n">list_entry</span><span class="p">,</span> <span class="n">hash_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">jbd2_revoke_record_s</span> <span class="o">*</span><span class="n">record</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
			<span class="n">record</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">jbd2_revoke_record_s</span> <span class="o">*</span><span class="p">)</span><span class="n">list_entry</span><span class="p">;</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="n">__find_get_block</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_fs_dev</span><span class="p">,</span>
					      <span class="n">record</span><span class="o">-&gt;</span><span class="n">blocknr</span><span class="p">,</span>
					      <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_blocksize</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">clear_buffer_revoked</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">__brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* journal_switch_revoke table select j_revoke for next transaction</span>
<span class="cm"> * we do not want to suspend any processing until all revokes are</span>
<span class="cm"> * written -bzzz</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">jbd2_journal_switch_revoke_table</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke</span> <span class="o">==</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_table</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_table</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_table</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke</span><span class="o">-&gt;</span><span class="n">hash_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke</span><span class="o">-&gt;</span><span class="n">hash_table</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write revoke records to the journal for all entries in the current</span>
<span class="cm"> * revoke hash, deleting the entries as we go.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">jbd2_journal_write_revoke_records</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span>
				       <span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">write_op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">descriptor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jbd2_revoke_record_s</span> <span class="o">*</span><span class="n">record</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jbd2_revoke_table_s</span> <span class="o">*</span><span class="n">revoke</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">hash_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">descriptor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* select revoke table for committing transaction */</span>
	<span class="n">revoke</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke</span> <span class="o">==</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_table</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_table</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_table</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">revoke</span><span class="o">-&gt;</span><span class="n">hash_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hash_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">revoke</span><span class="o">-&gt;</span><span class="n">hash_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">hash_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">record</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">jbd2_revoke_record_s</span> <span class="o">*</span><span class="p">)</span>
				<span class="n">hash_list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">write_one_revoke_record</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">transaction</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">descriptor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span>
						<span class="n">record</span><span class="p">,</span> <span class="n">write_op</span><span class="p">);</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">record</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">);</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">jbd2_revoke_record_cache</span><span class="p">,</span> <span class="n">record</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">descriptor</span><span class="p">)</span>
		<span class="n">flush_descriptor</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">descriptor</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">write_op</span><span class="p">);</span>
	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Wrote %d revoke records</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write out one revoke record.  We need to create a new descriptor</span>
<span class="cm"> * block if the old one is full or if we have not already created one.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_one_revoke_record</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span>
				    <span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">**</span><span class="n">descriptorp</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="o">*</span><span class="n">offsetp</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">jbd2_revoke_record_s</span> <span class="o">*</span><span class="n">record</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">write_op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">csum_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">descriptor</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">journal_header_t</span> <span class="o">*</span><span class="n">header</span><span class="p">;</span>

	<span class="cm">/* If we are already aborting, this all becomes a noop.  We</span>
<span class="cm">           still need to go round the loop in</span>
<span class="cm">           jbd2_journal_write_revoke_records in order to free all of the</span>
<span class="cm">           revoke records: only the IO to the journal is omitted. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_journal_aborted</span><span class="p">(</span><span class="n">journal</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">descriptor</span> <span class="o">=</span> <span class="o">*</span><span class="n">descriptorp</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="o">*</span><span class="n">offsetp</span><span class="p">;</span>

	<span class="cm">/* Do we need to leave space at the end for a checksum? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">JBD2_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">JBD2_FEATURE_INCOMPAT_CSUM_V2</span><span class="p">))</span>
		<span class="n">csum_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">jbd2_journal_revoke_tail</span><span class="p">);</span>

	<span class="cm">/* Make sure we have a descriptor with space left for the record */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">descriptor</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_blocksize</span> <span class="o">-</span> <span class="n">csum_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">flush_descriptor</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">descriptor</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">write_op</span><span class="p">);</span>
			<span class="n">descriptor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">descriptor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">descriptor</span> <span class="o">=</span> <span class="n">jbd2_journal_get_descriptor_buffer</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">descriptor</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">header</span> <span class="o">=</span> <span class="p">(</span><span class="n">journal_header_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">jh2bh</span><span class="p">(</span><span class="n">descriptor</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">header</span><span class="o">-&gt;</span><span class="n">h_magic</span>     <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">JBD2_MAGIC_NUMBER</span><span class="p">);</span>
		<span class="n">header</span><span class="o">-&gt;</span><span class="n">h_blocktype</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">JBD2_REVOKE_BLOCK</span><span class="p">);</span>
		<span class="n">header</span><span class="o">-&gt;</span><span class="n">h_sequence</span>  <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">);</span>

		<span class="cm">/* Record it so that we can wait for IO completion later */</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">descriptor</span><span class="p">,</span> <span class="s">&quot;file as BJ_LogCtl&quot;</span><span class="p">);</span>
		<span class="n">jbd2_journal_file_buffer</span><span class="p">(</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">transaction</span><span class="p">,</span> <span class="n">BJ_LogCtl</span><span class="p">);</span>

		<span class="n">offset</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jbd2_journal_revoke_header_t</span><span class="p">);</span>
		<span class="o">*</span><span class="n">descriptorp</span> <span class="o">=</span> <span class="n">descriptor</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">JBD2_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">JBD2_FEATURE_INCOMPAT_64BIT</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span> <span class="p">((</span><span class="n">__be64</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">jh2bh</span><span class="p">(</span><span class="n">descriptor</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">[</span><span class="n">offset</span><span class="p">]))</span> <span class="o">=</span>
			<span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">record</span><span class="o">-&gt;</span><span class="n">blocknr</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span> <span class="p">((</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">jh2bh</span><span class="p">(</span><span class="n">descriptor</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">[</span><span class="n">offset</span><span class="p">]))</span> <span class="o">=</span>
			<span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">record</span><span class="o">-&gt;</span><span class="n">blocknr</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">offsetp</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">jbd2_revoke_csum_set</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">j</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">descriptor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jbd2_journal_revoke_tail</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">csum</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">JBD2_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">JBD2_FEATURE_INCOMPAT_CSUM_V2</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">tail</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">jbd2_journal_revoke_tail</span> <span class="o">*</span><span class="p">)</span>
			<span class="p">(</span><span class="n">jh2bh</span><span class="p">(</span><span class="n">descriptor</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">j</span><span class="o">-&gt;</span><span class="n">j_blocksize</span> <span class="o">-</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">jbd2_journal_revoke_tail</span><span class="p">));</span>
	<span class="n">tail</span><span class="o">-&gt;</span><span class="n">r_checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">csum</span> <span class="o">=</span> <span class="n">jbd2_chksum</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="o">-&gt;</span><span class="n">j_csum_seed</span><span class="p">,</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">descriptor</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span>
			   <span class="n">j</span><span class="o">-&gt;</span><span class="n">j_blocksize</span><span class="p">);</span>
	<span class="n">tail</span><span class="o">-&gt;</span><span class="n">r_checksum</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">csum</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Flush a revoke descriptor out to the journal.  If we are aborting,</span>
<span class="cm"> * this is a noop; otherwise we are generating a buffer which needs to</span>
<span class="cm"> * be waited for during commit, so it has to go onto the appropriate</span>
<span class="cm"> * journal buffer list.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_descriptor</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">descriptor</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write_op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">jbd2_journal_revoke_header_t</span> <span class="o">*</span><span class="n">header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">descriptor</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_journal_aborted</span><span class="p">(</span><span class="n">journal</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">header</span> <span class="o">=</span> <span class="p">(</span><span class="n">jbd2_journal_revoke_header_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">descriptor</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="n">header</span><span class="o">-&gt;</span><span class="n">r_count</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
	<span class="n">jbd2_revoke_csum_set</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">descriptor</span><span class="p">);</span>

	<span class="n">set_buffer_jwrite</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;write&quot;</span><span class="p">);</span>
	<span class="n">set_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">write_dirty_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">write_op</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Revoke support for recovery.</span>
<span class="cm"> *</span>
<span class="cm"> * Recovery needs to be able to:</span>
<span class="cm"> *</span>
<span class="cm"> *  record all revoke records, including the tid of the latest instance</span>
<span class="cm"> *  of each revoke in the journal</span>
<span class="cm"> *</span>
<span class="cm"> *  check whether a given block in a given transaction should be replayed</span>
<span class="cm"> *  (ie. has not been revoked by a revoke record in that or a subsequent</span>
<span class="cm"> *  transaction)</span>
<span class="cm"> *</span>
<span class="cm"> *  empty the revoke table after recovery.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * First, setting revoke records.  We create a new revoke record for</span>
<span class="cm"> * every block ever revoked in the log as we scan it for recovery, and</span>
<span class="cm"> * we update the existing records if we find multiple revokes for a</span>
<span class="cm"> * single block.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">jbd2_journal_set_revoke</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">blocknr</span><span class="p">,</span>
		       <span class="n">tid_t</span> <span class="n">sequence</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jbd2_revoke_record_s</span> <span class="o">*</span><span class="n">record</span><span class="p">;</span>

	<span class="n">record</span> <span class="o">=</span> <span class="n">find_revoke_record</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">record</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If we have multiple occurrences, only record the</span>
<span class="cm">		 * latest sequence number in the hashed record */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tid_gt</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">record</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">))</span>
			<span class="n">record</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">sequence</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">insert_revoke_hash</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span> <span class="n">sequence</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Test revoke records.  For a given block referenced in the log, has</span>
<span class="cm"> * that block been revoked?  A revoke record with a given transaction</span>
<span class="cm"> * sequence number revokes all blocks in that transaction and earlier</span>
<span class="cm"> * ones, but later transactions still need replayed.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">jbd2_journal_test_revoke</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">blocknr</span><span class="p">,</span>
			<span class="n">tid_t</span> <span class="n">sequence</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jbd2_revoke_record_s</span> <span class="o">*</span><span class="n">record</span><span class="p">;</span>

	<span class="n">record</span> <span class="o">=</span> <span class="n">find_revoke_record</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">record</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tid_gt</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">record</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Finally, once recovery is over, we need to clear the revoke table so</span>
<span class="cm"> * that it can be reused by the running filesystem.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">jbd2_journal_clear_revoke</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">hash_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jbd2_revoke_record_s</span> <span class="o">*</span><span class="n">record</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jbd2_revoke_table_s</span> <span class="o">*</span><span class="n">revoke</span><span class="p">;</span>

	<span class="n">revoke</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">revoke</span><span class="o">-&gt;</span><span class="n">hash_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hash_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">revoke</span><span class="o">-&gt;</span><span class="n">hash_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">hash_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">record</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">jbd2_revoke_record_s</span><span class="o">*</span><span class="p">)</span> <span class="n">hash_list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">record</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">);</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">jbd2_revoke_record_cache</span><span class="p">,</span> <span class="n">record</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
