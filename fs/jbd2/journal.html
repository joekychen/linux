<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › jbd2 › journal.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>journal.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/fs/jbd2/journal.c</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Stephen C. Tweedie &lt;sct@redhat.com&gt;, 1998</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 1998 Red Hat corp --- All Rights Reserved</span>
<span class="cm"> *</span>
<span class="cm"> * This file is part of the Linux kernel and is made available under</span>
<span class="cm"> * the terms of the GNU General Public License, version 2, or at your</span>
<span class="cm"> * option, any later version, incorporated herein by reference.</span>
<span class="cm"> *</span>
<span class="cm"> * Generic filesystem journal-writing code; part of the ext2fs</span>
<span class="cm"> * journaling system.</span>
<span class="cm"> *</span>
<span class="cm"> * This file manages journals: areas of disk reserved for logging</span>
<span class="cm"> * transactional updates.  This includes the kernel journaling thread</span>
<span class="cm"> * which is responsible for scheduling updates to the log.</span>
<span class="cm"> *</span>
<span class="cm"> * We do not actually manage the physical storage of the journal in this</span>
<span class="cm"> * file: that is left to a per-journal policy function, which allows us</span>
<span class="cm"> * to store the journal within a filesystem-specified area for ext2</span>
<span class="cm"> * journaling (ext2 can use a reserved inode for storing the log).</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/jbd2.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/poison.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/math64.h&gt;</span>
<span class="cp">#include &lt;linux/hash.h&gt;</span>
<span class="cp">#include &lt;linux/log2.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>

<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &lt;trace/events/jbd2.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_extend</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_stop</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_lock_updates</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_unlock_updates</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_get_write_access</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_get_create_access</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_get_undo_access</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_set_triggers</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_dirty_metadata</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_release_buffer</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_forget</span><span class="p">);</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">EXPORT_SYMBOL(journal_sync_buffer);</span>
<span class="cp">#endif</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_flush</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_revoke</span><span class="p">);</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_init_dev</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_init_inode</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_check_used_features</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_check_available_features</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_set_features</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_load</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_destroy</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_abort</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_errno</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_ack_err</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_clear_err</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_log_wait_commit</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_log_start_commit</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_start_commit</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_force_commit_nested</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_wipe</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_blocks_per_page</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_invalidatepage</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_try_to_free_buffers</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_force_commit</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_file_inode</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_init_jbd_inode</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_release_jbd_inode</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_begin_ordered_truncate</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_inode_cache</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__journal_abort_soft</span> <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="kt">int</span> <span class="n">errno</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">jbd2_journal_create_slab</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">slab_size</span><span class="p">);</span>

<span class="cm">/* Checksumming functions */</span>
<span class="kt">int</span> <span class="nf">jbd2_verify_csum_type</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">j</span><span class="p">,</span> <span class="n">journal_superblock_t</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">JBD2_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">JBD2_FEATURE_INCOMPAT_CSUM_V2</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_checksum_type</span> <span class="o">==</span> <span class="n">JBD2_CRC32C_CHKSUM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__u32</span> <span class="nf">jbd2_superblock_csum</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">j</span><span class="p">,</span> <span class="n">journal_superblock_t</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="n">csum</span><span class="p">,</span> <span class="n">old_csum</span><span class="p">;</span>

	<span class="n">old_csum</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_checksum</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">csum</span> <span class="o">=</span> <span class="n">jbd2_chksum</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">journal_superblock_t</span><span class="p">));</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_checksum</span> <span class="o">=</span> <span class="n">old_csum</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">csum</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">jbd2_superblock_csum_verify</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">j</span><span class="p">,</span> <span class="n">journal_superblock_t</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">JBD2_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">JBD2_FEATURE_INCOMPAT_CSUM_V2</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_checksum</span> <span class="o">==</span> <span class="n">jbd2_superblock_csum</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">jbd2_superblock_csum_set</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">j</span><span class="p">,</span> <span class="n">journal_superblock_t</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">JBD2_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">JBD2_FEATURE_INCOMPAT_CSUM_V2</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_checksum</span> <span class="o">=</span> <span class="n">jbd2_superblock_csum</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Helper function used to manage commit timeouts</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">commit_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">)</span> <span class="n">__data</span><span class="p">;</span>

	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * kjournald2: The main thread function used to manage a logging device</span>
<span class="cm"> * journal.</span>
<span class="cm"> *</span>
<span class="cm"> * This kernel thread is responsible for two things:</span>
<span class="cm"> *</span>
<span class="cm"> * 1) COMMIT:  Every so often we need to commit the current state of the</span>
<span class="cm"> *    filesystem to disk.  The journal thread is responsible for writing</span>
<span class="cm"> *    all of the metadata buffers to disk.</span>
<span class="cm"> *</span>
<span class="cm"> * 2) CHECKPOINT: We cannot reuse a used section of the log file until all</span>
<span class="cm"> *    of the data in that part of the log has been rewritten elsewhere on</span>
<span class="cm"> *    the disk.  Flushing these old buffers to reclaim space in the log is</span>
<span class="cm"> *    known as checkpointing, and this thread is responsible for that job.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kjournald2</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up an interval timer which can be used to trigger a commit wakeup</span>
<span class="cm">	 * after the commit interval expires</span>
<span class="cm">	 */</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_timer</span><span class="p">,</span> <span class="n">commit_timeout</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">current</span><span class="p">);</span>

	<span class="n">set_freezable</span><span class="p">();</span>

	<span class="cm">/* Record that the journal thread is running */</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_done_commit</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * And now, wait forever for commit wakeup events.</span>
<span class="cm">	 */</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>

<span class="nl">loop:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">&amp;</span> <span class="n">JBD2_UNMOUNT</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">end_loop</span><span class="p">;</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;commit_sequence=%d, commit_request=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_sequence</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_request</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_sequence</span> <span class="o">!=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_request</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;OK, requests differ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_timer</span><span class="p">);</span>
		<span class="n">jbd2_journal_commit_transaction</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
		<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_done_commit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">freezing</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The simpler the better. Flushing journal isn&#39;t a</span>
<span class="cm">		 * good idea, because that depends on threads that may</span>
<span class="cm">		 * be already stopped.</span>
<span class="cm">		 */</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Now suspending kjournald2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="n">try_to_freeze</span><span class="p">();</span>
		<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We assume on resume that commits are already there,</span>
<span class="cm">		 * so we don&#39;t sleep</span>
<span class="cm">		 */</span>
		<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">should_sleep</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">prepare_to_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_commit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span>
				<span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_sequence</span> <span class="o">!=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_request</span><span class="p">)</span>
			<span class="n">should_sleep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">transaction</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transaction</span> <span class="o">&amp;&amp;</span> <span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
						<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_expires</span><span class="p">))</span>
			<span class="n">should_sleep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">&amp;</span> <span class="n">JBD2_UNMOUNT</span><span class="p">)</span>
			<span class="n">should_sleep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">should_sleep</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_commit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;kjournald2 wakes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Were we woken up by a commit wakeup event?</span>
<span class="cm">	 */</span>
	<span class="n">transaction</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transaction</span> <span class="o">&amp;&amp;</span> <span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_expires</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_request</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;woke because of timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>

<span class="nl">end_loop:</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_timer</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_done_commit</span><span class="p">);</span>
	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Journal thread exiting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">jbd2_journal_start_thread</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">kjournald2</span><span class="p">,</span> <span class="n">journal</span><span class="p">,</span> <span class="s">&quot;jbd2/%s&quot;</span><span class="p">,</span>
			<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_devname</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>

	<span class="n">wait_event</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_done_commit</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_task</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">journal_kill_thread</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">|=</span> <span class="n">JBD2_UNMOUNT</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_commit</span><span class="p">);</span>
		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_done_commit</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_task</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * jbd2_journal_write_metadata_buffer: write a metadata buffer to the journal.</span>
<span class="cm"> *</span>
<span class="cm"> * Writes a metadata buffer to a given disk block.  The actual IO is not</span>
<span class="cm"> * performed but a new buffer_head is constructed which labels the data</span>
<span class="cm"> * to be written with the correct destination disk block.</span>
<span class="cm"> *</span>
<span class="cm"> * Any magic-number escaping which needs to be done will cause a</span>
<span class="cm"> * copy-out here.  If the buffer happens to start with the</span>
<span class="cm"> * JBD2_MAGIC_NUMBER, then we can&#39;t write it to the log directly: the</span>
<span class="cm"> * magic number is only written to the log for descripter blocks.  In</span>
<span class="cm"> * this case, we copy the data and replace the first word with 0, and we</span>
<span class="cm"> * return a result code which indicates that this buffer needs to be</span>
<span class="cm"> * marked as an escaped buffer in the corresponding log descriptor</span>
<span class="cm"> * block.  The missing word can then be restored when the block is read</span>
<span class="cm"> * during recovery.</span>
<span class="cm"> *</span>
<span class="cm"> * If the source buffer has already been modified by a new transaction</span>
<span class="cm"> * since we took the last commit snapshot, we use the frozen copy of</span>
<span class="cm"> * that data for IO.  If we end up using the existing buffer_head&#39;s data</span>
<span class="cm"> * for the write, then we *have* to lock the buffer to prevent anyone</span>
<span class="cm"> * else from using and possibly modifying it while the IO is in</span>
<span class="cm"> * progress.</span>
<span class="cm"> *</span>
<span class="cm"> * The function returns a pointer to the buffer_heads to be used for IO.</span>
<span class="cm"> *</span>
<span class="cm"> * We assume that the journal has already been locked in this function.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value:</span>
<span class="cm"> *  &lt;0: Error</span>
<span class="cm"> * &gt;=0: Finished OK</span>
<span class="cm"> *</span>
<span class="cm"> * On success:</span>
<span class="cm"> * Bit 0 set == escape performed on the data</span>
<span class="cm"> * Bit 1 set == buffer copy-out performed (kfree the data after IO)</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">jbd2_journal_write_metadata_buffer</span><span class="p">(</span><span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">journal_head</span>  <span class="o">*</span><span class="n">jh_in</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">**</span><span class="n">jh_out</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">blocknr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">need_copy_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">done_copy_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">do_escape</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">mapped_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">new_bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">new_jh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">new_page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_in</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh_in</span><span class="p">);</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The buffer really shouldn&#39;t be locked: only the current committing</span>
<span class="cm">	 * transaction is allowed to write it, so nobody else is allowed</span>
<span class="cm">	 * to do any IO.</span>
<span class="cm">	 *</span>
<span class="cm">	 * akpm: except if we&#39;re journalling data, and write() output is</span>
<span class="cm">	 * also part of a shared mapping, and another thread has</span>
<span class="cm">	 * decided to launch a writepage() against this buffer.</span>
<span class="cm">	 */</span>
	<span class="n">J_ASSERT_BH</span><span class="p">(</span><span class="n">bh_in</span><span class="p">,</span> <span class="n">buffer_jbddirty</span><span class="p">(</span><span class="n">bh_in</span><span class="p">));</span>

<span class="nl">retry_alloc:</span>
	<span class="n">new_bh</span> <span class="o">=</span> <span class="n">alloc_buffer_head</span><span class="p">(</span><span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Failure is not an option, but __GFP_NOFAIL is going</span>
<span class="cm">		 * away; so we retry ourselves here.</span>
<span class="cm">		 */</span>
		<span class="n">congestion_wait</span><span class="p">(</span><span class="n">BLK_RW_ASYNC</span><span class="p">,</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">50</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry_alloc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* keep subsequent assertions sane */</span>
	<span class="n">new_bh</span><span class="o">-&gt;</span><span class="n">b_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">init_buffer</span><span class="p">(</span><span class="n">new_bh</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_bh</span><span class="o">-&gt;</span><span class="n">b_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">new_jh</span> <span class="o">=</span> <span class="n">jbd2_journal_add_journal_head</span><span class="p">(</span><span class="n">new_bh</span><span class="p">);</span>	<span class="cm">/* This sleeps */</span>

	<span class="cm">/*</span>
<span class="cm">	 * If a new transaction has already done a buffer copy-out, then</span>
<span class="cm">	 * we use that version of the data for the commit.</span>
<span class="cm">	 */</span>
	<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bh_in</span><span class="p">);</span>
<span class="nl">repeat:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jh_in</span><span class="o">-&gt;</span><span class="n">b_frozen_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">done_copy_out</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">new_page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">jh_in</span><span class="o">-&gt;</span><span class="n">b_frozen_data</span><span class="p">);</span>
		<span class="n">new_offset</span> <span class="o">=</span> <span class="n">offset_in_page</span><span class="p">(</span><span class="n">jh_in</span><span class="o">-&gt;</span><span class="n">b_frozen_data</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">new_page</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh_in</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">;</span>
		<span class="n">new_offset</span> <span class="o">=</span> <span class="n">offset_in_page</span><span class="p">(</span><span class="n">jh2bh</span><span class="p">(</span><span class="n">jh_in</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mapped_data</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Fire data frozen trigger if data already wasn&#39;t frozen.  Do this</span>
<span class="cm">	 * before checking for escaping, as the trigger may modify the magic</span>
<span class="cm">	 * offset.  If a copy-out happens afterwards, it will have the correct</span>
<span class="cm">	 * data in the buffer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done_copy_out</span><span class="p">)</span>
		<span class="n">jbd2_buffer_frozen_trigger</span><span class="p">(</span><span class="n">jh_in</span><span class="p">,</span> <span class="n">mapped_data</span> <span class="o">+</span> <span class="n">new_offset</span><span class="p">,</span>
					   <span class="n">jh_in</span><span class="o">-&gt;</span><span class="n">b_triggers</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for escaping</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)(</span><span class="n">mapped_data</span> <span class="o">+</span> <span class="n">new_offset</span><span class="p">))</span> <span class="o">==</span>
				<span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">JBD2_MAGIC_NUMBER</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">need_copy_out</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">do_escape</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">mapped_data</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do we need to do a data copy?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_copy_out</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">done_copy_out</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

		<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh_in</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">jbd2_alloc</span><span class="p">(</span><span class="n">bh_in</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jbd2_journal_put_journal_head</span><span class="p">(</span><span class="n">new_jh</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bh_in</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jh_in</span><span class="o">-&gt;</span><span class="n">b_frozen_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jbd2_free</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">bh_in</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">jh_in</span><span class="o">-&gt;</span><span class="n">b_frozen_data</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">mapped_data</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">mapped_data</span> <span class="o">+</span> <span class="n">new_offset</span><span class="p">,</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh_in</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">mapped_data</span><span class="p">);</span>

		<span class="n">new_page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">new_offset</span> <span class="o">=</span> <span class="n">offset_in_page</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">done_copy_out</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * This isn&#39;t strictly necessary, as we&#39;re using frozen</span>
<span class="cm">		 * data for the escaping, but it keeps consistency with</span>
<span class="cm">		 * b_frozen_data usage.</span>
<span class="cm">		 */</span>
		<span class="n">jh_in</span><span class="o">-&gt;</span><span class="n">b_frozen_triggers</span> <span class="o">=</span> <span class="n">jh_in</span><span class="o">-&gt;</span><span class="n">b_triggers</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Did we need to do an escaping?  Now we&#39;ve done all the</span>
<span class="cm">	 * copying, we can finally do so.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_escape</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mapped_data</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>
		<span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">mapped_data</span> <span class="o">+</span> <span class="n">new_offset</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">mapped_data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">set_bh_page</span><span class="p">(</span><span class="n">new_bh</span><span class="p">,</span> <span class="n">new_page</span><span class="p">,</span> <span class="n">new_offset</span><span class="p">);</span>
	<span class="n">new_jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">new_bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh_in</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>
	<span class="n">new_bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span><span class="o">-&gt;</span><span class="n">j_dev</span><span class="p">;</span>
	<span class="n">new_bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">=</span> <span class="n">blocknr</span><span class="p">;</span>
	<span class="n">set_buffer_mapped</span><span class="p">(</span><span class="n">new_bh</span><span class="p">);</span>
	<span class="n">set_buffer_dirty</span><span class="p">(</span><span class="n">new_bh</span><span class="p">);</span>

	<span class="o">*</span><span class="n">jh_out</span> <span class="o">=</span> <span class="n">new_jh</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The to-be-written buffer needs to get moved to the io queue,</span>
<span class="cm">	 * and the original buffer whose contents we are shadowing or</span>
<span class="cm">	 * copying is moved to the transaction&#39;s shadow queue.</span>
<span class="cm">	 */</span>
	<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh_in</span><span class="p">,</span> <span class="s">&quot;file as BJ_Shadow&quot;</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="n">__jbd2_journal_file_buffer</span><span class="p">(</span><span class="n">jh_in</span><span class="p">,</span> <span class="n">transaction</span><span class="p">,</span> <span class="n">BJ_Shadow</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh_in</span><span class="p">);</span>

	<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">new_jh</span><span class="p">,</span> <span class="s">&quot;file as BJ_IO&quot;</span><span class="p">);</span>
	<span class="n">jbd2_journal_file_buffer</span><span class="p">(</span><span class="n">new_jh</span><span class="p">,</span> <span class="n">transaction</span><span class="p">,</span> <span class="n">BJ_IO</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">do_escape</span> <span class="o">|</span> <span class="p">(</span><span class="n">done_copy_out</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocation code for the journal file.  Manage the space left in the</span>
<span class="cm"> * journal, so that we can begin checkpointing when appropriate.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * __jbd2_log_space_left: Return the number of free blocks left in the journal.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with the journal already locked.</span>
<span class="cm"> *</span>
<span class="cm"> * Called under j_state_lock</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">__jbd2_log_space_left</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_free</span><span class="p">;</span>

	<span class="cm">/* assert_spin_locked(&amp;journal-&gt;j_state_lock); */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Be pessimistic here about the number of those free blocks which</span>
<span class="cm">	 * might be required for log descriptor control blocks.</span>
<span class="cm">	 */</span>

<span class="cp">#define MIN_LOG_RESERVED_BLOCKS 32 </span><span class="cm">/* Allow for rounding errors */</span><span class="cp"></span>

	<span class="n">left</span> <span class="o">-=</span> <span class="n">MIN_LOG_RESERVED_BLOCKS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">left</span> <span class="o">-=</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">left</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called with j_state_lock locked for writing.</span>
<span class="cm"> * Returns true if a transaction commit was started.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__jbd2_log_start_commit</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid_t</span> <span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The only transaction we can possibly wait upon is the</span>
<span class="cm">	 * currently running transaction (if it exists).  Otherwise,</span>
<span class="cm">	 * the target tid must be an old one.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span> <span class="o">&amp;&amp;</span>
	    <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We want a new commit: OK, mark the request and wakeup the</span>
<span class="cm">		 * commit thread.  We do _not_ do the commit ourselves.</span>
<span class="cm">		 */</span>

		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_request</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;JBD2: requesting commit %d/%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_request</span><span class="p">,</span>
			  <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_sequence</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_commit</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tid_geq</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_request</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span>
		<span class="cm">/* This should never happen, but if it does, preserve</span>
<span class="cm">		   the evidence before kjournald goes into a loop and</span>
<span class="cm">		   increments j_commit_sequence beyond all recognition. */</span>
		<span class="n">WARN_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;JBD2: bad log_start_commit: %u %u %u %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_request</span><span class="p">,</span>
			  <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_sequence</span><span class="p">,</span>
			  <span class="n">target</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span> <span class="o">?</span> 
			  <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">jbd2_log_start_commit</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid_t</span> <span class="n">tid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__jbd2_log_start_commit</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Force and wait upon a commit if the calling process is not within</span>
<span class="cm"> * transaction.  This is used for forcing out undo-protected data which contains</span>
<span class="cm"> * bitmaps, when the fs is running out of space.</span>
<span class="cm"> *</span>
<span class="cm"> * We can only force the running transaction if we don&#39;t have an active handle;</span>
<span class="cm"> * otherwise, we will deadlock.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if a transaction was started.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">jbd2_journal_force_commit_nested</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">tid_t</span> <span class="n">tid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">need_to_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transaction</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tid_geq</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_request</span><span class="p">,</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">))</span>
			<span class="n">need_to_start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">)</span>
		<span class="n">transaction</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transaction</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Nothing to retry */</span>
	<span class="p">}</span>

	<span class="n">tid</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_to_start</span><span class="p">)</span>
		<span class="n">jbd2_log_start_commit</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
	<span class="n">jbd2_log_wait_commit</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Start a commit of the current running transaction (if any).  Returns true</span>
<span class="cm"> * if a transaction is going to be committed (or is currently already</span>
<span class="cm"> * committing), and fills its tid in at *ptid</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">jbd2_journal_start_commit</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid_t</span> <span class="o">*</span><span class="n">ptid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tid_t</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>

		<span class="n">__jbd2_log_start_commit</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
		<span class="cm">/* There&#39;s a running transaction and we&#39;ve just made sure</span>
<span class="cm">		 * it&#39;s commit has been scheduled. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptid</span><span class="p">)</span>
			<span class="o">*</span><span class="n">ptid</span> <span class="o">=</span> <span class="n">tid</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If ext3_write_super() recently started a commit, then we</span>
<span class="cm">		 * have to wait for completion of that transaction</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptid</span><span class="p">)</span>
			<span class="o">*</span><span class="n">ptid</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return 1 if a given transaction has not yet sent barrier request</span>
<span class="cm"> * connected with a transaction commit. If 0 is returned, transaction</span>
<span class="cm"> * may or may not have sent the barrier. Used to avoid sending barrier</span>
<span class="cm"> * twice in common cases.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">jbd2_trans_will_send_data_barrier</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid_t</span> <span class="n">tid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">commit_trans</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">&amp;</span> <span class="n">JBD2_BARRIER</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="cm">/* Transaction already committed? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tid_geq</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_sequence</span><span class="p">,</span> <span class="n">tid</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">commit_trans</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">commit_trans</span> <span class="o">||</span> <span class="n">commit_trans</span><span class="o">-&gt;</span><span class="n">t_tid</span> <span class="o">!=</span> <span class="n">tid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Transaction is being committed and we already proceeded to</span>
<span class="cm">	 * submitting a flush to fs partition?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_fs_dev</span> <span class="o">!=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">commit_trans</span><span class="o">-&gt;</span><span class="n">t_need_data_flush</span> <span class="o">||</span>
		    <span class="n">commit_trans</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">&gt;=</span> <span class="n">T_COMMIT_DFLUSH</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">commit_trans</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">&gt;=</span> <span class="n">T_COMMIT_JFLUSH</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_trans_will_send_data_barrier</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Wait for a specified commit to complete.</span>
<span class="cm"> * The caller may not hold the journal lock.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">jbd2_log_wait_commit</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid_t</span> <span class="n">tid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_JBD2_DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tid_geq</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_request</span><span class="p">,</span> <span class="n">tid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span>
		       <span class="s">&quot;%s: error: j_commit_request=%d, tid=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_request</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tid_gt</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_sequence</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;JBD2: want %d, j_commit_sequence=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">tid</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_sequence</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_commit</span><span class="p">);</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_done_commit</span><span class="p">,</span>
				<span class="o">!</span><span class="n">tid_gt</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_sequence</span><span class="p">));</span>
		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_journal_aborted</span><span class="p">(</span><span class="n">journal</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;journal commit I/O error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Log buffer allocation routines:</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">jbd2_journal_next_log_block</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">retp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">blocknr</span><span class="p">;</span>

	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_free</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">blocknr</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_head</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_head</span><span class="o">++</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_free</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_head</span> <span class="o">==</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last</span><span class="p">)</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_head</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_first</span><span class="p">;</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">jbd2_journal_bmap</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span> <span class="n">retp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Conversion of logical to physical block numbers for the journal</span>
<span class="cm"> *</span>
<span class="cm"> * On external journals the journal blocks are identity-mapped, so</span>
<span class="cm"> * this is a no-op.  If needed, we can use j_blk_offset - everything is</span>
<span class="cm"> * ready.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">jbd2_journal_bmap</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">blocknr</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">retp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">bmap</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_inode</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="o">*</span><span class="n">retp</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;%s: journal block not found &quot;</span>
					<span class="s">&quot;at offset %lu on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_devname</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="n">__journal_abort_soft</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">retp</span> <span class="o">=</span> <span class="n">blocknr</span><span class="p">;</span> <span class="cm">/* +journal-&gt;j_blk_offset */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We play buffer_head aliasing tricks to write data/metadata blocks to</span>
<span class="cm"> * the journal without copying their contents, but for journal</span>
<span class="cm"> * descriptor blocks we do need to generate bona fide buffers.</span>
<span class="cm"> *</span>
<span class="cm"> * After the caller of jbd2_journal_get_descriptor_buffer() has finished modifying</span>
<span class="cm"> * the buffer&#39;s contents they really should run flush_dcache_page(bh-&gt;b_page).</span>
<span class="cm"> * But we don&#39;t bother doing that, so there will be coherency problems with</span>
<span class="cm"> * mmaps of blockdevs which hold live JBD-controlled filesystems.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="nf">jbd2_journal_get_descriptor_buffer</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">blocknr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">jbd2_journal_next_log_block</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blocknr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">__getblk</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_blocksize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_blocksize</span><span class="p">);</span>
	<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;return this buffer&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">jbd2_journal_add_journal_head</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return tid of the oldest transaction in the journal and block in the journal</span>
<span class="cm"> * where the transaction starts.</span>
<span class="cm"> *</span>
<span class="cm"> * If the journal is now empty, return which will be the next transaction ID</span>
<span class="cm"> * we will write and where will that transaction start.</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is 0 if journal tail cannot be pushed any further, 1 if</span>
<span class="cm"> * it can.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">jbd2_journal_get_log_tail</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid_t</span> <span class="o">*</span><span class="n">tid</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="n">transaction</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_transactions</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transaction</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">tid</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>
		<span class="o">*</span><span class="n">block</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_log_start</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">transaction</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">tid</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>
		<span class="o">*</span><span class="n">block</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_log_start</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">transaction</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">tid</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>
		<span class="o">*</span><span class="n">block</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_head</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">tid</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_transaction_sequence</span><span class="p">;</span>
		<span class="o">*</span><span class="n">block</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_head</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">tid_gt</span><span class="p">(</span><span class="o">*</span><span class="n">tid</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail_sequence</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update information in journal structure and in on disk journal superblock</span>
<span class="cm"> * about log tail. This function does not check whether information passed in</span>
<span class="cm"> * really pushes log tail further. It&#39;s responsibility of the caller to make</span>
<span class="cm"> * sure provided log tail information is valid (e.g. by holding</span>
<span class="cm"> * j_checkpoint_mutex all the time between computing log tail and calling this</span>
<span class="cm"> * function as is the case with jbd2_cleanup_journal_tail()).</span>
<span class="cm"> *</span>
<span class="cm"> * Requires j_checkpoint_mutex</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__jbd2_update_log_tail</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">freed</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_mutex</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * We cannot afford for write to remain in drive&#39;s caches since as</span>
<span class="cm">	 * soon as we update j_tail, next transaction can start reusing journal</span>
<span class="cm">	 * space and if we lose sb update during power failure we&#39;d replay</span>
<span class="cm">	 * old transaction with possibly newly overwritten data.</span>
<span class="cm">	 */</span>
	<span class="n">jbd2_journal_update_sb_log_tail</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">WRITE_FUA</span><span class="p">);</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="n">freed</span> <span class="o">=</span> <span class="n">block</span> <span class="o">-</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&lt;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail</span><span class="p">)</span>
		<span class="n">freed</span> <span class="o">+=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last</span> <span class="o">-</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_first</span><span class="p">;</span>

	<span class="n">trace_jbd2_update_log_tail</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">freed</span><span class="p">);</span>
	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span>
		  <span class="s">&quot;Cleaning journal tail from %d to %d (offset %lu), &quot;</span>
		  <span class="s">&quot;freeing %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail_sequence</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">freed</span><span class="p">);</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_free</span> <span class="o">+=</span> <span class="n">freed</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail_sequence</span> <span class="o">=</span> <span class="n">tid</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is a variaon of __jbd2_update_log_tail which checks for validity of</span>
<span class="cm"> * provided log tail and locks j_checkpoint_mutex. So it is safe against races</span>
<span class="cm"> * with other threads updating log tail.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">jbd2_update_log_tail</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid_t</span> <span class="n">tid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tid_gt</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail_sequence</span><span class="p">))</span>
		<span class="n">__jbd2_update_log_tail</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">jbd2_stats_proc_session</span> <span class="p">{</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">transaction_stats_s</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">jbd2_seq_info_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">pos</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">SEQ_START_TOKEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">jbd2_seq_info_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">jbd2_seq_info_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jbd2_stats_proc_session</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">SEQ_START_TOKEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%lu transaction, each up to %u blocks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">ts_tid</span><span class="p">,</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_transaction_buffers</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">ts_tid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;average: </span><span class="se">\n</span><span class="s">  %ums waiting for transaction</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">.</span><span class="n">rs_wait</span> <span class="o">/</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">ts_tid</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  %ums running transaction</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">.</span><span class="n">rs_running</span> <span class="o">/</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">ts_tid</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  %ums transaction was being locked</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">.</span><span class="n">rs_locked</span> <span class="o">/</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">ts_tid</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  %ums flushing data (in ordered mode)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">.</span><span class="n">rs_flushing</span> <span class="o">/</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">ts_tid</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  %ums logging transaction</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">.</span><span class="n">rs_logging</span> <span class="o">/</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">ts_tid</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  %lluus average transaction commit time</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">div_u64</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_average_commit_time</span><span class="p">,</span> <span class="mi">1000</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  %lu handles per transaction</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">.</span><span class="n">rs_handle_count</span> <span class="o">/</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">ts_tid</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  %lu blocks per transaction</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">.</span><span class="n">rs_blocks</span> <span class="o">/</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">ts_tid</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  %lu logged blocks per transaction</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">.</span><span class="n">rs_blocks_logged</span> <span class="o">/</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">ts_tid</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">jbd2_seq_info_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">jbd2_seq_info_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span>  <span class="o">=</span> <span class="n">jbd2_seq_info_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>   <span class="o">=</span> <span class="n">jbd2_seq_info_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>   <span class="o">=</span> <span class="n">jbd2_seq_info_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>   <span class="o">=</span> <span class="n">jbd2_seq_info_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">jbd2_seq_info_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">PDE</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jbd2_stats_proc_session</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">transaction_stats_s</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_history_lock</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_stats</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">journal</span> <span class="o">=</span> <span class="n">journal</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_history_lock</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">jbd2_seq_info_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">jbd2_seq_info_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jbd2_stats_proc_session</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">seq_release</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">jbd2_seq_info_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>           <span class="o">=</span> <span class="n">jbd2_seq_info_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>           <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>         <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>        <span class="o">=</span> <span class="n">jbd2_seq_info_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">proc_jbd2_stats</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">jbd2_stats_proc_init</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_proc_entry</span> <span class="o">=</span> <span class="n">proc_mkdir</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_devname</span><span class="p">,</span> <span class="n">proc_jbd2_stats</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_proc_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">proc_create_data</span><span class="p">(</span><span class="s">&quot;info&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_proc_entry</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">jbd2_seq_info_fops</span><span class="p">,</span> <span class="n">journal</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">jbd2_stats_proc_exit</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;info&quot;</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_proc_entry</span><span class="p">);</span>
	<span class="n">remove_proc_entry</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_devname</span><span class="p">,</span> <span class="n">proc_jbd2_stats</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Management for journal control blocks: functions to create and</span>
<span class="cm"> * destroy journal_t structures, and to initialise and read existing</span>
<span class="cm"> * journal blocks from disk.  */</span>

<span class="cm">/* First: create and setup a journal_t object in memory.  We initialise</span>
<span class="cm"> * very few fields yet: that has to wait until we have created the</span>
<span class="cm"> * journal structures from from scratch, or loaded them from disk. */</span>

<span class="k">static</span> <span class="n">journal_t</span> <span class="o">*</span> <span class="nf">journal_init_common</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">journal</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">journal</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_transaction_locked</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_logspace</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_done_commit</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_checkpoint</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_commit</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_updates</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_barrier</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="n">rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_interval</span> <span class="o">=</span> <span class="p">(</span><span class="n">HZ</span> <span class="o">*</span> <span class="n">JBD2_DEFAULT_MAX_COMMIT_AGE</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_min_batch_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_batch_time</span> <span class="o">=</span> <span class="mi">15000</span><span class="p">;</span> <span class="cm">/* 15ms */</span>

	<span class="cm">/* The journal is marked for error until we succeed with recovery! */</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">=</span> <span class="n">JBD2_ABORT</span><span class="p">;</span>

	<span class="cm">/* Set up a default-sized revoke table for the new mount. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">jbd2_journal_init_revoke</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">JOURNAL_REVOKE_DEFAULT_HASH</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_history_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">journal</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* jbd2_journal_init_dev and jbd2_journal_init_inode:</span>
<span class="cm"> *</span>
<span class="cm"> * Create a journal structure assigned some fixed set of disk blocks to</span>
<span class="cm"> * the journal.  We don&#39;t actually touch those disk blocks yet, but we</span>
<span class="cm"> * need to set up all of the mapping information to tell the journaling</span>
<span class="cm"> * system where the journal blocks are.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> *  journal_t * jbd2_journal_init_dev() - creates and initialises a journal structure</span>
<span class="cm"> *  @bdev: Block device on which to create the journal</span>
<span class="cm"> *  @fs_dev: Device which hold journalled filesystem for this journal.</span>
<span class="cm"> *  @start: Block nr Start of journal.</span>
<span class="cm"> *  @len:  Length of the journal in blocks.</span>
<span class="cm"> *  @blocksize: blocksize of journalling device</span>
<span class="cm"> *</span>
<span class="cm"> *  Returns: a newly created journal_t *</span>
<span class="cm"> *</span>
<span class="cm"> *  jbd2_journal_init_dev creates a journal which maps a fixed contiguous</span>
<span class="cm"> *  range of blocks on an arbitrary block device.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="n">journal_t</span> <span class="o">*</span> <span class="nf">jbd2_journal_init_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">fs_dev</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blocksize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">journal_init_common</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* journal descriptor can store up to n blocks -bzzz */</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_blocksize</span> <span class="o">=</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev</span> <span class="o">=</span> <span class="n">bdev</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_fs_dev</span> <span class="o">=</span> <span class="n">fs_dev</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_blk_offset</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_maxlen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">bdevname</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_devname</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_devname</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">)))</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;!&#39;</span><span class="p">;</span>
	<span class="n">jbd2_stats_proc_init</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_blocksize</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">journal_block_tag_t</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wbufsize</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wbuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span><span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Can&#39;t allocate bhs for commit thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">__getblk</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_blocksize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;%s: Cannot get buffer for journal superblock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_sb_buffer</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_superblock</span> <span class="o">=</span> <span class="p">(</span><span class="n">journal_superblock_t</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">journal</span><span class="p">;</span>
<span class="nl">out_err:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wbuf</span><span class="p">);</span>
	<span class="n">jbd2_stats_proc_exit</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  journal_t * jbd2_journal_init_inode () - creates a journal which maps to a inode.</span>
<span class="cm"> *  @inode: An inode to create the journal in</span>
<span class="cm"> *</span>
<span class="cm"> * jbd2_journal_init_inode creates a journal which maps an on-disk inode as</span>
<span class="cm"> * the journal.  The inode must exist already, must support bmap() and</span>
<span class="cm"> * must have all data blocks preallocated.</span>
<span class="cm"> */</span>
<span class="n">journal_t</span> <span class="o">*</span> <span class="nf">jbd2_journal_init_inode</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">journal_init_common</span><span class="p">();</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">blocknr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_fs_dev</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>
	<span class="n">bdevname</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_devname</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_devname</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">)))</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;!&#39;</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_devname</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_devname</span><span class="p">);</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;-%lu&quot;</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span>
		  <span class="s">&quot;journal %p: inode %s/%ld, size %Ld, bits %d, blksize %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">journal</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
		  <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span>
		  <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_maxlen</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_blocksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="n">jbd2_stats_proc_init</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>

	<span class="cm">/* journal descriptor can store up to n blocks -bzzz */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_blocksize</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">journal_block_tag_t</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wbufsize</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wbuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span><span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Can&#39;t allocate bhs for commit thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">jbd2_journal_bmap</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blocknr</span><span class="p">);</span>
	<span class="cm">/* If that failed, give up */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Cannot locate journal superblock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">__getblk</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_blocksize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;%s: Cannot get buffer for journal superblock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_sb_buffer</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_superblock</span> <span class="o">=</span> <span class="p">(</span><span class="n">journal_superblock_t</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">journal</span><span class="p">;</span>
<span class="nl">out_err:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wbuf</span><span class="p">);</span>
	<span class="n">jbd2_stats_proc_exit</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If the journal init or create aborts, we need to mark the journal</span>
<span class="cm"> * superblock as being NULL to prevent the journal destroy from writing</span>
<span class="cm"> * back a bogus superblock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">journal_fail_superblock</span> <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_sb_buffer</span><span class="p">;</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_sb_buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Given a journal_t structure, initialise the various fields for</span>
<span class="cm"> * startup of a new journaling session.  We use this both when creating</span>
<span class="cm"> * a journal, and after recovering an old journal to reset it for</span>
<span class="cm"> * subsequent use.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">journal_reset</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">journal_superblock_t</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_superblock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">;</span>

	<span class="n">first</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_first</span><span class="p">);</span>
	<span class="n">last</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_maxlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">+</span> <span class="n">JBD2_MIN_JOURNAL_BLOCKS</span> <span class="o">&gt;</span> <span class="n">last</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;JBD2: Journal too short (blocks %llu-%llu).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
		<span class="n">journal_fail_superblock</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_first</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_head</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_free</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">;</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail_sequence</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_transaction_sequence</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_sequence</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_transaction_sequence</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_request</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_sequence</span><span class="p">;</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_transaction_buffers</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_maxlen</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * As a special case, if the on-disk copy is already marked as needing</span>
<span class="cm">	 * no recovery (s_start == 0), then we can safely defer the superblock</span>
<span class="cm">	 * update until the next commit by setting JBD2_FLUSHED.  This avoids</span>
<span class="cm">	 * attempting a write to a potential-readonly device.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;JBD2: Skipping superblock update on recovered sb &quot;</span>
			<span class="s">&quot;(start %ld, seq %d, errno %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail_sequence</span><span class="p">,</span>
			<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_errno</span><span class="p">);</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">|=</span> <span class="n">JBD2_FLUSHED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Lock here to make assertions happy... */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_mutex</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Update log tail information. We use WRITE_FUA since new</span>
<span class="cm">		 * transaction will start reusing journal space and so we</span>
<span class="cm">		 * must make sure information about current log tail is on</span>
<span class="cm">		 * disk before that.</span>
<span class="cm">		 */</span>
		<span class="n">jbd2_journal_update_sb_log_tail</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span>
						<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail_sequence</span><span class="p">,</span>
						<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail</span><span class="p">,</span>
						<span class="n">WRITE_FUA</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_mutex</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">jbd2_journal_start_thread</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">jbd2_write_superblock</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write_op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_sb_buffer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">trace_jbd2_write_superblock</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">write_op</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">&amp;</span> <span class="n">JBD2_BARRIER</span><span class="p">))</span>
		<span class="n">write_op</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">REQ_FUA</span> <span class="o">|</span> <span class="n">REQ_FLUSH</span><span class="p">);</span>
	<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_write_io_error</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Oh, dear.  A previous attempt to write the journal</span>
<span class="cm">		 * superblock failed.  This could happen because the</span>
<span class="cm">		 * USB device was yanked out.  Or it could happen to</span>
<span class="cm">		 * be a transient write error and maybe the block will</span>
<span class="cm">		 * be remapped.  Nothing we can do but to retry the</span>
<span class="cm">		 * write and hope for the best.</span>
<span class="cm">		 */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;JBD2: previous I/O error detected &quot;</span>
		       <span class="s">&quot;for journal superblock update for %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_devname</span><span class="p">);</span>
		<span class="n">clear_buffer_write_io_error</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">end_buffer_write_sync</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">submit_bh</span><span class="p">(</span><span class="n">write_op</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_write_io_error</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">clear_buffer_write_io_error</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;JBD2: Error %d detected when updating &quot;</span>
		       <span class="s">&quot;journal superblock for %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span>
		       <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_devname</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * jbd2_journal_update_sb_log_tail() - Update log tail in journal sb on disk.</span>
<span class="cm"> * @journal: The journal to update.</span>
<span class="cm"> * @tail_tid: TID of the new transaction at the tail of the log</span>
<span class="cm"> * @tail_block: The first block of the transaction at the tail of the log</span>
<span class="cm"> * @write_op: With which operation should we write the journal sb</span>
<span class="cm"> *</span>
<span class="cm"> * Update a journal&#39;s superblock information about log tail and write it to</span>
<span class="cm"> * disk, waiting for the IO to complete.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">jbd2_journal_update_sb_log_tail</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid_t</span> <span class="n">tail_tid</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tail_block</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write_op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">journal_superblock_t</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_superblock</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_mutex</span><span class="p">));</span>
	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;JBD2: updating superblock (start %lu, seq %u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">tail_block</span><span class="p">,</span> <span class="n">tail_tid</span><span class="p">);</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_sequence</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">tail_tid</span><span class="p">);</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_start</span>    <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">tail_block</span><span class="p">);</span>

	<span class="n">jbd2_write_superblock</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">write_op</span><span class="p">);</span>

	<span class="cm">/* Log is no longer empty */</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_sequence</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">JBD2_FLUSHED</span><span class="p">;</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * jbd2_mark_journal_empty() - Mark on disk journal as empty.</span>
<span class="cm"> * @journal: The journal to update.</span>
<span class="cm"> *</span>
<span class="cm"> * Update a journal&#39;s dynamic superblock fields to show that journal is empty.</span>
<span class="cm"> * Write updated superblock to disk waiting for IO to complete.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">jbd2_mark_journal_empty</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">journal_superblock_t</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_superblock</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_mutex</span><span class="p">));</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;JBD2: Marking journal as empty (seq %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail_sequence</span><span class="p">);</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_sequence</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail_sequence</span><span class="p">);</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_start</span>    <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>

	<span class="n">jbd2_write_superblock</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">WRITE_FUA</span><span class="p">);</span>

	<span class="cm">/* Log is no longer empty */</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">|=</span> <span class="n">JBD2_FLUSHED</span><span class="p">;</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * jbd2_journal_update_sb_errno() - Update error in the journal.</span>
<span class="cm"> * @journal: The journal to update.</span>
<span class="cm"> *</span>
<span class="cm"> * Update a journal&#39;s errno.  Write updated superblock to disk waiting for IO</span>
<span class="cm"> * to complete.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">jbd2_journal_update_sb_errno</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">journal_superblock_t</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_superblock</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;JBD2: updating superblock error (errno %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_errno</span><span class="p">);</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_errno</span>    <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_errno</span><span class="p">);</span>
	<span class="n">jbd2_superblock_csum_set</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">sb</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>

	<span class="n">jbd2_write_superblock</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">WRITE_SYNC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read the superblock for a given journal, performing initial</span>
<span class="cm"> * validation of the format.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">journal_get_superblock</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="n">journal_superblock_t</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_sb_buffer</span><span class="p">;</span>

	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ll_rw_block</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				<span class="s">&quot;JBD2: IO error reading journal superblock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_verified</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sb</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_superblock</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_header</span><span class="p">.</span><span class="n">h_magic</span> <span class="o">!=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">JBD2_MAGIC_NUMBER</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">!=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_blocksize</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;JBD2: no valid journal superblock found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_header</span><span class="p">.</span><span class="n">h_blocktype</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">JBD2_SUPERBLOCK_V1</span>:
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_format_version</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">JBD2_SUPERBLOCK_V2</span>:
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_format_version</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;JBD2: unrecognised superblock format ID</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_maxlen</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_maxlen</span><span class="p">)</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_maxlen</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_maxlen</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_maxlen</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_maxlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;JBD2: journal file too short</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_first</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_first</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_maxlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;JBD2: Invalid start block of journal: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_first</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">JBD2_HAS_COMPAT_FEATURE</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">JBD2_FEATURE_COMPAT_CHECKSUM</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">JBD2_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">JBD2_FEATURE_INCOMPAT_CSUM_V2</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Can&#39;t have checksum v1 and v2 on at the same time! */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;JBD: Can&#39;t enable checksumming v1 and v2 &quot;</span>
		       <span class="s">&quot;at the same time!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jbd2_verify_csum_type</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;JBD: Unknown checksum type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Load the checksum driver */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">JBD2_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">JBD2_FEATURE_INCOMPAT_CSUM_V2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_chksum_driver</span> <span class="o">=</span> <span class="n">crypto_alloc_shash</span><span class="p">(</span><span class="s">&quot;crc32c&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_chksum_driver</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;JBD: Cannot load crc32c driver.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_chksum_driver</span><span class="p">);</span>
			<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_chksum_driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Check superblock checksum */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jbd2_superblock_csum_verify</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;JBD: journal checksum error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Precompute checksum seed for all metadata */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">JBD2_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">JBD2_FEATURE_INCOMPAT_CSUM_V2</span><span class="p">))</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_csum_seed</span> <span class="o">=</span> <span class="n">jbd2_chksum</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_uuid</span><span class="p">,</span>
						   <span class="k">sizeof</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_uuid</span><span class="p">));</span>

	<span class="n">set_buffer_verified</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">journal_fail_superblock</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Load the on-disk journal superblock and read the key fields into the</span>
<span class="cm"> * journal_t.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">load_superblock</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">journal_superblock_t</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">journal_get_superblock</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">sb</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_superblock</span><span class="p">;</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail_sequence</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_sequence</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_start</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_first</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_first</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_maxlen</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_errno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_errno</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * int jbd2_journal_load() - Read journal from disk.</span>
<span class="cm"> * @journal: Journal to act on.</span>
<span class="cm"> *</span>
<span class="cm"> * Given a journal_t structure which tells us which disk blocks contain</span>
<span class="cm"> * a journal, read the journal from disk to initialise the in-memory</span>
<span class="cm"> * structures.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">jbd2_journal_load</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">journal_superblock_t</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">load_superblock</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">sb</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_superblock</span><span class="p">;</span>
	<span class="cm">/* If this is a V2 superblock, then we have to check the</span>
<span class="cm">	 * features flags on it. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_format_version</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_feature_ro_compat</span> <span class="o">&amp;</span>
		     <span class="o">~</span><span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">JBD2_KNOWN_ROCOMPAT_FEATURES</span><span class="p">))</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_feature_incompat</span> <span class="o">&amp;</span>
		     <span class="o">~</span><span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">JBD2_KNOWN_INCOMPAT_FEATURES</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;JBD2: Unrecognised features on journal</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Create a slab for this blocksize</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">jbd2_journal_create_slab</span><span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Let the recovery code check whether it needs to recover any</span>
<span class="cm">	 * data from the journal. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jbd2_journal_recover</span><span class="p">(</span><span class="n">journal</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">recovery_error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_failed_commit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;JBD2: journal transaction %u on %s &quot;</span>
		       <span class="s">&quot;is corrupt.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_failed_commit</span><span class="p">,</span>
		       <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_devname</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* OK, we&#39;ve finished with the dynamic journal bits:</span>
<span class="cm">	 * reinitialise the dynamic contents of the superblock in memory</span>
<span class="cm">	 * and reset them on disk. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal_reset</span><span class="p">(</span><span class="n">journal</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">recovery_error</span><span class="p">;</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">JBD2_ABORT</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">|=</span> <span class="n">JBD2_LOADED</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">recovery_error:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;JBD2: recovery failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * void jbd2_journal_destroy() - Release a journal_t structure.</span>
<span class="cm"> * @journal: Journal to act on.</span>
<span class="cm"> *</span>
<span class="cm"> * Release a journal_t structure once it is no longer in use by the</span>
<span class="cm"> * journaled object.</span>
<span class="cm"> * Return &lt;0 if we couldn&#39;t clean up the journal.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">jbd2_journal_destroy</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Wait for the commit thread to wake up and die. */</span>
	<span class="n">journal_kill_thread</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>

	<span class="cm">/* Force a final log commit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">)</span>
		<span class="n">jbd2_journal_commit_transaction</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>

	<span class="cm">/* Force any old transactions to disk */</span>

	<span class="cm">/* Totally anal locking here... */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_transactions</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_mutex</span><span class="p">);</span>
		<span class="n">jbd2_log_do_checkpoint</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_mutex</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_transactions</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_sb_buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_journal_aborted</span><span class="p">(</span><span class="n">journal</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_mutex</span><span class="p">);</span>
			<span class="n">jbd2_mark_journal_empty</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_mutex</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_sb_buffer</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_proc_entry</span><span class="p">)</span>
		<span class="n">jbd2_stats_proc_exit</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_inode</span><span class="p">)</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_revoke</span><span class="p">)</span>
		<span class="n">jbd2_journal_destroy_revoke</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_chksum_driver</span><span class="p">)</span>
		<span class="n">crypto_free_shash</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_chksum_driver</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wbuf</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *int jbd2_journal_check_used_features () - Check if features specified are used.</span>
<span class="cm"> * @journal: Journal to check.</span>
<span class="cm"> * @compat: bitmask of compatible features</span>
<span class="cm"> * @ro: bitmask of features that force read-only mount</span>
<span class="cm"> * @incompat: bitmask of incompatible features</span>
<span class="cm"> *</span>
<span class="cm"> * Check whether the journal uses all of a given set of</span>
<span class="cm"> * features.  Return true (non-zero) if it does.</span>
<span class="cm"> **/</span>

<span class="kt">int</span> <span class="nf">jbd2_journal_check_used_features</span> <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">compat</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ro</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">incompat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">journal_superblock_t</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">compat</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ro</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">incompat</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Load journal superblock if it is not loaded yet. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_format_version</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">journal_get_superblock</span><span class="p">(</span><span class="n">journal</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_format_version</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sb</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_superblock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_feature_compat</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">compat</span><span class="p">)</span> <span class="o">==</span> <span class="n">compat</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_feature_ro_compat</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ro</span><span class="p">)</span> <span class="o">==</span> <span class="n">ro</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_feature_incompat</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">incompat</span><span class="p">)</span> <span class="o">==</span> <span class="n">incompat</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * int jbd2_journal_check_available_features() - Check feature set in journalling layer</span>
<span class="cm"> * @journal: Journal to check.</span>
<span class="cm"> * @compat: bitmask of compatible features</span>
<span class="cm"> * @ro: bitmask of features that force read-only mount</span>
<span class="cm"> * @incompat: bitmask of incompatible features</span>
<span class="cm"> *</span>
<span class="cm"> * Check whether the journaling code supports the use of</span>
<span class="cm"> * all of a given set of features on this journal.  Return true</span>
<span class="cm"> * (non-zero) if it can. */</span>

<span class="kt">int</span> <span class="nf">jbd2_journal_check_available_features</span> <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">compat</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ro</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">incompat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">compat</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ro</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">incompat</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* We can support any known requested features iff the</span>
<span class="cm">	 * superblock is in version 2.  Otherwise we fail to support any</span>
<span class="cm">	 * extended sb features. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_format_version</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">compat</span>   <span class="o">&amp;</span> <span class="n">JBD2_KNOWN_COMPAT_FEATURES</span><span class="p">)</span> <span class="o">==</span> <span class="n">compat</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ro</span>       <span class="o">&amp;</span> <span class="n">JBD2_KNOWN_ROCOMPAT_FEATURES</span><span class="p">)</span> <span class="o">==</span> <span class="n">ro</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">incompat</span> <span class="o">&amp;</span> <span class="n">JBD2_KNOWN_INCOMPAT_FEATURES</span><span class="p">)</span> <span class="o">==</span> <span class="n">incompat</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * int jbd2_journal_set_features () - Mark a given journal feature in the superblock</span>
<span class="cm"> * @journal: Journal to act on.</span>
<span class="cm"> * @compat: bitmask of compatible features</span>
<span class="cm"> * @ro: bitmask of features that force read-only mount</span>
<span class="cm"> * @incompat: bitmask of incompatible features</span>
<span class="cm"> *</span>
<span class="cm"> * Mark a given journal feature as present on the</span>
<span class="cm"> * superblock.  Returns true if the requested features could be set.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">jbd2_journal_set_features</span> <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">compat</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ro</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">incompat</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define INCOMPAT_FEATURE_ON(f) \</span>
<span class="cp">		((incompat &amp; (f)) &amp;&amp; !(sb-&gt;s_feature_incompat &amp; cpu_to_be32(f)))</span>
<span class="cp">#define COMPAT_FEATURE_ON(f) \</span>
<span class="cp">		((compat &amp; (f)) &amp;&amp; !(sb-&gt;s_feature_compat &amp; cpu_to_be32(f)))</span>
	<span class="n">journal_superblock_t</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">jbd2_journal_check_used_features</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">compat</span><span class="p">,</span> <span class="n">ro</span><span class="p">,</span> <span class="n">incompat</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jbd2_journal_check_available_features</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">compat</span><span class="p">,</span> <span class="n">ro</span><span class="p">,</span> <span class="n">incompat</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Asking for checksumming v2 and v1?  Only give them v2. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">incompat</span> <span class="o">&amp;</span> <span class="n">JBD2_FEATURE_INCOMPAT_CSUM_V2</span> <span class="o">&amp;&amp;</span>
	    <span class="n">compat</span> <span class="o">&amp;</span> <span class="n">JBD2_FEATURE_COMPAT_CHECKSUM</span><span class="p">)</span>
		<span class="n">compat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">JBD2_FEATURE_COMPAT_CHECKSUM</span><span class="p">;</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Setting new features 0x%lx/0x%lx/0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">compat</span><span class="p">,</span> <span class="n">ro</span><span class="p">,</span> <span class="n">incompat</span><span class="p">);</span>

	<span class="n">sb</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_superblock</span><span class="p">;</span>

	<span class="cm">/* If enabling v2 checksums, update superblock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">INCOMPAT_FEATURE_ON</span><span class="p">(</span><span class="n">JBD2_FEATURE_INCOMPAT_CSUM_V2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_checksum_type</span> <span class="o">=</span> <span class="n">JBD2_CRC32C_CHKSUM</span><span class="p">;</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_feature_compat</span> <span class="o">&amp;=</span>
			<span class="o">~</span><span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">JBD2_FEATURE_COMPAT_CHECKSUM</span><span class="p">);</span>

		<span class="cm">/* Load the checksum driver */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_chksum_driver</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_chksum_driver</span> <span class="o">=</span> <span class="n">crypto_alloc_shash</span><span class="p">(</span><span class="s">&quot;crc32c&quot;</span><span class="p">,</span>
								      <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_chksum_driver</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;JBD: Cannot load crc32c &quot;</span>
				       <span class="s">&quot;driver.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_chksum_driver</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Precompute checksum seed for all metadata */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">JBD2_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span>
					      <span class="n">JBD2_FEATURE_INCOMPAT_CSUM_V2</span><span class="p">))</span>
			<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_csum_seed</span> <span class="o">=</span> <span class="n">jbd2_chksum</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span>
							   <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_uuid</span><span class="p">,</span>
							   <span class="k">sizeof</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_uuid</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* If enabling v1 checksums, downgrade superblock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">COMPAT_FEATURE_ON</span><span class="p">(</span><span class="n">JBD2_FEATURE_COMPAT_CHECKSUM</span><span class="p">))</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_feature_incompat</span> <span class="o">&amp;=</span>
			<span class="o">~</span><span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">JBD2_FEATURE_INCOMPAT_CSUM_V2</span><span class="p">);</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_feature_compat</span>    <span class="o">|=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">compat</span><span class="p">);</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_feature_ro_compat</span> <span class="o">|=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">ro</span><span class="p">);</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_feature_incompat</span>  <span class="o">|=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">incompat</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#undef COMPAT_FEATURE_ON</span>
<span class="cp">#undef INCOMPAT_FEATURE_ON</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * jbd2_journal_clear_features () - Clear a given journal feature in the</span>
<span class="cm"> * 				    superblock</span>
<span class="cm"> * @journal: Journal to act on.</span>
<span class="cm"> * @compat: bitmask of compatible features</span>
<span class="cm"> * @ro: bitmask of features that force read-only mount</span>
<span class="cm"> * @incompat: bitmask of incompatible features</span>
<span class="cm"> *</span>
<span class="cm"> * Clear a given journal feature as present on the</span>
<span class="cm"> * superblock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">jbd2_journal_clear_features</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">compat</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ro</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">incompat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">journal_superblock_t</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Clear features 0x%lx/0x%lx/0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">compat</span><span class="p">,</span> <span class="n">ro</span><span class="p">,</span> <span class="n">incompat</span><span class="p">);</span>

	<span class="n">sb</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_superblock</span><span class="p">;</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_feature_compat</span>    <span class="o">&amp;=</span> <span class="o">~</span><span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">compat</span><span class="p">);</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_feature_ro_compat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">ro</span><span class="p">);</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_feature_incompat</span>  <span class="o">&amp;=</span> <span class="o">~</span><span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">incompat</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_clear_features</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * int jbd2_journal_flush () - Flush journal</span>
<span class="cm"> * @journal: Journal to act on.</span>
<span class="cm"> *</span>
<span class="cm"> * Flush all data for a given journal to disk and empty the journal.</span>
<span class="cm"> * Filesystems can use this when remounting readonly to ensure that</span>
<span class="cm"> * recovery does not need to happen on remount.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">jbd2_journal_flush</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>

	<span class="cm">/* Force everything buffered to the log... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transaction</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">;</span>
		<span class="n">__jbd2_log_start_commit</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">)</span>
		<span class="n">transaction</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">;</span>

	<span class="cm">/* Wait for the log commit to complete... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transaction</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tid_t</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>

		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="n">jbd2_log_wait_commit</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* ...and flush everything in the log out to disk. */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_transactions</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_mutex</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">jbd2_log_do_checkpoint</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_mutex</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_journal_aborted</span><span class="p">(</span><span class="n">journal</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_mutex</span><span class="p">);</span>
	<span class="n">jbd2_cleanup_journal_tail</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>

	<span class="cm">/* Finally, mark the journal as really needing no recovery.</span>
<span class="cm">	 * This sets s_start==0 in the underlying superblock, which is</span>
<span class="cm">	 * the magic code for a fully-recovered superblock.  Any future</span>
<span class="cm">	 * commits of data to the journal will restore the current</span>
<span class="cm">	 * s_start value. */</span>
	<span class="n">jbd2_mark_journal_empty</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_mutex</span><span class="p">);</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_transactions</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_head</span> <span class="o">==</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail_sequence</span> <span class="o">==</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_transaction_sequence</span><span class="p">);</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * int jbd2_journal_wipe() - Wipe journal contents</span>
<span class="cm"> * @journal: Journal to act on.</span>
<span class="cm"> * @write: flag (see below)</span>
<span class="cm"> *</span>
<span class="cm"> * Wipe out all of the contents of a journal, safely.  This will produce</span>
<span class="cm"> * a warning if the journal contains any valid recovery information.</span>
<span class="cm"> * Must be called between journal_init_*() and jbd2_journal_load().</span>
<span class="cm"> *</span>
<span class="cm"> * If &#39;write&#39; is non-zero, then we wipe out the journal on disk; otherwise</span>
<span class="cm"> * we merely suppress recovery.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">jbd2_journal_wipe</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">J_ASSERT</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">&amp;</span> <span class="n">JBD2_LOADED</span><span class="p">));</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">load_superblock</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_recovery</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;JBD2: %s recovery information on journal</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">write</span> <span class="o">?</span> <span class="s">&quot;Clearing&quot;</span> <span class="o">:</span> <span class="s">&quot;Ignoring&quot;</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">jbd2_journal_skip_recovery</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Lock to make assertions happy... */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_mutex</span><span class="p">);</span>
		<span class="n">jbd2_mark_journal_empty</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_mutex</span><span class="p">);</span>
	<span class="p">}</span>

 <span class="nl">no_recovery:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Journal abort has very specific semantics, which we describe</span>
<span class="cm"> * for journal abort.</span>
<span class="cm"> *</span>
<span class="cm"> * Two internal functions, which provide abort to the jbd layer</span>
<span class="cm"> * itself are here.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Quick version for internal journal use (doesn&#39;t lock the journal).</span>
<span class="cm"> * Aborts hard --- we mark the abort as occurred, but do _nothing_ else,</span>
<span class="cm"> * and don&#39;t attempt to make any other journal updates.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__jbd2_journal_abort_hard</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">&amp;</span> <span class="n">JBD2_ABORT</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Aborting journal on device %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_devname</span><span class="p">);</span>

	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">|=</span> <span class="n">JBD2_ABORT</span><span class="p">;</span>
	<span class="n">transaction</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transaction</span><span class="p">)</span>
		<span class="n">__jbd2_log_start_commit</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">);</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Soft abort: record the abort error status in the journal superblock,</span>
<span class="cm"> * but don&#39;t do any other IO. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__journal_abort_soft</span> <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="kt">int</span> <span class="n">errno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">&amp;</span> <span class="n">JBD2_ABORT</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_errno</span><span class="p">)</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_errno</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>

	<span class="n">__jbd2_journal_abort_hard</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">errno</span><span class="p">)</span>
		<span class="n">jbd2_journal_update_sb_errno</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * void jbd2_journal_abort () - Shutdown the journal immediately.</span>
<span class="cm"> * @journal: the journal to shutdown.</span>
<span class="cm"> * @errno:   an error number to record in the journal indicating</span>
<span class="cm"> *           the reason for the shutdown.</span>
<span class="cm"> *</span>
<span class="cm"> * Perform a complete, immediate shutdown of the ENTIRE</span>
<span class="cm"> * journal (not of a single transaction).  This operation cannot be</span>
<span class="cm"> * undone without closing and reopening the journal.</span>
<span class="cm"> *</span>
<span class="cm"> * The jbd2_journal_abort function is intended to support higher level error</span>
<span class="cm"> * recovery mechanisms such as the ext2/ext3 remount-readonly error</span>
<span class="cm"> * mode.</span>
<span class="cm"> *</span>
<span class="cm"> * Journal abort has very specific semantics.  Any existing dirty,</span>
<span class="cm"> * unjournaled buffers in the main filesystem will still be written to</span>
<span class="cm"> * disk by bdflush, but the journaling mechanism will be suspended</span>
<span class="cm"> * immediately and no further transaction commits will be honoured.</span>
<span class="cm"> *</span>
<span class="cm"> * Any dirty, journaled buffers will be written back to disk without</span>
<span class="cm"> * hitting the journal.  Atomicity cannot be guaranteed on an aborted</span>
<span class="cm"> * filesystem, but we _do_ attempt to leave as much data as possible</span>
<span class="cm"> * behind for fsck to use for cleanup.</span>
<span class="cm"> *</span>
<span class="cm"> * Any attempt to get a new transaction handle on a journal which is in</span>
<span class="cm"> * ABORT state will just result in an -EROFS error return.  A</span>
<span class="cm"> * jbd2_journal_stop on an existing handle will return -EIO if we have</span>
<span class="cm"> * entered abort state during the update.</span>
<span class="cm"> *</span>
<span class="cm"> * Recursive transactions are not disturbed by journal abort until the</span>
<span class="cm"> * final jbd2_journal_stop, which will receive the -EIO error.</span>
<span class="cm"> *</span>
<span class="cm"> * Finally, the jbd2_journal_abort call allows the caller to supply an errno</span>
<span class="cm"> * which will be recorded (if possible) in the journal superblock.  This</span>
<span class="cm"> * allows a client to record failure conditions in the middle of a</span>
<span class="cm"> * transaction without having to complete the transaction to record the</span>
<span class="cm"> * failure to disk.  ext3_error, for example, now uses this</span>
<span class="cm"> * functionality.</span>
<span class="cm"> *</span>
<span class="cm"> * Errors which originate from within the journaling layer will NOT</span>
<span class="cm"> * supply an errno; a null errno implies that absolutely no further</span>
<span class="cm"> * writes are done to the journal (unless there are any already in</span>
<span class="cm"> * progress).</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">jbd2_journal_abort</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="kt">int</span> <span class="n">errno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__journal_abort_soft</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">errno</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * int jbd2_journal_errno () - returns the journal&#39;s error state.</span>
<span class="cm"> * @journal: journal to examine.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the errno number set with jbd2_journal_abort(), the last</span>
<span class="cm"> * time the journal was mounted - if the journal was stopped</span>
<span class="cm"> * without calling abort this will be 0.</span>
<span class="cm"> *</span>
<span class="cm"> * If the journal has been aborted on this mount time -EROFS will</span>
<span class="cm"> * be returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">jbd2_journal_errno</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">&amp;</span> <span class="n">JBD2_ABORT</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_errno</span><span class="p">;</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * int jbd2_journal_clear_err () - clears the journal&#39;s error state</span>
<span class="cm"> * @journal: journal to act on.</span>
<span class="cm"> *</span>
<span class="cm"> * An error must be cleared or acked to take a FS out of readonly</span>
<span class="cm"> * mode.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">jbd2_journal_clear_err</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">&amp;</span> <span class="n">JBD2_ABORT</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * void jbd2_journal_ack_err() - Ack journal err.</span>
<span class="cm"> * @journal: journal to act on.</span>
<span class="cm"> *</span>
<span class="cm"> * An error must be cleared or acked to take a FS out of readonly</span>
<span class="cm"> * mode.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">jbd2_journal_ack_err</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_errno</span><span class="p">)</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">|=</span> <span class="n">JBD2_ACK_ERR</span><span class="p">;</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">jbd2_journal_blocks_per_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * helper functions to deal with 32 or 64bit block numbers.</span>
<span class="cm"> */</span>
<span class="kt">size_t</span> <span class="nf">journal_tag_bytes</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">journal_block_tag_t</span> <span class="n">tag</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">JBD2_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">JBD2_FEATURE_INCOMPAT_CSUM_V2</span><span class="p">))</span>
		<span class="n">x</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tag</span><span class="p">.</span><span class="n">t_checksum</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">JBD2_HAS_INCOMPAT_FEATURE</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">JBD2_FEATURE_INCOMPAT_64BIT</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">JBD2_TAG_SIZE64</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">JBD2_TAG_SIZE32</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * JBD memory management</span>
<span class="cm"> *</span>
<span class="cm"> * These functions are used to allocate block-sized chunks of memory</span>
<span class="cm"> * used for making copies of buffer_head data.  Very often it will be</span>
<span class="cm"> * page-sized chunks of data, but sometimes it will be in</span>
<span class="cm"> * sub-page-size chunks.  (For example, 16k pages on Power systems</span>
<span class="cm"> * with a 4k block file system.)  For blocks smaller than a page, we</span>
<span class="cm"> * use a SLAB allocator.  There are slab caches for each block size,</span>
<span class="cm"> * which are allocated at mount time, if necessary, and we only free</span>
<span class="cm"> * (all of) the slab caches when/if the jbd2 module is unloaded.  For</span>
<span class="cm"> * this reason we don&#39;t need to a mutex to protect access to</span>
<span class="cm"> * jbd2_slab[] allocating or releasing memory; only in</span>
<span class="cm"> * jbd2_journal_create_slab().</span>
<span class="cm"> */</span>
<span class="cp">#define JBD2_MAX_SLABS 8</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">jbd2_slab</span><span class="p">[</span><span class="n">JBD2_MAX_SLABS</span><span class="p">];</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">jbd2_slab_names</span><span class="p">[</span><span class="n">JBD2_MAX_SLABS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;jbd2_1k&quot;</span><span class="p">,</span> <span class="s">&quot;jbd2_2k&quot;</span><span class="p">,</span> <span class="s">&quot;jbd2_4k&quot;</span><span class="p">,</span> <span class="s">&quot;jbd2_8k&quot;</span><span class="p">,</span>
	<span class="s">&quot;jbd2_16k&quot;</span><span class="p">,</span> <span class="s">&quot;jbd2_32k&quot;</span><span class="p">,</span> <span class="s">&quot;jbd2_64k&quot;</span><span class="p">,</span> <span class="s">&quot;jbd2_128k&quot;</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">jbd2_journal_destroy_slabs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">JBD2_MAX_SLABS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jbd2_slab</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">jbd2_slab</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">jbd2_slab</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">jbd2_journal_create_slab</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">jbd2_slab_create_mutex</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">order_base_2</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">10</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">slab_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">JBD2_MAX_SLABS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jbd2_slab_create_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jbd2_slab</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jbd2_slab_create_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Already created */</span>
	<span class="p">}</span>

	<span class="n">slab_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">jbd2_slab</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="n">jbd2_slab_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">slab_size</span><span class="p">,</span>
					 <span class="n">slab_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jbd2_slab_create_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jbd2_slab</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;JBD2: no memory for jbd2_slab cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="nf">get_slab</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">order_base_2</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">10</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">JBD2_MAX_SLABS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">jbd2_slab</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">jbd2_slab</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">jbd2_alloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span> <span class="cm">/* Must be a power of 2 */</span>

	<span class="n">flags</span> <span class="o">|=</span> <span class="n">__GFP_REPEAT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_pages</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
			<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_pages</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ptr</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">get_slab</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Check alignment; SLUB has gotten this wrong in the past,</span>
<span class="cm">	 * and this can lead to user data corruption! */</span>
	<span class="n">BUG_ON</span><span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ptr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">jbd2_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
			<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ptr</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">vfree</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">get_slab</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">ptr</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Journal_head storage management</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">jbd2_journal_head_cache</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_JBD2_DEBUG</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">nr_journal_heads</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">jbd2_journal_init_journal_head_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">jbd2_journal_head_cache</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">jbd2_journal_head_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;jbd2_journal_head&quot;</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span><span class="p">),</span>
				<span class="mi">0</span><span class="p">,</span>		<span class="cm">/* offset */</span>
				<span class="n">SLAB_TEMPORARY</span><span class="p">,</span>	<span class="cm">/* flags */</span>
				<span class="nb">NULL</span><span class="p">);</span>		<span class="cm">/* ctor */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jbd2_journal_head_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;JBD2: no memory for journal_head cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">jbd2_journal_destroy_journal_head_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jbd2_journal_head_cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">jbd2_journal_head_cache</span><span class="p">);</span>
		<span class="n">jbd2_journal_head_cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * journal_head splicing and dicing</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="nf">journal_alloc_journal_head</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_JBD2_DEBUG</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_journal_heads</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">jbd2_journal_head_cache</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;out of memory for journal_head</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pr_notice_ratelimited</span><span class="p">(</span><span class="s">&quot;ENOMEM in %s, retrying.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">yield</span><span class="p">();</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">jbd2_journal_head_cache</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">journal_free_journal_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_JBD2_DEBUG</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_journal_heads</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">JBD2_POISON_FREE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">jh</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">jbd2_journal_head_cache</span><span class="p">,</span> <span class="n">jh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A journal_head is attached to a buffer_head whenever JBD has an</span>
<span class="cm"> * interest in the buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Whenever a buffer has an attached journal_head, its -&gt;b_state:BH_JBD bit</span>
<span class="cm"> * is set.  This bit is tested in core kernel code where we need to take</span>
<span class="cm"> * JBD-specific actions.  Testing the zeroness of -&gt;b_private is not reliable</span>
<span class="cm"> * there.</span>
<span class="cm"> *</span>
<span class="cm"> * When a buffer has its BH_JBD bit set, its -&gt;b_count is elevated by one.</span>
<span class="cm"> *</span>
<span class="cm"> * When a buffer has its BH_JBD bit set it is immune from being released by</span>
<span class="cm"> * core kernel code, mainly via -&gt;b_count.</span>
<span class="cm"> *</span>
<span class="cm"> * A journal_head is detached from its buffer_head when the journal_head&#39;s</span>
<span class="cm"> * b_jcount reaches zero. Running transaction (b_transaction) and checkpoint</span>
<span class="cm"> * transaction (b_cp_transaction) hold their references to b_jcount.</span>
<span class="cm"> *</span>
<span class="cm"> * Various places in the kernel want to attach a journal_head to a buffer_head</span>
<span class="cm"> * _before_ attaching the journal_head to a transaction.  To protect the</span>
<span class="cm"> * journal_head in this situation, jbd2_journal_add_journal_head elevates the</span>
<span class="cm"> * journal_head&#39;s b_jcount refcount by one.  The caller must call</span>
<span class="cm"> * jbd2_journal_put_journal_head() to undo this.</span>
<span class="cm"> *</span>
<span class="cm"> * So the typical usage would be:</span>
<span class="cm"> *</span>
<span class="cm"> *	(Attach a journal_head if needed.  Increments b_jcount)</span>
<span class="cm"> *	struct journal_head *jh = jbd2_journal_add_journal_head(bh);</span>
<span class="cm"> *	...</span>
<span class="cm"> *      (Get another reference for transaction)</span>
<span class="cm"> *	jbd2_journal_grab_journal_head(bh);</span>
<span class="cm"> *	jh-&gt;b_transaction = xxx;</span>
<span class="cm"> *	(Put original reference)</span>
<span class="cm"> *	jbd2_journal_put_journal_head(jh);</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Give a buffer_head a journal_head.</span>
<span class="cm"> *</span>
<span class="cm"> * May sleep.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="nf">jbd2_journal_add_journal_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">new_jh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">repeat:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_jbd</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">new_jh</span> <span class="o">=</span> <span class="n">journal_alloc_journal_head</span><span class="p">();</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">new_jh</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new_jh</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">jbd_lock_bh_journal_head</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_jbd</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jh</span> <span class="o">=</span> <span class="n">bh2jh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">J_ASSERT_BH</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span>
			<span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span> <span class="o">&amp;&amp;</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_jh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jbd_unlock_bh_journal_head</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">jh</span> <span class="o">=</span> <span class="n">new_jh</span><span class="p">;</span>
		<span class="n">new_jh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>		<span class="cm">/* We consumed it */</span>
		<span class="n">set_buffer_jbd</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span> <span class="o">=</span> <span class="n">jh</span><span class="p">;</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_bh</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;added journal_head&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jcount</span><span class="o">++</span><span class="p">;</span>
	<span class="n">jbd_unlock_bh_journal_head</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_jh</span><span class="p">)</span>
		<span class="n">journal_free_journal_head</span><span class="p">(</span><span class="n">new_jh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Grab a ref against this buffer_head&#39;s journal_head.  If it ended up not</span>
<span class="cm"> * having a journal_head, return NULL</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="nf">jbd2_journal_grab_journal_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">jbd_lock_bh_journal_head</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_jbd</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jh</span> <span class="o">=</span> <span class="n">bh2jh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jcount</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">jbd_unlock_bh_journal_head</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">jh</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__journal_remove_journal_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span> <span class="o">=</span> <span class="n">bh2jh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jcount</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_next_transaction</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cp_transaction</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span> <span class="o">==</span> <span class="n">BJ_None</span><span class="p">);</span>
	<span class="n">J_ASSERT_BH</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">buffer_jbd</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>
	<span class="n">J_ASSERT_BH</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">)</span> <span class="o">==</span> <span class="n">bh</span><span class="p">);</span>
	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;remove journal_head&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_frozen_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: freeing b_frozen_data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">jbd2_free</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_frozen_data</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_committed_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: freeing b_committed_data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">jbd2_free</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_committed_data</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* debug, really */</span>
	<span class="n">clear_buffer_jbd</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">journal_free_journal_head</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Drop a reference on the passed journal_head.  If it fell to zero then</span>
<span class="cm"> * release the journal_head from the buffer_head.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">jbd2_journal_put_journal_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>

	<span class="n">jbd_lock_bh_journal_head</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jcount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="o">--</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jcount</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jcount</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__journal_remove_journal_head</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">jbd_unlock_bh_journal_head</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">__brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">jbd_unlock_bh_journal_head</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize jbd inode head</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">jbd2_journal_init_jbd_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">jbd2_inode</span> <span class="o">*</span><span class="n">jinode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_transaction</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_next_transaction</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_vfs_inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>
	<span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function to be called before we start removing inode from memory (i.e.,</span>
<span class="cm"> * clear_inode() is a fine place to be called from). It removes inode from</span>
<span class="cm"> * transaction&#39;s lists.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">jbd2_journal_release_jbd_inode</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">jbd2_inode</span> <span class="o">*</span><span class="n">jinode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
<span class="nl">restart:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="cm">/* Is commit writing out inode - we have to wait */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__JI_COMMIT_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>
		<span class="n">DEFINE_WAIT_BIT</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">,</span> <span class="n">__JI_COMMIT_RUNNING</span><span class="p">);</span>
		<span class="n">wq</span> <span class="o">=</span> <span class="n">bit_waitqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">,</span> <span class="n">__JI_COMMIT_RUNNING</span><span class="p">);</span>
		<span class="n">prepare_to_wait</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">.</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">finish_wait</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">.</span><span class="n">wait</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_transaction</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_list</span><span class="p">);</span>
		<span class="n">jinode</span><span class="o">-&gt;</span><span class="n">i_transaction</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * debugfs tunables</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_JBD2_DEBUG</span>
<span class="n">u8</span> <span class="n">jbd2_journal_enable_debug</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">jbd2_journal_enable_debug</span><span class="p">);</span>

<span class="cp">#define JBD2_DEBUG_NAME &quot;jbd2-debug&quot;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">jbd2_debugfs_dir</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">jbd2_debug</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">jbd2_create_debugfs_entry</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">jbd2_debugfs_dir</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;jbd2&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jbd2_debugfs_dir</span><span class="p">)</span>
		<span class="n">jbd2_debug</span> <span class="o">=</span> <span class="n">debugfs_create_u8</span><span class="p">(</span><span class="n">JBD2_DEBUG_NAME</span><span class="p">,</span>
					       <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
					       <span class="n">jbd2_debugfs_dir</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">jbd2_journal_enable_debug</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">jbd2_remove_debugfs_entry</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">jbd2_debug</span><span class="p">);</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">jbd2_debugfs_dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">jbd2_create_debugfs_entry</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">jbd2_remove_debugfs_entry</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>

<span class="cp">#define JBD2_STATS_PROC_NAME &quot;fs/jbd2&quot;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">jbd2_create_jbd_stats_proc_entry</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">proc_jbd2_stats</span> <span class="o">=</span> <span class="n">proc_mkdir</span><span class="p">(</span><span class="n">JBD2_STATS_PROC_NAME</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">jbd2_remove_jbd_stats_proc_entry</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">proc_jbd2_stats</span><span class="p">)</span>
		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="n">JBD2_STATS_PROC_NAME</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="cp">#define jbd2_create_jbd_stats_proc_entry() do {} while (0)</span>
<span class="cp">#define jbd2_remove_jbd_stats_proc_entry() do {} while (0)</span>

<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">jbd2_handle_cache</span><span class="p">,</span> <span class="o">*</span><span class="n">jbd2_inode_cache</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">jbd2_journal_init_handle_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">jbd2_handle_cache</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">jbd2_journal_handle</span><span class="p">,</span> <span class="n">SLAB_TEMPORARY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jbd2_handle_cache</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;JBD2: failed to create handle cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">jbd2_inode_cache</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">jbd2_inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jbd2_inode_cache</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;JBD2: failed to create inode cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">jbd2_handle_cache</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">jbd2_journal_destroy_handle_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jbd2_handle_cache</span><span class="p">)</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">jbd2_handle_cache</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jbd2_inode_cache</span><span class="p">)</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">jbd2_inode_cache</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Module startup and shutdown</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">journal_init_caches</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">jbd2_journal_init_revoke_caches</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">jbd2_journal_init_journal_head_cache</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">jbd2_journal_init_handle_cache</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">jbd2_journal_init_transaction_cache</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">jbd2_journal_destroy_caches</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">jbd2_journal_destroy_revoke_caches</span><span class="p">();</span>
	<span class="n">jbd2_journal_destroy_journal_head_cache</span><span class="p">();</span>
	<span class="n">jbd2_journal_destroy_handle_cache</span><span class="p">();</span>
	<span class="n">jbd2_journal_destroy_transaction_cache</span><span class="p">();</span>
	<span class="n">jbd2_journal_destroy_slabs</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">journal_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_superblock_s</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1024</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">journal_init_caches</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jbd2_create_debugfs_entry</span><span class="p">();</span>
		<span class="n">jbd2_create_jbd_stats_proc_entry</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">jbd2_journal_destroy_caches</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">journal_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_JBD2_DEBUG</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_journal_heads</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;JBD2: leaked %d journal_heads!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">jbd2_remove_debugfs_entry</span><span class="p">();</span>
	<span class="n">jbd2_remove_jbd_stats_proc_entry</span><span class="p">();</span>
	<span class="n">jbd2_journal_destroy_caches</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">journal_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">journal_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
