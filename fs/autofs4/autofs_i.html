<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › autofs4 › autofs_i.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>autofs_i.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* -*- c -*- ------------------------------------------------------------- *</span>
<span class="cm"> *   </span>
<span class="cm"> * linux/fs/autofs/autofs_i.h</span>
<span class="cm"> *</span>
<span class="cm"> *   Copyright 1997-1998 Transmeta Corporation - All Rights Reserved</span>
<span class="cm"> *   Copyright 2005-2006 Ian Kent &lt;raven@themaw.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file is part of the Linux kernel and is made available under</span>
<span class="cm"> * the terms of the GNU General Public License, version 2, or at your</span>
<span class="cm"> * option, any later version, incorporated herein by reference.</span>
<span class="cm"> *</span>
<span class="cm"> * ----------------------------------------------------------------------- */</span>

<span class="cm">/* Internal header file for autofs */</span>

<span class="cp">#include &lt;linux/auto_fs4.h&gt;</span>
<span class="cp">#include &lt;linux/auto_dev-ioctl.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>

<span class="cm">/* This is the range of ioctl() numbers we claim as ours */</span>
<span class="cp">#define AUTOFS_IOC_FIRST     AUTOFS_IOC_READY</span>
<span class="cp">#define AUTOFS_IOC_COUNT     32</span>

<span class="cp">#define AUTOFS_DEV_IOCTL_IOC_FIRST	(AUTOFS_DEV_IOCTL_VERSION)</span>
<span class="cp">#define AUTOFS_DEV_IOCTL_IOC_COUNT	(AUTOFS_IOC_COUNT - 11)</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;asm/current.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cm">/* #define DEBUG */</span>

<span class="cp">#define DPRINTK(fmt, ...)				\</span>
<span class="cp">	pr_debug(&quot;pid %d: %s: &quot; fmt &quot;\n&quot;,		\</span>
<span class="cp">		current-&gt;pid, __func__, ##__VA_ARGS__)</span>

<span class="cp">#define AUTOFS_WARN(fmt, ...)				\</span>
<span class="cp">	printk(KERN_WARNING &quot;pid %d: %s: &quot; fmt &quot;\n&quot;,	\</span>
<span class="cp">		current-&gt;pid, __func__, ##__VA_ARGS__)</span>

<span class="cp">#define AUTOFS_ERROR(fmt, ...)				\</span>
<span class="cp">	printk(KERN_ERR &quot;pid %d: %s: &quot; fmt &quot;\n&quot;,	\</span>
<span class="cp">		current-&gt;pid, __func__, ##__VA_ARGS__)</span>

<span class="cm">/* Unified info structure.  This is pointed to by both the dentry and</span>
<span class="cm">   inode structures.  Each file in the filesystem has an instance of this</span>
<span class="cm">   structure.  It holds a reference to the dentry, so dentries are never</span>
<span class="cm">   flushed while the file exists.  All name lookups are dealt with at the</span>
<span class="cm">   dentry level, although the filesystem can interfere in the validation</span>
<span class="cm">   process.  Readdir is implemented by traversing the dentry lists. */</span>
<span class="k">struct</span> <span class="n">autofs_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="kt">int</span>		<span class="n">flags</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">completion</span> <span class="n">expire_complete</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">active</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">active_count</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">expiring</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">autofs_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_used</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">uid_t</span> <span class="n">uid</span><span class="p">;</span>
	<span class="n">gid_t</span> <span class="n">gid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define AUTOFS_INF_EXPIRING	(1&lt;&lt;0) </span><span class="cm">/* dentry is in the process of expiring */</span><span class="cp"></span>
<span class="cp">#define AUTOFS_INF_PENDING	(1&lt;&lt;2) </span><span class="cm">/* dentry pending mount */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">autofs_wait_queue</span> <span class="p">{</span>
	<span class="n">wait_queue_head_t</span> <span class="n">queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">autofs_wait_queue</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="n">autofs_wqt_t</span> <span class="n">wait_queue_token</span><span class="p">;</span>
	<span class="cm">/* We use the following to see what we are waiting for */</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ino</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">uid</span><span class="p">;</span>
	<span class="n">gid_t</span> <span class="n">gid</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">tgid</span><span class="p">;</span>
	<span class="cm">/* This is for status reporting upon return */</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wait_ctr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define AUTOFS_SBI_MAGIC 0x6d4a556d</span>

<span class="k">struct</span> <span class="n">autofs_sb_info</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">magic</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pipefd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">pipe</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">oz_pgrp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">catatonic</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">version</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sub_version</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">min_proto</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_proto</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exp_timeout</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reghost_enabled</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">needs_reghost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">wq_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">pipe_mutex</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">fs_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">autofs_wait_queue</span> <span class="o">*</span><span class="n">queues</span><span class="p">;</span> <span class="cm">/* Wait queue pointer */</span>
	<span class="n">spinlock_t</span> <span class="n">lookup_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">active_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">expiring_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">autofs_sb_info</span> <span class="o">*</span><span class="nf">autofs4_sbi</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">autofs_sb_info</span> <span class="o">*</span><span class="p">)(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">autofs_info</span> <span class="o">*</span><span class="nf">autofs4_dentry_ino</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">autofs_info</span> <span class="o">*</span><span class="p">)(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* autofs4_oz_mode(): do we see the man behind the curtain?  (The</span>
<span class="cm">   processes which do manipulations for us in user space sees the raw</span>
<span class="cm">   filesystem without &quot;magic&quot;.) */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">autofs4_oz_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">autofs_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">catatonic</span> <span class="o">||</span> <span class="n">task_pgrp_nr</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">==</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">oz_pgrp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Does a dentry have some pending activity? */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">autofs4_ispending</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">autofs_info</span> <span class="o">*</span><span class="n">inf</span> <span class="o">=</span> <span class="n">autofs4_dentry_ino</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AUTOFS_INF_PENDING</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AUTOFS_INF_EXPIRING</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">autofs4_get_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="n">umode_t</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">autofs4_free_ino</span><span class="p">(</span><span class="k">struct</span> <span class="n">autofs_info</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Expiration */</span>
<span class="kt">int</span> <span class="n">is_autofs4_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">autofs4_expire_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">autofs4_expire_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">autofs_sb_info</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">autofs_packet_expire</span> <span class="n">__user</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">autofs4_do_expire_multi</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">autofs_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">when</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">autofs4_expire_multi</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">autofs_sb_info</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">autofs4_expire_direct</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">autofs_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">autofs4_expire_indirect</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">autofs_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how</span><span class="p">);</span>

<span class="cm">/* Device node initialization */</span>

<span class="kt">int</span> <span class="n">autofs_dev_ioctl_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">autofs_dev_ioctl_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* Operations structures */</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">autofs4_symlink_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">autofs4_dir_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">autofs4_dir_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">autofs4_root_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="n">autofs4_dentry_operations</span><span class="p">;</span>

<span class="cm">/* VFS automount flags management functions */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__managed_dentry_set_automount</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="n">DCACHE_NEED_AUTOMOUNT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">managed_dentry_set_automount</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">__managed_dentry_set_automount</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__managed_dentry_clear_automount</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DCACHE_NEED_AUTOMOUNT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">managed_dentry_clear_automount</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">__managed_dentry_clear_automount</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__managed_dentry_set_transit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="n">DCACHE_MANAGE_TRANSIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">managed_dentry_set_transit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">__managed_dentry_set_transit</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__managed_dentry_clear_transit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DCACHE_MANAGE_TRANSIT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">managed_dentry_clear_transit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">__managed_dentry_clear_transit</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__managed_dentry_set_managed</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DCACHE_NEED_AUTOMOUNT</span><span class="o">|</span><span class="n">DCACHE_MANAGE_TRANSIT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">managed_dentry_set_managed</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">__managed_dentry_set_managed</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__managed_dentry_clear_managed</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">DCACHE_NEED_AUTOMOUNT</span><span class="o">|</span><span class="n">DCACHE_MANAGE_TRANSIT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">managed_dentry_clear_managed</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">__managed_dentry_clear_managed</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Initializing function */</span>

<span class="kt">int</span> <span class="n">autofs4_fill_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">autofs_info</span> <span class="o">*</span><span class="n">autofs4_new_ino</span><span class="p">(</span><span class="k">struct</span> <span class="n">autofs_sb_info</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">autofs4_clean_ino</span><span class="p">(</span><span class="k">struct</span> <span class="n">autofs_info</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">autofs_prepare_pipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">||</span> <span class="o">!</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISFIFO</span><span class="p">(</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/* We want a packet pipe */</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">|=</span> <span class="n">O_DIRECT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Queue management functions */</span>

<span class="kt">int</span> <span class="n">autofs4_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">autofs_sb_info</span> <span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">autofs_notify</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">autofs4_wait_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">autofs_sb_info</span> <span class="o">*</span><span class="p">,</span><span class="n">autofs_wqt_t</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">autofs4_catatonic_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">autofs_sb_info</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">autofs4_get_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">autofs_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">new_encode_dev</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">autofs4_get_ino</span><span class="p">(</span><span class="k">struct</span> <span class="n">autofs_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">simple_positive</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">d_unhashed</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__autofs4_add_expiring</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">autofs_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">autofs4_sbi</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">autofs_info</span> <span class="o">*</span><span class="n">ino</span> <span class="o">=</span> <span class="n">autofs4_dentry_ino</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ino</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">expiring</span><span class="p">))</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">expiring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">expiring_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">autofs4_add_expiring</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">autofs_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">autofs4_sbi</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">autofs_info</span> <span class="o">*</span><span class="n">ino</span> <span class="o">=</span> <span class="n">autofs4_dentry_ino</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ino</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">lookup_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">expiring</span><span class="p">))</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">expiring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">expiring_list</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">lookup_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">autofs4_del_expiring</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">autofs_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">autofs4_sbi</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">autofs_info</span> <span class="o">*</span><span class="n">ino</span> <span class="o">=</span> <span class="n">autofs4_dentry_ino</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ino</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">lookup_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">expiring</span><span class="p">))</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">expiring</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">lookup_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">autofs4_kill_sb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
