<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › namespace.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>namespace.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/fs/namespace.c</span>
<span class="cm"> *</span>
<span class="cm"> * (C) Copyright Al Viro 2000, 2001</span>
<span class="cm"> *	Released under GPL v2.</span>
<span class="cm"> *</span>
<span class="cm"> * Based on code from fs/super.c, copyright Linus Torvalds and others.</span>
<span class="cm"> * Heavily rewritten.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/mnt_namespace.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/acct.h&gt;		</span><span class="cm">/* acct_auto_close_mnt */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/ramfs.h&gt;	</span><span class="cm">/* init_rootfs */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/fs_struct.h&gt;	</span><span class="cm">/* get_fs_root et.al. */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/fsnotify.h&gt;	</span><span class="cm">/* fsnotify_vfsmount_delete */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &quot;pnode.h&quot;</span>
<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cp">#define HASH_SHIFT ilog2(PAGE_SIZE / sizeof(struct list_head))</span>
<span class="cp">#define HASH_SIZE (1UL &lt;&lt; HASH_SHIFT)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">event</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_IDA</span><span class="p">(</span><span class="n">mnt_id_ida</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_IDA</span><span class="p">(</span><span class="n">mnt_group_ida</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">mnt_id_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mnt_id_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">mnt_group_start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">mount_hashtable</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">mnt_cache</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">namespace_sem</span><span class="p">;</span>

<span class="cm">/* /sys/fs */</span>
<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">fs_kobj</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">fs_kobj</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * vfsmount lock may be taken for read to prevent changes to the</span>
<span class="cm"> * vfsmount hash, ie. during mountpoint lookups or walking back</span>
<span class="cm"> * up the tree.</span>
<span class="cm"> *</span>
<span class="cm"> * It should be taken for write in all cases where the vfsmount</span>
<span class="cm"> * tree or hash is modified or when a vfsmount structure is modified.</span>
<span class="cm"> */</span>
<span class="n">DEFINE_BRLOCK</span><span class="p">(</span><span class="n">vfsmount_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mnt</span> <span class="o">/</span> <span class="n">L1_CACHE_BYTES</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">+=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dentry</span> <span class="o">/</span> <span class="n">L1_CACHE_BYTES</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">+</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="n">HASH_SHIFT</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tmp</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HASH_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define MNT_WRITER_UNDERFLOW_LIMIT -(1&lt;&lt;16)</span>

<span class="cm">/*</span>
<span class="cm"> * allocation is serialized by namespace_sem, but we need the spinlock to</span>
<span class="cm"> * serialize with freeing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mnt_alloc_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">ida_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt_id_ida</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt_id_lock</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">ida_get_new_above</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt_id_ida</span><span class="p">,</span> <span class="n">mnt_id_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span>
		<span class="n">mnt_id_start</span> <span class="o">=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt_id_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mnt_free_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_id</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt_id_lock</span><span class="p">);</span>
	<span class="n">ida_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt_id_ida</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mnt_id_start</span> <span class="o">&gt;</span> <span class="n">id</span><span class="p">)</span>
		<span class="n">mnt_id_start</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt_id_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a new peer group ID</span>
<span class="cm"> *</span>
<span class="cm"> * mnt_group_ida is protected by namespace_sem</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mnt_alloc_group_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ida_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt_group_ida</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">ida_get_new_above</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt_group_ida</span><span class="p">,</span>
				<span class="n">mnt_group_start</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_group_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span>
		<span class="n">mnt_group_start</span> <span class="o">=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_group_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release a peer group ID</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">mnt_release_group_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_group_id</span><span class="p">;</span>
	<span class="n">ida_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt_group_ida</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mnt_group_start</span> <span class="o">&gt;</span> <span class="n">id</span><span class="p">)</span>
		<span class="n">mnt_group_start</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_group_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vfsmount lock must be held for read</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mnt_add_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">this_cpu_add</span><span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_pcp</span><span class="o">-&gt;</span><span class="n">mnt_count</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_count</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vfsmount lock must be held for write</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">mnt_get_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_pcp</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mnt_count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_count</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="nf">alloc_vfsmnt</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">mnt_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">mnt_alloc_id</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free_cache</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_devname</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_devname</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_free_id</span><span class="p">;</span>
		<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
		<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_pcp</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">mnt_pcp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_pcp</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free_devname</span><span class="p">;</span>

		<span class="n">this_cpu_add</span><span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_pcp</span><span class="o">-&gt;</span><span class="n">mnt_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_writers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_hash</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_child</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_mounts</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_list</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_expire</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_share</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_slave_list</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_slave</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_FSNOTIFY</span>
		<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_fsnotify_marks</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">mnt</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="nl">out_free_devname:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_devname</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="nl">out_free_id:</span>
	<span class="n">mnt_free_id</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
<span class="nl">out_free_cache:</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">mnt_cache</span><span class="p">,</span> <span class="n">mnt</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Most r/o checks on a fs are for operations that take</span>
<span class="cm"> * discrete amounts of time, like a write() or unlink().</span>
<span class="cm"> * We must keep track of when those operations start</span>
<span class="cm"> * (for permission checks) and when they end, so that</span>
<span class="cm"> * we can determine when writes are able to occur to</span>
<span class="cm"> * a filesystem.</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * __mnt_is_readonly: check whether a mount is read-only</span>
<span class="cm"> * @mnt: the mount to check for its write status</span>
<span class="cm"> *</span>
<span class="cm"> * This shouldn&#39;t be used directly ouside of the VFS.</span>
<span class="cm"> * It does not guarantee that the filesystem will stay</span>
<span class="cm"> * r/w, just that it is right *now*.  This can not and</span>
<span class="cm"> * should not be used in place of IS_RDONLY(inode).</span>
<span class="cm"> * mnt_want/drop_write() will _keep_ the filesystem</span>
<span class="cm"> * r/w.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__mnt_is_readonly</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="n">MNT_READONLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__mnt_is_readonly</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mnt_inc_writers</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">this_cpu_inc</span><span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_pcp</span><span class="o">-&gt;</span><span class="n">mnt_writers</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_writers</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mnt_dec_writers</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">this_cpu_dec</span><span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_pcp</span><span class="o">-&gt;</span><span class="n">mnt_writers</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_writers</span><span class="o">--</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">mnt_get_writers</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_pcp</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mnt_writers</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_writers</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mnt_is_readonly</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_sb</span><span class="o">-&gt;</span><span class="n">s_readonly_remount</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Order wrt setting s_flags/s_readonly_remount in do_remount() */</span>
	<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">__mnt_is_readonly</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Most r/o checks on a fs are for operations that take</span>
<span class="cm"> * discrete amounts of time, like a write() or unlink().</span>
<span class="cm"> * We must keep track of when those operations start</span>
<span class="cm"> * (for permission checks) and when they end, so that</span>
<span class="cm"> * we can determine when writes are able to occur to</span>
<span class="cm"> * a filesystem.</span>
<span class="cm"> */</span>
<span class="cm">/**</span>
<span class="cm"> * mnt_want_write - get write access to a mount</span>
<span class="cm"> * @m: the mount on which to take a write</span>
<span class="cm"> *</span>
<span class="cm"> * This tells the low-level filesystem that a write is</span>
<span class="cm"> * about to be performed to it, and makes sure that</span>
<span class="cm"> * writes are allowed before returning success.  When</span>
<span class="cm"> * the write operation is finished, mnt_drop_write()</span>
<span class="cm"> * must be called.  This is effectively a refcount.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">mnt_want_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">real_mount</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">mnt_inc_writers</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The store to mnt_inc_writers must be visible before we pass</span>
<span class="cm">	 * MNT_WRITE_HOLD loop below, so that the slowpath can see our</span>
<span class="cm">	 * incremented count after it has set MNT_WRITE_HOLD.</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="n">MNT_WRITE_HOLD</span><span class="p">)</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * After the slowpath clears MNT_WRITE_HOLD, mnt_is_readonly will</span>
<span class="cm">	 * be set to match its requirements. So we must not load that until</span>
<span class="cm">	 * MNT_WRITE_HOLD is cleared.</span>
<span class="cm">	 */</span>
	<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mnt_is_readonly</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mnt_dec_writers</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">mnt_want_write</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * mnt_clone_write - get write access to a mount</span>
<span class="cm"> * @mnt: the mount on which to take a write</span>
<span class="cm"> *</span>
<span class="cm"> * This is effectively like mnt_want_write, except</span>
<span class="cm"> * it must only be used to take an extra write reference</span>
<span class="cm"> * on a mountpoint that we already know has a write reference</span>
<span class="cm"> * on it. This allows some optimisation.</span>
<span class="cm"> *</span>
<span class="cm"> * After finished, mnt_drop_write must be called as usual to</span>
<span class="cm"> * drop the reference.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">mnt_clone_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* superblock may be r/o */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__mnt_is_readonly</span><span class="p">(</span><span class="n">mnt</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">mnt_inc_writers</span><span class="p">(</span><span class="n">real_mount</span><span class="p">(</span><span class="n">mnt</span><span class="p">));</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">mnt_clone_write</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * mnt_want_write_file - get write access to a file&#39;s mount</span>
<span class="cm"> * @file: the file who&#39;s mount on which to take a write</span>
<span class="cm"> *</span>
<span class="cm"> * This is like mnt_want_write, but it takes a file and can</span>
<span class="cm"> * do some optimisations if the file is open for write already</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">mnt_want_write_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="o">||</span> <span class="n">special_file</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">mnt_want_write</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">mnt_clone_write</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">mnt_want_write_file</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * mnt_drop_write - give up write access to a mount</span>
<span class="cm"> * @mnt: the mount on which to give up write access</span>
<span class="cm"> *</span>
<span class="cm"> * Tells the low-level filesystem that we are done</span>
<span class="cm"> * performing writes to it.  Must be matched with</span>
<span class="cm"> * mnt_want_write() call above.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">mnt_drop_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">mnt_dec_writers</span><span class="p">(</span><span class="n">real_mount</span><span class="p">(</span><span class="n">mnt</span><span class="p">));</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">mnt_drop_write</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">mnt_drop_write_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mnt_drop_write</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mnt_drop_write_file</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mnt_make_readonly</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_flags</span> <span class="o">|=</span> <span class="n">MNT_WRITE_HOLD</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * After storing MNT_WRITE_HOLD, we&#39;ll read the counters. This store</span>
<span class="cm">	 * should be visible before we do.</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * With writers on hold, if this value is zero, then there are</span>
<span class="cm">	 * definitely no active writers (although held writers may subsequently</span>
<span class="cm">	 * increment the count, they&#39;ll have to wait, and decrement it after</span>
<span class="cm">	 * seeing MNT_READONLY).</span>
<span class="cm">	 *</span>
<span class="cm">	 * It is OK to have counter incremented on one CPU and decremented on</span>
<span class="cm">	 * another: the sum will add up correctly. The danger would be when we</span>
<span class="cm">	 * sum up each counter, if we read a counter before it is incremented,</span>
<span class="cm">	 * but then read another CPU&#39;s count which it has been subsequently</span>
<span class="cm">	 * decremented from -- we would see more decrements than we should.</span>
<span class="cm">	 * MNT_WRITE_HOLD protects against this scenario, because</span>
<span class="cm">	 * mnt_want_write first increments count, then smp_mb, then spins on</span>
<span class="cm">	 * MNT_WRITE_HOLD, so it can&#39;t be decremented by another CPU while</span>
<span class="cm">	 * we&#39;re counting up here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mnt_get_writers</span><span class="p">(</span><span class="n">mnt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_flags</span> <span class="o">|=</span> <span class="n">MNT_READONLY</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * MNT_READONLY must become visible before ~MNT_WRITE_HOLD, so writers</span>
<span class="cm">	 * that become unheld will see MNT_READONLY.</span>
<span class="cm">	 */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MNT_WRITE_HOLD</span><span class="p">;</span>
	<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__mnt_unmake_readonly</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MNT_READONLY</span><span class="p">;</span>
	<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sb_prepare_remount_readonly</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Racy optimization.  Recheck the counter under MNT_WRITE_HOLD */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_remove_count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_mounts</span><span class="p">,</span> <span class="n">mnt_instance</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="n">MNT_READONLY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_flags</span> <span class="o">|=</span> <span class="n">MNT_WRITE_HOLD</span><span class="p">;</span>
			<span class="n">smp_mb</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mnt_get_writers</span><span class="p">(</span><span class="n">mnt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_remove_count</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_readonly_remount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_mounts</span><span class="p">,</span> <span class="n">mnt_instance</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="n">MNT_WRITE_HOLD</span><span class="p">)</span>
			<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MNT_WRITE_HOLD</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_vfsmnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_devname</span><span class="p">);</span>
	<span class="n">mnt_free_id</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_pcp</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">mnt_cache</span><span class="p">,</span> <span class="n">mnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * find the first or last mount at @dentry on vfsmount @mnt depending on</span>
<span class="cm"> * @dir. If @dir is set return the first mount else return the last mount.</span>
<span class="cm"> * vfsmount_lock must be held for read or write.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="nf">__lookup_mnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">mount_hashtable</span> <span class="o">+</span> <span class="n">hash</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">found</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">dir</span> <span class="o">?</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">:</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">head</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mount</span><span class="p">,</span> <span class="n">mnt_hash</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_parent</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">==</span> <span class="n">mnt</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_mountpoint</span> <span class="o">==</span> <span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * lookup_mnt increments the ref count before returning</span>
<span class="cm"> * the vfsmount struct.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="nf">lookup_mnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">child_mnt</span><span class="p">;</span>

	<span class="n">br_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">child_mnt</span> <span class="o">=</span> <span class="n">__lookup_mnt</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">child_mnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mnt_add_count</span><span class="p">(</span><span class="n">child_mnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">br_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">child_mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">br_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">check_mnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_ns</span> <span class="o">==</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">mnt_ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vfsmount lock must be held for write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">touch_mnt_namespace</span><span class="p">(</span><span class="k">struct</span> <span class="n">mnt_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ns</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ns</span><span class="o">-&gt;</span><span class="n">event</span> <span class="o">=</span> <span class="o">++</span><span class="n">event</span><span class="p">;</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vfsmount lock must be held for write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__touch_mnt_namespace</span><span class="p">(</span><span class="k">struct</span> <span class="n">mnt_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ns</span> <span class="o">&amp;&amp;</span> <span class="n">ns</span><span class="o">-&gt;</span><span class="n">event</span> <span class="o">!=</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ns</span><span class="o">-&gt;</span><span class="n">event</span> <span class="o">=</span> <span class="n">event</span><span class="p">;</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clear dentry&#39;s mounted state if it has no remaining mounts.</span>
<span class="cm"> * vfsmount_lock must be held for write.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dentry_reset_mounted</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">u</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="n">HASH_SIZE</span><span class="p">;</span> <span class="n">u</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mount_hashtable</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">mnt_hash</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_mountpoint</span> <span class="o">==</span> <span class="n">dentry</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DCACHE_MOUNTED</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vfsmount lock must be held for write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">detach_mnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">old_path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">old_path</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_mountpoint</span><span class="p">;</span>
	<span class="n">old_path</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_parent</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">;</span>
	<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_parent</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span>
	<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_mountpoint</span> <span class="o">=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_root</span><span class="p">;</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_child</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_hash</span><span class="p">);</span>
	<span class="n">dentry_reset_mounted</span><span class="p">(</span><span class="n">old_path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vfsmount lock must be held for write</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">mnt_set_mountpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">child_mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mnt_add_count</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>	<span class="cm">/* essentially, that&#39;s mntget */</span>
	<span class="n">child_mnt</span><span class="o">-&gt;</span><span class="n">mnt_mountpoint</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">child_mnt</span><span class="o">-&gt;</span><span class="n">mnt_parent</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="n">DCACHE_MOUNTED</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vfsmount lock must be held for write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">attach_mnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mnt_set_mountpoint</span><span class="p">(</span><span class="n">real_mount</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">),</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span> <span class="n">mnt</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_hash</span><span class="p">,</span> <span class="n">mount_hashtable</span> <span class="o">+</span>
			<span class="n">hash</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">));</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">real_mount</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mnt_mounts</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__mnt_make_longterm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_longterm</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* needs vfsmount lock for write */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__mnt_make_shortterm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_longterm</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vfsmount lock must be held for write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">commit_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mnt_namespace</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">mnt_ns</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">parent</span> <span class="o">==</span> <span class="n">mnt</span><span class="p">);</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_list</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">,</span> <span class="n">mnt_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">mnt_ns</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">__mnt_make_longterm</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">prev</span><span class="p">);</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_hash</span><span class="p">,</span> <span class="n">mount_hashtable</span> <span class="o">+</span>
				<span class="n">hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">,</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_mountpoint</span><span class="p">));</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">mnt_mounts</span><span class="p">);</span>
	<span class="n">touch_mnt_namespace</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="nf">next_mnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_mounts</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_mounts</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">root</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_child</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_parent</span><span class="o">-&gt;</span><span class="n">mnt_mounts</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_parent</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mount</span><span class="p">,</span> <span class="n">mnt_child</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="nf">skip_mnt_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_mounts</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_mounts</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mount</span><span class="p">,</span> <span class="n">mnt_child</span><span class="p">);</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_mounts</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span>
<span class="nf">vfs_kern_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">type</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>

	<span class="n">mnt</span> <span class="o">=</span> <span class="n">alloc_vfsmnt</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mnt</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_KERNMOUNT</span><span class="p">)</span>
		<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_flags</span> <span class="o">=</span> <span class="n">MNT_INTERNAL</span><span class="p">;</span>

	<span class="n">root</span> <span class="o">=</span> <span class="n">mount_fs</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">root</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">free_vfsmnt</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
	<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_sb</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">;</span>
	<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_mountpoint</span> <span class="o">=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_root</span><span class="p">;</span>
	<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_parent</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span>
	<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_mounts</span><span class="p">);</span>
	<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vfs_kern_mount</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="nf">clone_mnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">alloc_vfsmnt</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">mnt_devname</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CL_SLAVE</span> <span class="o">|</span> <span class="n">CL_PRIVATE</span><span class="p">))</span>
			<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_group_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* not a peer of original */</span>
		<span class="k">else</span>
			<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_group_id</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">mnt_group_id</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">CL_MAKE_SHARED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_group_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">mnt_alloc_group_id</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_flags</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MNT_WRITE_HOLD</span><span class="p">;</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_active</span><span class="p">);</span>
		<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_sb</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>
		<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_root</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_mountpoint</span> <span class="o">=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_root</span><span class="p">;</span>
		<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_parent</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span>
		<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_instance</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_mounts</span><span class="p">);</span>
		<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">CL_SLAVE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_slave</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">mnt_slave_list</span><span class="p">);</span>
			<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_master</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>
			<span class="n">CLEAR_MNT_SHARED</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">CL_PRIVATE</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">CL_MAKE_SHARED</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_MNT_SHARED</span><span class="p">(</span><span class="n">old</span><span class="p">))</span>
				<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_share</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">mnt_share</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_MNT_SLAVE</span><span class="p">(</span><span class="n">old</span><span class="p">))</span>
				<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_slave</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">mnt_slave</span><span class="p">);</span>
			<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_master</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">mnt_master</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">CL_MAKE_SHARED</span><span class="p">)</span>
			<span class="n">set_mnt_shared</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>

		<span class="cm">/* stick the duplicate mount on the same expiry list</span>
<span class="cm">		 * as the original if that was on one */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">CL_EXPIRE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">mnt_expire</span><span class="p">))</span>
				<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_expire</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">mnt_expire</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">mnt</span><span class="p">;</span>

 <span class="nl">out_free:</span>
	<span class="n">free_vfsmnt</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mntfree</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">mnt_sb</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This probably indicates that somebody messed</span>
<span class="cm">	 * up a mnt_want/drop_write() pair.  If this</span>
<span class="cm">	 * happens, the filesystem was probably unable</span>
<span class="cm">	 * to make r/w-&gt;r/o transitions.</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 * The locking used to deal with mnt_count decrement provides barriers,</span>
<span class="cm">	 * so mnt_get_writers() below is safe.</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">mnt_get_writers</span><span class="p">(</span><span class="n">mnt</span><span class="p">));</span>
	<span class="n">fsnotify_vfsmount_delete</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">);</span>
	<span class="n">free_vfsmnt</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
	<span class="n">deactivate_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mntput_no_expire</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
<span class="nl">put_again:</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">br_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_longterm</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">mnt_add_count</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">br_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">br_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>

	<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">mnt_add_count</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mnt_get_count</span><span class="p">(</span><span class="n">mnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="n">mnt_add_count</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">mnt_get_count</span><span class="p">(</span><span class="n">mnt</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_pinned</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mnt_add_count</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_pinned</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_pinned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
		<span class="n">acct_auto_close_mnt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">put_again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_instance</span><span class="p">);</span>
	<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">mntfree</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mntput</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">real_mount</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
		<span class="cm">/* avoid cacheline pingpong, hope gcc doesn&#39;t get &quot;smart&quot; */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">mnt_expiry_mark</span><span class="p">))</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">mnt_expiry_mark</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mntput_no_expire</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mntput</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="nf">mntget</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mnt</span><span class="p">)</span>
		<span class="n">mnt_add_count</span><span class="p">(</span><span class="n">real_mount</span><span class="p">(</span><span class="n">mnt</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mnt</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mntget</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">mnt_pin</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">real_mount</span><span class="p">(</span><span class="n">mnt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mnt_pinned</span><span class="o">++</span><span class="p">;</span>
	<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mnt_pin</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">mnt_unpin</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">real_mount</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_pinned</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mnt_add_count</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_pinned</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mnt_unpin</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mangle</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seq_escape</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="s">&quot; </span><span class="se">\t\n\\</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Simple .show_options callback for filesystems which don&#39;t want to</span>
<span class="cm"> * implement more complex mount option showing.</span>
<span class="cm"> *</span>
<span class="cm"> * See also save_mount_options().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">generic_show_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">options</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_options</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">options</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">options</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;,&#39;</span><span class="p">);</span>
		<span class="n">mangle</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_show_options</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * If filesystem uses generic_show_options(), this function should be</span>
<span class="cm"> * called from the fill_super() callback.</span>
<span class="cm"> *</span>
<span class="cm"> * The .remount_fs callback usually needs to be handled in a special</span>
<span class="cm"> * way, to make sure, that previous options are not overwritten if the</span>
<span class="cm"> * remount fails.</span>
<span class="cm"> *</span>
<span class="cm"> * Also note, that if the filesystem&#39;s .remount_fs function doesn&#39;t</span>
<span class="cm"> * reset all options to their default value, but changes only newly</span>
<span class="cm"> * given options, then the displayed options will not reflect reality</span>
<span class="cm"> * any more.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">save_mount_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_options</span><span class="p">);</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_options</span><span class="p">,</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">save_mount_options</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">replace_mount_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_options</span><span class="p">;</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_options</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">synchronize_rcu</span><span class="p">();</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">replace_mount_options</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="cm">/* iterator; we want it to have access to namespace_sem, thus here... */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">m_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">proc_mounts</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">proc_mounts</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">seq_list_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">m_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">proc_mounts</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">proc_mounts</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">seq_list_next</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">m_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">m_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">proc_mounts</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">proc_mounts</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mount</span><span class="p">,</span> <span class="n">mnt_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">mounts_op</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="n">m_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>	<span class="o">=</span> <span class="n">m_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>	<span class="o">=</span> <span class="n">m_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>	<span class="o">=</span> <span class="n">m_show</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif  </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * may_umount_tree - check if a mount tree is busy</span>
<span class="cm"> * @mnt: root of mount tree</span>
<span class="cm"> *</span>
<span class="cm"> * This is called to check if a tree of mounts has any</span>
<span class="cm"> * open files, pwds, chroots or sub mounts that are</span>
<span class="cm"> * busy.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">may_umount_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">real_mount</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">actual_refs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">minimum_refs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">m</span><span class="p">);</span>

	<span class="cm">/* write lock needed for mnt_get_count */</span>
	<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">next_mnt</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">mnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">actual_refs</span> <span class="o">+=</span> <span class="n">mnt_get_count</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">minimum_refs</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">actual_refs</span> <span class="o">&gt;</span> <span class="n">minimum_refs</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">may_umount_tree</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * may_umount - check if a mount point is busy</span>
<span class="cm"> * @mnt: root of mount</span>
<span class="cm"> *</span>
<span class="cm"> * This is called to check if a mount point has any</span>
<span class="cm"> * open files, pwds, chroots or sub mounts. If the</span>
<span class="cm"> * mount has sub mounts this will return busy</span>
<span class="cm"> * regardless of whether the sub mounts are busy.</span>
<span class="cm"> *</span>
<span class="cm"> * Doesn&#39;t take quota and stuff into account. IOW, in some cases it will</span>
<span class="cm"> * give false negatives. The main reason why it&#39;s here is that we need</span>
<span class="cm"> * a non-destructive way to look for easily umountable filesystems.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">may_umount</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
	<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">propagate_mount_busy</span><span class="p">(</span><span class="n">real_mount</span><span class="p">(</span><span class="n">mnt</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">may_umount</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">release_mounts</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mnt</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mount</span><span class="p">,</span> <span class="n">mnt_hash</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_hash</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mnt_has_parent</span><span class="p">(</span><span class="n">mnt</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>

			<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
			<span class="n">dentry</span> <span class="o">=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_mountpoint</span><span class="p">;</span>
			<span class="n">m</span> <span class="o">=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_parent</span><span class="p">;</span>
			<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_mountpoint</span> <span class="o">=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_root</span><span class="p">;</span>
			<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_parent</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">mnt_ghosts</span><span class="o">--</span><span class="p">;</span>
			<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
			<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
			<span class="n">mntput</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mntput</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * vfsmount lock must be held for write</span>
<span class="cm"> * namespace_sem must be held for write</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">umount_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">propagate</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">kill</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">tmp_list</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">next_mnt</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">mnt</span><span class="p">))</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_hash</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_list</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">propagate</span><span class="p">)</span>
		<span class="n">propagate_umount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_list</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_list</span><span class="p">,</span> <span class="n">mnt_hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_expire</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_list</span><span class="p">);</span>
		<span class="n">__touch_mnt_namespace</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_ns</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_ns</span><span class="p">)</span>
			<span class="n">__mnt_make_shortterm</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_ns</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_child</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mnt_has_parent</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_parent</span><span class="o">-&gt;</span><span class="n">mnt_ghosts</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dentry_reset_mounted</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_mountpoint</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">change_mnt_propagation</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">MS_PRIVATE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_list</span><span class="p">,</span> <span class="n">kill</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">shrink_submounts</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">umounts</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_umount</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_sb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">umount_list</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">security_sb_umount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allow userspace to request a mountpoint be expired rather than</span>
<span class="cm">	 * unmounting unconditionally. Unmount only happens if:</span>
<span class="cm">	 *  (1) the mark is already set (the mark is cleared by mntput())</span>
<span class="cm">	 *  (2) the usage count == 1 [parent vfsmount] + 1 [sys_umount]</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MNT_EXPIRE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">==</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">mnt</span> <span class="o">||</span>
		    <span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MNT_FORCE</span> <span class="o">|</span> <span class="n">MNT_DETACH</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * probably don&#39;t strictly need the lock here if we examined</span>
<span class="cm">		 * all race cases, but it&#39;s a slowpath.</span>
<span class="cm">		 */</span>
		<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mnt_get_count</span><span class="p">(</span><span class="n">mnt</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_expiry_mark</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we may have to abort operations to get out of this</span>
<span class="cm">	 * mount, and they will themselves hold resources we must</span>
<span class="cm">	 * allow the fs to do things. In the Unix tradition of</span>
<span class="cm">	 * &#39;Gee thats tricky lets do it in userspace&#39; the umount_begin</span>
<span class="cm">	 * might fail to complete on the first run through as other tasks</span>
<span class="cm">	 * must return, and the like. Thats for the mount program to worry</span>
<span class="cm">	 * about for the moment.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MNT_FORCE</span> <span class="o">&amp;&amp;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">umount_begin</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">umount_begin</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * No sense to grab the lock for this test, but test itself looks</span>
<span class="cm">	 * somewhat bogus. Suggestions for better replacement?</span>
<span class="cm">	 * Ho-hum... In principle, we might treat that as umount + switch</span>
<span class="cm">	 * to rootfs. GC would eventually take care of the old vfsmount.</span>
<span class="cm">	 * Actually it makes sense, especially if rootfs would contain a</span>
<span class="cm">	 * /reboot - static binary that would close all descriptors and</span>
<span class="cm">	 * call reboot(9). Then init(8) could umount root and exec /reboot.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">==</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">mnt</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MNT_DETACH</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Special case for &quot;unmounting&quot; root ...</span>
<span class="cm">		 * we just try to remount it readonly.</span>
<span class="cm">		 */</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">do_remount_sb</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">MS_RDONLY</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
	<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">event</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MNT_DETACH</span><span class="p">))</span>
		<span class="n">shrink_submounts</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">umount_list</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MNT_DETACH</span> <span class="o">||</span> <span class="o">!</span><span class="n">propagate_mount_busy</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_list</span><span class="p">))</span>
			<span class="n">umount_tree</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">umount_list</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
	<span class="n">release_mounts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">umount_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Now umount can handle mount points as well as block devices.</span>
<span class="cm"> * This is important for filesystems which use unnamed block devices.</span>
<span class="cm"> *</span>
<span class="cm"> * We now support a flag for forced unmount like the other &#39;big iron&#39;</span>
<span class="cm"> * unixes. Our API is identical to OSF/1 to avoid making a mess of AMD</span>
<span class="cm"> */</span>

<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">umount</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lookup_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">MNT_FORCE</span> <span class="o">|</span> <span class="n">MNT_DETACH</span> <span class="o">|</span> <span class="n">MNT_EXPIRE</span> <span class="o">|</span> <span class="n">UMOUNT_NOFOLLOW</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UMOUNT_NOFOLLOW</span><span class="p">))</span>
		<span class="n">lookup_flags</span> <span class="o">|=</span> <span class="n">LOOKUP_FOLLOW</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">user_path_at</span><span class="p">(</span><span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">lookup_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">mnt</span> <span class="o">=</span> <span class="n">real_mount</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">!=</span> <span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">dput_and_out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_mnt</span><span class="p">(</span><span class="n">mnt</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">dput_and_out</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">dput_and_out</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">do_umount</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="nl">dput_and_out:</span>
	<span class="cm">/* we mustn&#39;t call path_put() as that would clear mnt_expiry_mark */</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">mntput_no_expire</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef __ARCH_WANT_SYS_OLDUMOUNT</span>

<span class="cm">/*</span>
<span class="cm"> *	The 2.0 compatible umount. No flags.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">oldumount</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sys_umount</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">mount_is_safe</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="cp">#ifdef notyet</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_ISVTX</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current_uid</span><span class="p">()</span> <span class="o">!=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode_permission</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">copy_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">CL_COPY_ALL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">IS_MNT_UNBINDABLE</span><span class="p">(</span><span class="n">mnt</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">q</span> <span class="o">=</span> <span class="n">clone_mnt</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">Enomem</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">mnt_mountpoint</span> <span class="o">=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_mountpoint</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_mounts</span><span class="p">,</span> <span class="n">mnt_child</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_subdir</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">mnt_mountpoint</span><span class="p">,</span> <span class="n">dentry</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span> <span class="n">s</span><span class="p">;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">next_mnt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">CL_COPY_ALL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">IS_MNT_UNBINDABLE</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">s</span> <span class="o">=</span> <span class="n">skip_mnt_tree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">mnt_parent</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_parent</span><span class="p">;</span>
				<span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">mnt_parent</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
			<span class="n">path</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">;</span>
			<span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_mountpoint</span><span class="p">;</span>
			<span class="n">q</span> <span class="o">=</span> <span class="n">clone_mnt</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_root</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">Enomem</span><span class="p">;</span>
			<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">mnt_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">mnt_list</span><span class="p">);</span>
			<span class="n">attach_mnt</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
			<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="nl">Enomem:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">umount_list</span><span class="p">);</span>
		<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
		<span class="n">umount_tree</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">umount_list</span><span class="p">);</span>
		<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
		<span class="n">release_mounts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">umount_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">collect_mounts</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">tree</span><span class="p">;</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
	<span class="n">tree</span> <span class="o">=</span> <span class="n">copy_tree</span><span class="p">(</span><span class="n">real_mount</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">),</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span>
			 <span class="n">CL_COPY_ALL</span> <span class="o">|</span> <span class="n">CL_PRIVATE</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tree</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">drop_collected_mounts</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">umount_list</span><span class="p">);</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
	<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">umount_tree</span><span class="p">(</span><span class="n">real_mount</span><span class="p">(</span><span class="n">mnt</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">umount_list</span><span class="p">);</span>
	<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
	<span class="n">release_mounts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">umount_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">iterate_mounts</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">real_mount</span><span class="p">(</span><span class="n">root</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mnt_list</span><span class="p">,</span> <span class="n">mnt_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">cleanup_group_ids</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">next_mnt</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">mnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_group_id</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_MNT_SHARED</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
			<span class="n">mnt_release_group_id</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">invent_group_ids</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="n">bool</span> <span class="n">recurse</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">recurse</span> <span class="o">?</span> <span class="n">next_mnt</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">mnt</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_group_id</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_MNT_SHARED</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">mnt_alloc_group_id</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cleanup_group_ids</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  @source_mnt : mount tree to be attached</span>
<span class="cm"> *  @nd         : place the mount tree @source_mnt is attached</span>
<span class="cm"> *  @parent_nd  : if non-null, detach the source_mnt from its parent and</span>
<span class="cm"> *  		   store the parent mount and mountpoint dentry.</span>
<span class="cm"> *  		   (done when source_mnt is moved)</span>
<span class="cm"> *</span>
<span class="cm"> *  NOTE: in the table below explains the semantics when a source mount</span>
<span class="cm"> *  of a given type is attached to a destination mount of a given type.</span>
<span class="cm"> * ---------------------------------------------------------------------------</span>
<span class="cm"> * |         BIND MOUNT OPERATION                                            |</span>
<span class="cm"> * |**************************************************************************</span>
<span class="cm"> * | source--&gt;| shared        |       private  |       slave    | unbindable |</span>
<span class="cm"> * | dest     |               |                |                |            |</span>
<span class="cm"> * |   |      |               |                |                |            |</span>
<span class="cm"> * |   v      |               |                |                |            |</span>
<span class="cm"> * |**************************************************************************</span>
<span class="cm"> * |  shared  | shared (++)   |     shared (+) |     shared(+++)|  invalid   |</span>
<span class="cm"> * |          |               |                |                |            |</span>
<span class="cm"> * |non-shared| shared (+)    |      private   |      slave (*) |  invalid   |</span>
<span class="cm"> * ***************************************************************************</span>
<span class="cm"> * A bind operation clones the source mount and mounts the clone on the</span>
<span class="cm"> * destination mount.</span>
<span class="cm"> *</span>
<span class="cm"> * (++)  the cloned mount is propagated to all the mounts in the propagation</span>
<span class="cm"> * 	 tree of the destination mount and the cloned mount is added to</span>
<span class="cm"> * 	 the peer group of the source mount.</span>
<span class="cm"> * (+)   the cloned mount is created under the destination mount and is marked</span>
<span class="cm"> *       as shared. The cloned mount is added to the peer group of the source</span>
<span class="cm"> *       mount.</span>
<span class="cm"> * (+++) the mount is propagated to all the mounts in the propagation tree</span>
<span class="cm"> *       of the destination mount and the cloned mount is made slave</span>
<span class="cm"> *       of the same master as that of the source mount. The cloned mount</span>
<span class="cm"> *       is marked as &#39;shared and slave&#39;.</span>
<span class="cm"> * (*)   the cloned mount is made a slave of the same master as that of the</span>
<span class="cm"> * 	 source mount.</span>
<span class="cm"> *</span>
<span class="cm"> * ---------------------------------------------------------------------------</span>
<span class="cm"> * |         		MOVE MOUNT OPERATION                                 |</span>
<span class="cm"> * |**************************************************************************</span>
<span class="cm"> * | source--&gt;| shared        |       private  |       slave    | unbindable |</span>
<span class="cm"> * | dest     |               |                |                |            |</span>
<span class="cm"> * |   |      |               |                |                |            |</span>
<span class="cm"> * |   v      |               |                |                |            |</span>
<span class="cm"> * |**************************************************************************</span>
<span class="cm"> * |  shared  | shared (+)    |     shared (+) |    shared(+++) |  invalid   |</span>
<span class="cm"> * |          |               |                |                |            |</span>
<span class="cm"> * |non-shared| shared (+*)   |      private   |    slave (*)   | unbindable |</span>
<span class="cm"> * ***************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * (+)  the mount is moved to the destination. And is then propagated to</span>
<span class="cm"> * 	all the mounts in the propagation tree of the destination mount.</span>
<span class="cm"> * (+*)  the mount is moved to the destination.</span>
<span class="cm"> * (+++)  the mount is moved to the destination and is then propagated to</span>
<span class="cm"> * 	all the mounts belonging to the destination mount&#39;s propagation tree.</span>
<span class="cm"> * 	the mount is marked as &#39;shared and slave&#39;.</span>
<span class="cm"> * (*)	the mount continues to be a slave at the new location.</span>
<span class="cm"> *</span>
<span class="cm"> * if the source mount is a tree, the operations explained above is</span>
<span class="cm"> * applied to each mount in the tree.</span>
<span class="cm"> * Must be called without spinlocks held, since this function can sleep</span>
<span class="cm"> * in allocations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">attach_recursive_mnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">source_mnt</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">parent_path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">tree_list</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">dest_mnt</span> <span class="o">=</span> <span class="n">real_mount</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dest_dentry</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_MNT_SHARED</span><span class="p">(</span><span class="n">dest_mnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">invent_group_ids</span><span class="p">(</span><span class="n">source_mnt</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">propagate_mnt</span><span class="p">(</span><span class="n">dest_mnt</span><span class="p">,</span> <span class="n">dest_dentry</span><span class="p">,</span> <span class="n">source_mnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tree_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_cleanup_ids</span><span class="p">;</span>

	<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_MNT_SHARED</span><span class="p">(</span><span class="n">dest_mnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">source_mnt</span><span class="p">;</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">next_mnt</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">source_mnt</span><span class="p">))</span>
			<span class="n">set_mnt_shared</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent_path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">detach_mnt</span><span class="p">(</span><span class="n">source_mnt</span><span class="p">,</span> <span class="n">parent_path</span><span class="p">);</span>
		<span class="n">attach_mnt</span><span class="p">(</span><span class="n">source_mnt</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
		<span class="n">touch_mnt_namespace</span><span class="p">(</span><span class="n">source_mnt</span><span class="o">-&gt;</span><span class="n">mnt_ns</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mnt_set_mountpoint</span><span class="p">(</span><span class="n">dest_mnt</span><span class="p">,</span> <span class="n">dest_dentry</span><span class="p">,</span> <span class="n">source_mnt</span><span class="p">);</span>
		<span class="n">commit_tree</span><span class="p">(</span><span class="n">source_mnt</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tree_list</span><span class="p">,</span> <span class="n">mnt_hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">mnt_hash</span><span class="p">);</span>
		<span class="n">commit_tree</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">out_cleanup_ids:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_MNT_SHARED</span><span class="p">(</span><span class="n">dest_mnt</span><span class="p">))</span>
		<span class="n">cleanup_group_ids</span><span class="p">(</span><span class="n">source_mnt</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">lock_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">;</span>
<span class="nl">retry:</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cant_mount</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
	<span class="n">mnt</span> <span class="o">=</span> <span class="n">lookup_mnt</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">mnt</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">path_put</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">unlock_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">graft_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_NOUSER</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">!=</span>
	      <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTDIR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">d_unlinked</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">attach_recursive_mnt</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sanity check the flags to change_mnt_propagation.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">flags_to_propagation_type</span><span class="p">(</span><span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">MS_REC</span> <span class="o">|</span> <span class="n">MS_SILENT</span><span class="p">);</span>

	<span class="cm">/* Fail if any non-propagation flags are set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">MS_SHARED</span> <span class="o">|</span> <span class="n">MS_PRIVATE</span> <span class="o">|</span> <span class="n">MS_SLAVE</span> <span class="o">|</span> <span class="n">MS_UNBINDABLE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Only one propagation flag should be set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">type</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * recursively change the type of the mountpoint.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">do_change_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">real_mount</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">recurse</span> <span class="o">=</span> <span class="n">flag</span> <span class="o">&amp;</span> <span class="n">MS_REC</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">!=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">type</span> <span class="o">=</span> <span class="n">flags_to_propagation_type</span><span class="p">(</span><span class="n">flag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">type</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">MS_SHARED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">invent_group_ids</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="n">recurse</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">m</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span> <span class="n">m</span><span class="p">;</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">recurse</span> <span class="o">?</span> <span class="n">next_mnt</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mnt</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">change_mnt_propagation</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>

 <span class="nl">out_unlock:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * do loopback mount.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">do_loopback</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">old_name</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">recurse</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">umount_list</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">old_path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">old</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">mount_is_safe</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old_name</span> <span class="o">||</span> <span class="o">!*</span><span class="n">old_name</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">kern_path</span><span class="p">(</span><span class="n">old_name</span><span class="p">,</span> <span class="n">LOOKUP_FOLLOW</span><span class="o">|</span><span class="n">LOOKUP_AUTOMOUNT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">lock_mount</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">old</span> <span class="o">=</span> <span class="n">real_mount</span><span class="p">(</span><span class="n">old_path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_MNT_UNBINDABLE</span><span class="p">(</span><span class="n">old</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_mnt</span><span class="p">(</span><span class="n">real_mount</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">))</span> <span class="o">||</span> <span class="o">!</span><span class="n">check_mnt</span><span class="p">(</span><span class="n">old</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">recurse</span><span class="p">)</span>
		<span class="n">mnt</span> <span class="o">=</span> <span class="n">copy_tree</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">old_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">mnt</span> <span class="o">=</span> <span class="n">clone_mnt</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">old_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mnt</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">graft_tree</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
		<span class="n">umount_tree</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">umount_list</span><span class="p">);</span>
		<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out2:</span>
	<span class="n">unlock_mount</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">release_mounts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">umount_list</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">change_mount_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ms_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">readonly_request</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ms_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span>
		<span class="n">readonly_request</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">readonly_request</span> <span class="o">==</span> <span class="n">__mnt_is_readonly</span><span class="p">(</span><span class="n">mnt</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">readonly_request</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">mnt_make_readonly</span><span class="p">(</span><span class="n">real_mount</span><span class="p">(</span><span class="n">mnt</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">__mnt_unmake_readonly</span><span class="p">(</span><span class="n">real_mount</span><span class="p">(</span><span class="n">mnt</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * change filesystem flags. dir should be a physical root of filesystem.</span>
<span class="cm"> * If you&#39;ve mounted a non-root directory somewhere and want to do remount</span>
<span class="cm"> * on it - tough luck.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">do_remount</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mnt_flags</span><span class="p">,</span>
		      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">real_mount</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_mnt</span><span class="p">(</span><span class="n">mnt</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">!=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">security_sb_remount</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_BIND</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">change_mount_flags</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">do_remount_sb</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
		<span class="n">mnt_flags</span> <span class="o">|=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="n">MNT_PROPAGATION_MASK</span><span class="p">;</span>
		<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_flags</span> <span class="o">=</span> <span class="n">mnt_flags</span><span class="p">;</span>
		<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
		<span class="n">touch_mnt_namespace</span><span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_ns</span><span class="p">);</span>
		<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">tree_contains_unbindable</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">next_mnt</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">mnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_MNT_UNBINDABLE</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">do_move_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">old_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">old_path</span><span class="p">,</span> <span class="n">parent_path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">old</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old_name</span> <span class="o">||</span> <span class="o">!*</span><span class="n">old_name</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">kern_path</span><span class="p">(</span><span class="n">old_name</span><span class="p">,</span> <span class="n">LOOKUP_FOLLOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">lock_mount</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">old</span> <span class="o">=</span> <span class="n">real_mount</span><span class="p">(</span><span class="n">old_path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">real_mount</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_mnt</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">check_mnt</span><span class="p">(</span><span class="n">old</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">d_unlinked</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">!=</span> <span class="n">old_path</span><span class="p">.</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mnt_has_parent</span><span class="p">(</span><span class="n">old</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">!=</span>
	      <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">old_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t move a mount residing in a shared parent.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_MNT_SHARED</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">mnt_parent</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t move a mount tree containing unbindable mounts to a destination</span>
<span class="cm">	 * mount which is shared.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_MNT_SHARED</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tree_contains_unbindable</span><span class="p">(</span><span class="n">old</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ELOOP</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">mnt_has_parent</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt_parent</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">old</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">attach_recursive_mnt</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>

	<span class="cm">/* if the mount is moved, it should no longer be expire</span>
<span class="cm">	 * automatically */</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">mnt_expire</span><span class="p">);</span>
<span class="nl">out1:</span>
	<span class="n">unlock_mount</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent_path</span><span class="p">);</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">fs_set_subtype</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fstype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">subtype</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">fstype</span><span class="p">,</span> <span class="sc">&#39;.&#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">subtype</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">subtype</span><span class="o">++</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">subtype</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">subtype</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

	<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_sb</span><span class="o">-&gt;</span><span class="n">s_subtype</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_sb</span><span class="o">-&gt;</span><span class="n">s_subtype</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mnt</span><span class="p">;</span>

 <span class="nl">err:</span>
	<span class="n">mntput</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span>
<span class="n">do_kern_mount</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fstype</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">get_fs_type</span><span class="p">(</span><span class="n">fstype</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">type</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>
	<span class="n">mnt</span> <span class="o">=</span> <span class="n">vfs_kern_mount</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mnt</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">fs_flags</span> <span class="o">&amp;</span> <span class="n">FS_HAS_SUBTYPE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_sb</span><span class="o">-&gt;</span><span class="n">s_subtype</span><span class="p">)</span>
		<span class="n">mnt</span> <span class="o">=</span> <span class="n">fs_set_subtype</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="n">fstype</span><span class="p">);</span>
	<span class="n">put_filesystem</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * add a mount into a namespace&#39;s mount tree</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">do_add_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">newmnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mnt_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mnt_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MNT_SHARED</span> <span class="o">|</span> <span class="n">MNT_WRITE_HOLD</span> <span class="o">|</span> <span class="n">MNT_INTERNAL</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">lock_mount</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="n">MNT_SHRINKABLE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">check_mnt</span><span class="p">(</span><span class="n">real_mount</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="cm">/* Refuse the same filesystem on the same mount point */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_sb</span> <span class="o">==</span> <span class="n">newmnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_sb</span> <span class="o">&amp;&amp;</span>
	    <span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span> <span class="o">==</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">newmnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="n">newmnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_flags</span> <span class="o">=</span> <span class="n">mnt_flags</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">graft_tree</span><span class="p">(</span><span class="n">newmnt</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>

<span class="nl">unlock:</span>
	<span class="n">unlock_mount</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * create a new mount for userspace and request it to be added into the</span>
<span class="cm"> * namespace&#39;s tree</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">do_new_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">mnt_flags</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">type</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* we need capabilities... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">mnt</span> <span class="o">=</span> <span class="n">do_kern_mount</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mnt</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">do_add_mount</span><span class="p">(</span><span class="n">real_mount</span><span class="p">(</span><span class="n">mnt</span><span class="p">),</span> <span class="n">path</span><span class="p">,</span> <span class="n">mnt_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">mntput</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">finish_automount</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">real_mount</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="cm">/* The new mount record should have at least 2 refs to prevent it being</span>
<span class="cm">	 * expired before we get a chance to add it</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mnt_get_count</span><span class="p">(</span><span class="n">mnt</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">mnt_sb</span> <span class="o">==</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_sb</span> <span class="o">&amp;&amp;</span>
	    <span class="n">m</span><span class="o">-&gt;</span><span class="n">mnt_root</span> <span class="o">==</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ELOOP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">do_add_mount</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_flags</span> <span class="o">|</span> <span class="n">MNT_SHRINKABLE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="cm">/* remove m from any expiration list it may be on */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_expire</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
		<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_expire</span><span class="p">);</span>
		<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mntput</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="n">mntput</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mnt_set_expiry - Put a mount on an expiration list</span>
<span class="cm"> * @mnt: The mount to list.</span>
<span class="cm"> * @expiry_list: The list to add the mount to.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">mnt_set_expiry</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">expiry_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
	<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">real_mount</span><span class="p">(</span><span class="n">mnt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mnt_expire</span><span class="p">,</span> <span class="n">expiry_list</span><span class="p">);</span>

	<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mnt_set_expiry</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * process a list of expirable mountpoints with the intent of discarding any</span>
<span class="cm"> * mountpoints that aren&#39;t in use and haven&#39;t been touched since last we came</span>
<span class="cm"> * here</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">mark_mounts_for_expiry</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">mounts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">graveyard</span><span class="p">);</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">umounts</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">mounts</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
	<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>

	<span class="cm">/* extract from the expiration list every vfsmount that matches the</span>
<span class="cm">	 * following criteria:</span>
<span class="cm">	 * - only referenced by its parent vfsmount</span>
<span class="cm">	 * - still marked for expiry (marked on the last call here; marks are</span>
<span class="cm">	 *   cleared by mntput())</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">mounts</span><span class="p">,</span> <span class="n">mnt_expire</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_expiry_mark</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">propagate_mount_busy</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_expire</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">graveyard</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graveyard</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mnt</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graveyard</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mount</span><span class="p">,</span> <span class="n">mnt_expire</span><span class="p">);</span>
		<span class="n">touch_mnt_namespace</span><span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_ns</span><span class="p">);</span>
		<span class="n">umount_tree</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">umounts</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>

	<span class="n">release_mounts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">umounts</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">mark_mounts_for_expiry</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Ripoff of &#39;select_parent()&#39;</span>
<span class="cm"> *</span>
<span class="cm"> * search the list of submounts for a given mountpoint, and move any</span>
<span class="cm"> * shrinkable submounts to the &#39;graveyard&#39; list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">select_submounts</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">graveyard</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">this_parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">repeat:</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">mnt_mounts</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
<span class="nl">resume:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">mnt_mounts</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mount</span><span class="p">,</span> <span class="n">mnt_child</span><span class="p">);</span>

		<span class="n">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="n">MNT_SHRINKABLE</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Descend a level if the d_mounts list is non-empty.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_mounts</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">this_parent</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">propagate_mount_busy</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_expire</span><span class="p">,</span> <span class="n">graveyard</span><span class="p">);</span>
			<span class="n">found</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * All done at this level ... ascend and resume the search</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this_parent</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">mnt_child</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="n">this_parent</span> <span class="o">=</span> <span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">mnt_parent</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">resume</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * process a list of expirable mountpoints with the intent of discarding any</span>
<span class="cm"> * submounts of a specific parent mountpoint</span>
<span class="cm"> *</span>
<span class="cm"> * vfsmount_lock must be held for write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">shrink_submounts</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">umounts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">graveyard</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>

	<span class="cm">/* extract submounts of &#39;mountpoint&#39; from the expiration list */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">select_submounts</span><span class="p">(</span><span class="n">mnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">graveyard</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graveyard</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">m</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graveyard</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mount</span><span class="p">,</span>
						<span class="n">mnt_expire</span><span class="p">);</span>
			<span class="n">touch_mnt_namespace</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">mnt_ns</span><span class="p">);</span>
			<span class="n">umount_tree</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">umounts</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Some copy_from_user() implementations do not return the exact number of</span>
<span class="cm"> * bytes remaining to copy on a fault.  But copy_mount_options() requires that.</span>
<span class="cm"> * Note that this function differs from copy_from_user() in that it will oops</span>
<span class="cm"> * on bad values of `to&#39;, rather than returning a short copy.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">exact_copy_from_user</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">from</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">to</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">from</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">c</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__get_user</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">t</span><span class="o">++</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="n">f</span><span class="o">++</span><span class="p">;</span>
		<span class="n">n</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">copy_mount_options</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">where</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>

	<span class="o">*</span><span class="n">where</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">page</span> <span class="o">=</span> <span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* We only care that *some* data at the address the user</span>
<span class="cm">	 * gave us is valid.  Just in case, we&#39;ll zero</span>
<span class="cm">	 * the remainder of the page.</span>
<span class="cm">	 */</span>
	<span class="cm">/* copy_from_user cannot cross TASK_SIZE ! */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">TASK_SIZE</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">exact_copy_from_user</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">page</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">page</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
	<span class="o">*</span><span class="n">where</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">copy_mount_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">where</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">where</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">strndup_user</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

	<span class="o">*</span><span class="n">where</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Flags is a 32-bit value that allows up to 31 non-fs dependent flags to</span>
<span class="cm"> * be given to the mount() call (ie: read-only, no-dev, no-suid etc).</span>
<span class="cm"> *</span>
<span class="cm"> * data is a (void *) that can point to any structure up to</span>
<span class="cm"> * PAGE_SIZE-1 bytes, which can contain arbitrary fs-dependent</span>
<span class="cm"> * information (or be NULL).</span>
<span class="cm"> *</span>
<span class="cm"> * Pre-0.97 versions of mount() didn&#39;t have a flags word.</span>
<span class="cm"> * When the flags word was introduced its top half was required</span>
<span class="cm"> * to have the magic value 0xC0ED, and this remained so until 2.4.0-test9.</span>
<span class="cm"> * Therefore, if this magic number is present, it carries no information</span>
<span class="cm"> * and must be discarded.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="nf">do_mount</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dir_name</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type_page</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mnt_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Discard magic */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_MGC_MSK</span><span class="p">)</span> <span class="o">==</span> <span class="n">MS_MGC_VAL</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MS_MGC_MSK</span><span class="p">;</span>

	<span class="cm">/* Basic sanity checks */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir_name</span> <span class="o">||</span> <span class="o">!*</span><span class="n">dir_name</span> <span class="o">||</span> <span class="o">!</span><span class="n">memchr</span><span class="p">(</span><span class="n">dir_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data_page</span><span class="p">)</span>
		<span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">data_page</span><span class="p">)[</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* ... and get the mountpoint */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">kern_path</span><span class="p">(</span><span class="n">dir_name</span><span class="p">,</span> <span class="n">LOOKUP_FOLLOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">security_sb_mount</span><span class="p">(</span><span class="n">dev_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">,</span>
				   <span class="n">type_page</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">data_page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">dput_out</span><span class="p">;</span>

	<span class="cm">/* Default to relatime unless overriden */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_NOATIME</span><span class="p">))</span>
		<span class="n">mnt_flags</span> <span class="o">|=</span> <span class="n">MNT_RELATIME</span><span class="p">;</span>

	<span class="cm">/* Separate the per-mountpoint flags */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_NOSUID</span><span class="p">)</span>
		<span class="n">mnt_flags</span> <span class="o">|=</span> <span class="n">MNT_NOSUID</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_NODEV</span><span class="p">)</span>
		<span class="n">mnt_flags</span> <span class="o">|=</span> <span class="n">MNT_NODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_NOEXEC</span><span class="p">)</span>
		<span class="n">mnt_flags</span> <span class="o">|=</span> <span class="n">MNT_NOEXEC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_NOATIME</span><span class="p">)</span>
		<span class="n">mnt_flags</span> <span class="o">|=</span> <span class="n">MNT_NOATIME</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_NODIRATIME</span><span class="p">)</span>
		<span class="n">mnt_flags</span> <span class="o">|=</span> <span class="n">MNT_NODIRATIME</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_STRICTATIME</span><span class="p">)</span>
		<span class="n">mnt_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MNT_RELATIME</span> <span class="o">|</span> <span class="n">MNT_NOATIME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span>
		<span class="n">mnt_flags</span> <span class="o">|=</span> <span class="n">MNT_READONLY</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MS_NOSUID</span> <span class="o">|</span> <span class="n">MS_NOEXEC</span> <span class="o">|</span> <span class="n">MS_NODEV</span> <span class="o">|</span> <span class="n">MS_ACTIVE</span> <span class="o">|</span> <span class="n">MS_BORN</span> <span class="o">|</span>
		   <span class="n">MS_NOATIME</span> <span class="o">|</span> <span class="n">MS_NODIRATIME</span> <span class="o">|</span> <span class="n">MS_RELATIME</span><span class="o">|</span> <span class="n">MS_KERNMOUNT</span> <span class="o">|</span>
		   <span class="n">MS_STRICTATIME</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_REMOUNT</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">do_remount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MS_REMOUNT</span><span class="p">,</span> <span class="n">mnt_flags</span><span class="p">,</span>
				    <span class="n">data_page</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_BIND</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">do_loopback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_REC</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MS_SHARED</span> <span class="o">|</span> <span class="n">MS_PRIVATE</span> <span class="o">|</span> <span class="n">MS_SLAVE</span> <span class="o">|</span> <span class="n">MS_UNBINDABLE</span><span class="p">))</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">do_change_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_MOVE</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">do_move_mount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">do_new_mount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">type_page</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">mnt_flags</span><span class="p">,</span>
				      <span class="n">dev_name</span><span class="p">,</span> <span class="n">data_page</span><span class="p">);</span>
<span class="nl">dput_out:</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mnt_namespace</span> <span class="o">*</span><span class="nf">alloc_mnt_ns</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mnt_namespace</span> <span class="o">*</span><span class="n">new_ns</span><span class="p">;</span>

	<span class="n">new_ns</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mnt_namespace</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_ns</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ns</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">new_ns</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ns</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ns</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">);</span>
	<span class="n">new_ns</span><span class="o">-&gt;</span><span class="n">event</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">new_ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mnt_make_longterm</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__mnt_make_longterm</span><span class="p">(</span><span class="n">real_mount</span><span class="p">(</span><span class="n">mnt</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mnt_make_shortterm</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">real_mount</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_add_unless</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_longterm</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_longterm</span><span class="p">);</span>
	<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a new namespace structure and populate it with contents</span>
<span class="cm"> * copied from the namespace of the passed in task structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mnt_namespace</span> <span class="o">*</span><span class="nf">dup_mnt_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">mnt_namespace</span> <span class="o">*</span><span class="n">mnt_ns</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">fs_struct</span> <span class="o">*</span><span class="n">fs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mnt_namespace</span> <span class="o">*</span><span class="n">new_ns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">rootmnt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">pwdmnt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="n">mnt_ns</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>

	<span class="n">new_ns</span> <span class="o">=</span> <span class="n">alloc_mnt_ns</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new_ns</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">new_ns</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
	<span class="cm">/* First pass: copy the tree topology */</span>
	<span class="n">new</span> <span class="o">=</span> <span class="n">copy_tree</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">.</span><span class="n">mnt_root</span><span class="p">,</span> <span class="n">CL_COPY_ALL</span> <span class="o">|</span> <span class="n">CL_EXPIRE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">new_ns</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">new_ns</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
	<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ns</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">mnt_list</span><span class="p">);</span>
	<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Second pass: switch the tsk-&gt;fs-&gt;* elements and mark new vfsmounts</span>
<span class="cm">	 * as belonging to new namespace.  We have already acquired a private</span>
<span class="cm">	 * fs_struct, so tsk-&gt;fs-&gt;lock is not needed.</span>
<span class="cm">	 */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>
	<span class="n">q</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">mnt_ns</span> <span class="o">=</span> <span class="n">new_ns</span><span class="p">;</span>
		<span class="n">__mnt_make_longterm</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fs</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">==</span> <span class="n">fs</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">mnt</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">fs</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">mntget</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
				<span class="n">__mnt_make_longterm</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
				<span class="n">mnt_make_shortterm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
				<span class="n">rootmnt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">==</span> <span class="n">fs</span><span class="o">-&gt;</span><span class="n">pwd</span><span class="p">.</span><span class="n">mnt</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">fs</span><span class="o">-&gt;</span><span class="n">pwd</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">mntget</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
				<span class="n">__mnt_make_longterm</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
				<span class="n">mnt_make_shortterm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
				<span class="n">pwdmnt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">next_mnt</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>
		<span class="n">q</span> <span class="o">=</span> <span class="n">next_mnt</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rootmnt</span><span class="p">)</span>
		<span class="n">mntput</span><span class="p">(</span><span class="n">rootmnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pwdmnt</span><span class="p">)</span>
		<span class="n">mntput</span><span class="p">(</span><span class="n">pwdmnt</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">new_ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">mnt_namespace</span> <span class="o">*</span><span class="nf">copy_mnt_ns</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mnt_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">fs_struct</span> <span class="o">*</span><span class="n">new_fs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mnt_namespace</span> <span class="o">*</span><span class="n">new_ns</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="p">);</span>
	<span class="n">get_mnt_ns</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLONE_NEWNS</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ns</span><span class="p">;</span>

	<span class="n">new_ns</span> <span class="o">=</span> <span class="n">dup_mnt_ns</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">new_fs</span><span class="p">);</span>

	<span class="n">put_mnt_ns</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">new_ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * create_mnt_ns - creates a private namespace and adds a root filesystem</span>
<span class="cm"> * @mnt: pointer to the new root filesystem mountpoint</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mnt_namespace</span> <span class="o">*</span><span class="nf">create_mnt_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mnt_namespace</span> <span class="o">*</span><span class="n">new_ns</span> <span class="o">=</span> <span class="n">alloc_mnt_ns</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new_ns</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">real_mount</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_ns</span> <span class="o">=</span> <span class="n">new_ns</span><span class="p">;</span>
		<span class="n">__mnt_make_longterm</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
		<span class="n">new_ns</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ns</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_list</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mntput</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">new_ns</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">mount_subtree</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mnt_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ns</span> <span class="o">=</span> <span class="n">create_mnt_ns</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ns</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">vfs_path_lookup</span><span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">,</span> <span class="n">mnt</span><span class="p">,</span>
			<span class="n">name</span><span class="p">,</span> <span class="n">LOOKUP_FOLLOW</span><span class="o">|</span><span class="n">LOOKUP_AUTOMOUNT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>

	<span class="n">put_mnt_ns</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>

	<span class="cm">/* trade a vfsmount reference for active sb one */</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_sb</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_active</span><span class="p">);</span>
	<span class="n">mntput</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
	<span class="cm">/* lock the sucker */</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
	<span class="cm">/* ... and return the root of (sub)tree on it */</span>
	<span class="k">return</span> <span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mount_subtree</span><span class="p">);</span>

<span class="n">SYSCALL_DEFINE5</span><span class="p">(</span><span class="n">mount</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">dir_name</span><span class="p">,</span>
		<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kernel_type</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kernel_dir</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kernel_dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data_page</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_mount_string</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kernel_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_type</span><span class="p">;</span>

	<span class="n">kernel_dir</span> <span class="o">=</span> <span class="n">getname</span><span class="p">(</span><span class="n">dir_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">kernel_dir</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">kernel_dir</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_dir</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_mount_string</span><span class="p">(</span><span class="n">dev_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kernel_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_dev</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_mount_options</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data_page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_data</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_mount</span><span class="p">(</span><span class="n">kernel_dev</span><span class="p">,</span> <span class="n">kernel_dir</span><span class="p">,</span> <span class="n">kernel_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">data_page</span><span class="p">);</span>

	<span class="n">free_page</span><span class="p">(</span><span class="n">data_page</span><span class="p">);</span>
<span class="nl">out_data:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">kernel_dev</span><span class="p">);</span>
<span class="nl">out_dev:</span>
	<span class="n">putname</span><span class="p">(</span><span class="n">kernel_dir</span><span class="p">);</span>
<span class="nl">out_dir:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">kernel_type</span><span class="p">);</span>
<span class="nl">out_type:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return true if path is reachable from root</span>
<span class="cm"> *</span>
<span class="cm"> * namespace_sem or vfsmount_lock is held</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="n">is_path_reachable</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">!=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">&amp;&amp;</span> <span class="n">mnt_has_parent</span><span class="p">(</span><span class="n">mnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dentry</span> <span class="o">=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_mountpoint</span><span class="p">;</span>
		<span class="n">mnt</span> <span class="o">=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_parent</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">mnt</span> <span class="o">&amp;&amp;</span> <span class="n">is_subdir</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">path_is_under</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
	<span class="n">br_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">is_path_reachable</span><span class="p">(</span><span class="n">real_mount</span><span class="p">(</span><span class="n">path1</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">),</span> <span class="n">path1</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span> <span class="n">path2</span><span class="p">);</span>
	<span class="n">br_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">path_is_under</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * pivot_root Semantics:</span>
<span class="cm"> * Moves the root file system of the current process to the directory put_old,</span>
<span class="cm"> * makes new_root as the new root file system of the current process, and sets</span>
<span class="cm"> * root/cwd of all processes which had them on the current root to new_root.</span>
<span class="cm"> *</span>
<span class="cm"> * Restrictions:</span>
<span class="cm"> * The new_root and put_old must be directories, and  must not be on the</span>
<span class="cm"> * same file  system as the current process root. The put_old  must  be</span>
<span class="cm"> * underneath new_root,  i.e. adding a non-zero number of /.. to the string</span>
<span class="cm"> * pointed to by put_old must yield the same directory as new_root. No other</span>
<span class="cm"> * file system may be mounted on put_old. After all, new_root is a mountpoint.</span>
<span class="cm"> *</span>
<span class="cm"> * Also, the current root cannot be on the &#39;rootfs&#39; (initial ramfs) filesystem.</span>
<span class="cm"> * See Documentation/filesystems/ramfs-rootfs-initramfs.txt for alternatives</span>
<span class="cm"> * in this situation.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *  - we don&#39;t move root/cwd if they are not at the root (reason: if something</span>
<span class="cm"> *    cared enough to change them, it&#39;s probably wrong to force them elsewhere)</span>
<span class="cm"> *  - it&#39;s okay to pick a root that isn&#39;t the root of a file system, e.g.</span>
<span class="cm"> *    /nfs/my_root where /nfs is the mount point. It must be a mountpoint,</span>
<span class="cm"> *    though, so you may need to say mount --bind /nfs/my_root /nfs/my_root</span>
<span class="cm"> *    first.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">pivot_root</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">new_root</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">put_old</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">parent_path</span><span class="p">,</span> <span class="n">root_parent</span><span class="p">,</span> <span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">new_mnt</span><span class="p">,</span> <span class="o">*</span><span class="n">root_mnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">user_path_dir</span><span class="p">(</span><span class="n">new_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out0</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">user_path_dir</span><span class="p">(</span><span class="n">put_old</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">security_sb_pivotroot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>

	<span class="n">get_fs_root</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">lock_mount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out3</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">new_mnt</span> <span class="o">=</span> <span class="n">real_mount</span><span class="p">(</span><span class="n">new</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
	<span class="n">root_mnt</span> <span class="o">=</span> <span class="n">real_mount</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_MNT_SHARED</span><span class="p">(</span><span class="n">real_mount</span><span class="p">(</span><span class="n">old</span><span class="p">.</span><span class="n">mnt</span><span class="p">))</span> <span class="o">||</span>
		<span class="n">IS_MNT_SHARED</span><span class="p">(</span><span class="n">new_mnt</span><span class="o">-&gt;</span><span class="n">mnt_parent</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">IS_MNT_SHARED</span><span class="p">(</span><span class="n">root_mnt</span><span class="o">-&gt;</span><span class="n">mnt_parent</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_mnt</span><span class="p">(</span><span class="n">root_mnt</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">check_mnt</span><span class="p">(</span><span class="n">new_mnt</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out4</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d_unlinked</span><span class="p">(</span><span class="n">new</span><span class="p">.</span><span class="n">dentry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d_unlinked</span><span class="p">(</span><span class="n">old</span><span class="p">.</span><span class="n">dentry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out4</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">.</span><span class="n">mnt</span> <span class="o">==</span> <span class="n">root</span><span class="p">.</span><span class="n">mnt</span> <span class="o">||</span>
	    <span class="n">old</span><span class="p">.</span><span class="n">mnt</span> <span class="o">==</span> <span class="n">root</span><span class="p">.</span><span class="n">mnt</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out4</span><span class="p">;</span> <span class="cm">/* loop, on the same file system  */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span> <span class="o">!=</span> <span class="n">root</span><span class="p">.</span><span class="n">dentry</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out4</span><span class="p">;</span> <span class="cm">/* not a mountpoint */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mnt_has_parent</span><span class="p">(</span><span class="n">root_mnt</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out4</span><span class="p">;</span> <span class="cm">/* not attached */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">.</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span> <span class="o">!=</span> <span class="n">new</span><span class="p">.</span><span class="n">dentry</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out4</span><span class="p">;</span> <span class="cm">/* not a mountpoint */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mnt_has_parent</span><span class="p">(</span><span class="n">new_mnt</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out4</span><span class="p">;</span> <span class="cm">/* not attached */</span>
	<span class="cm">/* make sure we can reach put_old from new_root */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_path_reachable</span><span class="p">(</span><span class="n">real_mount</span><span class="p">(</span><span class="n">old</span><span class="p">.</span><span class="n">mnt</span><span class="p">),</span> <span class="n">old</span><span class="p">.</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out4</span><span class="p">;</span>
	<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">detach_mnt</span><span class="p">(</span><span class="n">new_mnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_path</span><span class="p">);</span>
	<span class="n">detach_mnt</span><span class="p">(</span><span class="n">root_mnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root_parent</span><span class="p">);</span>
	<span class="cm">/* mount old root on put_old */</span>
	<span class="n">attach_mnt</span><span class="p">(</span><span class="n">root_mnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old</span><span class="p">);</span>
	<span class="cm">/* mount new_root on / */</span>
	<span class="n">attach_mnt</span><span class="p">(</span><span class="n">new_mnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root_parent</span><span class="p">);</span>
	<span class="n">touch_mnt_namespace</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">mnt_ns</span><span class="p">);</span>
	<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">chroot_fs_refs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out4:</span>
	<span class="n">unlock_mount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_parent</span><span class="p">);</span>
		<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent_path</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out3:</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="p">);</span>
<span class="nl">out2:</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old</span><span class="p">);</span>
<span class="nl">out1:</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="p">);</span>
<span class="nl">out0:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="n">init_mount_tree</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mnt_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">root</span><span class="p">;</span>

	<span class="n">mnt</span> <span class="o">=</span> <span class="n">do_kern_mount</span><span class="p">(</span><span class="s">&quot;rootfs&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;rootfs&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mnt</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Can&#39;t create rootfs&quot;</span><span class="p">);</span>

	<span class="n">ns</span> <span class="o">=</span> <span class="n">create_mnt_ns</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ns</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Can&#39;t allocate initial namespace&quot;</span><span class="p">);</span>

	<span class="n">init_task</span><span class="p">.</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">mnt_ns</span> <span class="o">=</span> <span class="n">ns</span><span class="p">;</span>
	<span class="n">get_mnt_ns</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>

	<span class="n">root</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">mnt</span><span class="p">;</span>
	<span class="n">root</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">;</span>

	<span class="n">set_fs_pwd</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="p">);</span>
	<span class="n">set_fs_root</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="n">mnt_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">u</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">init_rwsem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>

	<span class="n">mnt_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;mnt_cache&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mount</span><span class="p">),</span>
			<span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_HWCACHE_ALIGN</span> <span class="o">|</span> <span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">mount_hashtable</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mount_hashtable</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Failed to allocate mount hash table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Mount-cache hash table entries: %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">HASH_SIZE</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="n">HASH_SIZE</span><span class="p">;</span> <span class="n">u</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mount_hashtable</span><span class="p">[</span><span class="n">u</span><span class="p">]);</span>

	<span class="n">br_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sysfs_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: sysfs_init error: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">fs_kobj</span> <span class="o">=</span> <span class="n">kobject_create_and_add</span><span class="p">(</span><span class="s">&quot;fs&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fs_kobj</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: kobj create error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">init_rootfs</span><span class="p">();</span>
	<span class="n">init_mount_tree</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">put_mnt_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">mnt_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">umount_list</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
	<span class="n">br_write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">umount_tree</span><span class="p">(</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">umount_list</span><span class="p">);</span>
	<span class="n">br_write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">namespace_sem</span><span class="p">);</span>
	<span class="n">release_mounts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">umount_list</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">kern_mount_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">;</span>
	<span class="n">mnt</span> <span class="o">=</span> <span class="n">vfs_kern_mount</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">MS_KERNMOUNT</span><span class="p">,</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * it is a longterm mount, don&#39;t release mnt until</span>
<span class="cm">		 * we unmount before file sys is unregistered</span>
<span class="cm">		*/</span>
		<span class="n">mnt_make_longterm</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">mnt</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">kern_mount_data</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kern_unmount</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* release long term mount so mount point can be released */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">mnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mnt_make_shortterm</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
		<span class="n">mntput</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kern_unmount</span><span class="p">);</span>

<span class="n">bool</span> <span class="nf">our_mnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">check_mnt</span><span class="p">(</span><span class="n">real_mount</span><span class="p">(</span><span class="n">mnt</span><span class="p">));</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
