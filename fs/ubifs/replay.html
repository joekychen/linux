<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ubifs › replay.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>replay.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is part of UBIFS.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Nokia Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="cm"> * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Adrian Hunter</span>
<span class="cm"> *          Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file contains journal replay code. It runs when the file-system is being</span>
<span class="cm"> * mounted and requires no locking.</span>
<span class="cm"> *</span>
<span class="cm"> * The larger is the journal, the longer it takes to scan it, so the longer it</span>
<span class="cm"> * takes to mount UBIFS. This is why the journal has limited size which may be</span>
<span class="cm"> * changed depending on the system requirements. But a larger journal gives</span>
<span class="cm"> * faster I/O speed because it writes the index less frequently. So this is a</span>
<span class="cm"> * trade-off. Also, the journal is indexed by the in-memory index (TNC), so the</span>
<span class="cm"> * larger is the journal, the more memory its index may consume.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;ubifs.h&quot;</span>
<span class="cp">#include &lt;linux/list_sort.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * struct replay_entry - replay list entry.</span>
<span class="cm"> * @lnum: logical eraseblock number of the node</span>
<span class="cm"> * @offs: node offset</span>
<span class="cm"> * @len: node length</span>
<span class="cm"> * @deletion: non-zero if this entry corresponds to a node deletion</span>
<span class="cm"> * @sqnum: node sequence number</span>
<span class="cm"> * @list: links the replay list</span>
<span class="cm"> * @key: node key</span>
<span class="cm"> * @nm: directory entry name</span>
<span class="cm"> * @old_size: truncation old size</span>
<span class="cm"> * @new_size: truncation new size</span>
<span class="cm"> *</span>
<span class="cm"> * The replay process first scans all buds and builds the replay list, then</span>
<span class="cm"> * sorts the replay list in nodes sequence number order, and then inserts all</span>
<span class="cm"> * the replay entries to the TNC.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">replay_entry</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">deletion</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sqnum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">qstr</span> <span class="n">nm</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">loff_t</span> <span class="n">old_size</span><span class="p">;</span>
			<span class="n">loff_t</span> <span class="n">new_size</span><span class="p">;</span>
		<span class="p">};</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct bud_entry - entry in the list of buds to replay.</span>
<span class="cm"> * @list: next bud in the list</span>
<span class="cm"> * @bud: bud description object</span>
<span class="cm"> * @sqnum: reference node sequence number</span>
<span class="cm"> * @free: free bytes in the bud</span>
<span class="cm"> * @dirty: dirty bytes in the bud</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bud_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_bud</span> <span class="o">*</span><span class="n">bud</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sqnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">free</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dirty</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * set_bud_lprops - set free and dirty space used by a bud.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @b: bud entry which describes the bud</span>
<span class="cm"> *</span>
<span class="cm"> * This function makes sure the LEB properties of bud @b are set correctly</span>
<span class="cm"> * after the replay. Returns zero in case of success and a negative error code</span>
<span class="cm"> * in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_bud_lprops</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bud_entry</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dirty</span><span class="p">;</span>

	<span class="n">ubifs_get_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">lp</span> <span class="o">=</span> <span class="n">ubifs_lpt_lookup_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bud</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dirty</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bud</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">||</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The LEB was added to the journal with a starting offset of</span>
<span class="cm">		 * zero which means the LEB must have been empty. The LEB</span>
<span class="cm">		 * property values should be @lp-&gt;free == @c-&gt;leb_size and</span>
<span class="cm">		 * @lp-&gt;dirty == 0, but that is not the case. The reason is that</span>
<span class="cm">		 * the LEB had been garbage collected before it became the bud,</span>
<span class="cm">		 * and there was not commit inbetween. The garbage collector</span>
<span class="cm">		 * resets the free and dirty space without recording it</span>
<span class="cm">		 * anywhere except lprops, so if there was no commit then</span>
<span class="cm">		 * lprops does not have that information.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We do not need to adjust free space because the scan has told</span>
<span class="cm">		 * us the exact value which is recorded in the replay entry as</span>
<span class="cm">		 * @b-&gt;free.</span>
<span class="cm">		 *</span>
<span class="cm">		 * However we do need to subtract from the dirty space the</span>
<span class="cm">		 * amount of space that the garbage collector reclaimed, which</span>
<span class="cm">		 * is the whole LEB minus the amount of space that was free.</span>
<span class="cm">		 */</span>
		<span class="n">dbg_mnt</span><span class="p">(</span><span class="s">&quot;bud LEB %d was GC&#39;d (%d free, %d dirty)&quot;</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bud</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">);</span>
		<span class="n">dbg_gc</span><span class="p">(</span><span class="s">&quot;bud LEB %d was GC&#39;d (%d free, %d dirty)&quot;</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bud</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">);</span>
		<span class="n">dirty</span> <span class="o">-=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the replay order was perfect the dirty space would now be</span>
<span class="cm">		 * zero. The order is not perfect because the journal heads</span>
<span class="cm">		 * race with each other. This is not a problem but is does mean</span>
<span class="cm">		 * that the dirty space may temporarily exceed c-&gt;leb_size</span>
<span class="cm">		 * during the replay.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dirty</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;LEB %d lp: %d free %d dirty &quot;</span>
				<span class="s">&quot;replay: %d free %d dirty&quot;</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bud</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span>
				<span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="n">ubifs_change_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lp</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">dirty</span> <span class="o">+</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">,</span>
			     <span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|</span> <span class="n">LPROPS_TAKEN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure the journal head points to the latest bud */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_wbuf_seek_nolock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">bud</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">].</span><span class="n">wbuf</span><span class="p">,</span>
				     <span class="n">b</span><span class="o">-&gt;</span><span class="n">bud</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">ubifs_release_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * set_buds_lprops - set free and dirty space for all replayed buds.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function sets LEB properties for all replayed buds. Returns zero in</span>
<span class="cm"> * case of success and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_buds_lprops</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bud_entry</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">replay_buds</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">set_bud_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * trun_remove_range - apply a replay entry for a truncation to the TNC.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @r: replay entry of truncation</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">trun_remove_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">replay_entry</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">min_blk</span><span class="p">,</span> <span class="n">max_blk</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">min_key</span><span class="p">,</span> <span class="n">max_key</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">ino</span><span class="p">;</span>

	<span class="n">min_blk</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">new_size</span> <span class="o">/</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">new_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UBIFS_BLOCK_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">min_blk</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">max_blk</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">old_size</span> <span class="o">/</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">old_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UBIFS_BLOCK_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">max_blk</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ino</span> <span class="o">=</span> <span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>

	<span class="n">data_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">min_key</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">min_blk</span><span class="p">);</span>
	<span class="n">data_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">max_key</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">max_blk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ubifs_tnc_remove_range</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">min_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">max_key</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * apply_replay_entry - apply a replay entry to the TNC.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @r: replay entry to apply</span>
<span class="cm"> *</span>
<span class="cm"> * Apply a replay entry to the TNC.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">apply_replay_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">replay_entry</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dbg_mntk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;LEB %d:%d len %d deletion %d sqnum %llu key &quot;</span><span class="p">,</span>
		 <span class="n">r</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">deletion</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">sqnum</span><span class="p">);</span>

	<span class="cm">/* Set c-&gt;replay_sqnum to help deal with dangling branches. */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">replay_sqnum</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">sqnum</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_hash_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">deletion</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_remove_nm</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">nm</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_add_nm</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span>
					       <span class="n">r</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">nm</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">deletion</span><span class="p">)</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">UBIFS_INO_KEY</span>:
			<span class="p">{</span>
				<span class="n">ino_t</span> <span class="n">inum</span> <span class="o">=</span> <span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>

				<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_remove_ino</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">case</span> <span class="n">UBIFS_TRUN_KEY</span>:
				<span class="n">err</span> <span class="o">=</span> <span class="n">trun_remove_range</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_remove</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_add</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span>
					    <span class="n">r</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">need_recovery</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_recover_size_accum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">deletion</span><span class="p">,</span>
						       <span class="n">r</span><span class="o">-&gt;</span><span class="n">new_size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * replay_entries_cmp - compare 2 replay entries.</span>
<span class="cm"> * @priv: UBIFS file-system description object</span>
<span class="cm"> * @a: first replay entry</span>
<span class="cm"> * @a: second replay entry</span>
<span class="cm"> *</span>
<span class="cm"> * This is a comparios function for &#39;list_sort()&#39; which compares 2 replay</span>
<span class="cm"> * entries @a and @b by comparing their sequence numer.  Returns %1 if @a has</span>
<span class="cm"> * greater sequence number and %-1 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">replay_entries_cmp</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">replay_entry</span> <span class="o">*</span><span class="n">ra</span><span class="p">,</span> <span class="o">*</span><span class="n">rb</span><span class="p">;</span>

	<span class="n">cond_resched</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ra</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">replay_entry</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">rb</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="k">struct</span> <span class="n">replay_entry</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">ra</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">!=</span> <span class="n">rb</span><span class="o">-&gt;</span><span class="n">sqnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ra</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">&gt;</span> <span class="n">rb</span><span class="o">-&gt;</span><span class="n">sqnum</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * apply_replay_list - apply the replay list to the TNC.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * Apply all entries in the replay list to the TNC. Returns zero in case of</span>
<span class="cm"> * success and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">apply_replay_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">replay_entry</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">list_sort</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">replay_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">replay_entries_cmp</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">replay_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">apply_replay_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * destroy_replay_list - destroy the replay.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * Destroy the replay list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_replay_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">replay_entry</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">replay_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_hash_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">))</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">nm</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * insert_node - insert a node to the replay list</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lnum: node logical eraseblock number</span>
<span class="cm"> * @offs: node offset</span>
<span class="cm"> * @len: node length</span>
<span class="cm"> * @key: node key</span>
<span class="cm"> * @sqnum: sequence number</span>
<span class="cm"> * @deletion: non-zero if this is a deletion</span>
<span class="cm"> * @used: number of bytes in use in a LEB</span>
<span class="cm"> * @old_size: truncation old size</span>
<span class="cm"> * @new_size: truncation new size</span>
<span class="cm"> *</span>
<span class="cm"> * This function inserts a scanned non-direntry node to the replay list. The</span>
<span class="cm"> * replay list contains @struct replay_entry elements, and we sort this list in</span>
<span class="cm"> * sequence number order before applying it. The replay list is applied at the</span>
<span class="cm"> * very end of the replay process. Since the list is sorted in sequence number</span>
<span class="cm"> * order, the older modifications are applied first. This function returns zero</span>
<span class="cm"> * in case of success and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">insert_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
		       <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sqnum</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">deletion</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">used</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">old_size</span><span class="p">,</span>
		       <span class="n">loff_t</span> <span class="n">new_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">replay_entry</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>

	<span class="n">dbg_mntk</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;add LEB %d:%d, key &quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">highest_inum</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">highest_inum</span> <span class="o">=</span> <span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">replay_entry</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">deletion</span><span class="p">)</span>
		<span class="o">*</span><span class="n">used</span> <span class="o">+=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">deletion</span> <span class="o">=</span> <span class="o">!!</span><span class="n">deletion</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">=</span> <span class="n">sqnum</span><span class="p">;</span>
	<span class="n">key_copy</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">old_size</span> <span class="o">=</span> <span class="n">old_size</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">new_size</span> <span class="o">=</span> <span class="n">new_size</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">replay_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * insert_dent - insert a directory entry node into the replay list.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lnum: node logical eraseblock number</span>
<span class="cm"> * @offs: node offset</span>
<span class="cm"> * @len: node length</span>
<span class="cm"> * @key: node key</span>
<span class="cm"> * @name: directory entry name</span>
<span class="cm"> * @nlen: directory entry name length</span>
<span class="cm"> * @sqnum: sequence number</span>
<span class="cm"> * @deletion: non-zero if this is a deletion</span>
<span class="cm"> * @used: number of bytes in use in a LEB</span>
<span class="cm"> *</span>
<span class="cm"> * This function inserts a scanned directory entry node or an extended</span>
<span class="cm"> * attribute entry to the replay list. Returns zero in case of success and a</span>
<span class="cm"> * negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">insert_dent</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
		       <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nlen</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sqnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">deletion</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">used</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">replay_entry</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">nbuf</span><span class="p">;</span>

	<span class="n">dbg_mntk</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;add LEB %d:%d, key &quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">highest_inum</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">highest_inum</span> <span class="o">=</span> <span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">replay_entry</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">nbuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">nlen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">deletion</span><span class="p">)</span>
		<span class="o">*</span><span class="n">used</span> <span class="o">+=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">deletion</span> <span class="o">=</span> <span class="o">!!</span><span class="n">deletion</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">=</span> <span class="n">sqnum</span><span class="p">;</span>
	<span class="n">key_copy</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">nm</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">nlen</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">nbuf</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">nlen</span><span class="p">);</span>
	<span class="n">nbuf</span><span class="p">[</span><span class="n">nlen</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">r</span><span class="o">-&gt;</span><span class="n">nm</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">nbuf</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">replay_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_validate_entry - validate directory or extended attribute entry node.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @dent: the node to validate</span>
<span class="cm"> *</span>
<span class="cm"> * This function validates directory or extended attribute entry node @dent.</span>
<span class="cm"> * Returns zero if the node is all right and a %-EINVAL if not.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_validate_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">dent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">key_type</span> <span class="o">=</span> <span class="n">key_type_flash</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dent</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">nlen</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">nlen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nlen</span> <span class="o">+</span> <span class="n">UBIFS_DENT_NODE_SZ</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">||</span>
	    <span class="n">dent</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">UBIFS_ITYPES_CNT</span> <span class="o">||</span>
	    <span class="n">nlen</span> <span class="o">&gt;</span> <span class="n">UBIFS_MAX_NLEN</span> <span class="o">||</span> <span class="n">dent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">nlen</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">strnlen</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">nlen</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nlen</span> <span class="o">||</span>
	    <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MAX_INUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad %s node&quot;</span><span class="p">,</span> <span class="n">key_type</span> <span class="o">==</span> <span class="n">UBIFS_DENT_KEY</span> <span class="o">?</span>
			  <span class="s">&quot;directory entry&quot;</span> <span class="o">:</span> <span class="s">&quot;extended attribute entry&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">key_type</span> <span class="o">!=</span> <span class="n">UBIFS_DENT_KEY</span> <span class="o">&amp;&amp;</span> <span class="n">key_type</span> <span class="o">!=</span> <span class="n">UBIFS_XENT_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad key type %d&quot;</span><span class="p">,</span> <span class="n">key_type</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * is_last_bud - check if the bud is the last in the journal head.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @bud: bud description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks if bud @bud is the last bud in its journal head. This</span>
<span class="cm"> * information is then used by &#39;replay_bud()&#39; to decide whether the bud can</span>
<span class="cm"> * have corruptions or not. Indeed, only last buds can be corrupted by power</span>
<span class="cm"> * cuts. Returns %1 if this is the last bud, and %0 if not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_last_bud</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_bud</span> <span class="o">*</span><span class="n">bud</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_jhead</span> <span class="o">*</span><span class="n">jh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">bud</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ubifs_bud</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_is_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bud</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">buds_list</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The following is a quirk to make sure we work correctly with UBIFS</span>
<span class="cm">	 * images used with older UBIFS.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Normally, the last bud will be the last in the journal head&#39;s list</span>
<span class="cm">	 * of bud. However, there is one exception if the UBIFS image belongs</span>
<span class="cm">	 * to older UBIFS. This is fairly unlikely: one would need to use old</span>
<span class="cm">	 * UBIFS, then have a power cut exactly at the right point, and then</span>
<span class="cm">	 * try to mount this image with new UBIFS.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The exception is: it is possible to have 2 buds A and B, A goes</span>
<span class="cm">	 * before B, and B is the last, bud B is contains no data, and bud A is</span>
<span class="cm">	 * corrupted at the end. The reason is that in older versions when the</span>
<span class="cm">	 * journal code switched the next bud (from A to B), it first added a</span>
<span class="cm">	 * log reference node for the new bud (B), and only after this it</span>
<span class="cm">	 * synchronized the write-buffer of current bud (A). But later this was</span>
<span class="cm">	 * changed and UBIFS started to always synchronize the write-buffer of</span>
<span class="cm">	 * the bud (A) before writing the log reference for the new bud (B).</span>
<span class="cm">	 *</span>
<span class="cm">	 * But because older UBIFS always synchronized A&#39;s write-buffer before</span>
<span class="cm">	 * writing to B, we can recognize this exceptional situation but</span>
<span class="cm">	 * checking the contents of bud B - if it is empty, then A can be</span>
<span class="cm">	 * treated as the last and we can recover it.</span>
<span class="cm">	 *</span>
<span class="cm">	 * TODO: remove this piece of code in a couple of years (today it is</span>
<span class="cm">	 * 16.05.2011).</span>
<span class="cm">	 */</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">bud</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_bud</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_is_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">buds_list</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">data</span> <span class="o">==</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * replay_bud - replay a bud logical eraseblock.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @b: bud entry which describes the bud</span>
<span class="cm"> *</span>
<span class="cm"> * This function replays bud @bud, recovers it if needed, and adds all nodes</span>
<span class="cm"> * from this bud to the replay list. Returns zero in case of success and a</span>
<span class="cm"> * negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">replay_bud</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bud_entry</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">is_last</span> <span class="o">=</span> <span class="n">is_last_bud</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bud</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lnum</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bud</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bud</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">sleb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_scan_node</span> <span class="o">*</span><span class="n">snod</span><span class="p">;</span>

	<span class="n">dbg_mnt</span><span class="p">(</span><span class="s">&quot;replay bud LEB %d, head %d, offs %d, is_last %d&quot;</span><span class="p">,</span>
		<span class="n">lnum</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bud</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">is_last</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">need_recovery</span> <span class="o">&amp;&amp;</span> <span class="n">is_last</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Recover only last LEBs in the journal heads, because power</span>
<span class="cm">		 * cuts may cause corruptions only in these LEBs, because only</span>
<span class="cm">		 * these LEBs could possibly be written to at the power cut</span>
<span class="cm">		 * time.</span>
<span class="cm">		 */</span>
		<span class="n">sleb</span> <span class="o">=</span> <span class="n">ubifs_recover_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sbuf</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">bud</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sleb</span> <span class="o">=</span> <span class="n">ubifs_scan</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sleb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The bud does not have to start from offset zero - the beginning of</span>
<span class="cm">	 * the &#39;lnum&#39; LEB may contain previously committed data. One of the</span>
<span class="cm">	 * things we have to do in replay is to correctly update lprops with</span>
<span class="cm">	 * newer information about this LEB.</span>
<span class="cm">	 *</span>
<span class="cm">	 * At this point lprops thinks that this LEB has &#39;c-&gt;leb_size - offs&#39;</span>
<span class="cm">	 * bytes of free space because it only contain information about</span>
<span class="cm">	 * committed data.</span>
<span class="cm">	 *</span>
<span class="cm">	 * But we know that real amount of free space is &#39;c-&gt;leb_size -</span>
<span class="cm">	 * sleb-&gt;endpt&#39;, and the space in the &#39;lnum&#39; LEB between &#39;offs&#39; and</span>
<span class="cm">	 * &#39;sleb-&gt;endpt&#39; is used by bud data. We have to correctly calculate</span>
<span class="cm">	 * how much of these data are dirty and update lprops with this</span>
<span class="cm">	 * information.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The dirt in that LEB region is comprised of padding nodes, deletion</span>
<span class="cm">	 * nodes, truncation nodes and nodes which are obsoleted by subsequent</span>
<span class="cm">	 * nodes in this LEB. So instead of calculating clean space, we</span>
<span class="cm">	 * calculate used space (&#39;used&#39; variable).</span>
<span class="cm">	 */</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">snod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">deletion</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">&gt;=</span> <span class="n">SQNUM_WATERMARK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;file system&#39;s life ended&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_sqnum</span><span class="p">)</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">max_sqnum</span> <span class="o">=</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">sqnum</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">UBIFS_INO_NODE</span>:
		<span class="p">{</span>
			<span class="k">struct</span> <span class="n">ubifs_ino_node</span> <span class="o">*</span><span class="n">ino</span> <span class="o">=</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
			<span class="n">loff_t</span> <span class="n">new_size</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">deletion</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">insert_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">sqnum</span><span class="p">,</span> <span class="n">deletion</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">used</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">UBIFS_DATA_NODE</span>:
		<span class="p">{</span>
			<span class="k">struct</span> <span class="n">ubifs_data_node</span> <span class="o">*</span><span class="n">dn</span> <span class="o">=</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
			<span class="n">loff_t</span> <span class="n">new_size</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span>
					  <span class="n">key_block</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">*</span>
					  <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">;</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">insert_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">sqnum</span><span class="p">,</span> <span class="n">deletion</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">used</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">UBIFS_DENT_NODE</span>:
		<span class="k">case</span> <span class="n">UBIFS_XENT_NODE</span>:
		<span class="p">{</span>
			<span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">dent</span> <span class="o">=</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_validate_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dent</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">insert_dent</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">dent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					  <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">nlen</span><span class="p">),</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">sqnum</span><span class="p">,</span>
					  <span class="o">!</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">used</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">UBIFS_TRUN_NODE</span>:
		<span class="p">{</span>
			<span class="k">struct</span> <span class="n">ubifs_trun_node</span> <span class="o">*</span><span class="n">trun</span> <span class="o">=</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
			<span class="n">loff_t</span> <span class="n">old_size</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">trun</span><span class="o">-&gt;</span><span class="n">old_size</span><span class="p">);</span>
			<span class="n">loff_t</span> <span class="n">new_size</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">trun</span><span class="o">-&gt;</span><span class="n">new_size</span><span class="p">);</span>
			<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">;</span>

			<span class="cm">/* Validate truncation node */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">old_size</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">old_size</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_inode_sz</span> <span class="o">||</span>
			    <span class="n">new_size</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">new_size</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_inode_sz</span> <span class="o">||</span>
			    <span class="n">old_size</span> <span class="o">&lt;=</span> <span class="n">new_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad truncation node&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Create a fake truncation key just to use the same</span>
<span class="cm">			 * functions which expect nodes to have keys.</span>
<span class="cm">			 */</span>
			<span class="n">trun_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">trun</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">));</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">insert_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">sqnum</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">used</span><span class="p">,</span>
					  <span class="n">old_size</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="nl">default:</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;unexpected node type %d in bud LEB %d:%d&quot;</span><span class="p">,</span>
				  <span class="n">snod</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">ubifs_search_bud</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">endpt</span> <span class="o">-</span> <span class="n">offs</span> <span class="o">&gt;=</span> <span class="n">used</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">endpt</span> <span class="o">%</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">b</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">=</span> <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">endpt</span> <span class="o">-</span> <span class="n">offs</span> <span class="o">-</span> <span class="n">used</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">endpt</span><span class="p">;</span>
	<span class="n">dbg_mnt</span><span class="p">(</span><span class="s">&quot;bud LEB %d replied: dirty %d, free %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">ubifs_scan_destroy</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_dump:</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad node is at LEB %d:%d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
	<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">ubifs_scan_destroy</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * replay_buds - replay all buds.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero in case of success and a negative error code in</span>
<span class="cm"> * case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">replay_buds</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bud_entry</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">prev_sqnum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">replay_buds</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">replay_bud</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">&gt;</span> <span class="n">prev_sqnum</span><span class="p">);</span>
		<span class="n">prev_sqnum</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">sqnum</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * destroy_bud_list - destroy the list of buds to replay.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_bud_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bud_entry</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">replay_buds</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">replay_buds</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bud_entry</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * add_replay_bud - add a bud to the list of buds to replay.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lnum: bud logical eraseblock number to replay</span>
<span class="cm"> * @offs: bud start offset</span>
<span class="cm"> * @jhead: journal head to which this bud belongs</span>
<span class="cm"> * @sqnum: reference node sequence number</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero in case of success and a negative error code in</span>
<span class="cm"> * case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_replay_bud</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">jhead</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sqnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_bud</span> <span class="o">*</span><span class="n">bud</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bud_entry</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>

	<span class="n">dbg_mnt</span><span class="p">(</span><span class="s">&quot;add replay bud LEB %d:%d, head %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">jhead</span><span class="p">);</span>

	<span class="n">bud</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_bud</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bud</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">b</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bud_entry</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bud</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bud</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="n">bud</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
	<span class="n">bud</span><span class="o">-&gt;</span><span class="n">jhead</span> <span class="o">=</span> <span class="n">jhead</span><span class="p">;</span>
	<span class="n">ubifs_add_bud</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">bud</span><span class="p">);</span>

	<span class="n">b</span><span class="o">-&gt;</span><span class="n">bud</span> <span class="o">=</span> <span class="n">bud</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">=</span> <span class="n">sqnum</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">replay_buds</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * validate_ref - validate a reference node.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @ref: the reference node to validate</span>
<span class="cm"> * @ref_lnum: LEB number of the reference node</span>
<span class="cm"> * @ref_offs: reference node offset</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %1 if a bud reference already exists for the LEB. %0 is</span>
<span class="cm"> * returned if the reference node is new, otherwise %-EINVAL is returned if</span>
<span class="cm"> * validation failed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">validate_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_ref_node</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_bud</span> <span class="o">*</span><span class="n">bud</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lnum</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offs</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">jhead</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * ref-&gt;offs may point to the end of LEB when the journal head points</span>
<span class="cm">	 * to the end of LEB and we write reference node for it during commit.</span>
<span class="cm">	 * So this is why we require &#39;offs &gt; c-&gt;leb_size&#39;.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jhead</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span> <span class="o">||</span> <span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">||</span>
	    <span class="n">lnum</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_first</span> <span class="o">||</span> <span class="n">offs</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">||</span>
	    <span class="n">offs</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Make sure we have not already looked at this bud */</span>
	<span class="n">bud</span> <span class="o">=</span> <span class="n">ubifs_search_bud</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bud</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bud</span><span class="o">-&gt;</span><span class="n">jhead</span> <span class="o">==</span> <span class="n">jhead</span> <span class="o">&amp;&amp;</span> <span class="n">bud</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">offs</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bud at LEB %d:%d was already referred&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * replay_log_leb - replay a log logical eraseblock.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lnum: log logical eraseblock to replay</span>
<span class="cm"> * @offs: offset to start replaying from</span>
<span class="cm"> * @sbuf: scan buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This function replays a log LEB and returns zero in case of success, %1 if</span>
<span class="cm"> * this is the last LEB in the log, and a negative error code in case of</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">replay_log_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">sleb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_scan_node</span> <span class="o">*</span><span class="n">snod</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_cs_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">dbg_mnt</span><span class="p">(</span><span class="s">&quot;replay log LEB %d:%d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
	<span class="n">sleb</span> <span class="o">=</span> <span class="n">ubifs_scan</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">sbuf</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">need_recovery</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sleb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sleb</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EUCLEAN</span> <span class="o">||</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">need_recovery</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Note, the below function will recover this log LEB only if</span>
<span class="cm">		 * it is the last, because unclean reboots can possibly corrupt</span>
<span class="cm">		 * only the tail of the log.</span>
<span class="cm">		 */</span>
		<span class="n">sleb</span> <span class="o">=</span> <span class="n">ubifs_recover_log_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">sbuf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sleb</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">snod</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_scan_node</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_sqnum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is the first log LEB we are looking at, make sure that</span>
<span class="cm">		 * the first node is a commit start node. Also record its</span>
<span class="cm">		 * sequence number so that UBIFS can determine where the log</span>
<span class="cm">		 * ends, because all nodes which were have higher sequence</span>
<span class="cm">		 * numbers.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">UBIFS_CS_NODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;first log node at LEB %d:%d is not CS node&quot;</span><span class="p">,</span>
				  <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">cmt_no</span><span class="p">)</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_no</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;first CS node at LEB %d:%d has wrong &quot;</span>
				  <span class="s">&quot;commit number %llu expected %llu&quot;</span><span class="p">,</span>
				  <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">cmt_no</span><span class="p">),</span>
				  <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_no</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_sqnum</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">sqnum</span><span class="p">);</span>
		<span class="n">dbg_mnt</span><span class="p">(</span><span class="s">&quot;commit start sqnum %llu&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_sqnum</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_sqnum</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This means that we reached end of log and now</span>
<span class="cm">		 * look to the older log data, which was already</span>
<span class="cm">		 * committed but the eraseblock was not erased (UBIFS</span>
<span class="cm">		 * only un-maps it). So this basically means we have to</span>
<span class="cm">		 * exit with &quot;end of log&quot; code.</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure the first node sits at offset zero of the LEB */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;first node is not at zero offset&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">snod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">&gt;=</span> <span class="n">SQNUM_WATERMARK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;file system&#39;s life ended&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_sqnum</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad sqnum %llu, commit sqnum %llu&quot;</span><span class="p">,</span>
				  <span class="n">snod</span><span class="o">-&gt;</span><span class="n">sqnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_sqnum</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_sqnum</span><span class="p">)</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">max_sqnum</span> <span class="o">=</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">sqnum</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">UBIFS_REF_NODE</span>: <span class="p">{</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_ref_node</span> <span class="o">*</span><span class="n">ref</span> <span class="o">=</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">validate_ref</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span> <span class="cm">/* Already have this bud */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">add_replay_bud</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">),</span>
					     <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">),</span>
					     <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">),</span>
					     <span class="n">snod</span><span class="o">-&gt;</span><span class="n">sqnum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">UBIFS_CS_NODE</span>:
			<span class="cm">/* Make sure it sits at the beginning of LEB */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;unexpected node in log&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;unexpected node in log&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">endpt</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lhead_offs</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lhead_lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lhead_offs</span> <span class="o">=</span> <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">endpt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">!</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">endpt</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">ubifs_scan_destroy</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_dump:</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;log error detected while replaying the log at LEB %d:%d&quot;</span><span class="p">,</span>
		  <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span> <span class="o">+</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
	<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">ubifs_scan_destroy</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * take_ihead - update the status of the index head in lprops to &#39;taken&#39;.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the amount of free space in the index head LEB or a</span>
<span class="cm"> * negative error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">take_ihead</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">free</span><span class="p">;</span>

	<span class="n">ubifs_get_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">lp</span> <span class="o">=</span> <span class="n">ubifs_lpt_lookup_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ihead_lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">free</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">;</span>

	<span class="n">lp</span> <span class="o">=</span> <span class="n">ubifs_change_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lp</span><span class="p">,</span> <span class="n">LPROPS_NC</span><span class="p">,</span> <span class="n">LPROPS_NC</span><span class="p">,</span>
			     <span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|</span> <span class="n">LPROPS_TAKEN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">free</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">ubifs_release_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_replay_journal - replay journal.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function scans the journal, replays and cleans it up. It makes sure all</span>
<span class="cm"> * memory data structures related to uncommitted journal are built (dirty TNC</span>
<span class="cm"> * tree, tree of buds, modified lprops, etc).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_replay_journal</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">free</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_TRUN_KEY</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">);</span>

	<span class="cm">/* Update the status of the index head in lprops to &#39;taken&#39; */</span>
	<span class="n">free</span> <span class="o">=</span> <span class="n">take_ihead</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">free</span><span class="p">;</span> <span class="cm">/* Error code */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ihead_offs</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">free</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad index head LEB %d:%d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ihead_lnum</span><span class="p">,</span>
			  <span class="n">c</span><span class="o">-&gt;</span><span class="n">ihead_offs</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dbg_mnt</span><span class="p">(</span><span class="s">&quot;start replaying the journal&quot;</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">replaying</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltail_lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lhead_lnum</span><span class="p">;</span>
	<span class="n">offs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lhead_offs</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">log_lebs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">lnum</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">UBIFS_LOG_LNUM</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">log_lebs</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The log is logically circular, we reached the last</span>
<span class="cm">			 * LEB, switch to the first one.</span>
<span class="cm">			 */</span>
			<span class="n">lnum</span> <span class="o">=</span> <span class="n">UBIFS_LOG_LNUM</span><span class="p">;</span>
			<span class="n">offs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">replay_log_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sbuf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="cm">/* We hit the end of the log */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">offs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">replay_buds</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">apply_replay_list</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">set_buds_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * UBIFS budgeting calculations use @c-&gt;bi.uncommitted_idx variable</span>
<span class="cm">	 * to roughly estimate index growth. Things like @c-&gt;bi.min_idx_lebs</span>
<span class="cm">	 * depend on it. This means we have to initialize it to make sure</span>
<span class="cm">	 * budgeting works properly.</span>
<span class="cm">	 */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">uncommitted_idx</span> <span class="o">=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_zn_cnt</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">uncommitted_idx</span> <span class="o">*=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_idx_node_sz</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bud_bytes</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bud_bytes</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">need_recovery</span><span class="p">);</span>
	<span class="n">dbg_mnt</span><span class="p">(</span><span class="s">&quot;finished, log head LEB %d:%d, max_sqnum %llu, &quot;</span>
		<span class="s">&quot;highest_inum %lu&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lhead_lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lhead_offs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_sqnum</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">highest_inum</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">destroy_replay_list</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">destroy_bud_list</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">replaying</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
