<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ubifs › find.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>find.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is part of UBIFS.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Nokia Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="cm"> * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> *          Adrian Hunter</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file contains functions for finding LEBs for various purposes e.g.</span>
<span class="cm"> * garbage collection. In general, lprops category heaps and lists are used</span>
<span class="cm"> * for fast access, falling back on scanning the LPT as a last resort.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/sort.h&gt;</span>
<span class="cp">#include &quot;ubifs.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * struct scan_data - data provided to scan callback functions</span>
<span class="cm"> * @min_space: minimum number of bytes for which to scan</span>
<span class="cm"> * @pick_free: whether it is OK to scan for empty LEBs</span>
<span class="cm"> * @lnum: LEB number found is returned here</span>
<span class="cm"> * @exclude_index: whether to exclude index LEBs</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">scan_data</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">min_space</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pick_free</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">exclude_index</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * valuable - determine whether LEB properties are valuable.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @lprops: LEB properties</span>
<span class="cm"> *</span>
<span class="cm"> * This function return %1 if the LEB properties should be added to the LEB</span>
<span class="cm"> * properties tree in memory. Otherwise %0 is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">valuable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">cat</span> <span class="o">=</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_CAT_MASK</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_lpt_heap</span> <span class="o">*</span><span class="n">heap</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cat</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPROPS_DIRTY</span>:
	<span class="k">case</span> <span class="n">LPROPS_DIRTY_IDX</span>:
	<span class="k">case</span> <span class="n">LPROPS_FREE</span>:
		<span class="n">heap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_heap</span><span class="p">[</span><span class="n">cat</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">max_cnt</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dark_wm</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPROPS_EMPTY</span>:
		<span class="n">n</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">empty_lebs</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_cnt</span> <span class="o">-</span>
		    <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">taken_empty_lebs</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPROPS_FREEABLE</span>:
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPROPS_FRDI_IDX</span>:
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scan_for_dirty_cb - dirty space scan callback.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @lprops: LEB properties to scan</span>
<span class="cm"> * @in_tree: whether the LEB properties are in main memory</span>
<span class="cm"> * @data: information passed to and from the caller of the scan</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns a code that indicates whether the scan should continue</span>
<span class="cm"> * (%LPT_SCAN_CONTINUE), whether the LEB properties should be added to the tree</span>
<span class="cm"> * in main memory (%LPT_SCAN_ADD), or whether the scan should stop</span>
<span class="cm"> * (%LPT_SCAN_STOP).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">scan_for_dirty_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">in_tree</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">scan_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">LPT_SCAN_CONTINUE</span><span class="p">;</span>

	<span class="cm">/* Exclude LEBs that are currently in use */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">LPT_SCAN_CONTINUE</span><span class="p">;</span>
	<span class="cm">/* Determine whether to add these LEB properties to the tree */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_tree</span> <span class="o">&amp;&amp;</span> <span class="n">valuable</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lprops</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">LPT_SCAN_ADD</span><span class="p">;</span>
	<span class="cm">/* Exclude LEBs with too little space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">min_space</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/* If specified, exclude index LEBs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">exclude_index</span> <span class="o">&amp;&amp;</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/* If specified, exclude empty or freeable LEBs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">pick_free</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/* Exclude LEBs with too little dirty space (unless it is empty) */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dead_wm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/* Finally we found space */</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">LPT_SCAN_ADD</span> <span class="o">|</span> <span class="n">LPT_SCAN_STOP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scan_for_dirty - find a data LEB with free space.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @min_space: minimum amount free plus dirty space the returned LEB has to</span>
<span class="cm"> *             have</span>
<span class="cm"> * @pick_free: if it is OK to return a free or freeable LEB</span>
<span class="cm"> * @exclude_index: whether to exclude index LEBs</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns a pointer to the LEB properties found or a negative</span>
<span class="cm"> * error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="nf">scan_for_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
						 <span class="kt">int</span> <span class="n">min_space</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pick_free</span><span class="p">,</span>
						 <span class="kt">int</span> <span class="n">exclude_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_lpt_heap</span> <span class="o">*</span><span class="n">heap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scan_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* There may be an LEB with enough dirty space on the free heap */</span>
	<span class="n">heap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_heap</span><span class="p">[</span><span class="n">LPROPS_FREE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lprops</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">&lt;</span> <span class="n">min_space</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dead_wm</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">lprops</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * A LEB may have fallen off of the bottom of the dirty heap, and ended</span>
<span class="cm">	 * up as uncategorized even though it has enough dirty space for us now,</span>
<span class="cm">	 * so check the uncategorized list. N.B. neither empty nor freeable LEBs</span>
<span class="cm">	 * can end up as uncategorized because they are kept on lists not</span>
<span class="cm">	 * finite-sized heaps.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lprops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">uncat_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">&lt;</span> <span class="n">min_space</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">exclude_index</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dead_wm</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">lprops</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* We have looked everywhere in main memory, now scan the flash */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">pnodes_have</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">pnode_cnt</span><span class="p">)</span>
		<span class="cm">/* All pnodes are in memory, so skip scan */</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOSPC</span><span class="p">);</span>
	<span class="n">data</span><span class="p">.</span><span class="n">min_space</span> <span class="o">=</span> <span class="n">min_space</span><span class="p">;</span>
	<span class="n">data</span><span class="p">.</span><span class="n">pick_free</span> <span class="o">=</span> <span class="n">pick_free</span><span class="p">;</span>
	<span class="n">data</span><span class="p">.</span><span class="n">lnum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">data</span><span class="p">.</span><span class="n">exclude_index</span> <span class="o">=</span> <span class="n">exclude_index</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_lpt_scan_nolock</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lscan_lnum</span><span class="p">,</span>
				    <span class="p">(</span><span class="n">ubifs_lpt_scan_callback</span><span class="p">)</span><span class="n">scan_for_dirty_cb</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_first</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">.</span><span class="n">lnum</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">lscan_lnum</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">lnum</span><span class="p">;</span>
	<span class="n">lprops</span> <span class="o">=</span> <span class="n">ubifs_lpt_lookup_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lprops</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">lprops</span><span class="p">;</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">data</span><span class="p">.</span><span class="n">lnum</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">&gt;=</span> <span class="n">min_space</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dead_wm</span> <span class="o">||</span>
		     <span class="p">(</span><span class="n">pick_free</span> <span class="o">&amp;&amp;</span>
		      <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">exclude_index</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">lprops</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_find_dirty_leb - find a dirty LEB for the Garbage Collector.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @ret_lp: LEB properties are returned here on exit</span>
<span class="cm"> * @min_space: minimum amount free plus dirty space the returned LEB has to</span>
<span class="cm"> *             have</span>
<span class="cm"> * @pick_free: controls whether it is OK to pick empty or index LEBs</span>
<span class="cm"> *</span>
<span class="cm"> * This function tries to find a dirty logical eraseblock which has at least</span>
<span class="cm"> * @min_space free and dirty space. It prefers to take an LEB from the dirty or</span>
<span class="cm"> * dirty index heap, and it falls-back to LPT scanning if the heaps are empty</span>
<span class="cm"> * or do not have an LEB which satisfies the @min_space criteria.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, LEBs which have less than dead watermark of free + dirty space are</span>
<span class="cm"> * never picked by this function.</span>
<span class="cm"> *</span>
<span class="cm"> * The additional @pick_free argument controls if this function has to return a</span>
<span class="cm"> * free or freeable LEB if one is present. For example, GC must to set it to %1,</span>
<span class="cm"> * when called from the journal space reservation function, because the</span>
<span class="cm"> * appearance of free space may coincide with the loss of enough dirty space</span>
<span class="cm"> * for GC to succeed anyway.</span>
<span class="cm"> *</span>
<span class="cm"> * In contrast, if the Garbage Collector is called from budgeting, it should</span>
<span class="cm"> * just make free space, not return LEBs which are already free or freeable.</span>
<span class="cm"> *</span>
<span class="cm"> * In addition @pick_free is set to %2 by the recovery process in order to</span>
<span class="cm"> * recover gc_lnum in which case an index LEB must not be returned.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero and the LEB properties of found dirty LEB in case</span>
<span class="cm"> * of success, %-ENOSPC if no dirty LEB was found and a negative error code in</span>
<span class="cm"> * case of other failures. The returned LEB is marked as &quot;taken&quot;.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_find_dirty_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">ret_lp</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">min_space</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pick_free</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">exclude_index</span> <span class="o">=</span> <span class="n">pick_free</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">idx_lp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_lpt_heap</span> <span class="o">*</span><span class="n">heap</span><span class="p">,</span> <span class="o">*</span><span class="n">idx_heap</span><span class="p">;</span>

	<span class="n">ubifs_get_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pick_free</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">lebs</span><span class="p">,</span> <span class="n">rsvd_idx_lebs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
		<span class="n">lebs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">empty_lebs</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_gc_cnt</span><span class="p">;</span>
		<span class="n">lebs</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_cnt</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">taken_empty_lebs</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Note, the index may consume more LEBs than have been reserved</span>
<span class="cm">		 * for it. It is OK because it might be consolidated by GC.</span>
<span class="cm">		 * But if the index takes fewer LEBs than it is reserved for it,</span>
<span class="cm">		 * this function must avoid picking those reserved LEBs.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">min_idx_lebs</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">idx_lebs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rsvd_idx_lebs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">min_idx_lebs</span> <span class="o">-</span>  <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">idx_lebs</span><span class="p">;</span>
			<span class="n">exclude_index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>

		<span class="cm">/* Check if there are enough free LEBs for the index */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rsvd_idx_lebs</span> <span class="o">&lt;</span> <span class="n">lebs</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* OK, try to find an empty LEB */</span>
			<span class="n">lp</span> <span class="o">=</span> <span class="n">ubifs_fast_find_empty</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>

			<span class="cm">/* Or a freeable LEB */</span>
			<span class="n">lp</span> <span class="o">=</span> <span class="n">ubifs_fast_find_freeable</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="cm">/*</span>
<span class="cm">			 * We cannot pick free/freeable LEBs in the below code.</span>
<span class="cm">			 */</span>
			<span class="n">pick_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
		<span class="n">exclude_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">min_idx_lebs</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">idx_lebs</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Look on the dirty and dirty index heaps */</span>
	<span class="n">heap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_heap</span><span class="p">[</span><span class="n">LPROPS_DIRTY</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">idx_heap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_heap</span><span class="p">[</span><span class="n">LPROPS_DIRTY_IDX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">idx_heap</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">exclude_index</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx_lp</span> <span class="o">=</span> <span class="n">idx_heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">sum</span> <span class="o">=</span> <span class="n">idx_lp</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">idx_lp</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Since we reserve thrice as much space for the index than it</span>
<span class="cm">		 * actually takes, it does not make sense to pick indexing LEBs</span>
<span class="cm">		 * with less than, say, half LEB of dirty space. May be half is</span>
<span class="cm">		 * not the optimal boundary - this should be tested and</span>
<span class="cm">		 * checked. This boundary should determine how much we use</span>
<span class="cm">		 * in-the-gaps to consolidate the index comparing to how much</span>
<span class="cm">		 * we use garbage collector to consolidate it. The &quot;half&quot;</span>
<span class="cm">		 * criteria just feels to be fine.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">min_space</span> <span class="o">||</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">half_leb_size</span><span class="p">)</span>
			<span class="n">idx_lp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lp</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">+</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">&lt;</span> <span class="n">min_space</span><span class="p">)</span>
			<span class="n">lp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Pick the LEB with most space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx_lp</span> <span class="o">&amp;&amp;</span> <span class="n">lp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx_lp</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">idx_lp</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">&gt;=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">)</span>
			<span class="n">lp</span> <span class="o">=</span> <span class="n">idx_lp</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">idx_lp</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">lp</span><span class="p">)</span>
		<span class="n">lp</span> <span class="o">=</span> <span class="n">idx_lp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dead_wm</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Did not find a dirty LEB on the dirty heaps, have to scan */</span>
	<span class="n">dbg_find</span><span class="p">(</span><span class="s">&quot;scanning LPT for a dirty LEB&quot;</span><span class="p">);</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="n">scan_for_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">min_space</span><span class="p">,</span> <span class="n">pick_free</span><span class="p">,</span> <span class="n">exclude_index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dead_wm</span> <span class="o">||</span>
		     <span class="p">(</span><span class="n">pick_free</span> <span class="o">&amp;&amp;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">));</span>

<span class="nl">found:</span>
	<span class="n">dbg_find</span><span class="p">(</span><span class="s">&quot;found LEB %d, free %d, dirty %d, flags %#x&quot;</span><span class="p">,</span>
		 <span class="n">lp</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">lp</span> <span class="o">=</span> <span class="n">ubifs_change_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lp</span><span class="p">,</span> <span class="n">LPROPS_NC</span><span class="p">,</span> <span class="n">LPROPS_NC</span><span class="p">,</span>
			     <span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|</span> <span class="n">LPROPS_TAKEN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">ret_lp</span><span class="p">,</span> <span class="n">lp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_lprops</span><span class="p">));</span>

<span class="nl">out:</span>
	<span class="n">ubifs_release_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scan_for_free_cb - free space scan callback.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @lprops: LEB properties to scan</span>
<span class="cm"> * @in_tree: whether the LEB properties are in main memory</span>
<span class="cm"> * @data: information passed to and from the caller of the scan</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns a code that indicates whether the scan should continue</span>
<span class="cm"> * (%LPT_SCAN_CONTINUE), whether the LEB properties should be added to the tree</span>
<span class="cm"> * in main memory (%LPT_SCAN_ADD), or whether the scan should stop</span>
<span class="cm"> * (%LPT_SCAN_STOP).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">scan_for_free_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">in_tree</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">scan_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">LPT_SCAN_CONTINUE</span><span class="p">;</span>

	<span class="cm">/* Exclude LEBs that are currently in use */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">LPT_SCAN_CONTINUE</span><span class="p">;</span>
	<span class="cm">/* Determine whether to add these LEB properties to the tree */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_tree</span> <span class="o">&amp;&amp;</span> <span class="n">valuable</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lprops</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">LPT_SCAN_ADD</span><span class="p">;</span>
	<span class="cm">/* Exclude index LEBs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/* Exclude LEBs with too little space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">min_space</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/* If specified, exclude empty LEBs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">pick_free</span> <span class="o">&amp;&amp;</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * LEBs that have only free and dirty space must not be allocated</span>
<span class="cm">	 * because they may have been unmapped already or they may have data</span>
<span class="cm">	 * that is obsolete only because of nodes that are still sitting in a</span>
<span class="cm">	 * wbuf.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">&amp;&amp;</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/* Finally we found space */</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">LPT_SCAN_ADD</span> <span class="o">|</span> <span class="n">LPT_SCAN_STOP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * do_find_free_space - find a data LEB with free space.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @min_space: minimum amount of free space required</span>
<span class="cm"> * @pick_free: whether it is OK to scan for empty LEBs</span>
<span class="cm"> * @squeeze: whether to try to find space in a non-empty LEB first</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns a pointer to the LEB properties found or a negative</span>
<span class="cm"> * error code.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="nf">do_find_free_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
					      <span class="kt">int</span> <span class="n">min_space</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pick_free</span><span class="p">,</span>
					      <span class="kt">int</span> <span class="n">squeeze</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_lpt_heap</span> <span class="o">*</span><span class="n">heap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scan_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">squeeze</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lprops</span> <span class="o">=</span> <span class="n">ubifs_fast_find_free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span> <span class="o">&amp;&amp;</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">&gt;=</span> <span class="n">min_space</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">lprops</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pick_free</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lprops</span> <span class="o">=</span> <span class="n">ubifs_fast_find_empty</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">lprops</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">squeeze</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lprops</span> <span class="o">=</span> <span class="n">ubifs_fast_find_free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span> <span class="o">&amp;&amp;</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">&gt;=</span> <span class="n">min_space</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">lprops</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* There may be an LEB with enough free space on the dirty heap */</span>
	<span class="n">heap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_heap</span><span class="p">[</span><span class="n">LPROPS_DIRTY</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lprops</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">&gt;=</span> <span class="n">min_space</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">lprops</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * A LEB may have fallen off of the bottom of the free heap, and ended</span>
<span class="cm">	 * up as uncategorized even though it has enough free space for us now,</span>
<span class="cm">	 * so check the uncategorized list. N.B. neither empty nor freeable LEBs</span>
<span class="cm">	 * can end up as uncategorized because they are kept on lists not</span>
<span class="cm">	 * finite-sized heaps.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lprops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">uncat_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">&gt;=</span> <span class="n">min_space</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">lprops</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* We have looked everywhere in main memory, now scan the flash */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">pnodes_have</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">pnode_cnt</span><span class="p">)</span>
		<span class="cm">/* All pnodes are in memory, so skip scan */</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOSPC</span><span class="p">);</span>
	<span class="n">data</span><span class="p">.</span><span class="n">min_space</span> <span class="o">=</span> <span class="n">min_space</span><span class="p">;</span>
	<span class="n">data</span><span class="p">.</span><span class="n">pick_free</span> <span class="o">=</span> <span class="n">pick_free</span><span class="p">;</span>
	<span class="n">data</span><span class="p">.</span><span class="n">lnum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_lpt_scan_nolock</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lscan_lnum</span><span class="p">,</span>
				    <span class="p">(</span><span class="n">ubifs_lpt_scan_callback</span><span class="p">)</span><span class="n">scan_for_free_cb</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_first</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">.</span><span class="n">lnum</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">lscan_lnum</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">lnum</span><span class="p">;</span>
	<span class="n">lprops</span> <span class="o">=</span> <span class="n">ubifs_lpt_lookup_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lprops</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">lprops</span><span class="p">;</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">data</span><span class="p">.</span><span class="n">lnum</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">&gt;=</span> <span class="n">min_space</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">lprops</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_find_free_space - find a data LEB with free space.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @min_space: minimum amount of required free space</span>
<span class="cm"> * @offs: contains offset of where free space starts on exit</span>
<span class="cm"> * @squeeze: whether to try to find space in a non-empty LEB first</span>
<span class="cm"> *</span>
<span class="cm"> * This function looks for an LEB with at least @min_space bytes of free space.</span>
<span class="cm"> * It tries to find an empty LEB if possible. If no empty LEBs are available,</span>
<span class="cm"> * this function searches for a non-empty data LEB. The returned LEB is marked</span>
<span class="cm"> * as &quot;taken&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns found LEB number in case of success, %-ENOSPC if it</span>
<span class="cm"> * failed to find a LEB with @min_space bytes of free space and other a negative</span>
<span class="cm"> * error codes in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_find_free_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min_space</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">offs</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">squeeze</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lebs</span><span class="p">,</span> <span class="n">rsvd_idx_lebs</span><span class="p">,</span> <span class="n">pick_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">dbg_find</span><span class="p">(</span><span class="s">&quot;min_space %d&quot;</span><span class="p">,</span> <span class="n">min_space</span><span class="p">);</span>
	<span class="n">ubifs_get_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="cm">/* Check if there are enough empty LEBs for commit */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">min_idx_lebs</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">idx_lebs</span><span class="p">)</span>
		<span class="n">rsvd_idx_lebs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">min_idx_lebs</span> <span class="o">-</span>  <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">idx_lebs</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rsvd_idx_lebs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lebs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">empty_lebs</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_cnt</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_gc_cnt</span> <span class="o">-</span>
	       <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">taken_empty_lebs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rsvd_idx_lebs</span> <span class="o">&lt;</span> <span class="n">lebs</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * OK to allocate an empty LEB, but we still don&#39;t want to go</span>
<span class="cm">		 * looking for one if there aren&#39;t any.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">empty_lebs</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">taken_empty_lebs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pick_free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Because we release the space lock, we must account</span>
<span class="cm">			 * for this allocation here. After the LEB properties</span>
<span class="cm">			 * flags have been updated, we subtract one. Note, the</span>
<span class="cm">			 * result of this is that lprops also decreases</span>
<span class="cm">			 * @taken_empty_lebs in &#39;ubifs_change_lp()&#39;, so it is</span>
<span class="cm">			 * off by one for a short period of time which may</span>
<span class="cm">			 * introduce a small disturbance to budgeting</span>
<span class="cm">			 * calculations, but this is harmless because at the</span>
<span class="cm">			 * worst case this would make the budgeting subsystem</span>
<span class="cm">			 * be more pessimistic than needed.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Fundamentally, this is about serialization of the</span>
<span class="cm">			 * budgeting and lprops subsystems. We could make the</span>
<span class="cm">			 * @space_lock a mutex and avoid dropping it before</span>
<span class="cm">			 * calling &#39;ubifs_change_lp()&#39;, but mutex is more</span>
<span class="cm">			 * heavy-weight, and we want budgeting to be as fast as</span>
<span class="cm">			 * possible.</span>
<span class="cm">			 */</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">taken_empty_lebs</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>

	<span class="n">lprops</span> <span class="o">=</span> <span class="n">do_find_free_space</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">min_space</span><span class="p">,</span> <span class="n">pick_free</span><span class="p">,</span> <span class="n">squeeze</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lprops</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lprops</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lnum</span> <span class="o">=</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|</span> <span class="n">LPROPS_TAKEN</span><span class="p">;</span>

	<span class="n">lprops</span> <span class="o">=</span> <span class="n">ubifs_change_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lprops</span><span class="p">,</span> <span class="n">LPROPS_NC</span><span class="p">,</span> <span class="n">LPROPS_NC</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lprops</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lprops</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pick_free</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">taken_empty_lebs</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">offs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">;</span>
	<span class="n">ubifs_release_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">offs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Ensure that empty LEBs have been unmapped. They may not have</span>
<span class="cm">		 * been, for example, because of an unclean unmount.  Also</span>
<span class="cm">		 * LEBs that were freeable LEBs (free + dirty == leb_size) will</span>
<span class="cm">		 * not have been unmapped.</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dbg_find</span><span class="p">(</span><span class="s">&quot;found LEB %d, free %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="o">*</span><span class="n">offs</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">*</span><span class="n">offs</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">min_space</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">lnum</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pick_free</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">taken_empty_lebs</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ubifs_release_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scan_for_idx_cb - callback used by the scan for a free LEB for the index.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @lprops: LEB properties to scan</span>
<span class="cm"> * @in_tree: whether the LEB properties are in main memory</span>
<span class="cm"> * @data: information passed to and from the caller of the scan</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns a code that indicates whether the scan should continue</span>
<span class="cm"> * (%LPT_SCAN_CONTINUE), whether the LEB properties should be added to the tree</span>
<span class="cm"> * in main memory (%LPT_SCAN_ADD), or whether the scan should stop</span>
<span class="cm"> * (%LPT_SCAN_STOP).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">scan_for_idx_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">in_tree</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">scan_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">LPT_SCAN_CONTINUE</span><span class="p">;</span>

	<span class="cm">/* Exclude LEBs that are currently in use */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">LPT_SCAN_CONTINUE</span><span class="p">;</span>
	<span class="cm">/* Determine whether to add these LEB properties to the tree */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_tree</span> <span class="o">&amp;&amp;</span> <span class="n">valuable</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lprops</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">LPT_SCAN_ADD</span><span class="p">;</span>
	<span class="cm">/* Exclude index LEBS */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/* Exclude LEBs that cannot be made empty */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We are allocating for the index so it is safe to allocate LEBs with</span>
<span class="cm">	 * only free and dirty space, because write buffers are sync&#39;d at commit</span>
<span class="cm">	 * start.</span>
<span class="cm">	 */</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">LPT_SCAN_ADD</span> <span class="o">|</span> <span class="n">LPT_SCAN_STOP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scan_for_leb_for_idx - scan for a free LEB for the index.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="nf">scan_for_leb_for_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scan_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">data</span><span class="p">.</span><span class="n">lnum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_lpt_scan_nolock</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lscan_lnum</span><span class="p">,</span>
				    <span class="p">(</span><span class="n">ubifs_lpt_scan_callback</span><span class="p">)</span><span class="n">scan_for_idx_cb</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_first</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">.</span><span class="n">lnum</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">lscan_lnum</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">lnum</span><span class="p">;</span>
	<span class="n">lprops</span> <span class="o">=</span> <span class="n">ubifs_lpt_lookup_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lprops</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">lprops</span><span class="p">;</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">data</span><span class="p">.</span><span class="n">lnum</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">lprops</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_find_free_leb_for_idx - find a free LEB for the index.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function looks for a free LEB and returns that LEB number. The returned</span>
<span class="cm"> * LEB is marked as &quot;taken&quot;, &quot;index&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * Only empty LEBs are allocated. This is for two reasons. First, the commit</span>
<span class="cm"> * calculates the number of LEBs to allocate based on the assumption that they</span>
<span class="cm"> * will be empty. Secondly, free space at the end of an index LEB is not</span>
<span class="cm"> * guaranteed to be empty because it may have been used by the in-the-gaps</span>
<span class="cm"> * method prior to an unclean unmount.</span>
<span class="cm"> *</span>
<span class="cm"> * If no LEB is found %-ENOSPC is returned. For other failures another negative</span>
<span class="cm"> * error code is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_find_free_leb_for_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lnum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">ubifs_get_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">lprops</span> <span class="o">=</span> <span class="n">ubifs_fast_find_empty</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lprops</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lprops</span> <span class="o">=</span> <span class="n">ubifs_fast_find_freeable</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lprops</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">empty_lebs</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">taken_empty_lebs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lprops</span> <span class="o">=</span> <span class="n">scan_for_leb_for_idx</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lprops</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lprops</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lprops</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lnum</span> <span class="o">=</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>

	<span class="n">dbg_find</span><span class="p">(</span><span class="s">&quot;found LEB %d, free %d, dirty %d, flags %#x&quot;</span><span class="p">,</span>
		 <span class="n">lnum</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|</span> <span class="n">LPROPS_TAKEN</span> <span class="o">|</span> <span class="n">LPROPS_INDEX</span><span class="p">;</span>
	<span class="n">lprops</span> <span class="o">=</span> <span class="n">ubifs_change_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lprops</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lprops</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lprops</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ubifs_release_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that empty LEBs have been unmapped. They may not have been,</span>
<span class="cm">	 * for example, because of an unclean unmount. Also LEBs that were</span>
<span class="cm">	 * freeable LEBs (free + dirty == leb_size) will not have been unmapped.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_change_one_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">LPROPS_NC</span><span class="p">,</span> <span class="n">LPROPS_NC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				    <span class="n">LPROPS_TAKEN</span> <span class="o">|</span> <span class="n">LPROPS_INDEX</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">lnum</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">ubifs_release_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cmp_dirty_idx</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">**</span><span class="n">a</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">**</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lpa</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lpb</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">lpa</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">+</span> <span class="n">lpa</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">-</span> <span class="n">lpb</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">-</span> <span class="n">lpb</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">swap_dirty_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">**</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">**</span><span class="n">b</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>

	<span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
	<span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_save_dirty_idx_lnums - save an array of the most dirty index LEB nos.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called each commit to create an array of LEB numbers of</span>
<span class="cm"> * dirty index LEBs sorted in order of dirty and free space.  This is used by</span>
<span class="cm"> * the in-the-gaps method of TNC commit.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_save_dirty_idx_lnums</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ubifs_get_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="cm">/* Copy the LPROPS_DIRTY_IDX heap */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_idx</span><span class="p">.</span><span class="n">cnt</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_heap</span><span class="p">[</span><span class="n">LPROPS_DIRTY_IDX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">cnt</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_idx</span><span class="p">.</span><span class="n">arr</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_heap</span><span class="p">[</span><span class="n">LPROPS_DIRTY_IDX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">arr</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_idx</span><span class="p">.</span><span class="n">cnt</span><span class="p">);</span>
	<span class="cm">/* Sort it so that the dirtiest is now at the end */</span>
	<span class="n">sort</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_idx</span><span class="p">.</span><span class="n">arr</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_idx</span><span class="p">.</span><span class="n">cnt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
	     <span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">))</span><span class="n">cmp_dirty_idx</span><span class="p">,</span>
	     <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">))</span><span class="n">swap_dirty_idx</span><span class="p">);</span>
	<span class="n">dbg_find</span><span class="p">(</span><span class="s">&quot;found %d dirty index LEBs&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_idx</span><span class="p">.</span><span class="n">cnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_idx</span><span class="p">.</span><span class="n">cnt</span><span class="p">)</span>
		<span class="n">dbg_find</span><span class="p">(</span><span class="s">&quot;dirtiest index LEB is %d with dirty %d and free %d&quot;</span><span class="p">,</span>
			 <span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_idx</span><span class="p">.</span><span class="n">arr</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_idx</span><span class="p">.</span><span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span>
			 <span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_idx</span><span class="p">.</span><span class="n">arr</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_idx</span><span class="p">.</span><span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">,</span>
			 <span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_idx</span><span class="p">.</span><span class="n">arr</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_idx</span><span class="p">.</span><span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">);</span>
	<span class="cm">/* Replace the lprops pointers with LEB numbers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_idx</span><span class="p">.</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_idx</span><span class="p">.</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_idx</span><span class="p">.</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>
	<span class="n">ubifs_release_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scan_dirty_idx_cb - callback used by the scan for a dirty index LEB.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @lprops: LEB properties to scan</span>
<span class="cm"> * @in_tree: whether the LEB properties are in main memory</span>
<span class="cm"> * @data: information passed to and from the caller of the scan</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns a code that indicates whether the scan should continue</span>
<span class="cm"> * (%LPT_SCAN_CONTINUE), whether the LEB properties should be added to the tree</span>
<span class="cm"> * in main memory (%LPT_SCAN_ADD), or whether the scan should stop</span>
<span class="cm"> * (%LPT_SCAN_STOP).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">scan_dirty_idx_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">in_tree</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">scan_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">LPT_SCAN_CONTINUE</span><span class="p">;</span>

	<span class="cm">/* Exclude LEBs that are currently in use */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">LPT_SCAN_CONTINUE</span><span class="p">;</span>
	<span class="cm">/* Determine whether to add these LEB properties to the tree */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_tree</span> <span class="o">&amp;&amp;</span> <span class="n">valuable</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lprops</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">LPT_SCAN_ADD</span><span class="p">;</span>
	<span class="cm">/* Exclude non-index LEBs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/* Exclude LEBs with too little space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_idx_node_sz</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/* Finally we found space */</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">LPT_SCAN_ADD</span> <span class="o">|</span> <span class="n">LPT_SCAN_STOP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_dirty_idx_leb - find a dirty index LEB.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns LEB number upon success and a negative error code upon</span>
<span class="cm"> * failure.  In particular, -ENOSPC is returned if a dirty index LEB is not</span>
<span class="cm"> * found.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this function scans the entire LPT but it is called very rarely.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_dirty_idx_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_lpt_heap</span> <span class="o">*</span><span class="n">heap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scan_data</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Check all structures in memory first */</span>
	<span class="n">data</span><span class="p">.</span><span class="n">lnum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">heap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_heap</span><span class="p">[</span><span class="n">LPROPS_DIRTY_IDX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lprops</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">scan_dirty_idx_cb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lprops</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">LPT_SCAN_STOP</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lprops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">frdi_idx_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">scan_dirty_idx_cb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lprops</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">LPT_SCAN_STOP</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lprops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">uncat_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">scan_dirty_idx_cb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lprops</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">LPT_SCAN_STOP</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">pnodes_have</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">pnode_cnt</span><span class="p">)</span>
		<span class="cm">/* All pnodes are in memory, so skip scan */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_lpt_scan_nolock</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lscan_lnum</span><span class="p">,</span>
				    <span class="p">(</span><span class="n">ubifs_lpt_scan_callback</span><span class="p">)</span><span class="n">scan_dirty_idx_cb</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="nl">found:</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_first</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">.</span><span class="n">lnum</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">lscan_lnum</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">lnum</span><span class="p">;</span>
	<span class="n">lprops</span> <span class="o">=</span> <span class="n">ubifs_lpt_lookup_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lprops</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lprops</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">data</span><span class="p">.</span><span class="n">lnum</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_idx_node_sz</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">((</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">));</span>

	<span class="n">dbg_find</span><span class="p">(</span><span class="s">&quot;found dirty LEB %d, free %d, dirty %d, flags %#x&quot;</span><span class="p">,</span>
		 <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">lprops</span> <span class="o">=</span> <span class="n">ubifs_change_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lprops</span><span class="p">,</span> <span class="n">LPROPS_NC</span><span class="p">,</span> <span class="n">LPROPS_NC</span><span class="p">,</span>
				 <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|</span> <span class="n">LPROPS_TAKEN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lprops</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lprops</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_idx_gc_leb - try to get a LEB number from trivial GC.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_idx_gc_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">lnum</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_get_idx_gc_leb</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">lnum</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The LEB was due to be unmapped after the commit but</span>
<span class="cm">	 * it is needed now for this commit.</span>
<span class="cm">	 */</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="n">ubifs_lpt_lookup_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="n">ubifs_change_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lp</span><span class="p">,</span> <span class="n">LPROPS_NC</span><span class="p">,</span> <span class="n">LPROPS_NC</span><span class="p">,</span>
			     <span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|</span> <span class="n">LPROPS_INDEX</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
	<span class="n">dbg_find</span><span class="p">(</span><span class="s">&quot;LEB %d, dirty %d and free %d flags %#x&quot;</span><span class="p">,</span>
		 <span class="n">lp</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">lnum</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_dirtiest_idx_leb - find dirtiest index LEB from dirtiest array.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_dirtiest_idx_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_idx</span><span class="p">.</span><span class="n">cnt</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="cm">/* The lprops pointers were replaced by LEB numbers */</span>
		<span class="n">lnum</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_idx</span><span class="p">.</span><span class="n">arr</span><span class="p">[</span><span class="o">--</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_idx</span><span class="p">.</span><span class="n">cnt</span><span class="p">];</span>
		<span class="n">lp</span> <span class="o">=</span> <span class="n">ubifs_lpt_lookup</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">lp</span> <span class="o">=</span> <span class="n">ubifs_change_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lp</span><span class="p">,</span> <span class="n">LPROPS_NC</span><span class="p">,</span> <span class="n">LPROPS_NC</span><span class="p">,</span>
				     <span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|</span> <span class="n">LPROPS_TAKEN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dbg_find</span><span class="p">(</span><span class="s">&quot;LEB %d, dirty %d and free %d flags %#x&quot;</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">,</span>
		 <span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">lnum</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_find_dirty_idx_leb - try to find dirtiest index LEB as at last commit.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function attempts to find an untaken index LEB with the most free and</span>
<span class="cm"> * dirty space that can be used without overwriting index nodes that were in the</span>
<span class="cm"> * last index committed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_find_dirty_idx_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ubifs_get_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We made an array of the dirtiest index LEB numbers as at the start of</span>
<span class="cm">	 * last commit.  Try that array first.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">find_dirtiest_idx_leb</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="cm">/* Next try scanning the entire LPT */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">find_dirty_idx_leb</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="cm">/* Finally take any index LEBs awaiting trivial GC */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">get_idx_gc_leb</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">ubifs_release_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
