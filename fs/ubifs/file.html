<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ubifs › file.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>file.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is part of UBIFS.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Nokia Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="cm"> * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> *          Adrian Hunter</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file implements VFS file and inode operations for regular files, device</span>
<span class="cm"> * nodes and symlinks as well as address space operations.</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS uses 2 page flags: @PG_private and @PG_checked. @PG_private is set if</span>
<span class="cm"> * the page is dirty and is used for optimization purposes - dirty pages are</span>
<span class="cm"> * not budgeted so the flag shows that &#39;ubifs_write_end()&#39; should not release</span>
<span class="cm"> * the budget for this page. The @PG_checked flag is set if full budgeting is</span>
<span class="cm"> * required for the page e.g., when it corresponds to a file hole or it is</span>
<span class="cm"> * beyond the file size. The budgeting is done in &#39;ubifs_write_begin()&#39;, because</span>
<span class="cm"> * it is OK to fail in this function, and the budget is released in</span>
<span class="cm"> * &#39;ubifs_write_end()&#39;. So the @PG_private and @PG_checked flags carry</span>
<span class="cm"> * information about how the page was budgeted, to make it possible to release</span>
<span class="cm"> * the budget properly.</span>
<span class="cm"> *</span>
<span class="cm"> * A thing to keep in mind: inode @i_mutex is locked in most VFS operations we</span>
<span class="cm"> * implement. However, this is not true for &#39;ubifs_writepage()&#39;, which may be</span>
<span class="cm"> * called with @i_mutex unlocked. For example, when pdflush is doing background</span>
<span class="cm"> * write-back, it calls &#39;ubifs_writepage()&#39; with unlocked @i_mutex. At &quot;normal&quot;</span>
<span class="cm"> * work-paths the @i_mutex is locked in &#39;ubifs_writepage()&#39;, e.g. in the</span>
<span class="cm"> * &quot;sys_write -&gt; alloc_pages -&gt; direct reclaim path&quot;. So, in &#39;ubifs_writepage()&#39;</span>
<span class="cm"> * we are only guaranteed that the page is locked.</span>
<span class="cm"> *</span>
<span class="cm"> * Similarly, @i_mutex is not always locked in &#39;ubifs_readpage()&#39;, e.g., the</span>
<span class="cm"> * read-ahead path does not lock it (&quot;sys_read -&gt; generic_file_aio_read -&gt;</span>
<span class="cm"> * ondemand_readahead -&gt; readpage&quot;). In case of readahead, @I_SYNC flag is not</span>
<span class="cm"> * set as well. However, UBIFS disables readahead.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;ubifs.h&quot;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ubifs_data_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">out_len</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dlen</span><span class="p">;</span>

	<span class="n">data_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_lookup</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">dn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
			<span class="cm">/* Not found, so it must be a hole */</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">sqnum</span><span class="p">)</span> <span class="o">&gt;</span>
		     <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">creat_sqnum</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">dump</span><span class="p">;</span>

	<span class="n">dlen</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="o">-</span> <span class="n">UBIFS_DATA_NODE_SZ</span><span class="p">;</span>
	<span class="n">out_len</span> <span class="o">=</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_decompress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">dlen</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out_len</span><span class="p">,</span>
			       <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">compr_type</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="n">len</span> <span class="o">!=</span> <span class="n">out_len</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">dump</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Data length can be less than a full block, even for blocks that are</span>
<span class="cm">	 * not the last in the file (e.g., as a result of making a hole and</span>
<span class="cm">	 * appending data). Ensure that the remainder is zeroed out.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UBIFS_BLOCK_SIZE</span> <span class="o">-</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">dump:</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad data node (block %u, inode %lu)&quot;</span><span class="p">,</span>
		  <span class="n">block</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dn</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_readpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block</span><span class="p">,</span> <span class="n">beyond</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_data_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">i_size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;ino %lu, pg %lu, i_size %lld, flags %#lx&quot;</span><span class="p">,</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">i_size</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">PageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">PagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">block</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">UBIFS_BLOCKS_PER_PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">beyond</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">+</span> <span class="n">UBIFS_BLOCK_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">UBIFS_BLOCK_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;=</span> <span class="n">beyond</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Reading beyond inode */</span>
		<span class="n">SetPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dn</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">UBIFS_MAX_DATA_NODE_SZ</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;=</span> <span class="n">beyond</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Reading beyond inode */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">read_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">dn</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">beyond</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">dlen</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
				<span class="kt">int</span> <span class="n">ilen</span> <span class="o">=</span> <span class="n">i_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UBIFS_BLOCK_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">ilen</span> <span class="o">&amp;&amp;</span> <span class="n">ilen</span> <span class="o">&lt;</span> <span class="n">dlen</span><span class="p">)</span>
					<span class="n">memset</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">ilen</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dlen</span> <span class="o">-</span> <span class="n">ilen</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">UBIFS_BLOCKS_PER_PAGE</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">block</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Not found, so it must be a hole */</span>
			<span class="n">SetPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;hole&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot read page %lu of inode %lu, error %d&quot;</span><span class="p">,</span>
			  <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">ClearPageError</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
	<span class="n">ClearPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">SetPageError</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * release_new_page_budget - release budget of a new page.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function which releases budget corresponding to the budget</span>
<span class="cm"> * of one new page of data.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_new_page_budget</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="n">req</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">recalculate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">new_page</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">};</span>

	<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * release_existing_page_budget - release budget of an existing page.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function which releases budget corresponding to the budget</span>
<span class="cm"> * of changing one one page of data which already exists on the flash media.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_existing_page_budget</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="n">req</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">dd_growth</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">page_budget</span><span class="p">};</span>

	<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_begin_slow</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			    <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="n">req</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">new_page</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">err</span><span class="p">),</span> <span class="n">appending</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;ino %lu, pos %llu, len %u, i_size %lld&quot;</span><span class="p">,</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * At the slow path we have to budget before locking the page, because</span>
<span class="cm">	 * budgeting may force write-back, which would wait on locked pages and</span>
<span class="cm">	 * deadlock if we had the page locked. At this point we do not know</span>
<span class="cm">	 * anything about the page, so assume that this is a new page which is</span>
<span class="cm">	 * written to a hole. This corresponds to largest budget. Later the</span>
<span class="cm">	 * budget will be amended if this is not true.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">appending</span><span class="p">)</span>
		<span class="cm">/* We are appending data, budget for inode change */</span>
		<span class="n">req</span><span class="p">.</span><span class="n">dirtied_ino</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_budget_space</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">grab_cache_page_write_begin</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">==</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span>
			<span class="n">SetPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">do_readpage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">ClearPageError</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="cm">/*</span>
<span class="cm">		 * The page is dirty, which means it was budgeted twice:</span>
<span class="cm">		 *   o first time the budget was allocated by the task which</span>
<span class="cm">		 *     made the page dirty and set the PG_private flag;</span>
<span class="cm">		 *   o and then we budgeted for it for the second time at the</span>
<span class="cm">		 *     very beginning of this function.</span>
<span class="cm">		 *</span>
<span class="cm">		 * So what we have to do is to release the page budget we</span>
<span class="cm">		 * allocated.</span>
<span class="cm">		 */</span>
		<span class="n">release_new_page_budget</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are changing a page which already exists on the media.</span>
<span class="cm">		 * This means that changing the page does not make the amount</span>
<span class="cm">		 * of indexing information larger, and this part of the budget</span>
<span class="cm">		 * which we have already acquired may be released.</span>
<span class="cm">		 */</span>
		<span class="n">ubifs_convert_page_budget</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">appending</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * &#39;ubifs_write_end()&#39; is optimized from the fast-path part of</span>
<span class="cm">		 * &#39;ubifs_write_begin()&#39; and expects the @ui_mutex to be locked</span>
<span class="cm">		 * if data is appended.</span>
<span class="cm">		 */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * The inode is dirty already, so we may free the</span>
<span class="cm">			 * budget we allocated.</span>
<span class="cm">			 */</span>
			<span class="n">ubifs_release_dirty_inode_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ui</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">pagep</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * allocate_budget - allocate budget for &#39;ubifs_write_begin()&#39;.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @page: page to allocate budget for</span>
<span class="cm"> * @ui: UBIFS inode object the page belongs to</span>
<span class="cm"> * @appending: non-zero if the page is appended</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function for &#39;ubifs_write_begin()&#39; which allocates budget</span>
<span class="cm"> * for the operation. The budget is allocated differently depending on whether</span>
<span class="cm"> * this is appending, whether the page is dirty or not, and so on. This</span>
<span class="cm"> * function leaves the @ui-&gt;ui_mutex locked in case of appending. Returns zero</span>
<span class="cm"> * in case of success and %-ENOSPC in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">allocate_budget</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span><span class="p">,</span> <span class="kt">int</span> <span class="n">appending</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="n">req</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">fast</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">appending</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * The page is dirty and we are not appending, which</span>
<span class="cm">			 * means no budget is needed at all.</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * The page is dirty and we are appending, so the inode</span>
<span class="cm">			 * has to be marked as dirty. However, it is already</span>
<span class="cm">			 * dirty, so we do not need any budget. We may return,</span>
<span class="cm">			 * but @ui-&gt;ui_mutex hast to be left locked because we</span>
<span class="cm">			 * should prevent write-back from flushing the inode</span>
<span class="cm">			 * and freeing the budget. The lock will be released in</span>
<span class="cm">			 * &#39;ubifs_write_end()&#39;.</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * The page is dirty, we are appending, the inode is clean, so</span>
<span class="cm">		 * we need to budget the inode change.</span>
<span class="cm">		 */</span>
		<span class="n">req</span><span class="p">.</span><span class="n">dirtied_ino</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="cm">/*</span>
<span class="cm">			 * The page corresponds to a hole and does not</span>
<span class="cm">			 * exist on the media. So changing it makes</span>
<span class="cm">			 * make the amount of indexing information</span>
<span class="cm">			 * larger, and we have to budget for a new</span>
<span class="cm">			 * page.</span>
<span class="cm">			 */</span>
			<span class="n">req</span><span class="p">.</span><span class="n">new_page</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="cm">/*</span>
<span class="cm">			 * Not a hole, the change will not add any new</span>
<span class="cm">			 * indexing information, budget for page</span>
<span class="cm">			 * change.</span>
<span class="cm">			 */</span>
			<span class="n">req</span><span class="p">.</span><span class="n">dirtied_page</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">appending</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">)</span>
				<span class="cm">/*</span>
<span class="cm">				 * The inode is clean but we will have to mark</span>
<span class="cm">				 * it as dirty because we are appending. This</span>
<span class="cm">				 * needs a budget.</span>
<span class="cm">				 */</span>
				<span class="n">req</span><span class="p">.</span><span class="n">dirtied_ino</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ubifs_budget_space</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is called when a page of data is going to be written. Since</span>
<span class="cm"> * the page of data will not necessarily go to the flash straight away, UBIFS</span>
<span class="cm"> * has to reserve space on the media for it, which is done by means of</span>
<span class="cm"> * budgeting.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the hot-path of the file-system and we are trying to optimize it as</span>
<span class="cm"> * much as possible. For this reasons it is split on 2 parts - slow and fast.</span>
<span class="cm"> *</span>
<span class="cm"> * There many budgeting cases:</span>
<span class="cm"> *     o a new page is appended - we have to budget for a new page and for</span>
<span class="cm"> *       changing the inode; however, if the inode is already dirty, there is</span>
<span class="cm"> *       no need to budget for it;</span>
<span class="cm"> *     o an existing clean page is changed - we have budget for it; if the page</span>
<span class="cm"> *       does not exist on the media (a hole), we have to budget for a new</span>
<span class="cm"> *       page; otherwise, we may budget for changing an existing page; the</span>
<span class="cm"> *       difference between these cases is that changing an existing page does</span>
<span class="cm"> *       not introduce anything new to the FS indexing information, so it does</span>
<span class="cm"> *       not grow, and smaller budget is acquired in this case;</span>
<span class="cm"> *     o an existing dirty page is changed - no need to budget at all, because</span>
<span class="cm"> *       the page budget has been acquired by earlier, when the page has been</span>
<span class="cm"> *       marked dirty.</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS budgeting sub-system may force write-back if it thinks there is no</span>
<span class="cm"> * space to reserve. This imposes some locking restrictions and makes it</span>
<span class="cm"> * impossible to take into account the above cases, and makes it impossible to</span>
<span class="cm"> * optimize budgeting.</span>
<span class="cm"> *</span>
<span class="cm"> * The solution for this is that the fast path of &#39;ubifs_write_begin()&#39; assumes</span>
<span class="cm"> * there is a plenty of flash space and the budget will be acquired quickly,</span>
<span class="cm"> * without forcing write-back. The slow path does not make this assumption.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			     <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">pgoff_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">err</span><span class="p">),</span> <span class="n">appending</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">skipped_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">==</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_media</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_error</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="cm">/* Try out the fast-path part first */</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">grab_cache_page_write_begin</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* The page is not loaded from the flash */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">==</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We change whole page so no need to load it. But we</span>
<span class="cm">			 * do not know whether this page exists on the media or</span>
<span class="cm">			 * not, so we assume the latter because it requires</span>
<span class="cm">			 * larger budget. The assumption is that it is better</span>
<span class="cm">			 * to budget a bit more than to read the page from the</span>
<span class="cm">			 * media. Thus, we are setting the @PG_checked flag</span>
<span class="cm">			 * here.</span>
<span class="cm">			 */</span>
			<span class="n">SetPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">skipped_read</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">do_readpage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">ClearPageError</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">allocate_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">ui</span><span class="p">,</span> <span class="n">appending</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we skipped reading the page because we were going to</span>
<span class="cm">		 * write all of it, then it is not up to date.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skipped_read</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ClearPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">ClearPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Budgeting failed which means it would have to force</span>
<span class="cm">		 * write-back but didn&#39;t, because we set the @fast flag in the</span>
<span class="cm">		 * request. Write-back cannot be done now, while we have the</span>
<span class="cm">		 * page locked, because it would deadlock. Unlock and free</span>
<span class="cm">		 * everything and fall-back to slow-path.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">appending</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">));</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">write_begin_slow</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pagep</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Whee, we acquired budgeting quickly - without involving</span>
<span class="cm">	 * garbage-collection, committing or forcing write-back. We return</span>
<span class="cm">	 * with @ui-&gt;ui_mutex locked if we are appending pages, and unlocked</span>
<span class="cm">	 * otherwise. This is an optimization (slightly hacky though).</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">pagep</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cancel_budget - cancel budget.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @page: page to cancel budget for</span>
<span class="cm"> * @ui: UBIFS inode object the page belongs to</span>
<span class="cm"> * @appending: non-zero if the page is appended</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function for a page write operation. It unlocks the</span>
<span class="cm"> * @ui-&gt;ui_mutex in case of appending.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cancel_budget</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span><span class="p">,</span> <span class="kt">int</span> <span class="n">appending</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">appending</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">)</span>
			<span class="n">ubifs_release_dirty_inode_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ui</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">release_new_page_budget</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">release_existing_page_budget</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			   <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">end_pos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">appending</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">end_pos</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;ino %lu, pos %llu, pg %lu, len %u, copied %d, i_size %lld&quot;</span><span class="p">,</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">copied</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">copied</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">==</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * VFS copied less data to the page that it intended and</span>
<span class="cm">		 * declared in its &#39;-&gt;write_begin()&#39; call via the @len</span>
<span class="cm">		 * argument. If the page was not up-to-date, and @len was</span>
<span class="cm">		 * @PAGE_CACHE_SIZE, the &#39;ubifs_write_begin()&#39; function did</span>
<span class="cm">		 * not load it from the media (for optimization reasons). This</span>
<span class="cm">		 * means that part of the page contains garbage. So read the</span>
<span class="cm">		 * page now.</span>
<span class="cm">		 */</span>
		<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;copied %d instead of %d, read page and repeat&quot;</span><span class="p">,</span>
			<span class="n">copied</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">cancel_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">ui</span><span class="p">,</span> <span class="n">appending</span><span class="p">);</span>
		<span class="n">ClearPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Return 0 to force VFS to repeat the whole operation, or the</span>
<span class="cm">		 * error code if &#39;do_readpage()&#39; fails.</span>
<span class="cm">		 */</span>
		<span class="n">copied</span> <span class="o">=</span> <span class="n">do_readpage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">SetPagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_pg_cnt</span><span class="p">);</span>
		<span class="n">__set_page_dirty_nobuffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">appending</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">end_pos</span><span class="p">);</span>
		<span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">end_pos</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Note, we do not set @I_DIRTY_PAGES (which means that the</span>
<span class="cm">		 * inode has dirty pages), this has been done in</span>
<span class="cm">		 * &#39;__set_page_dirty_nobuffers()&#39;.</span>
<span class="cm">		 */</span>
		<span class="n">__mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">I_DIRTY_DATASYNC</span><span class="p">);</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">));</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * populate_page - copy data nodes into a page for bulk-read.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @page: page</span>
<span class="cm"> * @bu: bulk-read information</span>
<span class="cm"> * @n: next zbranch slot</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">populate_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">bu_info</span> <span class="o">*</span><span class="n">bu</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nn</span> <span class="o">=</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="n">offs</span> <span class="o">=</span> <span class="n">bu</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">offs</span><span class="p">,</span> <span class="n">hole</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">i_size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">page_block</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="o">*</span><span class="n">zaddr</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">end_index</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;ino %lu, pg %lu, i_size %lld, flags %#lx&quot;</span><span class="p">,</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">i_size</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">zaddr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">end_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_size</span> <span class="o">||</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">end_index</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hole</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_hole</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">page_block</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">UBIFS_BLOCKS_PER_PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">out_len</span><span class="p">,</span> <span class="n">dlen</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nn</span> <span class="o">&gt;=</span> <span class="n">bu</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hole</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key_block</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">nn</span><span class="p">].</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">page_block</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ubifs_data_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>

			<span class="n">dn</span> <span class="o">=</span> <span class="n">bu</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="p">(</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">nn</span><span class="p">].</span><span class="n">offs</span> <span class="o">-</span> <span class="n">offs</span><span class="p">);</span>

			<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">sqnum</span><span class="p">)</span> <span class="o">&gt;</span>
				     <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">creat_sqnum</span><span class="p">);</span>

			<span class="n">len</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

			<span class="n">dlen</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="o">-</span> <span class="n">UBIFS_DATA_NODE_SZ</span><span class="p">;</span>
			<span class="n">out_len</span> <span class="o">=</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_decompress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">dlen</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out_len</span><span class="p">,</span>
					       <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">compr_type</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="n">len</span> <span class="o">!=</span> <span class="n">out_len</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">)</span>
				<span class="n">memset</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UBIFS_BLOCK_SIZE</span> <span class="o">-</span> <span class="n">len</span><span class="p">);</span>

			<span class="n">nn</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">read</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">UBIFS_BLOCK_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key_block</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">nn</span><span class="p">].</span><span class="n">key</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">page_block</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nn</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">hole</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">UBIFS_BLOCKS_PER_PAGE</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">;</span>
		<span class="n">page_block</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">end_index</span> <span class="o">==</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">i_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">read</span><span class="p">)</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">zaddr</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">read</span> <span class="o">-</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out_hole:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hole</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SetPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;hole&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">ClearPageError</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">nn</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_err:</span>
	<span class="n">ClearPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">SetPageError</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad data node (block %u, inode %lu)&quot;</span><span class="p">,</span>
		  <span class="n">page_block</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_do_bulk_read - do bulk-read.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @bu: bulk-read information</span>
<span class="cm"> * @page1: first page to read</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %1 if the bulk-read is done, otherwise %0 is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_do_bulk_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bu_info</span> <span class="o">*</span><span class="n">bu</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgoff_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">page1</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page1</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">page_idx</span><span class="p">,</span> <span class="n">page_cnt</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">allocate</span> <span class="o">=</span> <span class="n">bu</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">isize</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_get_bu_keys</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">bu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_warn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">eof</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Turn off bulk-read at the end of the file */</span>
		<span class="n">ui</span><span class="o">-&gt;</span><span class="n">read_in_a_row</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ui</span><span class="o">-&gt;</span><span class="n">bulk_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">page_cnt</span> <span class="o">=</span> <span class="n">bu</span><span class="o">-&gt;</span><span class="n">blk_cnt</span> <span class="o">&gt;&gt;</span> <span class="n">UBIFS_BLOCKS_PER_PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This happens when there are multiple blocks per page and the</span>
<span class="cm">		 * blocks for the first page we are looking for, are not</span>
<span class="cm">		 * together. If all the pages were like this, bulk-read would</span>
<span class="cm">		 * reduce performance, so we turn it off for a while.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">out_bu_off</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">allocate</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Allocate bulk-read buffer depending on how many data</span>
<span class="cm">			 * nodes we are going to read.</span>
<span class="cm">			 */</span>
			<span class="n">bu</span><span class="o">-&gt;</span><span class="n">buf_len</span> <span class="o">=</span> <span class="n">bu</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">offs</span> <span class="o">+</span>
				      <span class="n">bu</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">len</span> <span class="o">-</span>
				      <span class="n">bu</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">offs</span><span class="p">;</span>
			<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">buf_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">buf_len</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
			<span class="n">bu</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">buf_len</span><span class="p">,</span> <span class="n">GFP_NOFS</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_bu_off</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_bulk_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">bu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_warn</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">populate_page</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">page1</span><span class="p">,</span> <span class="n">bu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_warn</span><span class="p">;</span>

	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page1</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">isize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="n">end_index</span> <span class="o">=</span> <span class="p">((</span><span class="n">isize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">page_idx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">page_idx</span> <span class="o">&lt;</span> <span class="n">page_cnt</span><span class="p">;</span> <span class="n">page_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pgoff_t</span> <span class="n">page_offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">page_idx</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">page_offset</span> <span class="o">&gt;</span> <span class="n">end_index</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">find_or_create_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">page_offset</span><span class="p">,</span>
					   <span class="n">GFP_NOFS</span> <span class="o">|</span> <span class="n">__GFP_COLD</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">populate_page</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">bu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">last_page_read</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">page_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">allocate</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">out_warn:</span>
	<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;ignoring error %d and skipping bulk-read&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

<span class="nl">out_bu_off:</span>
	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">read_in_a_row</span> <span class="o">=</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">bulk_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_bulk_read - determine whether to bulk-read and, if so, do it.</span>
<span class="cm"> * @page: page from which to start bulk-read.</span>
<span class="cm"> *</span>
<span class="cm"> * Some flash media are capable of reading sequentially at faster rates. UBIFS</span>
<span class="cm"> * bulk-read facility is designed to take advantage of that, by reading in one</span>
<span class="cm"> * go consecutive data nodes that are also located consecutively in the same</span>
<span class="cm"> * LEB. This function returns %1 if a bulk-read is done and %0 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_bulk_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">pgoff_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">last_page_read</span> <span class="o">=</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">last_page_read</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bu_info</span> <span class="o">*</span><span class="n">bu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">allocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">last_page_read</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bulk_read</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Bulk-read is protected by @ui-&gt;ui_mutex, but it is an optimization,</span>
<span class="cm">	 * so don&#39;t bother if we cannot lock the mutex.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">!=</span> <span class="n">last_page_read</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Turn off bulk-read if we stop reading sequentially */</span>
		<span class="n">ui</span><span class="o">-&gt;</span><span class="n">read_in_a_row</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">bulk_read</span><span class="p">)</span>
			<span class="n">ui</span><span class="o">-&gt;</span><span class="n">bulk_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">bulk_read</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ui</span><span class="o">-&gt;</span><span class="n">read_in_a_row</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">read_in_a_row</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="cm">/* Three reads in a row, so switch on bulk-read */</span>
		<span class="n">ui</span><span class="o">-&gt;</span><span class="n">bulk_read</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If possible, try to use pre-allocated bulk-read information, which</span>
<span class="cm">	 * is protected by @c-&gt;bu_mutex.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bu_mutex</span><span class="p">))</span>
		<span class="n">bu</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bu</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">bu</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bu_info</span><span class="p">),</span> <span class="n">GFP_NOFS</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bu</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

		<span class="n">bu</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">allocated</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bu</span><span class="o">-&gt;</span><span class="n">buf_len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bu_buf_len</span><span class="p">;</span>
	<span class="n">data_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
		      <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">UBIFS_BLOCKS_PER_PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_do_bulk_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">bu</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">allocated</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bu_mutex</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bu</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_readpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ubifs_bulk_read</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">do_readpage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>

<span class="cp">#ifdef UBIFS_DEBUG</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_lock</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">synced_i_size</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_lock</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Update radix tree tags */</span>
	<span class="n">set_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">UBIFS_BLOCKS_PER_PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">blen</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">);</span>
		<span class="n">data_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_jnl_write_data</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">UBIFS_BLOCKS_PER_PAGE</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">block</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">blen</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">blen</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SetPageError</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot write page %lu of inode %lu, error %d&quot;</span><span class="p">,</span>
			  <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">ubifs_ro_mode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">PagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">release_new_page_budget</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">release_existing_page_budget</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">atomic_long_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_pg_cnt</span><span class="p">);</span>
	<span class="n">ClearPagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">ClearPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">end_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When writing-back dirty inodes, VFS first writes-back pages belonging to the</span>
<span class="cm"> * inode, then the inode itself. For UBIFS this may cause a problem. Consider a</span>
<span class="cm"> * situation when a we have an inode with size 0, then a megabyte of data is</span>
<span class="cm"> * appended to the inode, then write-back starts and flushes some amount of the</span>
<span class="cm"> * dirty pages, the journal becomes full, commit happens and finishes, and then</span>
<span class="cm"> * an unclean reboot happens. When the file system is mounted next time, the</span>
<span class="cm"> * inode size would still be 0, but there would be many pages which are beyond</span>
<span class="cm"> * the inode size, they would be indexed and consume flash space. Because the</span>
<span class="cm"> * journal has been committed, the replay would not be able to detect this</span>
<span class="cm"> * situation and correct the inode size. This means UBIFS would have to scan</span>
<span class="cm"> * whole index and correct all inode sizes, which is long an unacceptable.</span>
<span class="cm"> *</span>
<span class="cm"> * To prevent situations like this, UBIFS writes pages back only if they are</span>
<span class="cm"> * within the last synchronized inode size, i.e. the size which has been</span>
<span class="cm"> * written to the flash media last time. Otherwise, UBIFS forces inode</span>
<span class="cm"> * write-back, thus making sure the on-flash inode contains current inode size,</span>
<span class="cm"> * and then keeps writing pages back.</span>
<span class="cm"> *</span>
<span class="cm"> * Some locking issues explanation. &#39;ubifs_writepage()&#39; first is called with</span>
<span class="cm"> * the page locked, and it locks @ui_mutex. However, write-back does take inode</span>
<span class="cm"> * @i_mutex, which means other VFS operations may be run on this inode at the</span>
<span class="cm"> * same time. And the problematic one is truncation to smaller size, from where</span>
<span class="cm"> * we have to call &#39;truncate_setsize()&#39;, which first changes @inode-&gt;i_size,</span>
<span class="cm"> * then drops the truncated pages. And while dropping the pages, it takes the</span>
<span class="cm"> * page lock. This means that &#39;do_truncation()&#39; cannot call &#39;truncate_setsize()&#39;</span>
<span class="cm"> * with @ui_mutex locked, because it would deadlock with &#39;ubifs_writepage()&#39;.</span>
<span class="cm"> * This means that @inode-&gt;i_size is changed while @ui_mutex is unlocked.</span>
<span class="cm"> *</span>
<span class="cm"> * XXX(truncate): with the new truncate sequence this is not true anymore,</span>
<span class="cm"> * and the calls to truncate_setsize can be move around freely.  They should</span>
<span class="cm"> * be moved to the very end of the truncate sequence.</span>
<span class="cm"> *</span>
<span class="cm"> * But in &#39;ubifs_writepage()&#39; we have to guarantee that we do not write beyond</span>
<span class="cm"> * inode size. How do we do this if @inode-&gt;i_size may became smaller while we</span>
<span class="cm"> * are in the middle of &#39;ubifs_writepage()&#39;? The UBIFS solution is the</span>
<span class="cm"> * @ui-&gt;ui_isize &quot;shadow&quot; field which UBIFS uses instead of @inode-&gt;i_size</span>
<span class="cm"> * internally and updates it under @ui_mutex.</span>
<span class="cm"> *</span>
<span class="cm"> * Q: why we do not worry that if we race with truncation, we may end up with a</span>
<span class="cm"> * situation when the inode is truncated while we are in the middle of</span>
<span class="cm"> * &#39;do_writepage()&#39;, so we do write beyond inode size?</span>
<span class="cm"> * A: If we are in the middle of &#39;do_writepage()&#39;, truncation would be locked</span>
<span class="cm"> * on the page lock and it would not write the truncated inode node to the</span>
<span class="cm"> * journal before we have finished.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">loff_t</span> <span class="n">i_size</span> <span class="o">=</span>  <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">synced_i_size</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">end_index</span> <span class="o">=</span> <span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">i_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;ino %lu, pg %lu, pg flags %#lx&quot;</span><span class="p">,</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">PagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="cm">/* Is the page fully outside @i_size? (truncate in progress) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">end_index</span> <span class="o">||</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="n">end_index</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_lock</span><span class="p">);</span>
	<span class="n">synced_i_size</span> <span class="o">=</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">synced_i_size</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_lock</span><span class="p">);</span>

	<span class="cm">/* Is the page fully inside @i_size? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">end_index</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">synced_i_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">write_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * The inode has been written, but the write-buffer has</span>
<span class="cm">			 * not been synchronized, so in case of an unclean</span>
<span class="cm">			 * reboot we may end up with some pages beyond inode</span>
<span class="cm">			 * size, but they would be in the journal (because</span>
<span class="cm">			 * commit flushes write buffers) and recovery would deal</span>
<span class="cm">			 * with this.</span>
<span class="cm">			 */</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">do_writepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The page straddles @i_size. It must be zeroed out on each and every</span>
<span class="cm">	 * writepage invocation because it may be mmapped. &quot;A file is mapped</span>
<span class="cm">	 * in multiples of the page size. For a file that is not a multiple of</span>
<span class="cm">	 * the page size, the remaining memory is zeroed when mapped, and</span>
<span class="cm">	 * writes to that region are not written out to the file.&quot;</span>
<span class="cm">	 */</span>
	<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">kaddr</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">&gt;</span> <span class="n">synced_i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">write_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">do_writepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * do_attr_changes - change inode attributes.</span>
<span class="cm"> * @inode: inode to change attributes for</span>
<span class="cm"> * @attr: describes attributes to change</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_attr_changes</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_UID</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_uid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_GID</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_gid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_ATIME</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">timespec_trunc</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_atime</span><span class="p">,</span>
						<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_time_gran</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MTIME</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">timespec_trunc</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_mtime</span><span class="p">,</span>
						<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_time_gran</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_CTIME</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">timespec_trunc</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_ctime</span><span class="p">,</span>
						<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_time_gran</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">umode_t</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_mode</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_group_p</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_FSETID</span><span class="p">))</span>
			<span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">S_ISGID</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * do_truncation - truncate an inode.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @inode: inode to truncate</span>
<span class="cm"> * @attr: inode attribute changes description</span>
<span class="cm"> *</span>
<span class="cm"> * This function implements VFS &#39;-&gt;setattr()&#39; call when the inode is truncated</span>
<span class="cm"> * to a smaller size. Returns zero in case of success and a negative error code</span>
<span class="cm"> * in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_truncation</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="n">req</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">old_size</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span> <span class="n">new_size</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">new_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UBIFS_BLOCK_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">budgeted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;ino %lu, size %lld -&gt; %lld&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">old_size</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_budget_req</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is truncation to a smaller size, and we do not truncate on a</span>
<span class="cm">	 * block boundary, budget for changing one data block, because the last</span>
<span class="cm">	 * block will be re-written.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UBIFS_BLOCK_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">req</span><span class="p">.</span><span class="n">dirtied_page</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">req</span><span class="p">.</span><span class="n">dirtied_ino</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* A funny way to budget for truncation node */</span>
	<span class="n">req</span><span class="p">.</span><span class="n">dirtied_ino_d</span> <span class="o">=</span> <span class="n">UBIFS_TRUN_NODE_SZ</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_budget_space</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Treat truncations to zero as deletion and always allow them,</span>
<span class="cm">		 * just like we do for &#39;-&gt;unlink()&#39;.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">||</span> <span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">budgeted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">truncate_setsize</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pgoff_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">new_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">find_lock_page</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * &#39;ubifs_jnl_truncate()&#39; will try to truncate</span>
<span class="cm">				 * the last data node, but it contains</span>
<span class="cm">				 * out-of-date data because the page is dirty.</span>
<span class="cm">				 * Write the page now, so that</span>
<span class="cm">				 * &#39;ubifs_jnl_truncate()&#39; will see an already</span>
<span class="cm">				 * truncated (and up to date) data node.</span>
<span class="cm">				 */</span>
				<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">PagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

				<span class="n">clear_page_dirty_for_io</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">UBIFS_BLOCKS_PER_PAGE_SHIFT</span><span class="p">)</span>
					<span class="n">offset</span> <span class="o">=</span> <span class="n">new_size</span> <span class="o">&amp;</span>
						 <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">do_writepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out_budg</span><span class="p">;</span>
				<span class="cm">/*</span>
<span class="cm">				 * We could now tell &#39;ubifs_jnl_truncate()&#39; not</span>
<span class="cm">				 * to read the last block.</span>
<span class="cm">				 */</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * We could &#39;kmap()&#39; the page and pass the data</span>
<span class="cm">				 * to &#39;ubifs_jnl_truncate()&#39; to save it from</span>
<span class="cm">				 * having to read it.</span>
<span class="cm">				 */</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="cm">/* Truncation changes inode [mc]time */</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">ubifs_current_time</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="cm">/* Other attributes may be changed at the same time as well */</span>
	<span class="n">do_attr_changes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_jnl_truncate</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">old_size</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>

<span class="nl">out_budg:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">budgeted</span><span class="p">)</span>
		<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">nospace</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">nospace_rp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * do_setattr - change inode attributes.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @inode: inode to change attributes for</span>
<span class="cm"> * @attr: inode attribute changes description</span>
<span class="cm"> *</span>
<span class="cm"> * This function implements VFS &#39;-&gt;setattr()&#39; call for all cases except</span>
<span class="cm"> * truncations to smaller size. Returns zero in case of success and a negative</span>
<span class="cm"> * error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">release</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">new_size</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="n">req</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">dirtied_ino</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
				<span class="p">.</span><span class="n">dirtied_ino_d</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="p">};</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_budget_space</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;size %lld -&gt; %lld&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
		<span class="n">truncate_setsize</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Truncation changes inode [mc]time */</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">ubifs_current_time</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="cm">/* &#39;truncate_setsize()&#39; changed @i_size, update @ui_size */</span>
		<span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">do_attr_changes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>

	<span class="n">release</span> <span class="o">=</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Inode length changed, so we have to make sure</span>
<span class="cm">		 * @I_DIRTY_DATASYNC is set.</span>
<span class="cm">		 */</span>
		 <span class="n">__mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">I_DIRTY_SYNC</span> <span class="o">|</span> <span class="n">I_DIRTY_DATASYNC</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">mark_inode_dirty_sync</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">release</span><span class="p">)</span>
		<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_SYNC</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">write_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ubifs_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;ino %lu, mode %#x, ia_valid %#x&quot;</span><span class="p">,</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">inode_change_ok</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_synced_i_size</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span> <span class="o">&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
		<span class="cm">/* Truncation to a smaller size */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">do_truncation</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">do_setattr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ubifs_invalidatepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">PagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span><span class="p">)</span>
		<span class="cm">/* Partial page remains dirty */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">release_new_page_budget</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">release_existing_page_budget</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">atomic_long_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_pg_cnt</span><span class="p">);</span>
	<span class="n">ClearPagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">ClearPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">ubifs_follow_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>

	<span class="n">nd_set_link</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ubifs_fsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datasync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;syncing inode %lu&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * For some really strange reasons VFS does not filter out</span>
<span class="cm">		 * &#39;fsync()&#39; for R/O mounted file-systems as per 2.6.39.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">filemap_write_and_wait_range</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="cm">/* Synchronize the inode unless this is a &#39;datasync()&#39; call. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">datasync</span> <span class="o">||</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_DIRTY_DATASYNC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">write_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Nodes related to this inode may still sit in a write-buffer. Flush</span>
<span class="cm">	 * them.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_sync_wbufs_by_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mctime_update_needed - check if mtime or ctime update is needed.</span>
<span class="cm"> * @inode: the inode to do the check for</span>
<span class="cm"> * @now: current time</span>
<span class="cm"> *</span>
<span class="cm"> * This helper function checks if the inode mtime/ctime should be updated or</span>
<span class="cm"> * not. If current values of the time-stamps are within the UBIFS inode time</span>
<span class="cm"> * granularity, they are not updated. This is an optimization.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mctime_update_needed</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timespec_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">,</span> <span class="n">now</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">timespec_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">,</span> <span class="n">now</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * update_ctime - update mtime and ctime of an inode.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @inode: inode to update</span>
<span class="cm"> *</span>
<span class="cm"> * This function updates mtime and ctime of the inode if it is not equivalent to</span>
<span class="cm"> * current time. Returns zero in case of success and a negative error code in</span>
<span class="cm"> * case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">update_mctime</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span> <span class="o">=</span> <span class="n">ubifs_current_time</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mctime_update_needed</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">release</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="n">req</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">dirtied_ino</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
				<span class="p">.</span><span class="n">dirtied_ino_d</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="p">};</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_budget_space</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">ubifs_current_time</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">release</span> <span class="o">=</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">;</span>
		<span class="n">mark_inode_dirty_sync</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">release</span><span class="p">)</span>
			<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ubifs_aio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">update_mctime</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">generic_file_aio_write</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_set_page_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__set_page_dirty_nobuffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * An attempt to dirty a page without budgeting for it - should not</span>
<span class="cm">	 * happen.</span>
<span class="cm">	 */</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_releasepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">unused_gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * An attempt to release a dirty page without budgeting for it - should</span>
<span class="cm">	 * not happen.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">PagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">ClearPagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">ClearPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * mmap()d file has taken write protection fault and is being made writable.</span>
<span class="cm"> * UBIFS must ensure page is budgeted for.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_vm_page_mkwrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span> <span class="o">=</span> <span class="n">ubifs_current_time</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="n">req</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">new_page</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">update_time</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;ino %lu, pg %lu, i_size %lld&quot;</span><span class="p">,</span>	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span>
		<span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_media</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_error</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span> <span class="cm">/* -EROFS */</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have not locked @page so far so we may budget for changing the</span>
<span class="cm">	 * page. Note, we cannot do this after we locked the page, because</span>
<span class="cm">	 * budgeting may cause write-back which would cause deadlock.</span>
<span class="cm">	 *</span>
<span class="cm">	 * At the moment we do not know whether the page is dirty or not, so we</span>
<span class="cm">	 * assume that it is not and budget for a new page. We could look at</span>
<span class="cm">	 * the @PG_private flag and figure this out, but we may race with write</span>
<span class="cm">	 * back and the page state may change by the time we lock it, so this</span>
<span class="cm">	 * would need additional care. We do not bother with this at the</span>
<span class="cm">	 * moment, although it might be good idea to do. Instead, we allocate</span>
<span class="cm">	 * budget for a new page and amend it later on if the page was in fact</span>
<span class="cm">	 * dirty.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The budgeting-related logic of this function is similar to what we</span>
<span class="cm">	 * do in &#39;ubifs_write_begin()&#39; and &#39;ubifs_write_end()&#39;. Glance there</span>
<span class="cm">	 * for more comments.</span>
<span class="cm">	 */</span>
	<span class="n">update_time</span> <span class="o">=</span> <span class="n">mctime_update_needed</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">update_time</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * We have to change inode time stamp which requires extra</span>
<span class="cm">		 * budgeting.</span>
<span class="cm">		 */</span>
		<span class="n">req</span><span class="p">.</span><span class="n">dirtied_ino</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_budget_space</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
			<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;out of space for mmapped file &quot;</span>
				   <span class="s">&quot;(inode number %lu)&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span> <span class="o">||</span>
		     <span class="n">page_offset</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* Page got truncated out from underneath us */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">release_new_page_budget</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">ubifs_convert_page_budget</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="n">SetPagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_pg_cnt</span><span class="p">);</span>
		<span class="n">__set_page_dirty_nobuffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">update_time</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">release</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">ubifs_current_time</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">release</span> <span class="o">=</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">;</span>
		<span class="n">mark_inode_dirty_sync</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">release</span><span class="p">)</span>
			<span class="n">ubifs_release_dirty_inode_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ui</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">ubifs_file_vm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">fault</span>        <span class="o">=</span> <span class="n">filemap_fault</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page_mkwrite</span> <span class="o">=</span> <span class="n">ubifs_vm_page_mkwrite</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_file_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">generic_file_mmap</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ubifs_file_vm_ops</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">ubifs_file_address_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readpage</span>       <span class="o">=</span> <span class="n">ubifs_readpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepage</span>      <span class="o">=</span> <span class="n">ubifs_writepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_begin</span>    <span class="o">=</span> <span class="n">ubifs_write_begin</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_end</span>      <span class="o">=</span> <span class="n">ubifs_write_end</span><span class="p">,</span>
	<span class="p">.</span><span class="n">invalidatepage</span> <span class="o">=</span> <span class="n">ubifs_invalidatepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_page_dirty</span> <span class="o">=</span> <span class="n">ubifs_set_page_dirty</span><span class="p">,</span>
	<span class="p">.</span><span class="n">releasepage</span>    <span class="o">=</span> <span class="n">ubifs_releasepage</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ubifs_file_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">setattr</span>     <span class="o">=</span> <span class="n">ubifs_setattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getattr</span>     <span class="o">=</span> <span class="n">ubifs_getattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setxattr</span>    <span class="o">=</span> <span class="n">ubifs_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span>    <span class="o">=</span> <span class="n">ubifs_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span>   <span class="o">=</span> <span class="n">ubifs_listxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span> <span class="o">=</span> <span class="n">ubifs_removexattr</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ubifs_symlink_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readlink</span>    <span class="o">=</span> <span class="n">generic_readlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">follow_link</span> <span class="o">=</span> <span class="n">ubifs_follow_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>     <span class="o">=</span> <span class="n">ubifs_setattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getattr</span>     <span class="o">=</span> <span class="n">ubifs_getattr</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ubifs_file_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">llseek</span>         <span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>           <span class="o">=</span> <span class="n">do_sync_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>          <span class="o">=</span> <span class="n">do_sync_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_read</span>       <span class="o">=</span> <span class="n">generic_file_aio_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_write</span>      <span class="o">=</span> <span class="n">ubifs_aio_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span>           <span class="o">=</span> <span class="n">ubifs_file_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fsync</span>          <span class="o">=</span> <span class="n">ubifs_fsync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">ubifs_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">splice_read</span>	<span class="o">=</span> <span class="n">generic_file_splice_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">splice_write</span>	<span class="o">=</span> <span class="n">generic_file_splice_write</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span>   <span class="o">=</span> <span class="n">ubifs_compat_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
