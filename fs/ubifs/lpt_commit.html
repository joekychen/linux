<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ubifs › lpt_commit.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>lpt_commit.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is part of UBIFS.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Nokia Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="cm"> * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Adrian Hunter</span>
<span class="cm"> *          Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file implements commit-related functionality of the LEB properties</span>
<span class="cm"> * subsystem.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/crc16.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &quot;ubifs.h&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">dbg_populate_lsave</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * first_dirty_cnode - find first dirty cnode.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @nnode: nnode at which to start</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the first dirty cnode or %NULL if there is not one.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ubifs_cnode</span> <span class="o">*</span><span class="nf">first_dirty_cnode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">nnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">nnode</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">cont</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UBIFS_LPT_FANOUT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ubifs_cnode</span> <span class="o">*</span><span class="n">cnode</span><span class="p">;</span>

			<span class="n">cnode</span> <span class="o">=</span> <span class="n">nnode</span><span class="o">-&gt;</span><span class="n">nbranch</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cnode</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cnode</span> <span class="o">&amp;&amp;</span>
			    <span class="n">test_bit</span><span class="p">(</span><span class="n">DIRTY_CNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cnode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">cnode</span><span class="p">;</span>
				<span class="n">nnode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="p">)</span><span class="n">cnode</span><span class="p">;</span>
				<span class="n">cont</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cont</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_cnode</span> <span class="o">*</span><span class="p">)</span><span class="n">nnode</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * next_dirty_cnode - find next dirty cnode.</span>
<span class="cm"> * @cnode: cnode from which to begin searching</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the next dirty cnode or %NULL if there is not one.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ubifs_cnode</span> <span class="o">*</span><span class="nf">next_dirty_cnode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_cnode</span> <span class="o">*</span><span class="n">cnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">nnode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">cnode</span><span class="p">);</span>
	<span class="n">nnode</span> <span class="o">=</span> <span class="n">cnode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nnode</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">cnode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UBIFS_LPT_FANOUT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cnode</span> <span class="o">=</span> <span class="n">nnode</span><span class="o">-&gt;</span><span class="n">nbranch</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cnode</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnode</span> <span class="o">&amp;&amp;</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">DIRTY_CNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cnode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">cnode</span><span class="p">;</span> <span class="cm">/* cnode is a pnode */</span>
			<span class="cm">/* cnode is a nnode */</span>
			<span class="k">return</span> <span class="n">first_dirty_cnode</span><span class="p">((</span><span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="p">)</span><span class="n">cnode</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_cnode</span> <span class="o">*</span><span class="p">)</span><span class="n">nnode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_cnodes_to_commit - create list of dirty cnodes to commit.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the number of cnodes to commit.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_cnodes_to_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_cnode</span> <span class="o">*</span><span class="n">cnode</span><span class="p">,</span> <span class="o">*</span><span class="n">cnext</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">nroot</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DIRTY_CNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">nroot</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_cnext</span> <span class="o">=</span> <span class="n">first_dirty_cnode</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">nroot</span><span class="p">);</span>
	<span class="n">cnode</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_cnext</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cnode</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">COW_CNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">COW_CNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">cnext</span> <span class="o">=</span> <span class="n">next_dirty_cnode</span><span class="p">(</span><span class="n">cnode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cnext</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cnode</span><span class="o">-&gt;</span><span class="n">cnext</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_cnext</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cnode</span><span class="o">-&gt;</span><span class="n">cnext</span> <span class="o">=</span> <span class="n">cnext</span><span class="p">;</span>
		<span class="n">cnode</span> <span class="o">=</span> <span class="n">cnext</span><span class="p">;</span>
		<span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;committing %d cnodes&quot;</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
	<span class="n">dbg_lp</span><span class="p">(</span><span class="s">&quot;committing %d cnodes&quot;</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_nn_cnt</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_pn_cnt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * upd_ltab - update LPT LEB properties.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB number</span>
<span class="cm"> * @free: amount of free space</span>
<span class="cm"> * @dirty: amount of dirty space to add</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">upd_ltab</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">free</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dirty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dbg_lp</span><span class="p">(</span><span class="s">&quot;LEB %d free %d dirty %d to %d +%d&quot;</span><span class="p">,</span>
	       <span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">lnum</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span><span class="p">].</span><span class="n">free</span><span class="p">,</span>
	       <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">lnum</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span><span class="p">].</span><span class="n">dirty</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">dirty</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span> <span class="o">&amp;&amp;</span> <span class="n">lnum</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_last</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">lnum</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span><span class="p">].</span><span class="n">free</span> <span class="o">=</span> <span class="n">free</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">lnum</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span><span class="p">].</span><span class="n">dirty</span> <span class="o">+=</span> <span class="n">dirty</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * alloc_lpt_leb - allocate an LPT LEB that is empty.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB number is passed and returned here</span>
<span class="cm"> *</span>
<span class="cm"> * This function finds the next empty LEB in the ltab starting from @lnum. If a</span>
<span class="cm"> * an empty LEB is found it is returned in @lnum and the function returns %0.</span>
<span class="cm"> * Otherwise the function returns -ENOSPC.  Note however, that LPT is designed</span>
<span class="cm"> * never to run out of space.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_lpt_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="o">*</span><span class="n">lnum</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lebs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tgc</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmt</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">free</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="o">*</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tgc</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmt</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">free</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="o">*</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * layout_cnodes - layout cnodes for commit.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">layout_cnodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">alen</span><span class="p">,</span> <span class="n">done_lsave</span><span class="p">,</span> <span class="n">done_ltab</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_cnode</span> <span class="o">*</span><span class="n">cnode</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">cnode</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_cnext</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cnode</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_lnum</span><span class="p">;</span>
	<span class="n">offs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_offs</span><span class="p">;</span>
	<span class="cm">/* Try to place lsave and ltab nicely */</span>
	<span class="n">done_lsave</span> <span class="o">=</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">big_lpt</span><span class="p">;</span>
	<span class="n">done_ltab</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done_lsave</span> <span class="o">&amp;&amp;</span> <span class="n">offs</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_sz</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">done_lsave</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
		<span class="n">offs</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_sz</span><span class="p">;</span>
		<span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_sz</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offs</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_sz</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">done_ltab</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
		<span class="n">offs</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_sz</span><span class="p">;</span>
		<span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_sz</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nnode_sz</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_nn_cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">pnode_sz</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_pn_cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">offs</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">alen</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">offs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
			<span class="n">upd_ltab</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">alen</span><span class="p">,</span> <span class="n">alen</span> <span class="o">-</span> <span class="n">offs</span><span class="p">);</span>
			<span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">offs</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">alloc_lpt_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lnum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">no_space</span><span class="p">;</span>
			<span class="n">offs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span> <span class="o">&amp;&amp;</span>
				     <span class="n">lnum</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_last</span><span class="p">);</span>
			<span class="cm">/* Try to place lsave and ltab nicely */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done_lsave</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">done_lsave</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
				<span class="n">offs</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_sz</span><span class="p">;</span>
				<span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_sz</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done_ltab</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">done_ltab</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
				<span class="n">offs</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_sz</span><span class="p">;</span>
				<span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_sz</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cnode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">nbranch</span><span class="p">[</span><span class="n">cnode</span><span class="o">-&gt;</span><span class="n">iip</span><span class="p">].</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
			<span class="n">cnode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">nbranch</span><span class="p">[</span><span class="n">cnode</span><span class="o">-&gt;</span><span class="n">iip</span><span class="p">].</span><span class="n">offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">offs</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">cnode</span> <span class="o">=</span> <span class="n">cnode</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">cnode</span> <span class="o">&amp;&amp;</span> <span class="n">cnode</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_cnext</span><span class="p">);</span>

	<span class="cm">/* Make sure to place LPT&#39;s save table */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done_lsave</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offs</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_sz</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">alen</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">offs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
			<span class="n">upd_ltab</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">alen</span><span class="p">,</span> <span class="n">alen</span> <span class="o">-</span> <span class="n">offs</span><span class="p">);</span>
			<span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">offs</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">alloc_lpt_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lnum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">no_space</span><span class="p">;</span>
			<span class="n">offs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span> <span class="o">&amp;&amp;</span>
				     <span class="n">lnum</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_last</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">done_lsave</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
		<span class="n">offs</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_sz</span><span class="p">;</span>
		<span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_sz</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure to place LPT&#39;s own lprops table */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done_ltab</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offs</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_sz</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">alen</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">offs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
			<span class="n">upd_ltab</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">alen</span><span class="p">,</span> <span class="n">alen</span> <span class="o">-</span> <span class="n">offs</span><span class="p">);</span>
			<span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">offs</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">alloc_lpt_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lnum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">no_space</span><span class="p">;</span>
			<span class="n">offs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span> <span class="o">&amp;&amp;</span>
				     <span class="n">lnum</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_last</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">done_ltab</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
		<span class="n">offs</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_sz</span><span class="p">;</span>
		<span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_sz</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">alen</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">offs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="n">upd_ltab</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">alen</span><span class="p">,</span> <span class="n">alen</span> <span class="o">-</span> <span class="n">offs</span><span class="p">);</span>
	<span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">alen</span> <span class="o">-</span> <span class="n">offs</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">alen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">no_space:</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;LPT out of space at LEB %d:%d needing %d, done_ltab %d, &quot;</span>
		  <span class="s">&quot;done_lsave %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">done_ltab</span><span class="p">,</span> <span class="n">done_lsave</span><span class="p">);</span>
	<span class="n">ubifs_dump_lpt_info</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">ubifs_dump_lpt_lebs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * realloc_lpt_leb - allocate an LPT LEB that is empty.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB number is passed and returned here</span>
<span class="cm"> *</span>
<span class="cm"> * This function duplicates exactly the results of the function alloc_lpt_leb.</span>
<span class="cm"> * It is used during end commit to reallocate the same LEB numbers that were</span>
<span class="cm"> * allocated by alloc_lpt_leb during start commit.</span>
<span class="cm"> *</span>
<span class="cm"> * This function finds the next LEB that was allocated by the alloc_lpt_leb</span>
<span class="cm"> * function starting from @lnum. If a LEB is found it is returned in @lnum and</span>
<span class="cm"> * the function returns %0. Otherwise the function returns -ENOSPC.</span>
<span class="cm"> * Note however, that LPT is designed never to run out of space.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">realloc_lpt_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="o">*</span><span class="n">lnum</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lebs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="o">*</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="o">*</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * write_cnodes - write cnodes for commit.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_cnodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">wlen</span><span class="p">,</span> <span class="n">alen</span><span class="p">,</span> <span class="n">done_ltab</span><span class="p">,</span> <span class="n">done_lsave</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_cnode</span> <span class="o">*</span><span class="n">cnode</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_buf</span><span class="p">;</span>

	<span class="n">cnode</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_cnext</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cnode</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_lnum</span><span class="p">;</span>
	<span class="n">offs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_offs</span><span class="p">;</span>
	<span class="n">from</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
	<span class="cm">/* Ensure empty LEB is unmapped */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Try to place lsave and ltab nicely */</span>
	<span class="n">done_lsave</span> <span class="o">=</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">big_lpt</span><span class="p">;</span>
	<span class="n">done_ltab</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done_lsave</span> <span class="o">&amp;&amp;</span> <span class="n">offs</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_sz</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">done_lsave</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ubifs_pack_lsave</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">offs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave</span><span class="p">);</span>
		<span class="n">offs</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_sz</span><span class="p">;</span>
		<span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_sz</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offs</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_sz</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">done_ltab</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ubifs_pack_ltab</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">offs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_cmt</span><span class="p">);</span>
		<span class="n">offs</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_sz</span><span class="p">;</span>
		<span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_sz</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Loop for each cnode */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nnode_sz</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">pnode_sz</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">offs</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wlen</span> <span class="o">=</span> <span class="n">offs</span> <span class="o">-</span> <span class="n">from</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wlen</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">alen</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">wlen</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
				<span class="n">memset</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">offs</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">alen</span> <span class="o">-</span> <span class="n">wlen</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_write</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">from</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span>
						       <span class="n">alen</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">offs</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">realloc_lpt_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lnum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">no_space</span><span class="p">;</span>
			<span class="n">offs</span> <span class="o">=</span> <span class="n">from</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span> <span class="o">&amp;&amp;</span>
				     <span class="n">lnum</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_last</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="cm">/* Try to place lsave and ltab nicely */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done_lsave</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">done_lsave</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">ubifs_pack_lsave</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">offs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave</span><span class="p">);</span>
				<span class="n">offs</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_sz</span><span class="p">;</span>
				<span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_sz</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done_ltab</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">done_ltab</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">ubifs_pack_ltab</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">offs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_cmt</span><span class="p">);</span>
				<span class="n">offs</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_sz</span><span class="p">;</span>
				<span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_sz</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span>
			<span class="n">ubifs_pack_nnode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">offs</span><span class="p">,</span>
					 <span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="p">)</span><span class="n">cnode</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ubifs_pack_pnode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">offs</span><span class="p">,</span>
					 <span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_pnode</span> <span class="o">*</span><span class="p">)</span><span class="n">cnode</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * The reason for the barriers is the same as in case of TNC.</span>
<span class="cm">		 * See comment in &#39;write_index()&#39;. &#39;dirty_cow_nnode()&#39; and</span>
<span class="cm">		 * &#39;dirty_cow_pnode()&#39; are the functions for which this is</span>
<span class="cm">		 * important.</span>
<span class="cm">		 */</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">DIRTY_CNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">smp_mb__before_clear_bit</span><span class="p">();</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">COW_CNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>
		<span class="n">offs</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">cnode</span> <span class="o">=</span> <span class="n">cnode</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">cnode</span> <span class="o">&amp;&amp;</span> <span class="n">cnode</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_cnext</span><span class="p">);</span>

	<span class="cm">/* Make sure to place LPT&#39;s save table */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done_lsave</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offs</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_sz</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wlen</span> <span class="o">=</span> <span class="n">offs</span> <span class="o">-</span> <span class="n">from</span><span class="p">;</span>
			<span class="n">alen</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">wlen</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">offs</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">alen</span> <span class="o">-</span> <span class="n">wlen</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_write</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">from</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">alen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">offs</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">realloc_lpt_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lnum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">no_space</span><span class="p">;</span>
			<span class="n">offs</span> <span class="o">=</span> <span class="n">from</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span> <span class="o">&amp;&amp;</span>
				     <span class="n">lnum</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_last</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">done_lsave</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ubifs_pack_lsave</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">offs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave</span><span class="p">);</span>
		<span class="n">offs</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_sz</span><span class="p">;</span>
		<span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_sz</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure to place LPT&#39;s own lprops table */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done_ltab</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offs</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_sz</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wlen</span> <span class="o">=</span> <span class="n">offs</span> <span class="o">-</span> <span class="n">from</span><span class="p">;</span>
			<span class="n">alen</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">wlen</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">offs</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">alen</span> <span class="o">-</span> <span class="n">wlen</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_write</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">from</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">alen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">offs</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">realloc_lpt_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lnum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">no_space</span><span class="p">;</span>
			<span class="n">offs</span> <span class="o">=</span> <span class="n">from</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span> <span class="o">&amp;&amp;</span>
				     <span class="n">lnum</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_last</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">done_ltab</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ubifs_pack_ltab</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">offs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_cmt</span><span class="p">);</span>
		<span class="n">offs</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_sz</span><span class="p">;</span>
		<span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_sz</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Write remaining data in buffer */</span>
	<span class="n">wlen</span> <span class="o">=</span> <span class="n">offs</span> <span class="o">-</span> <span class="n">from</span><span class="p">;</span>
	<span class="n">alen</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">wlen</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">offs</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">alen</span> <span class="o">-</span> <span class="n">wlen</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_write</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">from</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">alen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">alen</span> <span class="o">-</span> <span class="n">wlen</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_chk_lpt_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">offs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_offs</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">offs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>

	<span class="n">dbg_lp</span><span class="p">(</span><span class="s">&quot;LPT root is at %d:%d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_offs</span><span class="p">);</span>
	<span class="n">dbg_lp</span><span class="p">(</span><span class="s">&quot;LPT head is at %d:%d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_offs</span><span class="p">);</span>
	<span class="n">dbg_lp</span><span class="p">(</span><span class="s">&quot;LPT ltab is at %d:%d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_offs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">big_lpt</span><span class="p">)</span>
		<span class="n">dbg_lp</span><span class="p">(</span><span class="s">&quot;LPT lsave is at %d:%d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_offs</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">no_space:</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;LPT out of space mismatch at LEB %d:%d needing %d, done_ltab &quot;</span>
		  <span class="s">&quot;%d, done_lsave %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">done_ltab</span><span class="p">,</span> <span class="n">done_lsave</span><span class="p">);</span>
	<span class="n">ubifs_dump_lpt_info</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">ubifs_dump_lpt_lebs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * next_pnode_to_dirty - find next pnode to dirty.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @pnode: pnode</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the next pnode to dirty or %NULL if there are no more</span>
<span class="cm"> * pnodes.  Note that pnodes that have never been written (lnum == 0) are</span>
<span class="cm"> * skipped.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ubifs_pnode</span> <span class="o">*</span><span class="nf">next_pnode_to_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">ubifs_pnode</span> <span class="o">*</span><span class="n">pnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">nnode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iip</span><span class="p">;</span>

	<span class="cm">/* Try to go right */</span>
	<span class="n">nnode</span> <span class="o">=</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">iip</span> <span class="o">=</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">iip</span> <span class="o">&lt;</span> <span class="n">UBIFS_LPT_FANOUT</span><span class="p">;</span> <span class="n">iip</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nnode</span><span class="o">-&gt;</span><span class="n">nbranch</span><span class="p">[</span><span class="n">iip</span><span class="p">].</span><span class="n">lnum</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ubifs_get_pnode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">nnode</span><span class="p">,</span> <span class="n">iip</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Go up while can&#39;t go right */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">iip</span> <span class="o">=</span> <span class="n">nnode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">nnode</span> <span class="o">=</span> <span class="n">nnode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nnode</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">iip</span> <span class="o">&lt;</span> <span class="n">UBIFS_LPT_FANOUT</span><span class="p">;</span> <span class="n">iip</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nnode</span><span class="o">-&gt;</span><span class="n">nbranch</span><span class="p">[</span><span class="n">iip</span><span class="p">].</span><span class="n">lnum</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">iip</span> <span class="o">&gt;=</span> <span class="n">UBIFS_LPT_FANOUT</span><span class="p">);</span>

	<span class="cm">/* Go right */</span>
	<span class="n">nnode</span> <span class="o">=</span> <span class="n">ubifs_get_nnode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">nnode</span><span class="p">,</span> <span class="n">iip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">nnode</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">nnode</span><span class="p">;</span>

	<span class="cm">/* Go down to level 1 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nnode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">iip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iip</span> <span class="o">&lt;</span> <span class="n">UBIFS_LPT_FANOUT</span><span class="p">;</span> <span class="n">iip</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nnode</span><span class="o">-&gt;</span><span class="n">nbranch</span><span class="p">[</span><span class="n">iip</span><span class="p">].</span><span class="n">lnum</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iip</span> <span class="o">&gt;=</span> <span class="n">UBIFS_LPT_FANOUT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Should not happen, but we need to keep going</span>
<span class="cm">			 * if it does.</span>
<span class="cm">			 */</span>
			<span class="n">iip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">nnode</span> <span class="o">=</span> <span class="n">ubifs_get_nnode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">nnode</span><span class="p">,</span> <span class="n">iip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">nnode</span><span class="p">))</span>
			<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">nnode</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">iip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iip</span> <span class="o">&lt;</span> <span class="n">UBIFS_LPT_FANOUT</span><span class="p">;</span> <span class="n">iip</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nnode</span><span class="o">-&gt;</span><span class="n">nbranch</span><span class="p">[</span><span class="n">iip</span><span class="p">].</span><span class="n">lnum</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iip</span> <span class="o">&gt;=</span> <span class="n">UBIFS_LPT_FANOUT</span><span class="p">)</span>
		<span class="cm">/* Should not happen, but we need to keep going if it does */</span>
		<span class="n">iip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ubifs_get_pnode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">nnode</span><span class="p">,</span> <span class="n">iip</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pnode_lookup - lookup a pnode in the LPT.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @i: pnode number (0 to main_lebs - 1)</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns a pointer to the pnode on success or a negative</span>
<span class="cm"> * error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ubifs_pnode</span> <span class="o">*</span><span class="nf">pnode_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">iip</span><span class="p">,</span> <span class="n">shft</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">nnode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">nroot</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_read_nnode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">i</span> <span class="o">&lt;&lt;=</span> <span class="n">UBIFS_LPT_FANOUT_SHIFT</span><span class="p">;</span>
	<span class="n">nnode</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nroot</span><span class="p">;</span>
	<span class="n">shft</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_hght</span> <span class="o">*</span> <span class="n">UBIFS_LPT_FANOUT_SHIFT</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">h</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_hght</span><span class="p">;</span> <span class="n">h</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iip</span> <span class="o">=</span> <span class="p">((</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="n">shft</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UBIFS_LPT_FANOUT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="n">shft</span> <span class="o">-=</span> <span class="n">UBIFS_LPT_FANOUT_SHIFT</span><span class="p">;</span>
		<span class="n">nnode</span> <span class="o">=</span> <span class="n">ubifs_get_nnode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">nnode</span><span class="p">,</span> <span class="n">iip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">nnode</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">nnode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">iip</span> <span class="o">=</span> <span class="p">((</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="n">shft</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UBIFS_LPT_FANOUT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">ubifs_get_pnode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">nnode</span><span class="p">,</span> <span class="n">iip</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * add_pnode_dirt - add dirty space to LPT LEB properties.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @pnode: pnode for which to add dirt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_pnode_dirt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_pnode</span> <span class="o">*</span><span class="n">pnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ubifs_add_lpt_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">nbranch</span><span class="p">[</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">iip</span><span class="p">].</span><span class="n">lnum</span><span class="p">,</span>
			   <span class="n">c</span><span class="o">-&gt;</span><span class="n">pnode_sz</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * do_make_pnode_dirty - mark a pnode dirty.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @pnode: pnode to mark dirty</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_make_pnode_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_pnode</span> <span class="o">*</span><span class="n">pnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Assumes cnext list is empty i.e. not called during commit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">DIRTY_CNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">nnode</span><span class="p">;</span>

		<span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_pn_cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">add_pnode_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">pnode</span><span class="p">);</span>
		<span class="cm">/* Mark parent and ancestors dirty too */</span>
		<span class="n">nnode</span> <span class="o">=</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">nnode</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">DIRTY_CNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nnode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_nn_cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">ubifs_add_nnode_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">nnode</span><span class="p">);</span>
				<span class="n">nnode</span> <span class="o">=</span> <span class="n">nnode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * make_tree_dirty - mark the entire LEB properties tree dirty.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used by the &quot;small&quot; LPT model to cause the entire LEB</span>
<span class="cm"> * properties tree to be written.  The &quot;small&quot; LPT model does not use LPT</span>
<span class="cm"> * garbage collection because it is more efficient to write the entire tree</span>
<span class="cm"> * (because it is small).</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">make_tree_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_pnode</span> <span class="o">*</span><span class="n">pnode</span><span class="p">;</span>

	<span class="n">pnode</span> <span class="o">=</span> <span class="n">pnode_lookup</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pnode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pnode</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">pnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">do_make_pnode_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">pnode</span><span class="p">);</span>
		<span class="n">pnode</span> <span class="o">=</span> <span class="n">next_pnode_to_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">pnode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pnode</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pnode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * need_write_all - determine if the LPT area is running out of free space.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %1 if the LPT area is running out of free space and %0</span>
<span class="cm"> * if it is not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">need_write_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lebs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_lnum</span><span class="p">)</span>
			<span class="n">free</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_offs</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">free</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span>
			<span class="n">free</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">free</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dirty</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span>
			<span class="n">free</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Less than twice the size left */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_sz</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpt_tgc_start - start trivial garbage collection of LPT LEBs.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * LPT trivial garbage collection is where a LPT LEB contains only dirty and</span>
<span class="cm"> * free space and so may be reused as soon as the next commit is completed.</span>
<span class="cm"> * This function is called during start commit to mark LPT LEBs for trivial GC.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lpt_tgc_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lebs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_lnum</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dirty</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">free</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dirty</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tgc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">free</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">dbg_lp</span><span class="p">(</span><span class="s">&quot;LEB %d&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpt_tgc_end - end trivial garbage collection of LPT LEBs.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * LPT trivial garbage collection is where a LPT LEB contains only dirty and</span>
<span class="cm"> * free space and so may be reused as soon as the next commit is completed.</span>
<span class="cm"> * This function is called after the commit is completed (master node has been</span>
<span class="cm"> * written) and un-maps LPT LEBs that were marked for trivial GC.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpt_tgc_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lebs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tgc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tgc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">dbg_lp</span><span class="p">(</span><span class="s">&quot;LEB %d&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * populate_lsave - fill the lsave array with important LEB numbers.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function is only called for the &quot;big&quot; model. It records a small number</span>
<span class="cm"> * of LEB numbers of important LEBs.  Important LEBs are ones that are (from</span>
<span class="cm"> * most important to least important): empty, freeable, freeable index, dirty</span>
<span class="cm"> * index, dirty or free. Upon mount, we read this list of LEB numbers and bring</span>
<span class="cm"> * their pnodes into memory.  That will stop us from having to scan the LPT</span>
<span class="cm"> * straight away. For the &quot;small&quot; model we assume that scanning the LPT is no</span>
<span class="cm"> * big deal.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">populate_lsave</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_lpt_heap</span> <span class="o">*</span><span class="n">heap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">big_lpt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_drty_flgs</span> <span class="o">&amp;</span> <span class="n">LSAVE_DIRTY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_drty_flgs</span> <span class="o">|=</span> <span class="n">LSAVE_DIRTY</span><span class="p">;</span>
		<span class="n">ubifs_add_lpt_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_sz</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dbg_populate_lsave</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lprops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">empty_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave</span><span class="p">[</span><span class="n">cnt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lprops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave</span><span class="p">[</span><span class="n">cnt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lprops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">frdi_idx_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave</span><span class="p">[</span><span class="n">cnt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">heap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_heap</span><span class="p">[</span><span class="n">LPROPS_DIRTY_IDX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave</span><span class="p">[</span><span class="n">cnt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">heap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_heap</span><span class="p">[</span><span class="n">LPROPS_DIRTY</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave</span><span class="p">[</span><span class="n">cnt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">heap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_heap</span><span class="p">[</span><span class="n">LPROPS_FREE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave</span><span class="p">[</span><span class="n">cnt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Fill it up completely */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave</span><span class="p">[</span><span class="n">cnt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_first</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nnode_lookup - lookup a nnode in the LPT.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @i: nnode number</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns a pointer to the nnode on success or a negative</span>
<span class="cm"> * error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="nf">nnode_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">iip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">nnode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">nroot</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_read_nnode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">nnode</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nroot</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iip</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UBIFS_LPT_FANOUT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">&gt;&gt;=</span> <span class="n">UBIFS_LPT_FANOUT_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">nnode</span> <span class="o">=</span> <span class="n">ubifs_get_nnode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">nnode</span><span class="p">,</span> <span class="n">iip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">nnode</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">nnode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">nnode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * make_nnode_dirty - find a nnode and, if found, make it dirty.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @node_num: nnode number of nnode to make dirty</span>
<span class="cm"> * @lnum: LEB number where nnode was written</span>
<span class="cm"> * @offs: offset where nnode was written</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used by LPT garbage collection.  LPT garbage collection is</span>
<span class="cm"> * used only for the &quot;big&quot; LPT model (c-&gt;big_lpt == 1).  Garbage collection</span>
<span class="cm"> * simply involves marking all the nodes in the LEB being garbage-collected as</span>
<span class="cm"> * dirty.  The dirty nodes are written next commit, after which the LEB is free</span>
<span class="cm"> * to be reused.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">make_nnode_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">nnode</span><span class="p">;</span>

	<span class="n">nnode</span> <span class="o">=</span> <span class="n">nnode_lookup</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node_num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">nnode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">nnode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nnode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_nbranch</span> <span class="o">*</span><span class="n">branch</span><span class="p">;</span>

		<span class="n">branch</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nnode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">nbranch</span><span class="p">[</span><span class="n">nnode</span><span class="o">-&gt;</span><span class="n">iip</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">branch</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">!=</span> <span class="n">lnum</span> <span class="o">||</span> <span class="n">branch</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">!=</span> <span class="n">offs</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* nnode is obsolete */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lnum</span> <span class="o">!=</span> <span class="n">lnum</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_offs</span> <span class="o">!=</span> <span class="n">offs</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* nnode is obsolete */</span>
	<span class="cm">/* Assumes cnext list is empty i.e. not called during commit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">DIRTY_CNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nnode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_nn_cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ubifs_add_nnode_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">nnode</span><span class="p">);</span>
		<span class="cm">/* Mark parent and ancestors dirty too */</span>
		<span class="n">nnode</span> <span class="o">=</span> <span class="n">nnode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">nnode</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">DIRTY_CNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nnode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_nn_cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">ubifs_add_nnode_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">nnode</span><span class="p">);</span>
				<span class="n">nnode</span> <span class="o">=</span> <span class="n">nnode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * make_pnode_dirty - find a pnode and, if found, make it dirty.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @node_num: pnode number of pnode to make dirty</span>
<span class="cm"> * @lnum: LEB number where pnode was written</span>
<span class="cm"> * @offs: offset where pnode was written</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used by LPT garbage collection.  LPT garbage collection is</span>
<span class="cm"> * used only for the &quot;big&quot; LPT model (c-&gt;big_lpt == 1).  Garbage collection</span>
<span class="cm"> * simply involves marking all the nodes in the LEB being garbage-collected as</span>
<span class="cm"> * dirty.  The dirty nodes are written next commit, after which the LEB is free</span>
<span class="cm"> * to be reused.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">make_pnode_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_pnode</span> <span class="o">*</span><span class="n">pnode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_nbranch</span> <span class="o">*</span><span class="n">branch</span><span class="p">;</span>

	<span class="n">pnode</span> <span class="o">=</span> <span class="n">pnode_lookup</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node_num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pnode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pnode</span><span class="p">);</span>
	<span class="n">branch</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">nbranch</span><span class="p">[</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">iip</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">branch</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">!=</span> <span class="n">lnum</span> <span class="o">||</span> <span class="n">branch</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">!=</span> <span class="n">offs</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">do_make_pnode_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">pnode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * make_ltab_dirty - make ltab node dirty.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB number where ltab was written</span>
<span class="cm"> * @offs: offset where ltab was written</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used by LPT garbage collection.  LPT garbage collection is</span>
<span class="cm"> * used only for the &quot;big&quot; LPT model (c-&gt;big_lpt == 1).  Garbage collection</span>
<span class="cm"> * simply involves marking all the nodes in the LEB being garbage-collected as</span>
<span class="cm"> * dirty.  The dirty nodes are written next commit, after which the LEB is free</span>
<span class="cm"> * to be reused.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">make_ltab_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_lnum</span> <span class="o">||</span> <span class="n">offs</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_offs</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* This ltab node is obsolete */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_drty_flgs</span> <span class="o">&amp;</span> <span class="n">LTAB_DIRTY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_drty_flgs</span> <span class="o">|=</span> <span class="n">LTAB_DIRTY</span><span class="p">;</span>
		<span class="n">ubifs_add_lpt_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_sz</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * make_lsave_dirty - make lsave node dirty.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB number where lsave was written</span>
<span class="cm"> * @offs: offset where lsave was written</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used by LPT garbage collection.  LPT garbage collection is</span>
<span class="cm"> * used only for the &quot;big&quot; LPT model (c-&gt;big_lpt == 1).  Garbage collection</span>
<span class="cm"> * simply involves marking all the nodes in the LEB being garbage-collected as</span>
<span class="cm"> * dirty.  The dirty nodes are written next commit, after which the LEB is free</span>
<span class="cm"> * to be reused.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">make_lsave_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_lnum</span> <span class="o">||</span> <span class="n">offs</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_offs</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* This lsave node is obsolete */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_drty_flgs</span> <span class="o">&amp;</span> <span class="n">LSAVE_DIRTY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_drty_flgs</span> <span class="o">|=</span> <span class="n">LSAVE_DIRTY</span><span class="p">;</span>
		<span class="n">ubifs_add_lpt_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_sz</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * make_node_dirty - make node dirty.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @node_type: LPT node type</span>
<span class="cm"> * @node_num: node number</span>
<span class="cm"> * @lnum: LEB number where node was written</span>
<span class="cm"> * @offs: offset where node was written</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used by LPT garbage collection.  LPT garbage collection is</span>
<span class="cm"> * used only for the &quot;big&quot; LPT model (c-&gt;big_lpt == 1).  Garbage collection</span>
<span class="cm"> * simply involves marking all the nodes in the LEB being garbage-collected as</span>
<span class="cm"> * dirty.  The dirty nodes are written next commit, after which the LEB is free</span>
<span class="cm"> * to be reused.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">make_node_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node_type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node_num</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">node_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UBIFS_LPT_NNODE</span>:
		<span class="k">return</span> <span class="n">make_nnode_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node_num</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">UBIFS_LPT_PNODE</span>:
		<span class="k">return</span> <span class="n">make_pnode_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node_num</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">UBIFS_LPT_LTAB</span>:
		<span class="k">return</span> <span class="n">make_ltab_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">UBIFS_LPT_LSAVE</span>:
		<span class="k">return</span> <span class="n">make_lsave_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_lpt_node_len - return the length of a node based on its type.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @node_type: LPT node type</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_lpt_node_len</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">node_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UBIFS_LPT_NNODE</span>:
		<span class="k">return</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nnode_sz</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_LPT_PNODE</span>:
		<span class="k">return</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">pnode_sz</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_LPT_LTAB</span>:
		<span class="k">return</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_sz</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_LPT_LSAVE</span>:
		<span class="k">return</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_sz</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_pad_len - return the length of padding in a buffer.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @buf: buffer</span>
<span class="cm"> * @len: length of buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_pad_len</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="n">pad_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">offs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">pad_len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">offs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">)</span> <span class="o">-</span> <span class="n">offs</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pad_len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_lpt_node_type - return type (and node number) of a node in a buffer.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @buf: buffer</span>
<span class="cm"> * @node_num: node number is returned here</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_lpt_node_type</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="o">*</span><span class="n">node_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">UBIFS_LPT_CRC_BYTES</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">node_type</span><span class="p">;</span>

	<span class="n">node_type</span> <span class="o">=</span> <span class="n">ubifs_unpack_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">,</span> <span class="n">UBIFS_LPT_TYPE_BITS</span><span class="p">);</span>
	<span class="o">*</span><span class="n">node_num</span> <span class="o">=</span> <span class="n">ubifs_unpack_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">pcnt_bits</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">node_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * is_a_node - determine if a buffer contains a node.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @buf: buffer</span>
<span class="cm"> * @len: length of buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %1 if the buffer contains a node or %0 if it does not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_a_node</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">UBIFS_LPT_CRC_BYTES</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">node_type</span><span class="p">,</span> <span class="n">node_len</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">crc</span><span class="p">,</span> <span class="n">calc_crc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">UBIFS_LPT_CRC_BYTES</span> <span class="o">+</span> <span class="p">(</span><span class="n">UBIFS_LPT_TYPE_BITS</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">node_type</span> <span class="o">=</span> <span class="n">ubifs_unpack_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">,</span> <span class="n">UBIFS_LPT_TYPE_BITS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node_type</span> <span class="o">==</span> <span class="n">UBIFS_LPT_NOT_A_NODE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">node_len</span> <span class="o">=</span> <span class="n">get_lpt_node_len</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_len</span> <span class="o">||</span> <span class="n">node_len</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">crc</span> <span class="o">=</span> <span class="n">ubifs_unpack_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">,</span> <span class="n">UBIFS_LPT_CRC_BITS</span><span class="p">);</span>
	<span class="n">calc_crc</span> <span class="o">=</span> <span class="n">crc16</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">UBIFS_LPT_CRC_BYTES</span><span class="p">,</span>
			 <span class="n">node_len</span> <span class="o">-</span> <span class="n">UBIFS_LPT_CRC_BYTES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">crc</span> <span class="o">!=</span> <span class="n">calc_crc</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpt_gc_lnum - garbage collect a LPT LEB.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB number to garbage collect</span>
<span class="cm"> *</span>
<span class="cm"> * LPT garbage collection is used only for the &quot;big&quot; LPT model</span>
<span class="cm"> * (c-&gt;big_lpt == 1).  Garbage collection simply involves marking all the nodes</span>
<span class="cm"> * in the LEB being garbage-collected as dirty.  The dirty nodes are written</span>
<span class="cm"> * next commit, after which the LEB is free to be reused.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpt_gc_lnum</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">,</span> <span class="n">node_type</span><span class="p">,</span> <span class="n">node_num</span><span class="p">,</span> <span class="n">node_len</span><span class="p">,</span> <span class="n">offs</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_buf</span><span class="p">;</span>

	<span class="n">dbg_lp</span><span class="p">(</span><span class="s">&quot;LEB %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_a_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">pad_len</span><span class="p">;</span>

			<span class="n">pad_len</span> <span class="o">=</span> <span class="n">get_pad_len</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pad_len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">buf</span> <span class="o">+=</span> <span class="n">pad_len</span><span class="p">;</span>
				<span class="n">len</span> <span class="o">-=</span> <span class="n">pad_len</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">node_type</span> <span class="o">=</span> <span class="n">get_lpt_node_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_num</span><span class="p">);</span>
		<span class="n">node_len</span> <span class="o">=</span> <span class="n">get_lpt_node_len</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node_type</span><span class="p">);</span>
		<span class="n">offs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">node_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">make_node_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node_type</span><span class="p">,</span> <span class="n">node_num</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">node_len</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">node_len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpt_gc - LPT garbage collection.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * Select a LPT LEB for LPT garbage collection and call &#39;lpt_gc_lnum()&#39;.</span>
<span class="cm"> * Returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lpt_gc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">lnum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lebs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tgc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_lnum</span> <span class="o">||</span>
		    <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">free</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dirty</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dirty</span> <span class="o">&gt;</span> <span class="n">dirty</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dirty</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dirty</span><span class="p">;</span>
			<span class="n">lnum</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">lpt_gc_lnum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_lpt_start_commit - UBIFS commit starts.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function has to be called when UBIFS starts the commit operation.</span>
<span class="cm"> * This function &quot;freezes&quot; all currently dirty LEB properties and does not</span>
<span class="cm"> * change them anymore. Further changes are saved and tracked separately</span>
<span class="cm"> * because they are not part of this commit. This function returns zero in case</span>
<span class="cm"> * of success and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_lpt_start_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="n">dbg_lp</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_chk_lpt_free_spc</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_ltab</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">check_lpt_free</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We ensure there is enough free space in</span>
<span class="cm">		 * ubifs_lpt_post_commit() by marking nodes dirty. That</span>
<span class="cm">		 * information is lost when we unmount, so we also need</span>
<span class="cm">		 * to check free space once after mounting also.</span>
<span class="cm">		 */</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">check_lpt_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">need_write_all</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">lpt_gc</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">lpt_tgc_start</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_pn_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;no cnodes to commit&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">big_lpt</span> <span class="o">&amp;&amp;</span> <span class="n">need_write_all</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* If needed, write everything */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">make_tree_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">lpt_tgc_start</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">big_lpt</span><span class="p">)</span>
		<span class="n">populate_lsave</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">cnt</span> <span class="o">=</span> <span class="n">get_cnodes_to_commit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">cnt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">layout_cnodes</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Copy the LPT&#39;s own lprops for end commit to write */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_cmt</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_lpt_lprops</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lebs</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_drty_flgs</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">LTAB_DIRTY</span> <span class="o">|</span> <span class="n">LSAVE_DIRTY</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * free_obsolete_cnodes - free obsolete cnodes for commit end.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_obsolete_cnodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_cnode</span> <span class="o">*</span><span class="n">cnode</span><span class="p">,</span> <span class="o">*</span><span class="n">cnext</span><span class="p">;</span>

	<span class="n">cnext</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_cnext</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cnext</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">cnode</span> <span class="o">=</span> <span class="n">cnext</span><span class="p">;</span>
		<span class="n">cnext</span> <span class="o">=</span> <span class="n">cnode</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">OBSOLETE_CNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">cnode</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">cnode</span><span class="o">-&gt;</span><span class="n">cnext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">cnext</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_cnext</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_cnext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_lpt_end_commit - finish the commit operation.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function has to be called when the commit operation finishes. It</span>
<span class="cm"> * flushes the changes which were &quot;frozen&quot; by &#39;ubifs_lprops_start_commit()&#39; to</span>
<span class="cm"> * the media. Returns zero in case of success and a negative error code in case</span>
<span class="cm"> * of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_lpt_end_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dbg_lp</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_cnext</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">write_cnodes</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">);</span>
	<span class="n">free_obsolete_cnodes</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_lpt_post_commit - post commit LPT trivial GC and LPT GC.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * LPT trivial GC is completed after a commit. Also LPT GC is done after a</span>
<span class="cm"> * commit for the &quot;big&quot; LPT model.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_lpt_post_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">lpt_tgc_end</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">big_lpt</span><span class="p">)</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">need_write_all</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">lpt_gc</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">);</span>
		<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * first_nnode - find the first nnode in memory.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @hght: height of tree where nnode found is returned here</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns a pointer to the nnode found or %NULL if no nnode is</span>
<span class="cm"> * found. This function is a helper to &#39;ubifs_lpt_free()&#39;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="nf">first_nnode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">hght</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">nnode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">found</span><span class="p">;</span>

	<span class="n">nnode</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nroot</span><span class="p">;</span>
	<span class="o">*</span><span class="n">hght</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nnode</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">h</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_hght</span><span class="p">;</span> <span class="n">h</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UBIFS_LPT_FANOUT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nnode</span><span class="o">-&gt;</span><span class="n">nbranch</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nnode</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">nnode</span> <span class="o">=</span> <span class="n">nnode</span><span class="o">-&gt;</span><span class="n">nbranch</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nnode</span><span class="p">;</span>
				<span class="o">*</span><span class="n">hght</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">nnode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * next_nnode - find the next nnode in memory.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @nnode: nnode from which to start.</span>
<span class="cm"> * @hght: height of tree where nnode is, is passed and returned here</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns a pointer to the nnode found or %NULL if no nnode is</span>
<span class="cm"> * found. This function is a helper to &#39;ubifs_lpt_free()&#39;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="nf">next_nnode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">nnode</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">hght</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iip</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">found</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">nnode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nnode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">==</span> <span class="n">UBIFS_LPT_FANOUT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">hght</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">iip</span> <span class="o">=</span> <span class="n">nnode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">iip</span> <span class="o">&lt;</span> <span class="n">UBIFS_LPT_FANOUT</span><span class="p">;</span> <span class="n">iip</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nnode</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">nbranch</span><span class="p">[</span><span class="n">iip</span><span class="p">].</span><span class="n">nnode</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nnode</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">hght</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">h</span> <span class="o">=</span> <span class="o">*</span><span class="n">hght</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_hght</span><span class="p">;</span> <span class="n">h</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UBIFS_LPT_FANOUT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nnode</span><span class="o">-&gt;</span><span class="n">nbranch</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nnode</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">nnode</span> <span class="o">=</span> <span class="n">nnode</span><span class="o">-&gt;</span><span class="n">nbranch</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nnode</span><span class="p">;</span>
				<span class="o">*</span><span class="n">hght</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">nnode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_lpt_free - free resources owned by the LPT.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @wr_only: free only resources used for writing</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubifs_lpt_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wr_only</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">nnode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">hght</span><span class="p">;</span>

	<span class="cm">/* Free write-only things first */</span>

	<span class="n">free_obsolete_cnodes</span><span class="p">(</span><span class="n">c</span><span class="p">);</span> <span class="cm">/* Leftover from a failed commit */</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_cmt</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_cmt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_buf</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wr_only</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Now free the rest */</span>

	<span class="n">nnode</span> <span class="o">=</span> <span class="n">first_nnode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hght</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UBIFS_LPT_FANOUT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">nnode</span><span class="o">-&gt;</span><span class="n">nbranch</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nnode</span><span class="p">);</span>
		<span class="n">nnode</span> <span class="o">=</span> <span class="n">next_nnode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">nnode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hght</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LPROPS_HEAP_CNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_heap</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">arr</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_idx</span><span class="p">.</span><span class="n">arr</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">nroot</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_nod_buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Everything below is related to debugging.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_is_all_ff - determine if a buffer contains only 0xFF bytes.</span>
<span class="cm"> * @buf: buffer</span>
<span class="cm"> * @len: buffer length</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_is_all_ff</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xff</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_is_nnode_dirty - determine if a nnode is dirty.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB number where nnode was written</span>
<span class="cm"> * @offs: offset where nnode was written</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_is_nnode_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">nnode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hght</span><span class="p">;</span>

	<span class="cm">/* Entire tree is in memory so first_nnode / next_nnode are OK */</span>
	<span class="n">nnode</span> <span class="o">=</span> <span class="n">first_nnode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hght</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">nnode</span><span class="p">;</span> <span class="n">nnode</span> <span class="o">=</span> <span class="n">next_nnode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">nnode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hght</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_nbranch</span> <span class="o">*</span><span class="n">branch</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nnode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">branch</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nnode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">nbranch</span><span class="p">[</span><span class="n">nnode</span><span class="o">-&gt;</span><span class="n">iip</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">branch</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">!=</span> <span class="n">lnum</span> <span class="o">||</span> <span class="n">branch</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">!=</span> <span class="n">offs</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DIRTY_CNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nnode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lnum</span> <span class="o">!=</span> <span class="n">lnum</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_offs</span> <span class="o">!=</span> <span class="n">offs</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DIRTY_CNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nnode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_is_pnode_dirty - determine if a pnode is dirty.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB number where pnode was written</span>
<span class="cm"> * @offs: offset where pnode was written</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_is_pnode_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="n">cnt</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">main_lebs</span><span class="p">,</span> <span class="n">UBIFS_LPT_FANOUT</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_pnode</span> <span class="o">*</span><span class="n">pnode</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ubifs_nbranch</span> <span class="o">*</span><span class="n">branch</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">pnode</span> <span class="o">=</span> <span class="n">pnode_lookup</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pnode</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pnode</span><span class="p">);</span>
		<span class="n">branch</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">nbranch</span><span class="p">[</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">iip</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">branch</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">!=</span> <span class="n">lnum</span> <span class="o">||</span> <span class="n">branch</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">!=</span> <span class="n">offs</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">DIRTY_CNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_is_ltab_dirty - determine if a ltab node is dirty.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB number where ltab node was written</span>
<span class="cm"> * @offs: offset where ltab node was written</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_is_ltab_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_lnum</span> <span class="o">||</span> <span class="n">offs</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_offs</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_drty_flgs</span> <span class="o">&amp;</span> <span class="n">LTAB_DIRTY</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_is_lsave_dirty - determine if a lsave node is dirty.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB number where lsave node was written</span>
<span class="cm"> * @offs: offset where lsave node was written</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_is_lsave_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_lnum</span> <span class="o">||</span> <span class="n">offs</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_offs</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_drty_flgs</span> <span class="o">&amp;</span> <span class="n">LSAVE_DIRTY</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_is_node_dirty - determine if a node is dirty.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @node_type: node type</span>
<span class="cm"> * @lnum: LEB number where node was written</span>
<span class="cm"> * @offs: offset where node was written</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_is_node_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node_type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">node_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UBIFS_LPT_NNODE</span>:
		<span class="k">return</span> <span class="n">dbg_is_nnode_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">UBIFS_LPT_PNODE</span>:
		<span class="k">return</span> <span class="n">dbg_is_pnode_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">UBIFS_LPT_LTAB</span>:
		<span class="k">return</span> <span class="n">dbg_is_ltab_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">UBIFS_LPT_LSAVE</span>:
		<span class="k">return</span> <span class="n">dbg_is_lsave_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_check_ltab_lnum - check the ltab for a LPT LEB number.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB number where node was written</span>
<span class="cm"> * @offs: offset where node was written</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_check_ltab_lnum</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">,</span> <span class="n">dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">node_type</span><span class="p">,</span> <span class="n">node_num</span><span class="p">,</span> <span class="n">node_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_chk_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">p</span> <span class="o">=</span> <span class="n">__vmalloc</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">,</span> <span class="n">PAGE_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot allocate memory for ltab checking&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dbg_lp</span><span class="p">(</span><span class="s">&quot;LEB %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_a_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">pad_len</span><span class="p">;</span>

			<span class="n">pad_len</span> <span class="o">=</span> <span class="n">get_pad_len</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pad_len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">p</span> <span class="o">+=</span> <span class="n">pad_len</span><span class="p">;</span>
				<span class="n">len</span> <span class="o">-=</span> <span class="n">pad_len</span><span class="p">;</span>
				<span class="n">dirty</span> <span class="o">+=</span> <span class="n">pad_len</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_all_ff</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;invalid empty space in LEB %d at %d&quot;</span><span class="p">,</span>
					<span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">len</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">lnum</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">free</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;invalid free space in LEB %d &quot;</span>
					<span class="s">&quot;(free %d, expected %d)&quot;</span><span class="p">,</span>
					<span class="n">lnum</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">free</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dirty</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dirty</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;invalid dirty space in LEB %d &quot;</span>
					<span class="s">&quot;(dirty %d, expected %d)&quot;</span><span class="p">,</span>
					<span class="n">lnum</span><span class="p">,</span> <span class="n">dirty</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dirty</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">node_type</span> <span class="o">=</span> <span class="n">get_lpt_node_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_num</span><span class="p">);</span>
		<span class="n">node_len</span> <span class="o">=</span> <span class="n">get_lpt_node_len</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node_type</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dbg_is_node_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node_type</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">dirty</span> <span class="o">+=</span> <span class="n">node_len</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">node_len</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">node_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_check_ltab - check the free and dirty space in the ltab.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbg_check_ltab</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_chk_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Bring the entire tree into memory */</span>
	<span class="n">cnt</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">main_lebs</span><span class="p">,</span> <span class="n">UBIFS_LPT_FANOUT</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_pnode</span> <span class="o">*</span><span class="n">pnode</span><span class="p">;</span>

		<span class="n">pnode</span> <span class="o">=</span> <span class="n">pnode_lookup</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pnode</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pnode</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* Check nodes */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_lpt_nodes</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_cnode</span> <span class="o">*</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">nroot</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Check each LEB */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span><span class="p">;</span> <span class="n">lnum</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_last</span><span class="p">;</span> <span class="n">lnum</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_ltab_lnum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;failed at LEB %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dbg_lp</span><span class="p">(</span><span class="s">&quot;succeeded&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_chk_lpt_free_spc - check LPT free space is enough to write entire LPT.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbg_chk_lpt_free_spc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_chk_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lebs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tgc</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmt</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_lnum</span><span class="p">)</span>
			<span class="n">free</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_offs</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">free</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span>
			<span class="n">free</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_sz</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;LPT space error: free %lld lpt_sz %lld&quot;</span><span class="p">,</span>
			  <span class="n">free</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_sz</span><span class="p">);</span>
		<span class="n">ubifs_dump_lpt_info</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="n">ubifs_dump_lpt_lebs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_chk_lpt_sz - check LPT does not write more than LPT size.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @action: what to do</span>
<span class="cm"> * @len: length written</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> * The @action argument may be one of:</span>
<span class="cm"> *   o %0 - LPT debugging checking starts, initialize debugging variables;</span>
<span class="cm"> *   o %1 - wrote an LPT node, increase LPT size by @len bytes;</span>
<span class="cm"> *   o %2 - switched to a different LEB and wasted @len bytes;</span>
<span class="cm"> *   o %3 - check that we&#39;ve written the right number of bytes.</span>
<span class="cm"> *   o %4 - wasted @len bytes;</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbg_chk_lpt_sz</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">action</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_debug_info</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">chk_lpt_sz</span><span class="p">,</span> <span class="n">lpt_sz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_chk_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_sz2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_lebs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_wastage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_pn_cnt</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">pnode_cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;dirty pnodes %d exceed max %d&quot;</span><span class="p">,</span>
				  <span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_pn_cnt</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">pnode_cnt</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_nn_cnt</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nnode_cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;dirty nnodes %d exceed max %d&quot;</span><span class="p">,</span>
				  <span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_nn_cnt</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nnode_cnt</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_sz</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_sz</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_wastage</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_lebs</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">chk_lpt_sz</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">;</span>
		<span class="n">chk_lpt_sz</span> <span class="o">*=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_lebs</span><span class="p">;</span>
		<span class="n">chk_lpt_sz</span> <span class="o">+=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_offs</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_sz</span> <span class="o">!=</span> <span class="n">chk_lpt_sz</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;LPT wrote %lld but space used was %lld&quot;</span><span class="p">,</span>
				  <span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_sz</span><span class="p">,</span> <span class="n">chk_lpt_sz</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_sz</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_sz</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;LPT wrote %lld but lpt_sz is %lld&quot;</span><span class="p">,</span>
				  <span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_sz</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_sz</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_sz2</span> <span class="o">&amp;&amp;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_sz</span> <span class="o">!=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_sz2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;LPT layout size %lld but wrote %lld&quot;</span><span class="p">,</span>
				  <span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_sz</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_sz2</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_sz2</span> <span class="o">&amp;&amp;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">new_nhead_offs</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;LPT new nhead offs: expected %d was %d&quot;</span><span class="p">,</span>
				  <span class="n">d</span><span class="o">-&gt;</span><span class="n">new_nhead_offs</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lpt_sz</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">pnode_cnt</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">pnode_sz</span><span class="p">;</span>
		<span class="n">lpt_sz</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">nnode_cnt</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nnode_sz</span><span class="p">;</span>
		<span class="n">lpt_sz</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_sz</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">big_lpt</span><span class="p">)</span>
			<span class="n">lpt_sz</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_sz</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_sz</span> <span class="o">-</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_wastage</span> <span class="o">&gt;</span> <span class="n">lpt_sz</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;LPT chk_lpt_sz %lld + waste %lld exceeds %lld&quot;</span><span class="p">,</span>
				  <span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_sz</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_wastage</span><span class="p">,</span> <span class="n">lpt_sz</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_dump_lpt_info</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="n">ubifs_dump_lpt_lebs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="n">dump_stack</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_sz2</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_sz</span><span class="p">;</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_wastage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_lebs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">new_nhead_offs</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_sz</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lpt_wastage</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_dump_lpt_leb - dump an LPT LEB.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB number to dump</span>
<span class="cm"> *</span>
<span class="cm"> * This function dumps an LEB from LPT area. Nodes in this area are very</span>
<span class="cm"> * different to nodes in the main area (e.g., they do not have common headers,</span>
<span class="cm"> * they do not have 8-byte alignments, etc), so we have a separate function to</span>
<span class="cm"> * dump LPT area LEBs. Note, LPT has to be locked by the caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dump_lpt_leb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">,</span> <span class="n">node_type</span><span class="p">,</span> <span class="n">node_num</span><span class="p">,</span> <span class="n">node_len</span><span class="p">,</span> <span class="n">offs</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;(pid %d) start dumping LEB %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">p</span> <span class="o">=</span> <span class="n">__vmalloc</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">,</span> <span class="n">PAGE_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot allocate memory to dump LPT&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_a_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">pad_len</span><span class="p">;</span>

			<span class="n">pad_len</span> <span class="o">=</span> <span class="n">get_pad_len</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pad_len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;LEB %d:%d, pad %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">pad_len</span><span class="p">);</span>
				<span class="n">p</span> <span class="o">+=</span> <span class="n">pad_len</span><span class="p">;</span>
				<span class="n">len</span> <span class="o">-=</span> <span class="n">pad_len</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;LEB %d:%d, free %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">node_type</span> <span class="o">=</span> <span class="n">get_lpt_node_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_num</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">node_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">UBIFS_LPT_PNODE</span>:
		<span class="p">{</span>
			<span class="n">node_len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">pnode_sz</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">big_lpt</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;LEB %d:%d, pnode num %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">node_num</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;LEB %d:%d, pnode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">UBIFS_LPT_NNODE</span>:
		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="n">nnode</span><span class="p">;</span>

			<span class="n">node_len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nnode_sz</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">big_lpt</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;LEB %d:%d, nnode num %d, &quot;</span><span class="p">,</span>
				       <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">node_num</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;LEB %d:%d, nnode, &quot;</span><span class="p">,</span>
				       <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_unpack_nnode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nnode</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UBIFS_LPT_FANOUT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;%d:%d&quot;</span><span class="p">,</span> <span class="n">nnode</span><span class="p">.</span><span class="n">nbranch</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lnum</span><span class="p">,</span>
				       <span class="n">nnode</span><span class="p">.</span><span class="n">nbranch</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offs</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">UBIFS_LPT_FANOUT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;, &quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">UBIFS_LPT_LTAB</span>:
			<span class="n">node_len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_sz</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;LEB %d:%d, ltab</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">UBIFS_LPT_LSAVE</span>:
			<span class="n">node_len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_sz</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;LEB %d:%d, lsave len</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;LPT node type %d not recognized&quot;</span><span class="p">,</span> <span class="n">node_type</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">p</span> <span class="o">+=</span> <span class="n">node_len</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">node_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;(pid %d) finish dumping LEB %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_dump_lpt_lebs - dump LPT lebs.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function dumps all LPT LEBs. The caller has to make sure the LPT is</span>
<span class="cm"> * locked.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubifs_dump_lpt_lebs</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;(pid %d) start dumping all LPT LEBs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lebs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">dump_lpt_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;(pid %d) finish dumping all LPT LEBs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_populate_lsave - debugging version of &#39;populate_lsave()&#39;</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This is a debugging version for &#39;populate_lsave()&#39; which populates lsave</span>
<span class="cm"> * with random LEBs instead of useful LEBs, which is good for test coverage.</span>
<span class="cm"> * Returns zero if lsave has not been populated (this debugging feature is</span>
<span class="cm"> * disabled) an non-zero if lsave has been populated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_populate_lsave</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_lpt_heap</span> <span class="o">*</span><span class="n">heap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_chk_gen</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">random32</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_first</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lprops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">empty_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave</span><span class="p">[</span><span class="n">random32</span><span class="p">()</span> <span class="o">%</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lprops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave</span><span class="p">[</span><span class="n">random32</span><span class="p">()</span> <span class="o">%</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lprops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">frdi_idx_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave</span><span class="p">[</span><span class="n">random32</span><span class="p">()</span> <span class="o">%</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>

	<span class="n">heap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_heap</span><span class="p">[</span><span class="n">LPROPS_DIRTY_IDX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave</span><span class="p">[</span><span class="n">random32</span><span class="p">()</span> <span class="o">%</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>
	<span class="n">heap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_heap</span><span class="p">[</span><span class="n">LPROPS_DIRTY</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave</span><span class="p">[</span><span class="n">random32</span><span class="p">()</span> <span class="o">%</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>
	<span class="n">heap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_heap</span><span class="p">[</span><span class="n">LPROPS_FREE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave</span><span class="p">[</span><span class="n">random32</span><span class="p">()</span> <span class="o">%</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
