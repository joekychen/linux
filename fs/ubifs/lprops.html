<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ubifs › lprops.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>lprops.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is part of UBIFS.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Nokia Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="cm"> * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Adrian Hunter</span>
<span class="cm"> *          Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file implements the functions that access LEB properties and their</span>
<span class="cm"> * categories. LEBs are categorized based on the needs of UBIFS, and the</span>
<span class="cm"> * categories are stored as either heaps or lists to provide a fast way of</span>
<span class="cm"> * finding a LEB in a particular category. For example, UBIFS may need to find</span>
<span class="cm"> * an empty LEB for the journal, or a very dirty LEB for garbage collection.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;ubifs.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * get_heap_comp_val - get the LEB properties value for heap comparisons.</span>
<span class="cm"> * @lprops: LEB properties</span>
<span class="cm"> * @cat: LEB category</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_heap_comp_val</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cat</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPROPS_FREE</span>:
		<span class="k">return</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPROPS_DIRTY_IDX</span>:
		<span class="k">return</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * move_up_lpt_heap - move a new heap entry up as far as possible.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @heap: LEB category heap</span>
<span class="cm"> * @lprops: LEB properties to move</span>
<span class="cm"> * @cat: LEB category</span>
<span class="cm"> *</span>
<span class="cm"> * New entries to a heap are added at the bottom and then moved up until the</span>
<span class="cm"> * parent&#39;s value is greater.  In the case of LPT&#39;s category heaps, the value</span>
<span class="cm"> * is either the amount of free space or the amount of dirty space, depending</span>
<span class="cm"> * on the category.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">move_up_lpt_heap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lpt_heap</span> <span class="o">*</span><span class="n">heap</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">,</span> <span class="n">hpos</span><span class="p">;</span>

	<span class="n">hpos</span> <span class="o">=</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">hpos</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hpos</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* Already top of the heap */</span>
	<span class="n">val1</span> <span class="o">=</span> <span class="n">get_heap_comp_val</span><span class="p">(</span><span class="n">lprops</span><span class="p">,</span> <span class="n">cat</span><span class="p">);</span>
	<span class="cm">/* Compare to parent and, if greater, move up the heap */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ppos</span> <span class="o">=</span> <span class="p">(</span><span class="n">hpos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

		<span class="n">val2</span> <span class="o">=</span> <span class="n">get_heap_comp_val</span><span class="p">(</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">ppos</span><span class="p">],</span> <span class="n">cat</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val2</span> <span class="o">&gt;=</span> <span class="n">val1</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="cm">/* Greater than parent so move up */</span>
		<span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">ppos</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">hpos</span> <span class="o">=</span> <span class="n">hpos</span><span class="p">;</span>
		<span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">hpos</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">ppos</span><span class="p">];</span>
		<span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">ppos</span><span class="p">]</span> <span class="o">=</span> <span class="n">lprops</span><span class="p">;</span>
		<span class="n">lprops</span><span class="o">-&gt;</span><span class="n">hpos</span> <span class="o">=</span> <span class="n">ppos</span><span class="p">;</span>
		<span class="n">hpos</span> <span class="o">=</span> <span class="n">ppos</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">hpos</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * adjust_lpt_heap - move a changed heap entry up or down the heap.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @heap: LEB category heap</span>
<span class="cm"> * @lprops: LEB properties to move</span>
<span class="cm"> * @hpos: heap position of @lprops</span>
<span class="cm"> * @cat: LEB category</span>
<span class="cm"> *</span>
<span class="cm"> * Changed entries in a heap are moved up or down until the parent&#39;s value is</span>
<span class="cm"> * greater.  In the case of LPT&#39;s category heaps, the value is either the amount</span>
<span class="cm"> * of free space or the amount of dirty space, depending on the category.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">adjust_lpt_heap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lpt_heap</span> <span class="o">*</span><span class="n">heap</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hpos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">,</span> <span class="n">val3</span><span class="p">,</span> <span class="n">cpos</span><span class="p">;</span>

	<span class="n">val1</span> <span class="o">=</span> <span class="n">get_heap_comp_val</span><span class="p">(</span><span class="n">lprops</span><span class="p">,</span> <span class="n">cat</span><span class="p">);</span>
	<span class="cm">/* Compare to parent and, if greater than parent, move up the heap */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hpos</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ppos</span> <span class="o">=</span> <span class="p">(</span><span class="n">hpos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

		<span class="n">val2</span> <span class="o">=</span> <span class="n">get_heap_comp_val</span><span class="p">(</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">ppos</span><span class="p">],</span> <span class="n">cat</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val1</span> <span class="o">&gt;</span> <span class="n">val2</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Greater than parent so move up */</span>
			<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">ppos</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">hpos</span> <span class="o">=</span> <span class="n">hpos</span><span class="p">;</span>
				<span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">hpos</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">ppos</span><span class="p">];</span>
				<span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">ppos</span><span class="p">]</span> <span class="o">=</span> <span class="n">lprops</span><span class="p">;</span>
				<span class="n">lprops</span><span class="o">-&gt;</span><span class="n">hpos</span> <span class="o">=</span> <span class="n">ppos</span><span class="p">;</span>
				<span class="n">hpos</span> <span class="o">=</span> <span class="n">ppos</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hpos</span><span class="p">)</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="n">ppos</span> <span class="o">=</span> <span class="p">(</span><span class="n">hpos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
				<span class="n">val2</span> <span class="o">=</span> <span class="n">get_heap_comp_val</span><span class="p">(</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">ppos</span><span class="p">],</span> <span class="n">cat</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">val1</span> <span class="o">&lt;=</span> <span class="n">val2</span><span class="p">)</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="cm">/* Still greater than parent so keep going */</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Not greater than parent, so compare to children */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Compare to left child */</span>
		<span class="n">cpos</span> <span class="o">=</span> <span class="n">hpos</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpos</span> <span class="o">&gt;=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">val2</span> <span class="o">=</span> <span class="n">get_heap_comp_val</span><span class="p">(</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">cpos</span><span class="p">],</span> <span class="n">cat</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val1</span> <span class="o">&lt;</span> <span class="n">val2</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Less than left child, so promote biggest child */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpos</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">val3</span> <span class="o">=</span> <span class="n">get_heap_comp_val</span><span class="p">(</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">cpos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
							 <span class="n">cat</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">val3</span> <span class="o">&gt;</span> <span class="n">val2</span><span class="p">)</span>
					<span class="n">cpos</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Right child is bigger */</span>
			<span class="p">}</span>
			<span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">cpos</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">hpos</span> <span class="o">=</span> <span class="n">hpos</span><span class="p">;</span>
			<span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">hpos</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">cpos</span><span class="p">];</span>
			<span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">cpos</span><span class="p">]</span> <span class="o">=</span> <span class="n">lprops</span><span class="p">;</span>
			<span class="n">lprops</span><span class="o">-&gt;</span><span class="n">hpos</span> <span class="o">=</span> <span class="n">cpos</span><span class="p">;</span>
			<span class="n">hpos</span> <span class="o">=</span> <span class="n">cpos</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Compare to right child */</span>
		<span class="n">cpos</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpos</span> <span class="o">&gt;=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">val3</span> <span class="o">=</span> <span class="n">get_heap_comp_val</span><span class="p">(</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">cpos</span><span class="p">],</span> <span class="n">cat</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val1</span> <span class="o">&lt;</span> <span class="n">val3</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Less than right child, so promote right child */</span>
			<span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">cpos</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">hpos</span> <span class="o">=</span> <span class="n">hpos</span><span class="p">;</span>
			<span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">hpos</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">cpos</span><span class="p">];</span>
			<span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">cpos</span><span class="p">]</span> <span class="o">=</span> <span class="n">lprops</span><span class="p">;</span>
			<span class="n">lprops</span><span class="o">-&gt;</span><span class="n">hpos</span> <span class="o">=</span> <span class="n">cpos</span><span class="p">;</span>
			<span class="n">hpos</span> <span class="o">=</span> <span class="n">cpos</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * add_to_lpt_heap - add LEB properties to a LEB category heap.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lprops: LEB properties to add</span>
<span class="cm"> * @cat: LEB category</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %1 if @lprops is added to the heap for LEB category</span>
<span class="cm"> * @cat, otherwise %0 is returned because the heap is full.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_to_lpt_heap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">cat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_lpt_heap</span> <span class="o">*</span><span class="n">heap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_heap</span><span class="p">[</span><span class="n">cat</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">max_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">LPT_HEAP_SZ</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">cpos</span><span class="p">,</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">;</span>

		<span class="cm">/* Compare to some other LEB on the bottom of heap */</span>
		<span class="cm">/* Pick a position kind of randomly */</span>
		<span class="n">cpos</span> <span class="o">=</span> <span class="p">(((</span><span class="kt">size_t</span><span class="p">)</span><span class="n">lprops</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">cpos</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">);</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">cpos</span> <span class="o">&lt;</span> <span class="n">LPT_HEAP_SZ</span><span class="p">);</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">cpos</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">);</span>

		<span class="n">val1</span> <span class="o">=</span> <span class="n">get_heap_comp_val</span><span class="p">(</span><span class="n">lprops</span><span class="p">,</span> <span class="n">cat</span><span class="p">);</span>
		<span class="n">val2</span> <span class="o">=</span> <span class="n">get_heap_comp_val</span><span class="p">(</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">cpos</span><span class="p">],</span> <span class="n">cat</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val1</span> <span class="o">&gt;</span> <span class="n">val2</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>

			<span class="n">lp</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">cpos</span><span class="p">];</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPROPS_CAT_MASK</span><span class="p">;</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">LPROPS_UNCAT</span><span class="p">;</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">uncat_list</span><span class="p">);</span>
			<span class="n">lprops</span><span class="o">-&gt;</span><span class="n">hpos</span> <span class="o">=</span> <span class="n">cpos</span><span class="p">;</span>
			<span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">cpos</span><span class="p">]</span> <span class="o">=</span> <span class="n">lprops</span><span class="p">;</span>
			<span class="n">move_up_lpt_heap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">heap</span><span class="p">,</span> <span class="n">lprops</span><span class="p">,</span> <span class="n">cat</span><span class="p">);</span>
			<span class="n">dbg_check_heap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">heap</span><span class="p">,</span> <span class="n">cat</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">hpos</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Added to heap */</span>
		<span class="p">}</span>
		<span class="n">dbg_check_heap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">heap</span><span class="p">,</span> <span class="n">cat</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Not added to heap */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lprops</span><span class="o">-&gt;</span><span class="n">hpos</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">hpos</span><span class="p">]</span> <span class="o">=</span> <span class="n">lprops</span><span class="p">;</span>
		<span class="n">move_up_lpt_heap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">heap</span><span class="p">,</span> <span class="n">lprops</span><span class="p">,</span> <span class="n">cat</span><span class="p">);</span>
		<span class="n">dbg_check_heap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">heap</span><span class="p">,</span> <span class="n">cat</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">hpos</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Added to heap */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * remove_from_lpt_heap - remove LEB properties from a LEB category heap.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lprops: LEB properties to remove</span>
<span class="cm"> * @cat: LEB category</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_from_lpt_heap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_lpt_heap</span> <span class="o">*</span><span class="n">heap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hpos</span> <span class="o">=</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">hpos</span><span class="p">;</span>

	<span class="n">heap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_heap</span><span class="p">[</span><span class="n">cat</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">hpos</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">hpos</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">hpos</span><span class="p">]</span> <span class="o">==</span> <span class="n">lprops</span><span class="p">);</span>
	<span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hpos</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">hpos</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">];</span>
		<span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">hpos</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">hpos</span> <span class="o">=</span> <span class="n">hpos</span><span class="p">;</span>
		<span class="n">adjust_lpt_heap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">heap</span><span class="p">,</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">hpos</span><span class="p">],</span> <span class="n">hpos</span><span class="p">,</span> <span class="n">cat</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dbg_check_heap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">heap</span><span class="p">,</span> <span class="n">cat</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpt_heap_replace - replace lprops in a category heap.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @old_lprops: LEB properties to replace</span>
<span class="cm"> * @new_lprops: LEB properties with which to replace</span>
<span class="cm"> * @cat: LEB category</span>
<span class="cm"> *</span>
<span class="cm"> * During commit it is sometimes necessary to copy a pnode (see dirty_cow_pnode)</span>
<span class="cm"> * and the lprops that the pnode contains.  When that happens, references in</span>
<span class="cm"> * the category heaps to those lprops must be updated to point to the new</span>
<span class="cm"> * lprops.  This function does that.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lpt_heap_replace</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">old_lprops</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">new_lprops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_lpt_heap</span> <span class="o">*</span><span class="n">heap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hpos</span> <span class="o">=</span> <span class="n">new_lprops</span><span class="o">-&gt;</span><span class="n">hpos</span><span class="p">;</span>

	<span class="n">heap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_heap</span><span class="p">[</span><span class="n">cat</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">hpos</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_lprops</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_add_to_cat - add LEB properties to a category list or heap.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lprops: LEB properties to add</span>
<span class="cm"> * @cat: LEB category to which to add</span>
<span class="cm"> *</span>
<span class="cm"> * LEB properties are categorized to enable fast find operations.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubifs_add_to_cat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">cat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cat</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPROPS_DIRTY</span>:
	<span class="k">case</span> <span class="n">LPROPS_DIRTY_IDX</span>:
	<span class="k">case</span> <span class="n">LPROPS_FREE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">add_to_lpt_heap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lprops</span><span class="p">,</span> <span class="n">cat</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* No more room on heap so make it un-categorized */</span>
		<span class="n">cat</span> <span class="o">=</span> <span class="n">LPROPS_UNCAT</span><span class="p">;</span>
		<span class="cm">/* Fall through */</span>
	<span class="k">case</span> <span class="n">LPROPS_UNCAT</span>:
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">uncat_list</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPROPS_EMPTY</span>:
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">empty_list</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPROPS_FREEABLE</span>:
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_list</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPROPS_FRDI_IDX</span>:
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">frdi_idx_list</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPROPS_CAT_MASK</span><span class="p">;</span>
	<span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">cat</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_remove_from_cat - remove LEB properties from a category list or heap.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lprops: LEB properties to remove</span>
<span class="cm"> * @cat: LEB category from which to remove</span>
<span class="cm"> *</span>
<span class="cm"> * LEB properties are categorized to enable fast find operations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ubifs_remove_from_cat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cat</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPROPS_DIRTY</span>:
	<span class="k">case</span> <span class="n">LPROPS_DIRTY_IDX</span>:
	<span class="k">case</span> <span class="n">LPROPS_FREE</span>:
		<span class="n">remove_from_lpt_heap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lprops</span><span class="p">,</span> <span class="n">cat</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPROPS_FREEABLE</span>:
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_cnt</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* Fall through */</span>
	<span class="k">case</span> <span class="n">LPROPS_UNCAT</span>:
	<span class="k">case</span> <span class="n">LPROPS_EMPTY</span>:
	<span class="k">case</span> <span class="n">LPROPS_FRDI_IDX</span>:
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">));</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_replace_cat - replace lprops in a category list or heap.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @old_lprops: LEB properties to replace</span>
<span class="cm"> * @new_lprops: LEB properties with which to replace</span>
<span class="cm"> *</span>
<span class="cm"> * During commit it is sometimes necessary to copy a pnode (see dirty_cow_pnode)</span>
<span class="cm"> * and the lprops that the pnode contains. When that happens, references in</span>
<span class="cm"> * category lists and heaps must be replaced. This function does that.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubifs_replace_cat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">old_lprops</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">new_lprops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cat</span><span class="p">;</span>

	<span class="n">cat</span> <span class="o">=</span> <span class="n">new_lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_CAT_MASK</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cat</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPROPS_DIRTY</span>:
	<span class="k">case</span> <span class="n">LPROPS_DIRTY_IDX</span>:
	<span class="k">case</span> <span class="n">LPROPS_FREE</span>:
		<span class="n">lpt_heap_replace</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">old_lprops</span><span class="p">,</span> <span class="n">new_lprops</span><span class="p">,</span> <span class="n">cat</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPROPS_UNCAT</span>:
	<span class="k">case</span> <span class="n">LPROPS_EMPTY</span>:
	<span class="k">case</span> <span class="n">LPROPS_FREEABLE</span>:
	<span class="k">case</span> <span class="n">LPROPS_FRDI_IDX</span>:
		<span class="n">list_replace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_lprops</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_lprops</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_ensure_cat - ensure LEB properties are categorized.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lprops: LEB properties</span>
<span class="cm"> *</span>
<span class="cm"> * A LEB may have fallen off of the bottom of a heap, and ended up as</span>
<span class="cm"> * un-categorized even though it has enough space for us now. If that is the</span>
<span class="cm"> * case this function will put the LEB back onto a heap.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubifs_ensure_cat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cat</span> <span class="o">=</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_CAT_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cat</span> <span class="o">!=</span> <span class="n">LPROPS_UNCAT</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">cat</span> <span class="o">=</span> <span class="n">ubifs_categorize_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lprops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cat</span> <span class="o">==</span> <span class="n">LPROPS_UNCAT</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">ubifs_remove_from_cat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lprops</span><span class="p">,</span> <span class="n">LPROPS_UNCAT</span><span class="p">);</span>
	<span class="n">ubifs_add_to_cat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lprops</span><span class="p">,</span> <span class="n">cat</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_categorize_lprops - categorize LEB properties.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lprops: LEB properties to categorize</span>
<span class="cm"> *</span>
<span class="cm"> * LEB properties are categorized to enable fast find operations. This function</span>
<span class="cm"> * returns the LEB category to which the LEB properties belong. Note however</span>
<span class="cm"> * that if the LEB category is stored as a heap and the heap is full, the</span>
<span class="cm"> * LEB properties may have their category changed to %LPROPS_UNCAT.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_categorize_lprops</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">LPROPS_UNCAT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">LPROPS_EMPTY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">LPROPS_FRDI_IDX</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">LPROPS_FREEABLE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">+</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_idx_node_sz</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">LPROPS_DIRTY_IDX</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dead_wm</span> <span class="o">&amp;&amp;</span>
		    <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">&gt;</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">LPROPS_DIRTY</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">LPROPS_FREE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">LPROPS_UNCAT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * change_category - change LEB properties category.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lprops: LEB properties to re-categorize</span>
<span class="cm"> *</span>
<span class="cm"> * LEB properties are categorized to enable fast find operations. When the LEB</span>
<span class="cm"> * properties change they must be re-categorized.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">change_category</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">old_cat</span> <span class="o">=</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_CAT_MASK</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new_cat</span> <span class="o">=</span> <span class="n">ubifs_categorize_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lprops</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_cat</span> <span class="o">==</span> <span class="n">new_cat</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_lpt_heap</span> <span class="o">*</span><span class="n">heap</span><span class="p">;</span>

		<span class="cm">/* lprops on a heap now must be moved up or down */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_cat</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">new_cat</span> <span class="o">&gt;</span> <span class="n">LPROPS_HEAP_CNT</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span> <span class="cm">/* Not on a heap */</span>
		<span class="n">heap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_heap</span><span class="p">[</span><span class="n">new_cat</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
		<span class="n">adjust_lpt_heap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">heap</span><span class="p">,</span> <span class="n">lprops</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">hpos</span><span class="p">,</span> <span class="n">new_cat</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ubifs_remove_from_cat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lprops</span><span class="p">,</span> <span class="n">old_cat</span><span class="p">);</span>
		<span class="n">ubifs_add_to_cat</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lprops</span><span class="p">,</span> <span class="n">new_cat</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_calc_dark - calculate LEB dark space size.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @spc: amount of free and dirty space in the LEB</span>
<span class="cm"> *</span>
<span class="cm"> * This function calculates and returns amount of dark space in an LEB which</span>
<span class="cm"> * has @spc bytes of free and dirty space.</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS is trying to account the space which might not be usable, and this</span>
<span class="cm"> * space is called &quot;dark space&quot;. For example, if an LEB has only %512 free</span>
<span class="cm"> * bytes, it is dark space, because it cannot fit a large data node.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_calc_dark</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">spc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">spc</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spc</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dark_wm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">spc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have slightly more space then the dark space watermark, we can</span>
<span class="cm">	 * anyway safely assume it we&#39;ll be able to write a node of the</span>
<span class="cm">	 * smallest size there.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spc</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dark_wm</span> <span class="o">&lt;</span> <span class="n">MIN_WRITE_SZ</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">spc</span> <span class="o">-</span> <span class="n">MIN_WRITE_SZ</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dark_wm</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * is_lprops_dirty - determine if LEB properties are dirty.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @lprops: LEB properties to test</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_lprops_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_pnode</span> <span class="o">*</span><span class="n">pnode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_first</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UBIFS_LPT_FANOUT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">pnode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_pnode</span> <span class="o">*</span><span class="p">)</span><span class="n">container_of</span><span class="p">(</span><span class="n">lprops</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">ubifs_pnode</span><span class="p">,</span>
						   <span class="n">lprops</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">COW_CNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="n">test_bit</span><span class="p">(</span><span class="n">DIRTY_CNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_change_lp - change LEB properties.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @lp: LEB properties to change</span>
<span class="cm"> * @free: new free space amount</span>
<span class="cm"> * @dirty: new dirty space amount</span>
<span class="cm"> * @flags: new flags</span>
<span class="cm"> * @idx_gc_cnt: change to the count of @idx_gc list</span>
<span class="cm"> *</span>
<span class="cm"> * This function changes LEB properties (@free, @dirty or @flag). However, the</span>
<span class="cm"> * property which has the %LPROPS_NC value is not changed. Returns a pointer to</span>
<span class="cm"> * the updated LEB properties on success and a negative error code on failure.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, the LEB properties may have had to be copied (due to COW) and</span>
<span class="cm"> * consequently the pointer returned may not be the same as the pointer</span>
<span class="cm"> * passed.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="nf">ubifs_change_lp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lp</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">free</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dirty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">idx_gc_cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * This is the only function that is allowed to change lprops, so we</span>
<span class="cm">	 * discard the &quot;const&quot; qualifier.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="p">)</span><span class="n">lp</span><span class="p">;</span>

	<span class="n">dbg_lp</span><span class="p">(</span><span class="s">&quot;LEB %d, free %d, dirty %d, flags %d&quot;</span><span class="p">,</span>
	       <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">dirty</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">empty_lebs</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		     <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">empty_lebs</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_lebs</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_cnt</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_cnt</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_lebs</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">taken_empty_lebs</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">taken_empty_lebs</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">empty_lebs</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_free</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_dirty</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_dead</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_dark</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_used</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">free</span> <span class="o">==</span> <span class="n">LPROPS_NC</span> <span class="o">||</span> <span class="n">free</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">dirty</span> <span class="o">==</span> <span class="n">LPROPS_NC</span> <span class="o">||</span> <span class="n">dirty</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_lprops_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lprops</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lprops</span> <span class="o">=</span> <span class="n">ubifs_lpt_lookup_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lprops</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">lprops</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lprops</span> <span class="o">==</span> <span class="n">ubifs_lpt_lookup_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">));</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">));</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">taken_empty_lebs</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">old_spc</span><span class="p">;</span>

		<span class="n">old_spc</span> <span class="o">=</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_spc</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dead_wm</span><span class="p">)</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_dead</span> <span class="o">-=</span> <span class="n">old_spc</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_dark</span> <span class="o">-=</span> <span class="n">ubifs_calc_dark</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">old_spc</span><span class="p">);</span>

		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_used</span> <span class="o">-=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">old_spc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">!=</span> <span class="n">LPROPS_NC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">free</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_free</span> <span class="o">+=</span> <span class="n">free</span> <span class="o">-</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">;</span>

		<span class="cm">/* Increase or decrease empty LEBs counter if needed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">empty_lebs</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">empty_lebs</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="n">free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dirty</span> <span class="o">!=</span> <span class="n">LPROPS_NC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dirty</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">dirty</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_dirty</span> <span class="o">+=</span> <span class="n">dirty</span> <span class="o">-</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">;</span>
		<span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">=</span> <span class="n">dirty</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">!=</span> <span class="n">LPROPS_NC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Take care about indexing LEBs counter if needed */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">))</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">idx_lebs</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">)</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">idx_lebs</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">new_spc</span><span class="p">;</span>

		<span class="n">new_spc</span> <span class="o">=</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_spc</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dead_wm</span><span class="p">)</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_dead</span> <span class="o">+=</span> <span class="n">new_spc</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_dark</span> <span class="o">+=</span> <span class="n">ubifs_calc_dark</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">new_spc</span><span class="p">);</span>

		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_used</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">new_spc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">taken_empty_lebs</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">change_category</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lprops</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_gc_cnt</span> <span class="o">+=</span> <span class="n">idx_gc_cnt</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">lprops</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_get_lp_stats - get lprops statistics.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @st: return statistics</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubifs_get_lp_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lp_stats</span> <span class="o">*</span><span class="n">lst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_lp_stats</span><span class="p">));</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_change_one_lp - change LEB properties.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB to change properties for</span>
<span class="cm"> * @free: amount of free space</span>
<span class="cm"> * @dirty: amount of dirty space</span>
<span class="cm"> * @flags_set: flags to set</span>
<span class="cm"> * @flags_clean: flags to clean</span>
<span class="cm"> * @idx_gc_cnt: change to the count of idx_gc list</span>
<span class="cm"> *</span>
<span class="cm"> * This function changes properties of LEB @lnum. It is a helper wrapper over</span>
<span class="cm"> * &#39;ubifs_change_lp()&#39; which hides lprops get/release. The arguments are the</span>
<span class="cm"> * same as in case of &#39;ubifs_change_lp()&#39;. Returns zero in case of success and</span>
<span class="cm"> * a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_change_one_lp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">free</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dirty</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">flags_set</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags_clean</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx_gc_cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>

	<span class="n">ubifs_get_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">lp</span> <span class="o">=</span> <span class="n">ubifs_lpt_lookup_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|</span> <span class="n">flags_set</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">flags_clean</span><span class="p">;</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="n">ubifs_change_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lp</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">dirty</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">idx_gc_cnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">ubifs_release_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot change properties of LEB %d, error %d&quot;</span><span class="p">,</span>
			  <span class="n">lnum</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_update_one_lp - update LEB properties.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB to change properties for</span>
<span class="cm"> * @free: amount of free space</span>
<span class="cm"> * @dirty: amount of dirty space to add</span>
<span class="cm"> * @flags_set: flags to set</span>
<span class="cm"> * @flags_clean: flags to clean</span>
<span class="cm"> *</span>
<span class="cm"> * This function is the same as &#39;ubifs_change_one_lp()&#39; but @dirty is added to</span>
<span class="cm"> * current dirty space, not substitutes it.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_update_one_lp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">free</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dirty</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">flags_set</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags_clean</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>

	<span class="n">ubifs_get_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">lp</span> <span class="o">=</span> <span class="n">ubifs_lpt_lookup_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|</span> <span class="n">flags_set</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">flags_clean</span><span class="p">;</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="n">ubifs_change_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lp</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">+</span> <span class="n">dirty</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">ubifs_release_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot update properties of LEB %d, error %d&quot;</span><span class="p">,</span>
			  <span class="n">lnum</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_read_one_lp - read LEB properties.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB to read properties for</span>
<span class="cm"> * @lp: where to store read properties</span>
<span class="cm"> *</span>
<span class="cm"> * This helper function reads properties of a LEB @lnum and stores them in @lp.</span>
<span class="cm"> * Returns zero in case of success and a negative error code in case of</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_read_one_lp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lpp</span><span class="p">;</span>

	<span class="n">ubifs_get_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">lpp</span> <span class="o">=</span> <span class="n">ubifs_lpt_lookup</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lpp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lpp</span><span class="p">);</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot read properties of LEB %d, error %d&quot;</span><span class="p">,</span>
			  <span class="n">lnum</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">lpp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_lprops</span><span class="p">));</span>

<span class="nl">out:</span>
	<span class="n">ubifs_release_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_fast_find_free - try to find a LEB with free space quickly.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns LEB properties for a LEB with free space or %NULL if</span>
<span class="cm"> * the function is unable to find a LEB quickly.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="nf">ubifs_fast_find_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_lpt_heap</span> <span class="o">*</span><span class="n">heap</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">));</span>

	<span class="n">heap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_heap</span><span class="p">[</span><span class="n">LPROPS_FREE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">lprops</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">lprops</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_fast_find_empty - try to find an empty LEB quickly.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns LEB properties for an empty LEB or %NULL if the</span>
<span class="cm"> * function is unable to find an empty LEB quickly.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="nf">ubifs_fast_find_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">empty_list</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">lprops</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">empty_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">lprops</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_fast_find_freeable - try to find a freeable LEB quickly.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns LEB properties for a freeable LEB or %NULL if the</span>
<span class="cm"> * function is unable to find a freeable LEB quickly.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="nf">ubifs_fast_find_freeable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_list</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">lprops</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">lprops</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_fast_find_frdi_idx - try to find a freeable index LEB quickly.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns LEB properties for a freeable index LEB or %NULL if the</span>
<span class="cm"> * function is unable to find a freeable index LEB quickly.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="nf">ubifs_fast_find_frdi_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">frdi_idx_list</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">lprops</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">frdi_idx_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">((</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">lprops</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Everything below is related to debugging.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_check_cats - check category heaps and lists.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbg_check_cats</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">cat</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_chk_gen</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dbg_is_chk_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lprops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">empty_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;non-empty LEB %d on empty list &quot;</span>
				  <span class="s">&quot;(free %d dirty %d flags %d)&quot;</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span>
				  <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;taken LEB %d on empty list &quot;</span>
				  <span class="s">&quot;(free %d dirty %d flags %d)&quot;</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span>
				  <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lprops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;non-freeable LEB %d on freeable list &quot;</span>
				  <span class="s">&quot;(free %d dirty %d flags %d)&quot;</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span>
				  <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;taken LEB %d on freeable list &quot;</span>
				  <span class="s">&quot;(free %d dirty %d flags %d)&quot;</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span>
				  <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;freeable list count %d expected %d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
			  <span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_cnt</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_gc</span><span class="p">)</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_gc_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;idx_gc list count %d expected %d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
			  <span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_gc_cnt</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lprops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">frdi_idx_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;non-freeable LEB %d on frdi_idx list &quot;</span>
				  <span class="s">&quot;(free %d dirty %d flags %d)&quot;</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span>
				  <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;taken LEB %d on frdi_idx list &quot;</span>
				  <span class="s">&quot;(free %d dirty %d flags %d)&quot;</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span>
				  <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;non-index LEB %d on frdi_idx list &quot;</span>
				  <span class="s">&quot;(free %d dirty %d flags %d)&quot;</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span>
				  <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">cat</span> <span class="o">&lt;=</span> <span class="n">LPROPS_HEAP_CNT</span><span class="p">;</span> <span class="n">cat</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_lpt_heap</span> <span class="o">*</span><span class="n">heap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_heap</span><span class="p">[</span><span class="n">cat</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lprops</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lprops</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;null ptr in LPT heap cat %d&quot;</span><span class="p">,</span> <span class="n">cat</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">hpos</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad ptr in LPT heap cat %d&quot;</span><span class="p">,</span> <span class="n">cat</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;taken LEB in LPT heap cat %d&quot;</span><span class="p">,</span> <span class="n">cat</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dbg_check_heap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lpt_heap</span> <span class="o">*</span><span class="n">heap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cat</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">add_pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_chk_gen</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dbg_is_chk_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">add_pos</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_CAT_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">cat</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">hpos</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lp</span> <span class="o">=</span> <span class="n">ubifs_lpt_lookup</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span> <span class="o">!=</span> <span class="n">lp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;lprops %zx lp %zx lprops-&gt;lnum %d lp-&gt;lnum %d&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">lprops</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">lp</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span>
				<span class="n">lp</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lp</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span> <span class="o">==</span> <span class="n">lprops</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;failed cat %d hpos %d err %d&quot;</span><span class="p">,</span> <span class="n">cat</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="n">ubifs_dump_heap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">heap</span><span class="p">,</span> <span class="n">cat</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * scan_check_cb - scan callback.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @lp: LEB properties to scan</span>
<span class="cm"> * @in_tree: whether the LEB properties are in main memory</span>
<span class="cm"> * @lst: lprops statistics to update</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns a code that indicates whether the scan should continue</span>
<span class="cm"> * (%LPT_SCAN_CONTINUE), whether the LEB properties should be added to the tree</span>
<span class="cm"> * in main memory (%LPT_SCAN_ADD), or whether the scan should stop</span>
<span class="cm"> * (%LPT_SCAN_STOP).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">scan_check_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">in_tree</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ubifs_lp_stats</span> <span class="o">*</span><span class="n">lst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">sleb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_scan_node</span> <span class="o">*</span><span class="n">snod</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cat</span><span class="p">,</span> <span class="n">lnum</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">is_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">dirty</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">cat</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_CAT_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cat</span> <span class="o">!=</span> <span class="n">LPROPS_UNCAT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cat</span> <span class="o">=</span> <span class="n">ubifs_categorize_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cat</span> <span class="o">!=</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_CAT_MASK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad LEB category %d expected %d&quot;</span><span class="p">,</span>
				  <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_CAT_MASK</span><span class="p">),</span> <span class="n">cat</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Check lp is on its category list (if it has one) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_tree</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">cat</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">LPROPS_EMPTY</span>:
			<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">empty_list</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPROPS_FREEABLE</span>:
			<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_list</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPROPS_FRDI_IDX</span>:
			<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">frdi_idx_list</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPROPS_UNCAT</span>:
			<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">uncat_list</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lprops</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span> <span class="o">==</span> <span class="n">lp</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad LPT list (category %d)&quot;</span><span class="p">,</span> <span class="n">cat</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Check lp is on its category heap (if it has one) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_tree</span> <span class="o">&amp;&amp;</span> <span class="n">cat</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cat</span> <span class="o">&lt;=</span> <span class="n">LPROPS_HEAP_CNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_lpt_heap</span> <span class="o">*</span><span class="n">heap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_heap</span><span class="p">[</span><span class="n">cat</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">hpos</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">hpos</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">!=</span> <span class="n">lnum</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">lp</span> <span class="o">!=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">hpos</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad LPT heap (category %d)&quot;</span><span class="p">,</span> <span class="n">cat</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">__vmalloc</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">,</span> <span class="n">PAGE_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * After an unclean unmount, empty and freeable LEBs</span>
<span class="cm">	 * may contain garbage - do not scan them.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lst</span><span class="o">-&gt;</span><span class="n">empty_lebs</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">lst</span><span class="o">-&gt;</span><span class="n">total_free</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">;</span>
		<span class="n">lst</span><span class="o">-&gt;</span><span class="n">total_dark</span> <span class="o">+=</span> <span class="n">ubifs_calc_dark</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">LPT_SCAN_CONTINUE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lst</span><span class="o">-&gt;</span><span class="n">total_free</span>  <span class="o">+=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">;</span>
		<span class="n">lst</span><span class="o">-&gt;</span><span class="n">total_dirty</span> <span class="o">+=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">;</span>
		<span class="n">lst</span><span class="o">-&gt;</span><span class="n">total_dark</span>  <span class="o">+=</span>  <span class="n">ubifs_calc_dark</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">LPT_SCAN_CONTINUE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sleb</span> <span class="o">=</span> <span class="n">ubifs_scan</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sleb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EUCLEAN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_dump_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="n">ubifs_dump_budg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">is_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">snod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">found</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">is_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_IDX_NODE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_idx</span> <span class="o">&amp;&amp;</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">UBIFS_IDX_NODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;indexing node in data LEB %d:%d&quot;</span><span class="p">,</span>
				  <span class="n">lnum</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_destroy</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_IDX_NODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ubifs_idx_node</span> <span class="o">*</span><span class="n">idx</span> <span class="o">=</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>

			<span class="n">key_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ubifs_idx_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
			<span class="n">level</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">idx</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">found</span> <span class="o">=</span> <span class="n">ubifs_tnc_has_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span>
					   <span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">is_idx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_destroy</span><span class="p">;</span>
			<span class="n">used</span> <span class="o">+=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">free</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">endpt</span><span class="p">;</span>
	<span class="n">dirty</span> <span class="o">=</span> <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">endpt</span> <span class="o">-</span> <span class="n">used</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">||</span> <span class="n">free</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">dirty</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">||</span>
	    <span class="n">dirty</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad calculated accounting for LEB %d: &quot;</span>
			  <span class="s">&quot;free %d, dirty %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">dirty</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_destroy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">&amp;&amp;</span>
	    <span class="n">free</span> <span class="o">+</span> <span class="n">dirty</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">is_idx</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">))</span> <span class="o">||</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">is_idx</span> <span class="o">&amp;&amp;</span> <span class="n">free</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Empty or freeable LEBs could contain index</span>
<span class="cm">			 * nodes from an uncompleted commit due to an</span>
<span class="cm">			 * unclean unmount. Or they could be empty for</span>
<span class="cm">			 * the same reason. Or it may simply not have been</span>
<span class="cm">			 * unmapped.</span>
<span class="cm">			 */</span>
			<span class="n">free</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">;</span>
			<span class="n">dirty</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">;</span>
			<span class="n">is_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		    <span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_idx</span> <span class="o">&amp;&amp;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">==</span> <span class="n">free</span> <span class="o">+</span> <span class="n">dirty</span> <span class="o">&amp;&amp;</span>
	    <span class="n">lnum</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ihead_lnum</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * After an unclean unmount, an index LEB could have a different</span>
<span class="cm">		 * amount of free space than the value recorded by lprops. That</span>
<span class="cm">		 * is because the in-the-gaps method may use free space or</span>
<span class="cm">		 * create free space (as a side-effect of using ubi_leb_change</span>
<span class="cm">		 * and not writing the whole LEB). The incorrect free space</span>
<span class="cm">		 * value is not a problem because the index is only ever</span>
<span class="cm">		 * allocated empty LEBs, so there will never be an attempt to</span>
<span class="cm">		 * write to the free space at the end of an index LEB - except</span>
<span class="cm">		 * by the in-the-gaps method for which it is not a problem.</span>
<span class="cm">		 */</span>
		<span class="n">free</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">;</span>
		<span class="n">dirty</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">!=</span> <span class="n">free</span> <span class="o">||</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">!=</span> <span class="n">dirty</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_print</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_idx</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span>
			<span class="cm">/* Free but not unmapped LEB, it&#39;s fine */</span>
			<span class="n">is_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;indexing node without indexing &quot;</span>
				  <span class="s">&quot;flag&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_print</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_idx</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;data node with indexing flag&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_print</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span>
		<span class="n">lst</span><span class="o">-&gt;</span><span class="n">empty_lebs</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_idx</span><span class="p">)</span>
		<span class="n">lst</span><span class="o">-&gt;</span><span class="n">idx_lebs</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">))</span>
		<span class="n">lst</span><span class="o">-&gt;</span><span class="n">total_used</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">free</span> <span class="o">-</span> <span class="n">dirty</span><span class="p">;</span>
	<span class="n">lst</span><span class="o">-&gt;</span><span class="n">total_free</span> <span class="o">+=</span> <span class="n">free</span><span class="p">;</span>
	<span class="n">lst</span><span class="o">-&gt;</span><span class="n">total_dirty</span> <span class="o">+=</span> <span class="n">dirty</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">spc</span> <span class="o">=</span> <span class="n">free</span> <span class="o">+</span> <span class="n">dirty</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">spc</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dead_wm</span><span class="p">)</span>
			<span class="n">lst</span><span class="o">-&gt;</span><span class="n">total_dead</span> <span class="o">+=</span> <span class="n">spc</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">lst</span><span class="o">-&gt;</span><span class="n">total_dark</span> <span class="o">+=</span> <span class="n">ubifs_calc_dark</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">spc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ubifs_scan_destroy</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">LPT_SCAN_CONTINUE</span><span class="p">;</span>

<span class="nl">out_print:</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad accounting of LEB %d: free %d, dirty %d flags %#x, &quot;</span>
		  <span class="s">&quot;should be free %d, dirty %d&quot;</span><span class="p">,</span>
		  <span class="n">lnum</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">dirty</span><span class="p">);</span>
	<span class="n">ubifs_dump_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
<span class="nl">out_destroy:</span>
	<span class="n">ubifs_scan_destroy</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_check_lprops - check all LEB properties.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks all LEB properties and makes sure they are all correct.</span>
<span class="cm"> * It returns zero if everything is fine, %-EINVAL if there is an inconsistency</span>
<span class="cm"> * and other negative error codes in case of other errors. This function is</span>
<span class="cm"> * called while the file system is locked (because of commit start), so no</span>
<span class="cm"> * additional locking is required. Note that locking the LPT mutex would cause</span>
<span class="cm"> * a circular lock dependency with the TNC mutex.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbg_check_lprops</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_lp_stats</span> <span class="n">lst</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_chk_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * As we are going to scan the media, the write buffers have to be</span>
<span class="cm">	 * synchronized.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_wbuf_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wbuf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lst</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_lp_stats</span><span class="p">));</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_lpt_scan_nolock</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_first</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
				    <span class="p">(</span><span class="n">ubifs_lpt_scan_callback</span><span class="p">)</span><span class="n">scan_check_cb</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">lst</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lst</span><span class="p">.</span><span class="n">empty_lebs</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">empty_lebs</span> <span class="o">||</span>
	    <span class="n">lst</span><span class="p">.</span><span class="n">idx_lebs</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">idx_lebs</span> <span class="o">||</span>
	    <span class="n">lst</span><span class="p">.</span><span class="n">total_free</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_free</span> <span class="o">||</span>
	    <span class="n">lst</span><span class="p">.</span><span class="n">total_dirty</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_dirty</span> <span class="o">||</span>
	    <span class="n">lst</span><span class="p">.</span><span class="n">total_used</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_used</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad overall accounting&quot;</span><span class="p">);</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;calculated: empty_lebs %d, idx_lebs %d, &quot;</span>
			  <span class="s">&quot;total_free %lld, total_dirty %lld, total_used %lld&quot;</span><span class="p">,</span>
			  <span class="n">lst</span><span class="p">.</span><span class="n">empty_lebs</span><span class="p">,</span> <span class="n">lst</span><span class="p">.</span><span class="n">idx_lebs</span><span class="p">,</span> <span class="n">lst</span><span class="p">.</span><span class="n">total_free</span><span class="p">,</span>
			  <span class="n">lst</span><span class="p">.</span><span class="n">total_dirty</span><span class="p">,</span> <span class="n">lst</span><span class="p">.</span><span class="n">total_used</span><span class="p">);</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;read from lprops: empty_lebs %d, idx_lebs %d, &quot;</span>
			  <span class="s">&quot;total_free %lld, total_dirty %lld, total_used %lld&quot;</span><span class="p">,</span>
			  <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">empty_lebs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">idx_lebs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_free</span><span class="p">,</span>
			  <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_dirty</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_used</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lst</span><span class="p">.</span><span class="n">total_dead</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_dead</span> <span class="o">||</span>
	    <span class="n">lst</span><span class="p">.</span><span class="n">total_dark</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_dark</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad dead/dark space accounting&quot;</span><span class="p">);</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;calculated: total_dead %lld, total_dark %lld&quot;</span><span class="p">,</span>
			  <span class="n">lst</span><span class="p">.</span><span class="n">total_dead</span><span class="p">,</span> <span class="n">lst</span><span class="p">.</span><span class="n">total_dark</span><span class="p">);</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;read from lprops: total_dead %lld, total_dark %lld&quot;</span><span class="p">,</span>
			  <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_dead</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_dark</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_cats</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
