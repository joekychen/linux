<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ubifs › orphan.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>orphan.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is part of UBIFS.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Nokia Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="cm"> * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Adrian Hunter</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;ubifs.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * An orphan is an inode number whose inode node has been committed to the index</span>
<span class="cm"> * with a link count of zero. That happens when an open file is deleted</span>
<span class="cm"> * (unlinked) and then a commit is run. In the normal course of events the inode</span>
<span class="cm"> * would be deleted when the file is closed. However in the case of an unclean</span>
<span class="cm"> * unmount, orphans need to be accounted for. After an unclean unmount, the</span>
<span class="cm"> * orphans&#39; inodes must be deleted which means either scanning the entire index</span>
<span class="cm"> * looking for them, or keeping a list on flash somewhere. This unit implements</span>
<span class="cm"> * the latter approach.</span>
<span class="cm"> *</span>
<span class="cm"> * The orphan area is a fixed number of LEBs situated between the LPT area and</span>
<span class="cm"> * the main area. The number of orphan area LEBs is specified when the file</span>
<span class="cm"> * system is created. The minimum number is 1. The size of the orphan area</span>
<span class="cm"> * should be so that it can hold the maximum number of orphans that are expected</span>
<span class="cm"> * to ever exist at one time.</span>
<span class="cm"> *</span>
<span class="cm"> * The number of orphans that can fit in a LEB is:</span>
<span class="cm"> *</span>
<span class="cm"> *         (c-&gt;leb_size - UBIFS_ORPH_NODE_SZ) / sizeof(__le64)</span>
<span class="cm"> *</span>
<span class="cm"> * For example: a 15872 byte LEB can fit 1980 orphans so 1 LEB may be enough.</span>
<span class="cm"> *</span>
<span class="cm"> * Orphans are accumulated in a rb-tree. When an inode&#39;s link count drops to</span>
<span class="cm"> * zero, the inode number is added to the rb-tree. It is removed from the tree</span>
<span class="cm"> * when the inode is deleted.  Any new orphans that are in the orphan tree when</span>
<span class="cm"> * the commit is run, are written to the orphan area in 1 or more orphan nodes.</span>
<span class="cm"> * If the orphan area is full, it is consolidated to make space.  There is</span>
<span class="cm"> * always enough space because validation prevents the user from creating more</span>
<span class="cm"> * than the maximum number of orphans allowed.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">dbg_check_orphans</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_add_orphan - add an orphan.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @inum: orphan inode number</span>
<span class="cm"> *</span>
<span class="cm"> * Add an orphan. This function is called when an inodes link count drops to</span>
<span class="cm"> * zero.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_add_orphan</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">inum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_orphan</span> <span class="o">*</span><span class="n">orphan</span><span class="p">,</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">orphan</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_orphan</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orphan</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">orphan</span><span class="o">-&gt;</span><span class="n">inum</span> <span class="o">=</span> <span class="n">inum</span><span class="p">;</span>
	<span class="n">orphan</span><span class="o">-&gt;</span><span class="n">new</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tot_orphans</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_orphans</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">orphan</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENFILE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">o</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_orphan</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">&lt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">&gt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;orphaned twice&quot;</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">orphan</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">tot_orphans</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">new_orphans</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orphan</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orphan</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_tree</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orphan</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_list</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orphan</span><span class="o">-&gt;</span><span class="n">new_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_new</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;ino %lu&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inum</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_delete_orphan - delete an orphan.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @inum: orphan inode number</span>
<span class="cm"> *</span>
<span class="cm"> * Delete an orphan. This function is called when an inode is deleted.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubifs_delete_orphan</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">inum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_orphan</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">o</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_orphan</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">&lt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">&gt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">dnext</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
				<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;deleted twice ino %lu&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inum</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">o</span><span class="o">-&gt;</span><span class="n">dnext</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_dnext</span><span class="p">;</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_dnext</span> <span class="o">=</span> <span class="n">o</span><span class="p">;</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
				<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;delete later ino %lu&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inum</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">rb_erase</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_tree</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">tot_orphans</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">new_list</span><span class="p">);</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">new_orphans</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
			<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;inum %lu&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inum</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;missing orphan ino %lu&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inum</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_orphan_start_commit - start commit of orphans.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * Start commit of orphans.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_orphan_start_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_orphan</span> <span class="o">*</span><span class="n">orphan</span><span class="p">,</span> <span class="o">**</span><span class="n">last</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
	<span class="n">last</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_cnext</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">orphan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_new</span><span class="p">,</span> <span class="n">new_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">orphan</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">);</span>
		<span class="n">orphan</span><span class="o">-&gt;</span><span class="n">new</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">orphan</span><span class="p">;</span>
		<span class="n">last</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">orphan</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">orphan</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_orphans</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">new_orphans</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">new_orphans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;%d orphans to commit&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_orphans</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_new</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tot_orphans</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">no_orphs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">no_orphs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * avail_orphs - calculate available space.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the number of orphans that can be written in the</span>
<span class="cm"> * available space.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">avail_orphs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">avail_lebs</span><span class="p">,</span> <span class="n">avail</span><span class="p">,</span> <span class="n">gap</span><span class="p">;</span>

	<span class="n">avail_lebs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_lebs</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_lnum</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_first</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">avail</span> <span class="o">=</span> <span class="n">avail_lebs</span> <span class="o">*</span>
	       <span class="p">((</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">UBIFS_ORPH_NODE_SZ</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__le64</span><span class="p">));</span>
	<span class="n">gap</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_offs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gap</span> <span class="o">&gt;=</span> <span class="n">UBIFS_ORPH_NODE_SZ</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__le64</span><span class="p">))</span>
		<span class="n">avail</span> <span class="o">+=</span> <span class="p">(</span><span class="n">gap</span> <span class="o">-</span> <span class="n">UBIFS_ORPH_NODE_SZ</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__le64</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">avail</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tot_avail_orphs - calculate total space.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the number of orphans that can be written in half</span>
<span class="cm"> * the total space. That leaves half the space for adding new orphans.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tot_avail_orphs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">avail_lebs</span><span class="p">,</span> <span class="n">avail</span><span class="p">;</span>

	<span class="n">avail_lebs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_lebs</span><span class="p">;</span>
	<span class="n">avail</span> <span class="o">=</span> <span class="n">avail_lebs</span> <span class="o">*</span>
	       <span class="p">((</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">UBIFS_ORPH_NODE_SZ</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__le64</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">avail</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * do_write_orph_node - write a node to the orphan head.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @len: length of node</span>
<span class="cm"> * @atomic: write atomically</span>
<span class="cm"> *</span>
<span class="cm"> * This function writes a node to the orphan head from the orphan buffer. If</span>
<span class="cm"> * %atomic is not zero, then the write is done atomically. On success, %0 is</span>
<span class="cm"> * returned, otherwise a negative error code is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_write_orph_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">atomic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_offs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ubifs_prepare_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_change</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_offs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Ensure LEB has been unmapped */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_lnum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_write_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_lnum</span><span class="p">,</span>
				       <span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_offs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * write_orph_node - write an orphan node.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @atomic: write atomically</span>
<span class="cm"> *</span>
<span class="cm"> * This function builds an orphan node from the cnext list and writes it to the</span>
<span class="cm"> * orphan head. On success, %0 is returned, otherwise a negative error code</span>
<span class="cm"> * is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_orph_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">atomic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_orphan</span> <span class="o">*</span><span class="n">orphan</span><span class="p">,</span> <span class="o">*</span><span class="n">cnext</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_orph_node</span> <span class="o">*</span><span class="n">orph</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">gap</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_orphans</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">gap</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_offs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gap</span> <span class="o">&lt;</span> <span class="n">UBIFS_ORPH_NODE_SZ</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__le64</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_lnum</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_offs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">gap</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_lnum</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_last</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We limit the number of orphans so that this should</span>
<span class="cm">			 * never happen.</span>
<span class="cm">			 */</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;out of space in orphan area&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">cnt</span> <span class="o">=</span> <span class="p">(</span><span class="n">gap</span> <span class="o">-</span> <span class="n">UBIFS_ORPH_NODE_SZ</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__le64</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_orphans</span><span class="p">)</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_orphans</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">UBIFS_ORPH_NODE_SZ</span> <span class="o">+</span> <span class="n">cnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__le64</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_buf</span><span class="p">);</span>
	<span class="n">orph</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_buf</span><span class="p">;</span>
	<span class="n">orph</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">node_type</span> <span class="o">=</span> <span class="n">UBIFS_ORPH_NODE</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
	<span class="n">cnext</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_cnext</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">orphan</span> <span class="o">=</span> <span class="n">cnext</span><span class="p">;</span>
		<span class="n">orph</span><span class="o">-&gt;</span><span class="n">inos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">orphan</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">);</span>
		<span class="n">cnext</span> <span class="o">=</span> <span class="n">orphan</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">;</span>
		<span class="n">orphan</span><span class="o">-&gt;</span><span class="n">cnext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_cnext</span> <span class="o">=</span> <span class="n">cnext</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_orphans</span> <span class="o">-=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_orphans</span><span class="p">)</span>
		<span class="n">orph</span><span class="o">-&gt;</span><span class="n">cmt_no</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_no</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="cm">/* Mark the last node of the commit */</span>
		<span class="n">orph</span><span class="o">-&gt;</span><span class="n">cmt_no</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">((</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_no</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_offs</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_lnum</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_first</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_lnum</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_last</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">do_write_orph_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">atomic</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_offs</span> <span class="o">+=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_offs</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_offs</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * write_orph_nodes - write orphan nodes until there are no more to commit.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @atomic: write atomically</span>
<span class="cm"> *</span>
<span class="cm"> * This function writes orphan nodes for all the orphans to commit. On success,</span>
<span class="cm"> * %0 is returned, otherwise a negative error code is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_orph_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">atomic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_orphans</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">write_orph_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">atomic</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">lnum</span><span class="p">;</span>

		<span class="cm">/* Unmap any unused LEBs after consolidation */</span>
		<span class="n">lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_lnum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_lnum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">lnum</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_last</span><span class="p">;</span> <span class="n">lnum</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * consolidate - consolidate the orphan area.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function enables consolidation by putting all the orphans into the list</span>
<span class="cm"> * to commit. The list is in the order that the orphans were added, and the</span>
<span class="cm"> * LEBs are written atomically in order, so at no time can orphans be lost by</span>
<span class="cm"> * an unclean unmount.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">consolidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tot_avail</span> <span class="o">=</span> <span class="n">tot_avail_orphs</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
	<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;there is space for %d orphans and there are %d&quot;</span><span class="p">,</span>
		<span class="n">tot_avail</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">tot_orphans</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tot_orphans</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">new_orphans</span> <span class="o">&lt;=</span> <span class="n">tot_avail</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_orphan</span> <span class="o">*</span><span class="n">orphan</span><span class="p">,</span> <span class="o">**</span><span class="n">last</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Change the cnext list to include all non-new orphans */</span>
		<span class="n">last</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_cnext</span><span class="p">;</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">orphan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">orphan</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">orphan</span><span class="p">;</span>
			<span class="n">last</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">orphan</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">;</span>
			<span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">orphan</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">;</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">tot_orphans</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">new_orphans</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_orphans</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_first</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_offs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We limit the number of orphans so that this should</span>
<span class="cm">		 * never happen.</span>
<span class="cm">		 */</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;out of space in orphan area&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * commit_orphans - commit orphans.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function commits orphans to flash. On success, %0 is returned,</span>
<span class="cm"> * otherwise a negative error code is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">commit_orphans</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">avail</span><span class="p">,</span> <span class="n">atomic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_orphans</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">avail</span> <span class="o">=</span> <span class="n">avail_orphs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">avail</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_orphans</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Not enough space to write new orphans, so consolidate */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">consolidate</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">atomic</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">write_orph_nodes</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">atomic</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * erase_deleted - erase the orphans marked for deletion.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * During commit, the orphans being committed cannot be deleted, so they are</span>
<span class="cm"> * marked for deletion and deleted by this function. Also, the recovery</span>
<span class="cm"> * adds killed orphans to the deletion list, and therefore they are deleted</span>
<span class="cm"> * here too.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">erase_deleted</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_orphan</span> <span class="o">*</span><span class="n">orphan</span><span class="p">,</span> <span class="o">*</span><span class="n">dnext</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
	<span class="n">dnext</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_dnext</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">dnext</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">orphan</span> <span class="o">=</span> <span class="n">dnext</span><span class="p">;</span>
		<span class="n">dnext</span> <span class="o">=</span> <span class="n">orphan</span><span class="o">-&gt;</span><span class="n">dnext</span><span class="p">;</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">orphan</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">);</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orphan</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_tree</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orphan</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">tot_orphans</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;deleting orphan ino %lu&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">orphan</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">orphan</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_dnext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_orphan_end_commit - end commit of orphans.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * End commit of orphans.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_orphan_end_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_orphans</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">commit_orphans</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">erase_deleted</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_orphans</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_clear_orphans - erase all LEBs used for orphans.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * If recovery is not required, then the orphans from the previous session</span>
<span class="cm"> * are not needed. This function locates the LEBs used to record</span>
<span class="cm"> * orphans, and un-maps them.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_clear_orphans</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_first</span><span class="p">;</span> <span class="n">lnum</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_last</span><span class="p">;</span> <span class="n">lnum</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_first</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_offs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * insert_dead_orphan - insert an orphan.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @inum: orphan inode number</span>
<span class="cm"> *</span>
<span class="cm"> * This function is a helper to the &#39;do_kill_orphans()&#39; function. The orphan</span>
<span class="cm"> * must be kept until the next commit, so it is added to the rb-tree and the</span>
<span class="cm"> * deletion list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">insert_dead_orphan</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">inum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_orphan</span> <span class="o">*</span><span class="n">orphan</span><span class="p">,</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">orphan</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_orphan</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orphan</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">orphan</span><span class="o">-&gt;</span><span class="n">inum</span> <span class="o">=</span> <span class="n">inum</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">o</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_orphan</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">&lt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">&gt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Already added - no problem */</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">orphan</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">tot_orphans</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orphan</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orphan</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_tree</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orphan</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_list</span><span class="p">);</span>
	<span class="n">orphan</span><span class="o">-&gt;</span><span class="n">dnext</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_dnext</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_dnext</span> <span class="o">=</span> <span class="n">orphan</span><span class="p">;</span>
	<span class="n">dbg_mnt</span><span class="p">(</span><span class="s">&quot;ino %lu, new %d, tot %d&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inum</span><span class="p">,</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">new_orphans</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">tot_orphans</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * do_kill_orphans - remove orphan inodes from the index.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @sleb: scanned LEB</span>
<span class="cm"> * @last_cmt_no: cmt_no of last orphan node read is passed and returned here</span>
<span class="cm"> * @outofdate: whether the LEB is out of date is returned here</span>
<span class="cm"> * @last_flagged: whether the end orphan node is encountered</span>
<span class="cm"> *</span>
<span class="cm"> * This function is a helper to the &#39;kill_orphans()&#39; function. It goes through</span>
<span class="cm"> * every orphan node in a LEB and for every inode number recorded, removes</span>
<span class="cm"> * all keys for that inode from the TNC.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_kill_orphans</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">sleb</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">last_cmt_no</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">outofdate</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="o">*</span><span class="n">last_flagged</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_scan_node</span> <span class="o">*</span><span class="n">snod</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_orph_node</span> <span class="o">*</span><span class="n">orph</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">cmt_no</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">inum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">first</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">snod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">UBIFS_ORPH_NODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;invalid node type %d in orphan area at &quot;</span>
				  <span class="s">&quot;%d:%d&quot;</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
			<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">orph</span> <span class="o">=</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>

		<span class="cm">/* Check commit number */</span>
		<span class="n">cmt_no</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">orph</span><span class="o">-&gt;</span><span class="n">cmt_no</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LLONG_MAX</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The commit number on the master node may be less, because</span>
<span class="cm">		 * of a failed commit. If there are several failed commits in a</span>
<span class="cm">		 * row, the commit number written on orphan nodes will continue</span>
<span class="cm">		 * to increase (because the commit number is adjusted here) even</span>
<span class="cm">		 * though the commit number on the master node stays the same</span>
<span class="cm">		 * because the master node has not been re-written.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmt_no</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_no</span><span class="p">)</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_no</span> <span class="o">=</span> <span class="n">cmt_no</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmt_no</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">last_cmt_no</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">last_flagged</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The last orphan node had a higher commit number and</span>
<span class="cm">			 * was flagged as the last written for that commit</span>
<span class="cm">			 * number. That makes this orphan node, out of date.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;out of order commit number %llu in &quot;</span>
					  <span class="s">&quot;orphan node at %d:%d&quot;</span><span class="p">,</span>
					  <span class="n">cmt_no</span><span class="p">,</span> <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
				<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;out of date LEB %d&quot;</span><span class="p">,</span> <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>
			<span class="o">*</span><span class="n">outofdate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span>
			<span class="n">first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">orph</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="o">-</span> <span class="n">UBIFS_ORPH_NODE_SZ</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">inum</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">orph</span><span class="o">-&gt;</span><span class="n">inos</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;deleting orphaned inode %lu&quot;</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inum</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_remove_ino</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">insert_dead_orphan</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="o">*</span><span class="n">last_cmt_no</span> <span class="o">=</span> <span class="n">cmt_no</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">orph</span><span class="o">-&gt;</span><span class="n">cmt_no</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;last orph node for commit %llu at %d:%d&quot;</span><span class="p">,</span>
				  <span class="n">cmt_no</span><span class="p">,</span> <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
			<span class="o">*</span><span class="n">last_flagged</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="o">*</span><span class="n">last_flagged</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kill_orphans - remove all orphan inodes from the index.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * If recovery is required, then orphan inodes recorded during the previous</span>
<span class="cm"> * session (which ended with an unclean unmount) must be deleted from the index.</span>
<span class="cm"> * This is done by updating the TNC, but since the index is not updated until</span>
<span class="cm"> * the next commit, the LEBs where the orphan information is recorded are not</span>
<span class="cm"> * erased until the next commit.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">kill_orphans</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">last_cmt_no</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">outofdate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">last_flagged</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_first</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_offs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Check no-orphans flag and skip this if no orphans */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">no_orphs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;no orphans&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Orph nodes always start at c-&gt;orph_first and are written to each</span>
<span class="cm">	 * successive LEB in turn. Generally unused LEBs will have been unmapped</span>
<span class="cm">	 * but may contain out of date orphan nodes if the unmap didn&#39;t go</span>
<span class="cm">	 * through. In addition, the last orphan node written for each commit is</span>
<span class="cm">	 * marked (top bit of orph-&gt;cmt_no is set to 1). It is possible that</span>
<span class="cm">	 * there are orphan nodes from the next commit (i.e. the commit did not</span>
<span class="cm">	 * complete successfully). In that case, no orphans will have been lost</span>
<span class="cm">	 * due to the way that orphans are written, and any orphans added will</span>
<span class="cm">	 * be valid orphans anyway and so can be deleted.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_first</span><span class="p">;</span> <span class="n">lnum</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_last</span><span class="p">;</span> <span class="n">lnum</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">sleb</span><span class="p">;</span>

		<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;LEB %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="n">sleb</span> <span class="o">=</span> <span class="n">ubifs_scan</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sbuf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sleb</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sleb</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">EUCLEAN</span><span class="p">)</span>
				<span class="n">sleb</span> <span class="o">=</span> <span class="n">ubifs_recover_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
							 <span class="n">c</span><span class="o">-&gt;</span><span class="n">sbuf</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sleb</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">do_kill_orphans</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sleb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last_cmt_no</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">outofdate</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">last_flagged</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="n">outofdate</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_scan_destroy</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">endpt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">ohead_offs</span> <span class="o">=</span> <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">endpt</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ubifs_scan_destroy</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_mount_orphans - delete orphan inodes and erase LEBs that recorded them.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @unclean: indicates recovery from unclean unmount</span>
<span class="cm"> * @read_only: indicates read only mount</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called when mounting to erase orphans from the previous</span>
<span class="cm"> * session. If UBIFS was not unmounted cleanly, then the inodes recorded as</span>
<span class="cm"> * orphans are deleted.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_mount_orphans</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unclean</span><span class="p">,</span> <span class="kt">int</span> <span class="n">read_only</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">max_orphans</span> <span class="o">=</span> <span class="n">tot_avail_orphs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_only</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_buf</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_buf</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unclean</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">kill_orphans</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_only</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_clear_orphans</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Everything below is related to debugging.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">check_orphan</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rb</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">inum</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">check_info</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_ino</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tot_inos</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">missing</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">leaf_cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_ino_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">root</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_find_orphan</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">inum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_orphan</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">o</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_orphan</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">&lt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">&gt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_ins_check_orphan</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">inum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">check_orphan</span> <span class="o">*</span><span class="n">orphan</span><span class="p">,</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">orphan</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">check_orphan</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orphan</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">orphan</span><span class="o">-&gt;</span><span class="n">inum</span> <span class="o">=</span> <span class="n">inum</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">o</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">check_orphan</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">&lt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">&gt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">orphan</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orphan</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orphan</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_find_check_orphan</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">inum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">check_orphan</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">o</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">check_orphan</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">&lt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">&gt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dbg_free_check_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">check_orphan</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">this</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">this</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">o</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="k">struct</span> <span class="n">check_orphan</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="n">this</span> <span class="o">=</span> <span class="n">rb_parent</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">)</span>
				<span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_orphan_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">check_info</span> <span class="o">*</span><span class="n">ci</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">inum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">inum</span> <span class="o">=</span> <span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">!=</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">last_ino</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Lowest node type is the inode node, so it comes first */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="n">UBIFS_INO_KEY</span><span class="p">)</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;found orphan node ino %lu, type %d&quot;</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inum</span><span class="p">,</span> <span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">));</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">last_ino</span> <span class="o">=</span> <span class="n">inum</span><span class="p">;</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">tot_inos</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_read_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;node read failed, error %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="cm">/* Must be recorded as an orphan */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_find_check_orphan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span> <span class="n">inum</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">dbg_find_orphan</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inum</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;missing orphan, ino %lu&quot;</span><span class="p">,</span>
					  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inum</span><span class="p">);</span>
				<span class="n">ci</span><span class="o">-&gt;</span><span class="n">missing</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">leaf_cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_read_orphans</span><span class="p">(</span><span class="k">struct</span> <span class="n">check_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">sleb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_scan_node</span> <span class="o">*</span><span class="n">snod</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_orph_node</span> <span class="o">*</span><span class="n">orph</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">inum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">snod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">UBIFS_ORPH_NODE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">orph</span> <span class="o">=</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
		<span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">orph</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="o">-</span> <span class="n">UBIFS_ORPH_NODE_SZ</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">inum</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">orph</span><span class="o">-&gt;</span><span class="n">inos</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_ins_check_orphan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_scan_orphans</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">check_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="cm">/* Check no-orphans flag and skip this if no orphans */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">no_orphs</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">__vmalloc</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">,</span> <span class="n">PAGE_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot allocate memory to check orphans&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_first</span><span class="p">;</span> <span class="n">lnum</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_last</span><span class="p">;</span> <span class="n">lnum</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">sleb</span><span class="p">;</span>

		<span class="n">sleb</span> <span class="o">=</span> <span class="n">ubifs_scan</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sleb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_read_orphans</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="n">sleb</span><span class="p">);</span>
		<span class="n">ubifs_scan_destroy</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_check_orphans</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">check_info</span> <span class="n">ci</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_chk_orph</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ci</span><span class="p">.</span><span class="n">last_ino</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="p">.</span><span class="n">tot_inos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="p">.</span><span class="n">missing</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="p">.</span><span class="n">leaf_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ci</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
	<span class="n">ci</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">UBIFS_MAX_INO_NODE_SZ</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ci</span><span class="p">.</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;out of memory&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_scan_orphans</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_walk_index</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dbg_orphan_check</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ci</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot scan TNC, error %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ci</span><span class="p">.</span><span class="n">missing</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;%lu missing orphan(s)&quot;</span><span class="p">,</span> <span class="n">ci</span><span class="p">.</span><span class="n">missing</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;last inode number is %lu&quot;</span><span class="p">,</span> <span class="n">ci</span><span class="p">.</span><span class="n">last_ino</span><span class="p">);</span>
	<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;total number of inodes is %lu&quot;</span><span class="p">,</span> <span class="n">ci</span><span class="p">.</span><span class="n">tot_inos</span><span class="p">);</span>
	<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;total number of leaf nodes is %llu&quot;</span><span class="p">,</span> <span class="n">ci</span><span class="p">.</span><span class="n">leaf_cnt</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">dbg_free_check_tree</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="p">.</span><span class="n">root</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ci</span><span class="p">.</span><span class="n">node</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
