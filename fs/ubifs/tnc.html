<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ubifs › tnc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>tnc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is part of UBIFS.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Nokia Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="cm"> * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Adrian Hunter</span>
<span class="cm"> *          Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file implements TNC (Tree Node Cache) which caches indexing nodes of</span>
<span class="cm"> * the UBIFS B-tree.</span>
<span class="cm"> *</span>
<span class="cm"> * At the moment the locking rules of the TNC tree are quite simple and</span>
<span class="cm"> * straightforward. We just have a mutex and lock it when we traverse the</span>
<span class="cm"> * tree. If a znode is not in memory, we read it from flash while still having</span>
<span class="cm"> * the mutex locked.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &quot;ubifs.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Returned codes of &#39;matches_name()&#39; and &#39;fallible_matches_name()&#39; functions.</span>
<span class="cm"> * @NAME_LESS: name corresponding to the first argument is less than second</span>
<span class="cm"> * @NAME_MATCHES: names match</span>
<span class="cm"> * @NAME_GREATER: name corresponding to the second argument is greater than</span>
<span class="cm"> *                first</span>
<span class="cm"> * @NOT_ON_MEDIA: node referred by zbranch does not exist on the media</span>
<span class="cm"> *</span>
<span class="cm"> * These constants were introduce to improve readability.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">NAME_LESS</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">NAME_MATCHES</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">NAME_GREATER</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">NOT_ON_MEDIA</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * insert_old_idx - record an index node obsoleted since the last commit start.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB number of obsoleted index node</span>
<span class="cm"> * @offs: offset of obsoleted index node</span>
<span class="cm"> *</span>
<span class="cm"> * Returns %0 on success, and a negative error code on failure.</span>
<span class="cm"> *</span>
<span class="cm"> * For recovery, there must always be a complete intact version of the index on</span>
<span class="cm"> * flash at all times. That is called the &quot;old index&quot;. It is the index as at the</span>
<span class="cm"> * time of the last successful commit. Many of the index nodes in the old index</span>
<span class="cm"> * may be dirty, but they must not be erased until the next successful commit</span>
<span class="cm"> * (at which point that index becomes the old index).</span>
<span class="cm"> *</span>
<span class="cm"> * That means that the garbage collection and the in-the-gaps method of</span>
<span class="cm"> * committing must be able to determine if an index node is in the old index.</span>
<span class="cm"> * Most of the old index nodes can be found by looking up the TNC using the</span>
<span class="cm"> * &#39;lookup_znode()&#39; function. However, some of the old index nodes may have</span>
<span class="cm"> * been deleted from the current index or may have been changed so much that</span>
<span class="cm"> * they cannot be easily found. In those cases, an entry is added to an RB-tree.</span>
<span class="cm"> * That is what this function does. The RB-tree is ordered by LEB number and</span>
<span class="cm"> * offset because they uniquely identify the old index node.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">insert_old_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_old_idx</span> <span class="o">*</span><span class="n">old_idx</span><span class="p">,</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">old_idx</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_old_idx</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">old_idx</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">old_idx</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="n">old_idx</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">old_idx</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">o</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_old_idx</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&lt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&gt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">offs</span> <span class="o">&lt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">offs</span> <span class="o">&gt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;old idx added twice!&quot;</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">old_idx</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_idx</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_idx</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">old_idx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * insert_old_idx_znode - record a znode obsoleted since last commit start.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @znode: znode of obsoleted index node</span>
<span class="cm"> *</span>
<span class="cm"> * Returns %0 on success, and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">insert_old_idx_znode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">;</span>

		<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">insert_old_idx</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">len</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">insert_old_idx</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">lnum</span><span class="p">,</span>
					      <span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">offs</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ins_clr_old_idx_znode - record a znode obsoleted since last commit start.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @znode: znode of obsoleted index node</span>
<span class="cm"> *</span>
<span class="cm"> * Returns %0 on success, and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ins_clr_old_idx_znode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">;</span>

		<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">insert_old_idx</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">insert_old_idx</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">offs</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">lnum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">offs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * destroy_old_idx - destroy the old_idx RB-tree.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * During start commit, the old_idx RB-tree is used to avoid overwriting index</span>
<span class="cm"> * nodes that were in the index last commit but have since been deleted.  This</span>
<span class="cm"> * is necessary for recovery i.e. the old index must be kept intact until the</span>
<span class="cm"> * new index is successfully written.  The old-idx RB-tree is used for the</span>
<span class="cm"> * in-the-gaps method of writing index nodes and is destroyed every commit.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">destroy_old_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">old_idx</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_old_idx</span> <span class="o">*</span><span class="n">old_idx</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">this</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">this</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">old_idx</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_old_idx</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="n">this</span> <span class="o">=</span> <span class="n">rb_parent</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">old_idx</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">)</span>
				<span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">old_idx</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">old_idx</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * copy_znode - copy a dirty znode.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @znode: znode to copy</span>
<span class="cm"> *</span>
<span class="cm"> * A dirty znode being committed may not be changed, so it is copied.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="nf">copy_znode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">zn</span><span class="p">;</span>

	<span class="n">zn</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_znode_sz</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">zn</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">zn</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_znode_sz</span><span class="p">);</span>
	<span class="n">zn</span><span class="o">-&gt;</span><span class="n">cnext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">DIRTY_ZNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zn</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">__clear_bit</span><span class="p">(</span><span class="n">COW_ZNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zn</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">ubifs_zn_obsolete</span><span class="p">(</span><span class="n">znode</span><span class="p">));</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">OBSOLETE_ZNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">zn</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">;</span>

		<span class="cm">/* The children now have new parent */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zn</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="p">)</span>
				<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">zn</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_zn_cnt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">zn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * add_idx_dirt - add dirt due to a dirty znode.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB number of index node</span>
<span class="cm"> * @dirt: size of index node</span>
<span class="cm"> *</span>
<span class="cm"> * This function updates lprops dirty space and the new size of the index.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_idx_dirt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dirt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">calc_idx_sz</span> <span class="o">-=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">dirt</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ubifs_add_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">dirt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dirty_cow_znode - ensure a znode is not being committed.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @zbr: branch of znode to check</span>
<span class="cm"> *</span>
<span class="cm"> * Returns dirtied znode on success or negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="nf">dirty_cow_znode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span> <span class="o">=</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">zn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubifs_zn_cow</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* znode is not being committed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">DIRTY_ZNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_zn_cnt</span><span class="p">);</span>
			<span class="n">atomic_long_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">clean_zn_cnt</span><span class="p">);</span>
			<span class="n">atomic_long_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_clean_zn_cnt</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">add_idx_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">znode</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">zn</span> <span class="o">=</span> <span class="n">copy_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">zn</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">zn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">insert_old_idx</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">add_idx_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span> <span class="o">=</span> <span class="n">zn</span><span class="p">;</span>
	<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">zn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lnc_add - add a leaf node to the leaf node cache.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @zbr: zbranch of leaf node</span>
<span class="cm"> * @node: leaf node</span>
<span class="cm"> *</span>
<span class="cm"> * Leaf nodes are non-index nodes directory entry nodes or data nodes. The</span>
<span class="cm"> * purpose of the leaf node cache is to save re-reading the same leaf node over</span>
<span class="cm"> * and over again. Most things are cached by VFS, however the file system must</span>
<span class="cm"> * cache directory entries for readdir and for resolving hash collisions. The</span>
<span class="cm"> * present implementation of the leaf node cache is extremely simple, and</span>
<span class="cm"> * allows for error returns that are not used but that may be needed if a more</span>
<span class="cm"> * complex implementation is created.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, this function does not add the @node object to LNC directly, but</span>
<span class="cm"> * allocates a copy of the object and adds the copy to LNC. The reason for this</span>
<span class="cm"> * is that @node has been allocated outside of the TNC subsystem and will be</span>
<span class="cm"> * used with @c-&gt;tnc_mutex unlock upon return from the TNC subsystem. But LNC</span>
<span class="cm"> * may be changed at any time, e.g. freed by the shrinker.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lnc_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">,</span>
		   <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">lnc_node</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">dent</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">leaf</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">is_hash_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">));</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_validate_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dent</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lnc_node</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lnc_node</span><span class="p">)</span>
		<span class="cm">/* We don&#39;t have to have the cache, so no error */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">leaf</span> <span class="o">=</span> <span class="n">lnc_node</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

 <span class="cm">/**</span>
<span class="cm"> * lnc_add_directly - add a leaf node to the leaf-node-cache.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @zbr: zbranch of leaf node</span>
<span class="cm"> * @node: leaf node</span>
<span class="cm"> *</span>
<span class="cm"> * This function is similar to &#39;lnc_add()&#39;, but it does not create a copy of</span>
<span class="cm"> * @node but inserts @node to TNC directly.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lnc_add_directly</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">leaf</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_validate_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">leaf</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lnc_free - remove a leaf node from the leaf node cache.</span>
<span class="cm"> * @zbr: zbranch of leaf node</span>
<span class="cm"> * @node: leaf node</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lnc_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">leaf</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">leaf</span><span class="p">);</span>
	<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">leaf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tnc_read_node_nm - read a &quot;hashed&quot; leaf node.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @zbr: key and position of the node</span>
<span class="cm"> * @node: node is returned here</span>
<span class="cm"> *</span>
<span class="cm"> * This function reads a &quot;hashed&quot; node defined by @zbr from the leaf node cache</span>
<span class="cm"> * (in it is there) or from the hash media, in which case the node is also</span>
<span class="cm"> * added to LNC. Returns zero in case of success or a negative negative error</span>
<span class="cm"> * code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tnc_read_node_nm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">is_hash_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">leaf</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read from the leaf node cache */</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">leaf</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_read_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Add the node to the leaf node cache */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">lnc_add</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * try_read_node - read a node if it is a node.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @buf: buffer to read to</span>
<span class="cm"> * @type: node type</span>
<span class="cm"> * @len: node length (not aligned)</span>
<span class="cm"> * @lnum: LEB number of node to read</span>
<span class="cm"> * @offs: offset of node to read</span>
<span class="cm"> *</span>
<span class="cm"> * This function tries to read a node of known type and length, checks it and</span>
<span class="cm"> * stores it in @buf. This function returns %1 if a node is present and %0 if</span>
<span class="cm"> * a node is not present. A negative error code is returned for I/O errors.</span>
<span class="cm"> * This function performs that same function as ubifs_read_node except that</span>
<span class="cm"> * it does not require that there is actually a node present and instead</span>
<span class="cm"> * the return code indicates if a node was read.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, this function does not check CRC of data nodes if @c-&gt;no_chk_data_crc</span>
<span class="cm"> * is true (it is controlled by corresponding mount option). However, if</span>
<span class="cm"> * @c-&gt;mounting or @c-&gt;remounting_rw is true (we are mounting or re-mounting to</span>
<span class="cm"> * R/W mode), @c-&gt;no_chk_data_crc is ignored and CRC is checked. This is</span>
<span class="cm"> * because during mounting or re-mounting from R/O mode to R/W mode we may read</span>
<span class="cm"> * journal nodes (when replying the journal or doing the recovery) and the</span>
<span class="cm"> * journal nodes may potentially be corrupted, so checking is required.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">try_read_node</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">node_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="o">*</span><span class="n">ch</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">crc</span><span class="p">,</span> <span class="n">node_crc</span><span class="p">;</span>

	<span class="n">dbg_io</span><span class="p">(</span><span class="s">&quot;LEB %d:%d, %s, length %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">dbg_ntype</span><span class="p">(</span><span class="n">type</span><span class="p">),</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot read node type %d from LEB %d:%d, error %d&quot;</span><span class="p">,</span>
			  <span class="n">type</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">)</span> <span class="o">!=</span> <span class="n">UBIFS_NODE_MAGIC</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">node_type</span> <span class="o">!=</span> <span class="n">type</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">node_len</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node_len</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_DATA_NODE</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">no_chk_data_crc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mounting</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">remounting_rw</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="n">UBIFS_CRC32_INIT</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="n">node_len</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">node_crc</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">crc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">crc</span> <span class="o">!=</span> <span class="n">node_crc</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fallible_read_node - try to read a leaf node.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @key:  key of node to read</span>
<span class="cm"> * @zbr:  position of node</span>
<span class="cm"> * @node: node returned</span>
<span class="cm"> *</span>
<span class="cm"> * This function tries to read a node and returns %1 if the node is read, %0</span>
<span class="cm"> * if the node is not present, and a negative error code in the case of error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fallible_read_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">dbg_tnck</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;LEB %d:%d, key &quot;</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">try_read_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span>
			    <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">node_key</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">dent</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

		<span class="cm">/* All nodes have key in the same place */</span>
		<span class="n">key_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_key</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_key</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">replaying</span><span class="p">)</span>
		<span class="n">dbg_mntk</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;dangling branch LEB %d:%d len %d, key &quot;</span><span class="p">,</span>
			<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * matches_name - determine if a direntry or xattr entry matches a given name.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @zbr: zbranch of dent</span>
<span class="cm"> * @nm: name to match</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks if xentry/direntry referred by zbranch @zbr matches name</span>
<span class="cm"> * @nm. Returns %NAME_MATCHES if it does, %NAME_LESS if the name referred by</span>
<span class="cm"> * @zbr is less than @nm, and %NAME_GREATER if it is greater than @nm. In case</span>
<span class="cm"> * of failure, a negative error code is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">matches_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">nm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">dent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nlen</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* If possible, match against the dent in the leaf node cache */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">leaf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dent</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dent</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_read_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">,</span> <span class="n">dent</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

		<span class="cm">/* Add the node to the leaf node cache */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">lnc_add_directly</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">,</span> <span class="n">dent</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dent</span> <span class="o">=</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">leaf</span><span class="p">;</span>

	<span class="n">nlen</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">nlen</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">nlen</span><span class="p">,</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nlen</span> <span class="o">==</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">NAME_MATCHES</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nlen</span> <span class="o">&lt;</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">NAME_LESS</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">NAME_GREATER</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NAME_LESS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">NAME_GREATER</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dent</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_znode - get a TNC znode that may not be loaded yet.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @znode: parent znode</span>
<span class="cm"> * @n: znode branch slot number</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the znode or a negative error code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="nf">get_znode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">;</span>

	<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="p">)</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">ubifs_load_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">znode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tnc_next - find next TNC entry.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @zn: znode is passed and returned here</span>
<span class="cm"> * @n: znode branch slot number is passed and returned here</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 if the next TNC entry is found, %-ENOENT if there is</span>
<span class="cm"> * no next entry, or a negative error code otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tnc_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">**</span><span class="n">zn</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span> <span class="o">=</span> <span class="o">*</span><span class="n">zn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nn</span> <span class="o">=</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">nn</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nn</span> <span class="o">&lt;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">nn</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">zp</span><span class="p">;</span>

		<span class="n">zp</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zp</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="n">nn</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">zp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nn</span> <span class="o">&lt;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">znode</span> <span class="o">=</span> <span class="n">get_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">nn</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">znode</span> <span class="o">=</span> <span class="n">get_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
					<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">nn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">zn</span> <span class="o">=</span> <span class="n">znode</span><span class="p">;</span>
	<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">nn</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tnc_prev - find previous TNC entry.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @zn: znode is returned here</span>
<span class="cm"> * @n: znode branch slot number is passed and returned here</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 if the previous TNC entry is found, %-ENOENT if</span>
<span class="cm"> * there is no next entry, or a negative error code otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tnc_prev</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">**</span><span class="n">zn</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span> <span class="o">=</span> <span class="o">*</span><span class="n">zn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nn</span> <span class="o">=</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nn</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">nn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">zp</span><span class="p">;</span>

		<span class="n">zp</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zp</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="n">nn</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">zp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nn</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">znode</span> <span class="o">=</span> <span class="n">get_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">nn</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">nn</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">znode</span> <span class="o">=</span> <span class="n">get_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">nn</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
					<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">nn</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">zn</span> <span class="o">=</span> <span class="n">znode</span><span class="p">;</span>
	<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">nn</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * resolve_collision - resolve a collision.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @key: key of a directory or extended attribute entry</span>
<span class="cm"> * @zn: znode is returned here</span>
<span class="cm"> * @n: zbranch number is passed and returned here</span>
<span class="cm"> * @nm: name of the entry</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called for &quot;hashed&quot; keys to make sure that the found key</span>
<span class="cm"> * really corresponds to the looked up node (directory or extended attribute</span>
<span class="cm"> * entry). It returns %1 and sets @zn and @n if the collision is resolved.</span>
<span class="cm"> * %0 is returned if @nm is not found and @zn and @n are set to the previous</span>
<span class="cm"> * entry, i.e. to the entry after which @nm could follow if it were in TNC.</span>
<span class="cm"> * This means that @n may be set to %-1 if the leftmost key in @zn is the</span>
<span class="cm"> * previous one. A negative error code is returned on failures.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">resolve_collision</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">**</span><span class="n">zn</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">nm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">matches_name</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">zn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="o">*</span><span class="n">n</span><span class="p">],</span> <span class="n">nm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">NAME_MATCHES</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">NAME_GREATER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Look left */</span>
		<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_prev</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zn</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">*</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
				<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">zn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="o">*</span><span class="n">n</span><span class="p">].</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * We have found the branch after which we would</span>
<span class="cm">				 * like to insert, but inserting in this znode</span>
<span class="cm">				 * may still be wrong. Consider the following 3</span>
<span class="cm">				 * znodes, in the case where we are resolving a</span>
<span class="cm">				 * collision with Key2.</span>
<span class="cm">				 *</span>
<span class="cm">				 *                  znode zp</span>
<span class="cm">				 *            ----------------------</span>
<span class="cm">				 * level 1     |  Key0  |  Key1  |</span>
<span class="cm">				 *            -----------------------</span>
<span class="cm">				 *                 |            |</span>
<span class="cm">				 *       znode za  |            |  znode zb</span>
<span class="cm">				 *          ------------      ------------</span>
<span class="cm">				 * level 0  |  Key0  |        |  Key2  |</span>
<span class="cm">				 *          ------------      ------------</span>
<span class="cm">				 *</span>
<span class="cm">				 * The lookup finds Key2 in znode zb. Lets say</span>
<span class="cm">				 * there is no match and the name is greater so</span>
<span class="cm">				 * we look left. When we find Key0, we end up</span>
<span class="cm">				 * here. If we return now, we will insert into</span>
<span class="cm">				 * znode za at slot n = 1.  But that is invalid</span>
<span class="cm">				 * according to the parent&#39;s keys.  Key2 must</span>
<span class="cm">				 * be inserted into znode zb.</span>
<span class="cm">				 *</span>
<span class="cm">				 * Note, this problem is not relevant for the</span>
<span class="cm">				 * case when we go right, because</span>
<span class="cm">				 * &#39;tnc_insert()&#39; would correct the parent key.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">n</span> <span class="o">==</span> <span class="p">(</span><span class="o">*</span><span class="n">zn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_next</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zn</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
						<span class="cm">/* Should be impossible */</span>
						<span class="n">ubifs_assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
							<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
						<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">*</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
					<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">matches_name</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">zn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="o">*</span><span class="n">n</span><span class="p">],</span> <span class="n">nm</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">NAME_LESS</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">NAME_MATCHES</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">NAME_GREATER</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">nn</span> <span class="o">=</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span> <span class="o">=</span> <span class="o">*</span><span class="n">zn</span><span class="p">;</span>

		<span class="cm">/* Look right */</span>
		<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_next</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nn</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">nn</span><span class="p">].</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">matches_name</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">nn</span><span class="p">],</span> <span class="n">nm</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">NAME_GREATER</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="o">*</span><span class="n">zn</span> <span class="o">=</span> <span class="n">znode</span><span class="p">;</span>
			<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">nn</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">NAME_MATCHES</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">NAME_LESS</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fallible_matches_name - determine if a dent matches a given name.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @zbr: zbranch of dent</span>
<span class="cm"> * @nm: name to match</span>
<span class="cm"> *</span>
<span class="cm"> * This is a &quot;fallible&quot; version of &#39;matches_name()&#39; function which does not</span>
<span class="cm"> * panic if the direntry/xentry referred by @zbr does not exist on the media.</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks if xentry/direntry referred by zbranch @zbr matches name</span>
<span class="cm"> * @nm. Returns %NAME_MATCHES it does, %NAME_LESS if the name referred by @zbr</span>
<span class="cm"> * is less than @nm, %NAME_GREATER if it is greater than @nm, and @NOT_ON_MEDIA</span>
<span class="cm"> * if xentry/direntry referred by @zbr does not exist on the media. A negative</span>
<span class="cm"> * error code is returned in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fallible_matches_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">nm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">dent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nlen</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* If possible, match against the dent in the leaf node cache */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">leaf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dent</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dent</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">fallible_read_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">zbr</span><span class="p">,</span> <span class="n">dent</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* The node was not present */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">NOT_ON_MEDIA</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">lnc_add_directly</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">,</span> <span class="n">dent</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dent</span> <span class="o">=</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">leaf</span><span class="p">;</span>

	<span class="n">nlen</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">nlen</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">nlen</span><span class="p">,</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nlen</span> <span class="o">==</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">NAME_MATCHES</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nlen</span> <span class="o">&lt;</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">NAME_LESS</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">NAME_GREATER</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NAME_LESS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">NAME_GREATER</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dent</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fallible_resolve_collision - resolve a collision even if nodes are missing.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @key: key</span>
<span class="cm"> * @zn: znode is returned here</span>
<span class="cm"> * @n: branch number is passed and returned here</span>
<span class="cm"> * @nm: name of directory entry</span>
<span class="cm"> * @adding: indicates caller is adding a key to the TNC</span>
<span class="cm"> *</span>
<span class="cm"> * This is a &quot;fallible&quot; version of the &#39;resolve_collision()&#39; function which</span>
<span class="cm"> * does not panic if one of the nodes referred to by TNC does not exist on the</span>
<span class="cm"> * media. This may happen when replaying the journal if a deleted node was</span>
<span class="cm"> * Garbage-collected and the commit was not done. A branch that refers to a node</span>
<span class="cm"> * that is not present is called a dangling branch. The following are the return</span>
<span class="cm"> * codes for this function:</span>
<span class="cm"> *  o if @nm was found, %1 is returned and @zn and @n are set to the found</span>
<span class="cm"> *    branch;</span>
<span class="cm"> *  o if we are @adding and @nm was not found, %0 is returned;</span>
<span class="cm"> *  o if we are not @adding and @nm was not found, but a dangling branch was</span>
<span class="cm"> *    found, then %1 is returned and @zn and @n are set to the dangling branch;</span>
<span class="cm"> *  o a negative error code is returned in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fallible_resolve_collision</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">**</span><span class="n">zn</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">nm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">adding</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">o_znode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">znode</span> <span class="o">=</span> <span class="o">*</span><span class="n">zn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">o_n</span><span class="p">),</span> <span class="n">err</span><span class="p">,</span> <span class="n">cmp</span><span class="p">,</span> <span class="n">unsure</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nn</span> <span class="o">=</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">cmp</span> <span class="o">=</span> <span class="n">fallible_matches_name</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">nn</span><span class="p">],</span> <span class="n">nm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">cmp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">==</span> <span class="n">NAME_MATCHES</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">==</span> <span class="n">NOT_ON_MEDIA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">o_znode</span> <span class="o">=</span> <span class="n">znode</span><span class="p">;</span>
		<span class="n">o_n</span> <span class="o">=</span> <span class="n">nn</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are unlucky and hit a dangling branch straight away.</span>
<span class="cm">		 * Now we do not really know where to go to find the needed</span>
<span class="cm">		 * branch - to the left or to the right. Well, let&#39;s try left.</span>
<span class="cm">		 */</span>
		<span class="n">unsure</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adding</span><span class="p">)</span>
		<span class="n">unsure</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Remove a dangling branch wherever it is */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">==</span> <span class="n">NAME_GREATER</span> <span class="o">||</span> <span class="n">unsure</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Look left */</span>
		<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_prev</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zn</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">*</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
				<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">zn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="o">*</span><span class="n">n</span><span class="p">].</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* See comments in &#39;resolve_collision()&#39; */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">n</span> <span class="o">==</span> <span class="p">(</span><span class="o">*</span><span class="n">zn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_next</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zn</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
						<span class="cm">/* Should be impossible */</span>
						<span class="n">ubifs_assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
							<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
						<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">*</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
					<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">fallible_matches_name</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">zn</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="o">*</span><span class="n">n</span><span class="p">],</span> <span class="n">nm</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">NAME_MATCHES</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">NOT_ON_MEDIA</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">o_znode</span> <span class="o">=</span> <span class="o">*</span><span class="n">zn</span><span class="p">;</span>
				<span class="n">o_n</span> <span class="o">=</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adding</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">NAME_LESS</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">unsure</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">==</span> <span class="n">NAME_LESS</span> <span class="o">||</span> <span class="n">unsure</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Look right */</span>
		<span class="o">*</span><span class="n">zn</span> <span class="o">=</span> <span class="n">znode</span><span class="p">;</span>
		<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">nn</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_next</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nn</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">nn</span><span class="p">].</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">fallible_matches_name</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">nn</span><span class="p">],</span> <span class="n">nm</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">NAME_GREATER</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="o">*</span><span class="n">zn</span> <span class="o">=</span> <span class="n">znode</span><span class="p">;</span>
			<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">nn</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">NAME_MATCHES</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">NOT_ON_MEDIA</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">o_znode</span> <span class="o">=</span> <span class="n">znode</span><span class="p">;</span>
				<span class="n">o_n</span> <span class="o">=</span> <span class="n">nn</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Never match a dangling branch when adding */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adding</span> <span class="o">||</span> <span class="o">!</span><span class="n">o_znode</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dbg_mntk</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;dangling match LEB %d:%d len %d key &quot;</span><span class="p">,</span>
		<span class="n">o_znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">o_n</span><span class="p">].</span><span class="n">lnum</span><span class="p">,</span> <span class="n">o_znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">o_n</span><span class="p">].</span><span class="n">offs</span><span class="p">,</span>
		<span class="n">o_znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">o_n</span><span class="p">].</span><span class="n">len</span><span class="p">);</span>
	<span class="o">*</span><span class="n">zn</span> <span class="o">=</span> <span class="n">o_znode</span><span class="p">;</span>
	<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">o_n</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * matches_position - determine if a zbranch matches a given position.</span>
<span class="cm"> * @zbr: zbranch of dent</span>
<span class="cm"> * @lnum: LEB number of dent to match</span>
<span class="cm"> * @offs: offset of dent to match</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %1 if @lnum:@offs matches, and %0 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">matches_position</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">lnum</span> <span class="o">&amp;&amp;</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">==</span> <span class="n">offs</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * resolve_collision_directly - resolve a collision directly.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @key: key of directory entry</span>
<span class="cm"> * @zn: znode is passed and returned here</span>
<span class="cm"> * @n: zbranch number is passed and returned here</span>
<span class="cm"> * @lnum: LEB number of dent node to match</span>
<span class="cm"> * @offs: offset of dent node to match</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used for &quot;hashed&quot; keys to make sure the found directory or</span>
<span class="cm"> * extended attribute entry node is what was looked for. It is used when the</span>
<span class="cm"> * flash address of the right node is known (@lnum:@offs) which makes it much</span>
<span class="cm"> * easier to resolve collisions (no need to read entries and match full</span>
<span class="cm"> * names). This function returns %1 and sets @zn and @n if the collision is</span>
<span class="cm"> * resolved, %0 if @lnum:@offs is not found and @zn and @n are set to the</span>
<span class="cm"> * previous directory entry. Otherwise a negative error code is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">resolve_collision_directly</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">**</span><span class="n">zn</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nn</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">znode</span> <span class="o">=</span> <span class="o">*</span><span class="n">zn</span><span class="p">;</span>
	<span class="n">nn</span> <span class="o">=</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">matches_position</span><span class="p">(</span><span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">nn</span><span class="p">],</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Look left */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_prev</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">nn</span><span class="p">].</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">matches_position</span><span class="p">(</span><span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">nn</span><span class="p">],</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">zn</span> <span class="o">=</span> <span class="n">znode</span><span class="p">;</span>
			<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">nn</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Look right */</span>
	<span class="n">znode</span> <span class="o">=</span> <span class="o">*</span><span class="n">zn</span><span class="p">;</span>
	<span class="n">nn</span> <span class="o">=</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_next</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">nn</span><span class="p">].</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">zn</span> <span class="o">=</span> <span class="n">znode</span><span class="p">;</span>
		<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">nn</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">matches_position</span><span class="p">(</span><span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">nn</span><span class="p">],</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dirty_cow_bottom_up - dirty a znode and its ancestors.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @znode: znode to dirty</span>
<span class="cm"> *</span>
<span class="cm"> * If we do not have a unique key that resides in a znode, then we cannot</span>
<span class="cm"> * dirty that znode from the top down (i.e. by using lookup_level0_dirty)</span>
<span class="cm"> * This function records the path back to the last dirty ancestor, and then</span>
<span class="cm"> * dirties the znodes on that path.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="nf">dirty_cow_bottom_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">zp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bottom_up_buf</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">BOTTOM_UP_HEIGHT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bottom_up_buf</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">bottom_up_buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span>
					   <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bottom_up_buf</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="n">path</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bottom_up_buf</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Go up until parent is dirty */</span>
		<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

			<span class="n">zp</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zp</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span><span class="p">;</span>
			<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
			<span class="n">path</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zp</span><span class="o">-&gt;</span><span class="n">cnext</span> <span class="o">&amp;&amp;</span> <span class="n">ubifs_zn_dirty</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">znode</span> <span class="o">=</span> <span class="n">zp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Come back down, dirtying as we go */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">;</span>

		<span class="n">zp</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">zp</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">);</span>
			<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zp</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="o">--</span><span class="n">p</span><span class="p">]];</span>
			<span class="n">znode</span> <span class="o">=</span> <span class="n">dirty_cow_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">znode</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="p">);</span>
			<span class="n">znode</span> <span class="o">=</span> <span class="n">dirty_cow_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">p</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">);</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]].</span><span class="n">znode</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">znode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_lookup_level0 - search for zero-level znode.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @key:  key to lookup</span>
<span class="cm"> * @zn: znode is returned here</span>
<span class="cm"> * @n: znode branch slot number is returned here</span>
<span class="cm"> *</span>
<span class="cm"> * This function looks up the TNC tree and search for zero-level znode which</span>
<span class="cm"> * refers key @key. The found zero-level znode is returned in @zn. There are 3</span>
<span class="cm"> * cases:</span>
<span class="cm"> *   o exact match, i.e. the found zero-level znode contains key @key, then %1</span>
<span class="cm"> *     is returned and slot number of the matched branch is stored in @n;</span>
<span class="cm"> *   o not exact match, which means that zero-level znode does not contain</span>
<span class="cm"> *     @key, then %0 is returned and slot number of the closest branch is stored</span>
<span class="cm"> *     in @n;</span>
<span class="cm"> *   o @key is so small that it is even less than the lowest key of the</span>
<span class="cm"> *     leftmost zero-level node, then %0 is returned and %0 is stored in @n.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, when the TNC tree is traversed, some znodes may be absent, then this</span>
<span class="cm"> * function reads corresponding indexing nodes and inserts them to TNC. In</span>
<span class="cm"> * case of failure, a negative error code is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_lookup_level0</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">**</span><span class="n">zn</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">exact</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>

	<span class="n">dbg_tnck</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;search key &quot;</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">UBIFS_INVALID_KEY</span><span class="p">);</span>

	<span class="n">znode</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">znode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">ubifs_load_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">znode</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">;</span>

		<span class="n">exact</span> <span class="o">=</span> <span class="n">ubifs_search_zbranch</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="o">*</span><span class="n">n</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">znode</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span>
			<span class="n">znode</span> <span class="o">=</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* znode is not in TNC cache, load it from the media */</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">ubifs_load_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">zn</span> <span class="o">=</span> <span class="n">znode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exact</span> <span class="o">||</span> <span class="o">!</span><span class="n">is_hash_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">||</span> <span class="o">*</span><span class="n">n</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_tnc</span><span class="p">(</span><span class="s">&quot;found %d, lvl %d, n %d&quot;</span><span class="p">,</span> <span class="n">exact</span><span class="p">,</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">exact</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Here is a tricky place. We have not found the key and this is a</span>
<span class="cm">	 * &quot;hashed&quot; key, which may collide. The rest of the code deals with</span>
<span class="cm">	 * situations like this:</span>
<span class="cm">	 *</span>
<span class="cm">	 *                  | 3 | 5 |</span>
<span class="cm">	 *                  /       \</span>
<span class="cm">	 *          | 3 | 5 |      | 6 | 7 | (x)</span>
<span class="cm">	 *</span>
<span class="cm">	 * Or more a complex example:</span>
<span class="cm">	 *</span>
<span class="cm">	 *                | 1 | 5 |</span>
<span class="cm">	 *                /       \</span>
<span class="cm">	 *       | 1 | 3 |         | 5 | 8 |</span>
<span class="cm">	 *              \           /</span>
<span class="cm">	 *          | 5 | 5 |   | 6 | 7 | (x)</span>
<span class="cm">	 *</span>
<span class="cm">	 * In the examples, if we are looking for key &quot;5&quot;, we may reach nodes</span>
<span class="cm">	 * marked with &quot;(x)&quot;. In this case what we have do is to look at the</span>
<span class="cm">	 * left and see if there is &quot;5&quot; key there. If there is, we have to</span>
<span class="cm">	 * return it.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note, this whole situation is possible because we allow to have</span>
<span class="cm">	 * elements which are equivalent to the next key in the parent in the</span>
<span class="cm">	 * children of current znode. For example, this happens if we split a</span>
<span class="cm">	 * znode like this: | 3 | 5 | 5 | 6 | 7 |, which results in something</span>
<span class="cm">	 * like this:</span>
<span class="cm">	 *                      | 3 | 5 |</span>
<span class="cm">	 *                       /     \</span>
<span class="cm">	 *                | 3 | 5 |   | 5 | 6 | 7 |</span>
<span class="cm">	 *                              ^</span>
<span class="cm">	 * And this becomes what is at the first &quot;picture&quot; after key &quot;5&quot; marked</span>
<span class="cm">	 * with &quot;^&quot; is removed. What could be done is we could prohibit</span>
<span class="cm">	 * splitting in the middle of the colliding sequence. Also, when</span>
<span class="cm">	 * removing the leftmost key, we would have to correct the key of the</span>
<span class="cm">	 * parent node, which would introduce additional complications. Namely,</span>
<span class="cm">	 * if we changed the leftmost key of the parent znode, the garbage</span>
<span class="cm">	 * collector would be unable to find it (GC is doing this when GC&#39;ing</span>
<span class="cm">	 * indexing LEBs). Although we already have an additional RB-tree where</span>
<span class="cm">	 * we save such changed znodes (see &#39;ins_clr_old_idx_znode()&#39;) until</span>
<span class="cm">	 * after the commit. But anyway, this does not look easy to implement</span>
<span class="cm">	 * so we did not try this.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_prev</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_tnc</span><span class="p">(</span><span class="s">&quot;found 0, lvl %d, n -1&quot;</span><span class="p">,</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
		<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="o">*</span><span class="n">n</span><span class="p">].</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dbg_tnc</span><span class="p">(</span><span class="s">&quot;found 0, lvl %d, n -1&quot;</span><span class="p">,</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
		<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dbg_tnc</span><span class="p">(</span><span class="s">&quot;found 1, lvl %d, n %d&quot;</span><span class="p">,</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
	<span class="o">*</span><span class="n">zn</span> <span class="o">=</span> <span class="n">znode</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lookup_level0_dirty - search for zero-level znode dirtying.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @key:  key to lookup</span>
<span class="cm"> * @zn: znode is returned here</span>
<span class="cm"> * @n: znode branch slot number is returned here</span>
<span class="cm"> *</span>
<span class="cm"> * This function looks up the TNC tree and search for zero-level znode which</span>
<span class="cm"> * refers key @key. The found zero-level znode is returned in @zn. There are 3</span>
<span class="cm"> * cases:</span>
<span class="cm"> *   o exact match, i.e. the found zero-level znode contains key @key, then %1</span>
<span class="cm"> *     is returned and slot number of the matched branch is stored in @n;</span>
<span class="cm"> *   o not exact match, which means that zero-level znode does not contain @key</span>
<span class="cm"> *     then %0 is returned and slot number of the closed branch is stored in</span>
<span class="cm"> *     @n;</span>
<span class="cm"> *   o @key is so small that it is even less than the lowest key of the</span>
<span class="cm"> *     leftmost zero-level node, then %0 is returned and %-1 is stored in @n.</span>
<span class="cm"> *</span>
<span class="cm"> * Additionally all znodes in the path from the root to the located zero-level</span>
<span class="cm"> * znode are marked as dirty.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, when the TNC tree is traversed, some znodes may be absent, then this</span>
<span class="cm"> * function reads corresponding indexing nodes and inserts them to TNC. In</span>
<span class="cm"> * case of failure, a negative error code is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lookup_level0_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">**</span><span class="n">zn</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">exact</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>

	<span class="n">dbg_tnck</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;search and dirty key &quot;</span><span class="p">);</span>

	<span class="n">znode</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">znode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">ubifs_load_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">znode</span> <span class="o">=</span> <span class="n">dirty_cow_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>

	<span class="n">znode</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">;</span>

		<span class="n">exact</span> <span class="o">=</span> <span class="n">ubifs_search_zbranch</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="o">*</span><span class="n">n</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">znode</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span>
			<span class="n">znode</span> <span class="o">=</span> <span class="n">dirty_cow_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* znode is not in TNC cache, load it from the media */</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">ubifs_load_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">dirty_cow_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">zn</span> <span class="o">=</span> <span class="n">znode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exact</span> <span class="o">||</span> <span class="o">!</span><span class="n">is_hash_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">||</span> <span class="o">*</span><span class="n">n</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_tnc</span><span class="p">(</span><span class="s">&quot;found %d, lvl %d, n %d&quot;</span><span class="p">,</span> <span class="n">exact</span><span class="p">,</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">exact</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * See huge comment at &#39;lookup_level0_dirty()&#39; what is the rest of the</span>
<span class="cm">	 * code.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_prev</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">dbg_tnc</span><span class="p">(</span><span class="s">&quot;found 0, lvl %d, n -1&quot;</span><span class="p">,</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="o">*</span><span class="n">n</span><span class="p">].</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">dbg_tnc</span><span class="p">(</span><span class="s">&quot;found 0, lvl %d, n -1&quot;</span><span class="p">,</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">cnext</span> <span class="o">||</span> <span class="o">!</span><span class="n">ubifs_zn_dirty</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">dirty_cow_bottom_up</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dbg_tnc</span><span class="p">(</span><span class="s">&quot;found 1, lvl %d, n %d&quot;</span><span class="p">,</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
	<span class="o">*</span><span class="n">zn</span> <span class="o">=</span> <span class="n">znode</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * maybe_leb_gced - determine if a LEB may have been garbage collected.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB number</span>
<span class="cm"> * @gc_seq1: garbage collection sequence number</span>
<span class="cm"> *</span>
<span class="cm"> * This function determines if @lnum may have been garbage collected since</span>
<span class="cm"> * sequence number @gc_seq1. If it may have been then %1 is returned, otherwise</span>
<span class="cm"> * %0 is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">maybe_leb_gced</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gc_seq1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">gc_seq2</span><span class="p">,</span> <span class="n">gced_lnum</span><span class="p">;</span>

	<span class="n">gced_lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">gced_lnum</span><span class="p">;</span>
	<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="n">gc_seq2</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_seq</span><span class="p">;</span>
	<span class="cm">/* Same seq means no GC */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gc_seq1</span> <span class="o">==</span> <span class="n">gc_seq2</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Different by more than 1 means we don&#39;t know */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gc_seq1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">gc_seq2</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We have seen the sequence number has increased by 1. Now we need to</span>
<span class="cm">	 * be sure we read the right LEB number, so read it again.</span>
<span class="cm">	 */</span>
	<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gced_lnum</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">gced_lnum</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Finally we can check lnum */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gced_lnum</span> <span class="o">==</span> <span class="n">lnum</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_tnc_locate - look up a file-system node and return it and its location.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @key: node key to lookup</span>
<span class="cm"> * @node: the node is returned here</span>
<span class="cm"> * @lnum: LEB number is returned here</span>
<span class="cm"> * @offs: offset is returned here</span>
<span class="cm"> *</span>
<span class="cm"> * This function looks up and reads node with key @key. The caller has to make</span>
<span class="cm"> * sure the @node buffer is large enough to fit the node. Returns zero in case</span>
<span class="cm"> * of success, %-ENOENT if the node was not found, and a negative error code in</span>
<span class="cm"> * case of failure. The node location can be returned in @lnum and @offs.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_tnc_locate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
		     <span class="kt">void</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">found</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">safely</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gc_seq1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="n">zbr</span><span class="p">,</span> <span class="o">*</span><span class="n">zt</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="n">found</span> <span class="o">=</span> <span class="n">ubifs_lookup_level0</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">found</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">zt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">zt</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>
		<span class="o">*</span><span class="n">offs</span> <span class="o">=</span> <span class="n">zt</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_hash_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In this case the leaf node cache gets used, so we pass the</span>
<span class="cm">		 * address of the zbranch and keep the mutex locked</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_read_node_nm</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zt</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">safely</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_read_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zt</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Drop the TNC mutex prematurely and race with garbage collection */</span>
	<span class="n">zbr</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
	<span class="n">gc_seq1</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_seq</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubifs_get_wbuf</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">.</span><span class="n">lnum</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* We do not GC journal heads */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_read_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">fallible_read_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">maybe_leb_gced</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">.</span><span class="n">lnum</span><span class="p">,</span> <span class="n">gc_seq1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The node may have been GC&#39;ed out from under us so try again</span>
<span class="cm">		 * while keeping the TNC mutex locked.</span>
<span class="cm">		 */</span>
		<span class="n">safely</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_tnc_get_bu_keys - lookup keys for bulk-read.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @bu: bulk-read parameters and results</span>
<span class="cm"> *</span>
<span class="cm"> * Lookup consecutive data node keys for the same inode that reside</span>
<span class="cm"> * consecutively in the same LEB. This function returns zero in case of success</span>
<span class="cm"> * and a negative error code in case of failure.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, if the bulk-read buffer length (@bu-&gt;buf_len) is known, this function</span>
<span class="cm"> * makes sure bulk-read nodes fit the buffer. Otherwise, this function prepares</span>
<span class="cm"> * maximum possible amount of nodes for bulk-read.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_tnc_get_bu_keys</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bu_info</span> <span class="o">*</span><span class="n">bu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lnum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">offs</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block</span> <span class="o">=</span> <span class="n">key_block</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">;</span>

	<span class="n">bu</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bu</span><span class="o">-&gt;</span><span class="n">blk_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bu</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="cm">/* Find first key */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_lookup_level0</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Key found */</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">len</span><span class="p">;</span>
		<span class="cm">/* The buffer must be big enough for at least 1 node */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">bu</span><span class="o">-&gt;</span><span class="n">buf_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Add this key */</span>
		<span class="n">bu</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
		<span class="n">bu</span><span class="o">-&gt;</span><span class="n">blk_cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">lnum</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">lnum</span><span class="p">;</span>
		<span class="n">offs</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">offs</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">;</span>
		<span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">next_block</span><span class="p">;</span>

		<span class="cm">/* Find next key */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_next</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
		<span class="n">key</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
		<span class="cm">/* See if there is another data key for this file */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="n">UBIFS_DATA_KEY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* First key found */</span>
			<span class="n">lnum</span> <span class="o">=</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>
			<span class="n">offs</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">+</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">bu</span><span class="o">-&gt;</span><span class="n">buf_len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The data nodes must be in consecutive positions in</span>
<span class="cm">			 * the same LEB.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">!=</span> <span class="n">lnum</span> <span class="o">||</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">!=</span> <span class="n">offs</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">offs</span> <span class="o">+=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
			<span class="cm">/* Must not exceed buffer length */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">bu</span><span class="o">-&gt;</span><span class="n">buf_len</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Allow for holes */</span>
		<span class="n">next_block</span> <span class="o">=</span> <span class="n">key_block</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
		<span class="n">bu</span><span class="o">-&gt;</span><span class="n">blk_cnt</span> <span class="o">+=</span> <span class="p">(</span><span class="n">next_block</span> <span class="o">-</span> <span class="n">block</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">blk_cnt</span> <span class="o">&gt;=</span> <span class="n">UBIFS_MAX_BULK_READ</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">block</span> <span class="o">=</span> <span class="n">next_block</span><span class="p">;</span>
		<span class="cm">/* Add this key */</span>
		<span class="n">bu</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">zbr</span><span class="p">;</span>
		<span class="n">bu</span><span class="o">-&gt;</span><span class="n">blk_cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* See if we have room for more */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">UBIFS_MAX_BULK_READ</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">blk_cnt</span> <span class="o">&gt;=</span> <span class="n">UBIFS_MAX_BULK_READ</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bu</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bu</span><span class="o">-&gt;</span><span class="n">gc_seq</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_seq</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * An enormous hole could cause bulk-read to encompass too many</span>
<span class="cm">	 * page cache pages, so limit the number here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">blk_cnt</span> <span class="o">&gt;</span> <span class="n">UBIFS_MAX_BULK_READ</span><span class="p">)</span>
		<span class="n">bu</span><span class="o">-&gt;</span><span class="n">blk_cnt</span> <span class="o">=</span> <span class="n">UBIFS_MAX_BULK_READ</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Ensure that bulk-read covers a whole number of page cache</span>
<span class="cm">	 * pages.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UBIFS_BLOCKS_PER_PAGE</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">blk_cnt</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UBIFS_BLOCKS_PER_PAGE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">eof</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* At the end of file we can round up */</span>
		<span class="n">bu</span><span class="o">-&gt;</span><span class="n">blk_cnt</span> <span class="o">+=</span> <span class="n">UBIFS_BLOCKS_PER_PAGE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Exclude data nodes that do not make up a whole page cache page */</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">key_block</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="n">bu</span><span class="o">-&gt;</span><span class="n">blk_cnt</span><span class="p">;</span>
	<span class="n">block</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">UBIFS_BLOCKS_PER_PAGE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">key_block</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">key</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">block</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">bu</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * read_wbuf - bulk-read from a LEB with a wbuf.</span>
<span class="cm"> * @wbuf: wbuf that may overlap the read</span>
<span class="cm"> * @buf: buffer into which to read</span>
<span class="cm"> * @len: read length</span>
<span class="cm"> * @lnum: LEB number from which to read</span>
<span class="cm"> * @offs: offset from which to read</span>
<span class="cm"> *</span>
<span class="cm"> * This functions returns %0 on success or a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_wbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rlen</span><span class="p">,</span> <span class="n">overlap</span><span class="p">;</span>

	<span class="n">dbg_io</span><span class="p">(</span><span class="s">&quot;LEB %d:%d, length %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">wbuf</span> <span class="o">&amp;&amp;</span> <span class="n">lnum</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">lnum</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">&amp;&amp;</span> <span class="n">offs</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">offs</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">offs</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">offs</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">overlap</span> <span class="o">=</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">&amp;&amp;</span> <span class="n">offs</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">overlap</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We may safely unlock the write-buffer and read the data */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ubifs_leb_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Don&#39;t read under wbuf */</span>
	<span class="n">rlen</span> <span class="o">=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">-</span> <span class="n">offs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rlen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Copy the rest from the write-buffer */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">rlen</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">offs</span> <span class="o">+</span> <span class="n">rlen</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">rlen</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rlen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* Read everything that goes before write-buffer */</span>
		<span class="k">return</span> <span class="n">ubifs_leb_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">rlen</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * validate_data_node - validate data nodes for bulk-read.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @buf: buffer containing data node to validate</span>
<span class="cm"> * @zbr: zbranch of data node to validate</span>
<span class="cm"> *</span>
<span class="cm"> * This functions returns %0 on success or a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">validate_data_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="o">*</span><span class="n">ch</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">node_type</span> <span class="o">!=</span> <span class="n">UBIFS_DATA_NODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad node type (%d but expected %d)&quot;</span><span class="p">,</span>
			  <span class="n">ch</span><span class="o">-&gt;</span><span class="n">node_type</span><span class="p">,</span> <span class="n">UBIFS_DATA_NODE</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_check_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;expected node type %d&quot;</span><span class="p">,</span> <span class="n">UBIFS_DATA_NODE</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad node length %d, expected %d&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure the key of the read node is correct */</span>
	<span class="n">key_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">UBIFS_KEY_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">keys_eq</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad key in node at LEB %d:%d&quot;</span><span class="p">,</span>
			  <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
		<span class="n">dbg_tnck</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;looked for key &quot;</span><span class="p">);</span>
		<span class="n">dbg_tnck</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key1</span><span class="p">,</span> <span class="s">&quot;found node&#39;s key &quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_err:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad node at LEB %d:%d&quot;</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
	<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_tnc_bulk_read - read a number of data nodes in one go.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @bu: bulk-read parameters and results</span>
<span class="cm"> *</span>
<span class="cm"> * This functions reads and validates the data nodes that were identified by the</span>
<span class="cm"> * &#39;ubifs_tnc_get_bu_keys()&#39; function. This functions returns %0 on success,</span>
<span class="cm"> * -EAGAIN to indicate a race with GC, or another negative error code on</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_tnc_bulk_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bu_info</span> <span class="o">*</span><span class="n">bu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">lnum</span> <span class="o">=</span> <span class="n">bu</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span> <span class="o">=</span> <span class="n">bu</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">bu</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">offs</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">bu</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">len</span> <span class="o">-</span> <span class="n">offs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">bu</span><span class="o">-&gt;</span><span class="n">buf_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;buffer too small %d vs %d&quot;</span><span class="p">,</span> <span class="n">bu</span><span class="o">-&gt;</span><span class="n">buf_len</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Do the read */</span>
	<span class="n">wbuf</span> <span class="o">=</span> <span class="n">ubifs_get_wbuf</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wbuf</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">read_wbuf</span><span class="p">(</span><span class="n">wbuf</span><span class="p">,</span> <span class="n">bu</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">bu</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Check for a race with GC */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maybe_leb_gced</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">bu</span><span class="o">-&gt;</span><span class="n">gc_seq</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EBADMSG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;failed to read from LEB %d:%d, error %d&quot;</span><span class="p">,</span>
			  <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="n">dbg_tnck</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;key &quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Validate the nodes read */</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">bu</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bu</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">validate_data_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">bu</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * do_lookup_nm- look up a &quot;hashed&quot; node.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @key: node key to lookup</span>
<span class="cm"> * @node: the node is returned here</span>
<span class="cm"> * @nm: node name</span>
<span class="cm"> *</span>
<span class="cm"> * This function look up and reads a node which contains name hash in the key.</span>
<span class="cm"> * Since the hash may have collisions, there may be many nodes with the same</span>
<span class="cm"> * key, so we have to sequentially look to all of them until the needed one is</span>
<span class="cm"> * found. This function returns zero in case of success, %-ENOENT if the node</span>
<span class="cm"> * was not found, and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_lookup_nm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">nm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">found</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">;</span>

	<span class="n">dbg_tnck</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;name &#39;%.*s&#39; key &quot;</span><span class="p">,</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="n">found</span> <span class="o">=</span> <span class="n">ubifs_lookup_level0</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">found</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">resolve_collision</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="n">nm</span><span class="p">);</span>
	<span class="n">dbg_tnc</span><span class="p">(</span><span class="s">&quot;rc returned %d, znode %p, n %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_read_node_nm</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">node</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_tnc_lookup_nm - look up a &quot;hashed&quot; node.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @key: node key to lookup</span>
<span class="cm"> * @node: the node is returned here</span>
<span class="cm"> * @nm: node name</span>
<span class="cm"> *</span>
<span class="cm"> * This function look up and reads a node which contains name hash in the key.</span>
<span class="cm"> * Since the hash may have collisions, there may be many nodes with the same</span>
<span class="cm"> * key, so we have to sequentially look to all of them until the needed one is</span>
<span class="cm"> * found. This function returns zero in case of success, %-ENOENT if the node</span>
<span class="cm"> * was not found, and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_tnc_lookup_nm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">nm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">dent</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We assume that in most of the cases there are no name collisions and</span>
<span class="cm">	 * &#39;ubifs_tnc_lookup()&#39; returns us the right direntry.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_lookup</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">nlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nm</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unluckily, there are hash collisions and we have to iterate over</span>
<span class="cm">	 * them look at each direntry with colliding name hash sequentially.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">do_lookup_nm</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">nm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * correct_parent_keys - correct parent znodes&#39; keys.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @znode: znode to correct parent znodes for</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function for &#39;tnc_insert()&#39;. When the key of the leftmost</span>
<span class="cm"> * zbranch changes, keys of parent znodes have to be corrected. This helper</span>
<span class="cm"> * function is called in such situations and corrects the keys if needed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">correct_parent_keys</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">key1</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">key</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
	<span class="n">key1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">key1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">key_copy</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">key1</span><span class="p">);</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="n">znode</span><span class="o">-&gt;</span><span class="n">alt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">||</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">key1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * insert_zbranch - insert a zbranch into a znode.</span>
<span class="cm"> * @znode: znode into which to insert</span>
<span class="cm"> * @zbr: zbranch to insert</span>
<span class="cm"> * @n: slot number to insert to</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function for &#39;tnc_insert()&#39;. UBIFS does not allow &quot;gaps&quot; in</span>
<span class="cm"> * znode&#39;s array of zbranches and keeps zbranches consolidated, so when a new</span>
<span class="cm"> * zbranch has to be inserted to the @znode-&gt;zbranches[]&#39; array at the @n-th</span>
<span class="cm"> * slot, zbranches starting from @n have to be moved right.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">insert_zbranch</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">ubifs_zn_dirty</span><span class="p">(</span><span class="n">znode</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">znode</span><span class="p">)</span>
				<span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="p">)</span>
			<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
			<span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

	<span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">zbr</span><span class="p">;</span>
	<span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * After inserting at slot zero, the lower bound of the key range of</span>
<span class="cm">	 * this znode may have changed. If this znode is subsequently split</span>
<span class="cm">	 * then the upper bound of the key range may change, and furthermore</span>
<span class="cm">	 * it could change to be lower than the original lower bound. If that</span>
<span class="cm">	 * happens, then it will no longer be possible to find this znode in the</span>
<span class="cm">	 * TNC using the key from the index node on flash. That is bad because</span>
<span class="cm">	 * if it is not found, we will assume it is obsolete and may overwrite</span>
<span class="cm">	 * it. Then if there is an unclean unmount, we will start using the</span>
<span class="cm">	 * old index which will be broken.</span>
<span class="cm">	 *</span>
<span class="cm">	 * So we first mark znodes that have insertions at slot zero, and then</span>
<span class="cm">	 * if they are split we add their lnum/offs to the old_idx tree.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">znode</span><span class="o">-&gt;</span><span class="n">alt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tnc_insert - insert a node into TNC.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @znode: znode to insert into</span>
<span class="cm"> * @zbr: branch to insert</span>
<span class="cm"> * @n: slot number to insert new zbranch to</span>
<span class="cm"> *</span>
<span class="cm"> * This function inserts a new node described by @zbr into znode @znode. If</span>
<span class="cm"> * znode does not have a free slot for new zbranch, it is split. Parent znodes</span>
<span class="cm"> * are splat as well if needed. Returns zero in case of success or a negative</span>
<span class="cm"> * error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tnc_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">zn</span><span class="p">,</span> <span class="o">*</span><span class="n">zi</span><span class="p">,</span> <span class="o">*</span><span class="n">zp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">keep</span><span class="p">,</span> <span class="n">move</span><span class="p">,</span> <span class="n">appending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">key1</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span><span class="p">);</span>

	<span class="cm">/* Implement naive insert for now */</span>
<span class="nl">again:</span>
	<span class="n">zp</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span><span class="p">);</span>
		<span class="n">dbg_tnck</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;inserted at %d level %d, key &quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>

		<span class="n">insert_zbranch</span><span class="p">(</span><span class="n">znode</span><span class="p">,</span> <span class="n">zbr</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

		<span class="cm">/* Ensure parent&#39;s key is correct */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">zp</span> <span class="o">&amp;&amp;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">correct_parent_keys</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unfortunately, @znode does not have more empty slots and we have to</span>
<span class="cm">	 * split it.</span>
<span class="cm">	 */</span>
	<span class="n">dbg_tnck</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;splitting level %d, key &quot;</span><span class="p">,</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">alt</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * We can no longer be sure of finding this znode by key, so we</span>
<span class="cm">		 * record it in the old_idx tree.</span>
<span class="cm">		 */</span>
		<span class="n">ins_clr_old_idx_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>

	<span class="n">zn</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_znode_sz</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zn</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">zn</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">zp</span><span class="p">;</span>
	<span class="n">zn</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span>

	<span class="cm">/* Decide where to split */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">UBIFS_DATA_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Try not to split consecutive data keys */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">key1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key1</span><span class="p">)</span> <span class="o">==</span> <span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key1</span><span class="p">)</span> <span class="o">==</span> <span class="n">UBIFS_DATA_KEY</span><span class="p">)</span>
				<span class="n">appending</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">goto</span> <span class="n">check_split</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">appending</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Try not to split consecutive data keys */</span>
		<span class="n">appending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">check_split:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">key1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key1</span><span class="p">)</span> <span class="o">==</span> <span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key1</span><span class="p">)</span> <span class="o">==</span> <span class="n">UBIFS_DATA_KEY</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">key1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">||</span>
				    <span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">UBIFS_DATA_KEY</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">keep</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
					<span class="n">move</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span> <span class="o">-</span> <span class="n">keep</span><span class="p">;</span>
					<span class="n">zi</span> <span class="o">=</span> <span class="n">znode</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">do_split</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">appending</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">keep</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span><span class="p">;</span>
		<span class="n">move</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">keep</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">move</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span> <span class="o">-</span> <span class="n">keep</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Although we don&#39;t at present, we could look at the neighbors and see</span>
<span class="cm">	 * if we can move some zbranches there.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">keep</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Insert into existing znode */</span>
		<span class="n">zi</span> <span class="o">=</span> <span class="n">znode</span><span class="p">;</span>
		<span class="n">move</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">keep</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Insert into new znode */</span>
		<span class="n">zi</span> <span class="o">=</span> <span class="n">zn</span><span class="p">;</span>
		<span class="n">n</span> <span class="o">-=</span> <span class="n">keep</span><span class="p">;</span>
		<span class="cm">/* Re-parent */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zn</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">zn</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">do_split:</span>

	<span class="n">__set_bit</span><span class="p">(</span><span class="n">DIRTY_ZNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zn</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_zn_cnt</span><span class="p">);</span>

	<span class="n">zn</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">=</span> <span class="n">move</span><span class="p">;</span>
	<span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">=</span> <span class="n">keep</span><span class="p">;</span>

	<span class="n">dbg_tnc</span><span class="p">(</span><span class="s">&quot;moving %d, keeping %d&quot;</span><span class="p">,</span> <span class="n">move</span><span class="p">,</span> <span class="n">keep</span><span class="p">);</span>

	<span class="cm">/* Move zbranch */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">move</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">zn</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">keep</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
		<span class="cm">/* Re-parent */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zn</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">zn</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">znode</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">zn</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">zn</span><span class="p">;</span>
				<span class="n">zn</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Insert new key and branch */</span>
	<span class="n">dbg_tnck</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;inserting at %d level %d, key &quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">zn</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>

	<span class="n">insert_zbranch</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">zbr</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

	<span class="cm">/* Insert new znode (produced by spitting) into the parent */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">zi</span> <span class="o">==</span> <span class="n">znode</span> <span class="o">&amp;&amp;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">correct_parent_keys</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>

		<span class="cm">/* Locate insertion point */</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Tail recursion */</span>
		<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">zn</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
		<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span> <span class="o">=</span> <span class="n">zn</span><span class="p">;</span>
		<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">zp</span><span class="p">;</span>

		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We have to split root znode */</span>
	<span class="n">dbg_tnc</span><span class="p">(</span><span class="s">&quot;creating new zroot at level %d&quot;</span><span class="p">,</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">zi</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_znode_sz</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zi</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">zi</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">zi</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">__set_bit</span><span class="p">(</span><span class="n">DIRTY_ZNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zi</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_zn_cnt</span><span class="p">);</span>

	<span class="n">zi</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
	<span class="n">zi</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">znode</span> <span class="o">=</span> <span class="n">znode</span><span class="p">;</span>
	<span class="n">zi</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">lnum</span><span class="p">;</span>
	<span class="n">zi</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">offs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">offs</span><span class="p">;</span>
	<span class="n">zi</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
	<span class="n">zi</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="n">zn</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
	<span class="n">zi</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">znode</span> <span class="o">=</span> <span class="n">zn</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">lnum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">offs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span> <span class="o">=</span> <span class="n">zi</span><span class="p">;</span>

	<span class="n">zn</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">zi</span><span class="p">;</span>
	<span class="n">zn</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">zi</span><span class="p">;</span>
	<span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_tnc_add - add a node to TNC.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @key: key to add</span>
<span class="cm"> * @lnum: LEB number of node</span>
<span class="cm"> * @offs: node offset</span>
<span class="cm"> * @len: node length</span>
<span class="cm"> *</span>
<span class="cm"> * This function adds a node with key @key to TNC. The node may be new or it may</span>
<span class="cm"> * obsolete some existing one. Returns %0 on success or negative error code on</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_tnc_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
		  <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">found</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="n">dbg_tnck</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;%d:%d, len %d, key &quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">found</span> <span class="o">=</span> <span class="n">lookup_level0_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="n">zbr</span><span class="p">;</span>

		<span class="n">zbr</span><span class="p">.</span><span class="n">znode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">zbr</span><span class="p">.</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
		<span class="n">zbr</span><span class="p">.</span><span class="n">offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
		<span class="n">zbr</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">key_copy</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr</span><span class="p">.</span><span class="n">key</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_insert</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>

		<span class="n">lnc_free</span><span class="p">(</span><span class="n">zbr</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_add_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
		<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
		<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">found</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_tnc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_tnc_replace - replace a node in the TNC only if the old node is found.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @key: key to add</span>
<span class="cm"> * @old_lnum: LEB number of old node</span>
<span class="cm"> * @old_offs: old node offset</span>
<span class="cm"> * @lnum: LEB number of node</span>
<span class="cm"> * @offs: node offset</span>
<span class="cm"> * @len: node length</span>
<span class="cm"> *</span>
<span class="cm"> * This function replaces a node with key @key in the TNC only if the old node</span>
<span class="cm"> * is found.  This function is called by garbage collection when node are moved.</span>
<span class="cm"> * Returns %0 on success or negative error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_tnc_replace</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">old_lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">old_offs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">found</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="n">dbg_tnck</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;old LEB %d:%d, new LEB %d:%d, len %d, key &quot;</span><span class="p">,</span> <span class="n">old_lnum</span><span class="p">,</span>
		 <span class="n">old_offs</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">found</span> <span class="o">=</span> <span class="n">lookup_level0_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">found</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>

		<span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">old_lnum</span> <span class="o">&amp;&amp;</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">==</span> <span class="n">old_offs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lnc_free</span><span class="p">(</span><span class="n">zbr</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_add_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
			<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
			<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_hash_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="n">resolve_collision_directly</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span>
							   <span class="n">old_lnum</span><span class="p">,</span> <span class="n">old_offs</span><span class="p">);</span>
			<span class="n">dbg_tnc</span><span class="p">(</span><span class="s">&quot;rc returned %d, znode %p, n %d, LEB %d:%d&quot;</span><span class="p">,</span>
				<span class="n">found</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">old_lnum</span><span class="p">,</span> <span class="n">old_offs</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">found</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Ensure the znode is dirtied */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">cnext</span> <span class="o">||</span> <span class="o">!</span><span class="n">ubifs_zn_dirty</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">znode</span> <span class="o">=</span> <span class="n">dirty_cow_bottom_up</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
						<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
				<span class="n">lnc_free</span><span class="p">(</span><span class="n">zbr</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_add_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span>
						     <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
				<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
				<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
				<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_add_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_tnc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_tnc_add_nm - add a &quot;hashed&quot; node to TNC.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @key: key to add</span>
<span class="cm"> * @lnum: LEB number of node</span>
<span class="cm"> * @offs: node offset</span>
<span class="cm"> * @len: node length</span>
<span class="cm"> * @nm: node name</span>
<span class="cm"> *</span>
<span class="cm"> * This is the same as &#39;ubifs_tnc_add()&#39; but it should be used with keys which</span>
<span class="cm"> * may have collisions, like directory entry keys.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_tnc_add_nm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">nm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">found</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="n">dbg_tnck</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;LEB %d:%d, name &#39;%.*s&#39;, key &quot;</span><span class="p">,</span>
		 <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">found</span> <span class="o">=</span> <span class="n">lookup_level0_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">found</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">replaying</span><span class="p">)</span>
			<span class="n">found</span> <span class="o">=</span> <span class="n">fallible_resolve_collision</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span>
							   <span class="n">nm</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">found</span> <span class="o">=</span> <span class="n">resolve_collision</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="n">nm</span><span class="p">);</span>
		<span class="n">dbg_tnc</span><span class="p">(</span><span class="s">&quot;rc returned %d, znode %p, n %d&quot;</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">found</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Ensure the znode is dirtied */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">cnext</span> <span class="o">||</span> <span class="o">!</span><span class="n">ubifs_zn_dirty</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">znode</span> <span class="o">=</span> <span class="n">dirty_cow_bottom_up</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>

			<span class="n">lnc_free</span><span class="p">(</span><span class="n">zbr</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_add_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
			<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
			<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="n">zbr</span><span class="p">;</span>

		<span class="n">zbr</span><span class="p">.</span><span class="n">znode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">zbr</span><span class="p">.</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
		<span class="n">zbr</span><span class="p">.</span><span class="n">offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
		<span class="n">zbr</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">key_copy</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr</span><span class="p">.</span><span class="n">key</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_insert</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">replaying</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We did not find it in the index so there may be a</span>
<span class="cm">			 * dangling branch still in the index. So we remove it</span>
<span class="cm">			 * by passing &#39;ubifs_tnc_remove_nm()&#39; the same key but</span>
<span class="cm">			 * an unmatchable name.</span>
<span class="cm">			 */</span>
			<span class="k">struct</span> <span class="n">qstr</span> <span class="n">noname</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span> <span class="p">};</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_tnc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">ubifs_tnc_remove_nm</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">noname</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out_unlock:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_tnc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tnc_delete - delete a znode form TNC.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @znode: znode to delete from</span>
<span class="cm"> * @n: zbranch slot number to delete</span>
<span class="cm"> *</span>
<span class="cm"> * This function deletes a leaf node from @n-th slot of @znode. Returns zero in</span>
<span class="cm"> * case of success and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tnc_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">zp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Delete without merge for now */</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span><span class="p">);</span>
	<span class="n">dbg_tnck</span><span class="p">(</span><span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;deleting key &quot;</span><span class="p">);</span>

	<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
	<span class="n">lnc_free</span><span class="p">(</span><span class="n">zbr</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_add_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_dump_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We do not &quot;gap&quot; zbranch slots */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This was the last zbranch, we have to delete this znode from the</span>
<span class="cm">	 * parent.</span>
<span class="cm">	 */</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">ubifs_zn_obsolete</span><span class="p">(</span><span class="n">znode</span><span class="p">));</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">ubifs_zn_dirty</span><span class="p">(</span><span class="n">znode</span><span class="p">));</span>

		<span class="n">zp</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span><span class="p">;</span>

		<span class="n">atomic_long_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_zn_cnt</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">insert_old_idx_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__set_bit</span><span class="p">(</span><span class="n">OBSOLETE_ZNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">clean_zn_cnt</span><span class="p">);</span>
			<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_clean_zn_cnt</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">zp</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/* while removing last child */</span>

	<span class="cm">/* Remove from znode, entry n - 1 */</span>
	<span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">znode</span><span class="p">)</span>
			<span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this is the root and it has only 1 child then</span>
<span class="cm">	 * collapse the tree.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">zp</span> <span class="o">=</span> <span class="n">znode</span><span class="p">;</span>
			<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">znode</span> <span class="o">=</span> <span class="n">get_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
			<span class="n">znode</span> <span class="o">=</span> <span class="n">dirty_cow_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
			<span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">insert_old_idx</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">lnum</span><span class="p">,</span>
						     <span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">offs</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">offs</span> <span class="o">=</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span> <span class="o">=</span> <span class="n">znode</span><span class="p">;</span>
			<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">ubifs_zn_obsolete</span><span class="p">(</span><span class="n">zp</span><span class="p">));</span>
			<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">ubifs_zn_dirty</span><span class="p">(</span><span class="n">zp</span><span class="p">));</span>
			<span class="n">atomic_long_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_zn_cnt</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">zp</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">__set_bit</span><span class="p">(</span><span class="n">OBSOLETE_ZNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
				<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">clean_zn_cnt</span><span class="p">);</span>
				<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_clean_zn_cnt</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">zp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_tnc_remove - remove an index entry of a node.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @key: key of node</span>
<span class="cm"> *</span>
<span class="cm"> * Returns %0 on success or negative error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_tnc_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">found</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="n">dbg_tnck</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;key &quot;</span><span class="p">);</span>
	<span class="n">found</span> <span class="o">=</span> <span class="n">lookup_level0_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">found</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_delete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_tnc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_tnc_remove_nm - remove an index entry for a &quot;hashed&quot; node.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @key: key of node</span>
<span class="cm"> * @nm: directory entry name</span>
<span class="cm"> *</span>
<span class="cm"> * Returns %0 on success or negative error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_tnc_remove_nm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">nm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="n">dbg_tnck</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;%.*s, key &quot;</span><span class="p">,</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">lookup_level0_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">replaying</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">fallible_resolve_collision</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span>
							 <span class="n">nm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">resolve_collision</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="n">nm</span><span class="p">);</span>
		<span class="n">dbg_tnc</span><span class="p">(</span><span class="s">&quot;rc returned %d, znode %p, n %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Ensure the znode is dirtied */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">cnext</span> <span class="o">||</span> <span class="o">!</span><span class="n">ubifs_zn_dirty</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">znode</span> <span class="o">=</span> <span class="n">dirty_cow_bottom_up</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_delete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out_unlock:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_tnc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * key_in_range - determine if a key falls within a range of keys.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @key: key to check</span>
<span class="cm"> * @from_key: lowest key in range</span>
<span class="cm"> * @to_key: highest key in range</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %1 if the key is in range and %0 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">key_in_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			<span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">from_key</span><span class="p">,</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">to_key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">from_key</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">to_key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_tnc_remove_range - remove index entries in range.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @from_key: lowest key to remove</span>
<span class="cm"> * @to_key: highest key to remove</span>
<span class="cm"> *</span>
<span class="cm"> * This function removes index entries starting at @from_key and ending at</span>
<span class="cm"> * @to_key.  This function returns zero in case of success and a negative error</span>
<span class="cm"> * code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_tnc_remove_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">from_key</span><span class="p">,</span>
			   <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">to_key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Find first level 0 znode that contains keys to remove */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_lookup_level0</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">from_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">key</span> <span class="o">=</span> <span class="n">from_key</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_next</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="n">key</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">key_in_range</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">from_key</span><span class="p">,</span> <span class="n">to_key</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Ensure the znode is dirtied */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">cnext</span> <span class="o">||</span> <span class="o">!</span><span class="n">ubifs_zn_dirty</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">znode</span> <span class="o">=</span> <span class="n">dirty_cow_bottom_up</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Remove all keys in range except the first */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">key</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">key_in_range</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">from_key</span><span class="p">,</span> <span class="n">to_key</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">lnc_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_add_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lnum</span><span class="p">,</span>
					     <span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_dump_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">dbg_tnck</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;removing key &quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">-=</span> <span class="n">k</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Now delete the first */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_delete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out_unlock:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_tnc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_tnc_remove_ino - remove an inode from TNC.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @inum: inode number to remove</span>
<span class="cm"> *</span>
<span class="cm"> * This function remove inode @inum and all the extended attributes associated</span>
<span class="cm"> * with the anode from TNC and returns zero in case of success or a negative</span>
<span class="cm"> * error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_tnc_remove_ino</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">inum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key1</span><span class="p">,</span> <span class="n">key2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">xent</span><span class="p">,</span> <span class="o">*</span><span class="n">pxent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">nm</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">};</span>

	<span class="n">dbg_tnc</span><span class="p">(</span><span class="s">&quot;ino %lu&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inum</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Walk all extended attribute entries and remove them together with</span>
<span class="cm">	 * corresponding extended attribute inodes.</span>
<span class="cm">	 */</span>
	<span class="n">lowest_xent_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key1</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ino_t</span> <span class="n">xattr_inum</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">xent</span> <span class="o">=</span> <span class="n">ubifs_tnc_next_ent</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">xent</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">xent</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">xattr_inum</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">xent</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">);</span>
		<span class="n">dbg_tnc</span><span class="p">(</span><span class="s">&quot;xent &#39;%s&#39;, ino %lu&quot;</span><span class="p">,</span> <span class="n">xent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">xattr_inum</span><span class="p">);</span>

		<span class="n">nm</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">xent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="n">nm</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">xent</span><span class="o">-&gt;</span><span class="n">nlen</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_remove_nm</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">xent</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">lowest_ino_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key1</span><span class="p">,</span> <span class="n">xattr_inum</span><span class="p">);</span>
		<span class="n">highest_ino_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key2</span><span class="p">,</span> <span class="n">xattr_inum</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_remove_range</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">xent</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">pxent</span><span class="p">);</span>
		<span class="n">pxent</span> <span class="o">=</span> <span class="n">xent</span><span class="p">;</span>
		<span class="n">key_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xent</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">pxent</span><span class="p">);</span>
	<span class="n">lowest_ino_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key1</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
	<span class="n">highest_ino_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key2</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ubifs_tnc_remove_range</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_tnc_next_ent - walk directory or extended attribute entries.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @key: key of last entry</span>
<span class="cm"> * @nm: name of last entry found or %NULL</span>
<span class="cm"> *</span>
<span class="cm"> * This function finds and reads the next directory or extended attribute entry</span>
<span class="cm"> * after the given key (@key) if there is one. @nm is used to resolve</span>
<span class="cm"> * collisions.</span>
<span class="cm"> *</span>
<span class="cm"> * If the name of the current entry is not known and only the key is known,</span>
<span class="cm"> * @nm-&gt;name has to be %NULL. In this case the semantics of this function is a</span>
<span class="cm"> * little bit different and it returns the entry corresponding to this key, not</span>
<span class="cm"> * the next one. If the key was not found, the closest &quot;right&quot; entry is</span>
<span class="cm"> * returned.</span>
<span class="cm"> *</span>
<span class="cm"> * If the fist entry has to be found, @key has to contain the lowest possible</span>
<span class="cm"> * key value for this inode and @name has to be %NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the found directory or extended attribute entry node</span>
<span class="cm"> * in case of success, %-ENOENT is returned if no entry was found, and a</span>
<span class="cm"> * negative error code is returned in case of failure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="nf">ubifs_tnc_next_ent</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
					   <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">nm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">type</span> <span class="o">=</span> <span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">dent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">dkey</span><span class="p">;</span>

	<span class="n">dbg_tnck</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;%s &quot;</span><span class="p">,</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">?</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">nm</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;(lowest)&quot;</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">is_hash_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">));</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_lookup_level0</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Handle collisions */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">resolve_collision</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="n">nm</span><span class="p">);</span>
			<span class="n">dbg_tnc</span><span class="p">(</span><span class="s">&quot;rc returned %d, znode %p, n %d&quot;</span><span class="p">,</span>
				<span class="n">err</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Now find next entry */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_next</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The full name of the entry was not given, in which case the</span>
<span class="cm">		 * behavior of this function is a little different and it</span>
<span class="cm">		 * returns current entry, not the next one.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * However, the given key does not exist in the TNC</span>
<span class="cm">			 * tree and @znode/@n variables contain the closest</span>
<span class="cm">			 * &quot;preceding&quot; element. Switch to the next one.</span>
<span class="cm">			 */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_next</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
	<span class="n">dent</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">dent</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The above &#39;tnc_next()&#39; call could lead us to the next inode, check</span>
<span class="cm">	 * this.</span>
<span class="cm">	 */</span>
	<span class="n">dkey</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dkey</span><span class="p">)</span> <span class="o">!=</span> <span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dkey</span><span class="p">)</span> <span class="o">!=</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_read_node_nm</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">,</span> <span class="n">dent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dent</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dent</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tnc_destroy_cnext - destroy left-over obsolete znodes from a failed commit.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * Destroy left-over obsolete znodes from a failed commit.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tnc_destroy_cnext</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">cnext</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">==</span> <span class="n">COMMIT_BROKEN</span><span class="p">);</span>
	<span class="n">cnext</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span> <span class="o">=</span> <span class="n">cnext</span><span class="p">;</span>

		<span class="n">cnext</span> <span class="o">=</span> <span class="n">cnext</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ubifs_zn_obsolete</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">cnext</span> <span class="o">&amp;&amp;</span> <span class="n">cnext</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_tnc_close - close TNC subsystem and free all related resources.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubifs_tnc_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tnc_destroy_cnext</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="n">n</span><span class="p">;</span>

		<span class="n">ubifs_destroy_tnc_subtree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="p">);</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">clean_zn_cnt</span><span class="p">);</span>
		<span class="n">atomic_long_sub</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubifs_clean_zn_cnt</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">gap_lebs</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ilebs</span><span class="p">);</span>
	<span class="n">destroy_old_idx</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * left_znode - get the znode to the left.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @znode: znode</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns a pointer to the znode to the left of @znode or NULL if</span>
<span class="cm"> * there is not one. A negative error code is returned on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="nf">left_znode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Go up until we can go left */</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">znode</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Now go down the rightmost branch to &#39;level&#39; */</span>
			<span class="n">znode</span> <span class="o">=</span> <span class="n">get_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">znode</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">!=</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">n</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">znode</span> <span class="o">=</span> <span class="n">get_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
					<span class="k">return</span> <span class="n">znode</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">znode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * right_znode - get the znode to the right.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @znode: znode</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns a pointer to the znode to the right of @znode or NULL</span>
<span class="cm"> * if there is not one. A negative error code is returned on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="nf">right_znode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Go up until we can go right */</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">znode</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Now go down the leftmost branch to &#39;level&#39; */</span>
			<span class="n">znode</span> <span class="o">=</span> <span class="n">get_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">znode</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">!=</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">znode</span> <span class="o">=</span> <span class="n">get_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
					<span class="k">return</span> <span class="n">znode</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">znode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lookup_znode - find a particular indexing node from TNC.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @key: index node key to lookup</span>
<span class="cm"> * @level: index node level</span>
<span class="cm"> * @lnum: index node LEB number</span>
<span class="cm"> * @offs: index node offset</span>
<span class="cm"> *</span>
<span class="cm"> * This function searches an indexing node by its first key @key and its</span>
<span class="cm"> * address @lnum:@offs. It looks up the indexing tree by pulling all indexing</span>
<span class="cm"> * nodes it traverses to TNC. This function is called for indexing nodes which</span>
<span class="cm"> * were found on the media by scanning, for example when garbage-collecting or</span>
<span class="cm"> * when doing in-the-gaps commit. This means that the indexing node which is</span>
<span class="cm"> * looked for does not have to have exactly the same leftmost key @key, because</span>
<span class="cm"> * the leftmost key may have been changed, in which case TNC will contain a</span>
<span class="cm"> * dirty znode which still refers the same @lnum:@offs. This function is clever</span>
<span class="cm"> * enough to recognize such indexing nodes.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, if a znode was deleted or changed too much, then this function will</span>
<span class="cm"> * not find it. For situations like this UBIFS has the old index RB-tree</span>
<span class="cm"> * (indexed by @lnum:@offs).</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns a pointer to the znode found or %NULL if it is not</span>
<span class="cm"> * found. A negative error code is returned on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="nf">lookup_znode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
					<span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">,</span> <span class="o">*</span><span class="n">zn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">nn</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">UBIFS_INVALID_KEY</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The arguments have probably been read off flash, so don&#39;t assume</span>
<span class="cm">	 * they are valid.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="cm">/* Get the root znode */</span>
	<span class="n">znode</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">znode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">ubifs_load_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">znode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Check if it is the one we are looking for */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">lnum</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">offs</span> <span class="o">==</span> <span class="n">offs</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">znode</span><span class="p">;</span>
	<span class="cm">/* Descend to the parent level i.e. (level + 1) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_search_zbranch</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We reached a znode where the leftmost key is greater</span>
<span class="cm">			 * than the key we are searching for. This is the same</span>
<span class="cm">			 * situation as the one described in a huge comment at</span>
<span class="cm">			 * the end of the &#39;ubifs_lookup_level0()&#39; function. And</span>
<span class="cm">			 * for exactly the same reasons we have to try to look</span>
<span class="cm">			 * left before giving up.</span>
<span class="cm">			 */</span>
			<span class="n">znode</span> <span class="o">=</span> <span class="n">left_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">znode</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">znode</span><span class="p">;</span>
			<span class="n">ubifs_search_zbranch</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
			<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">==</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">get_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">znode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Check if the child is the one we are looking for */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">lnum</span> <span class="o">&amp;&amp;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">offs</span> <span class="o">==</span> <span class="n">offs</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">get_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="cm">/* If the key is unique, there is nowhere else to look */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_hash_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The key is not unique and so may be also in the znodes to either</span>
<span class="cm">	 * side.</span>
<span class="cm">	 */</span>
	<span class="n">zn</span> <span class="o">=</span> <span class="n">znode</span><span class="p">;</span>
	<span class="n">nn</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="cm">/* Look left */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Move one branch to the left */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">znode</span> <span class="o">=</span> <span class="n">left_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">znode</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">znode</span><span class="p">;</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Check it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">lnum</span> <span class="o">&amp;&amp;</span>
		    <span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">offs</span> <span class="o">==</span> <span class="n">offs</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">get_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="cm">/* Stop if the key is less than the one we are looking for */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Back to the middle */</span>
	<span class="n">znode</span> <span class="o">=</span> <span class="n">zn</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">nn</span><span class="p">;</span>
	<span class="cm">/* Look right */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Move one branch to the right */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">znode</span> <span class="o">=</span> <span class="n">right_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">znode</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">znode</span><span class="p">;</span>
			<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Check it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">lnum</span> <span class="o">&amp;&amp;</span>
		    <span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">offs</span> <span class="o">==</span> <span class="n">offs</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">get_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="cm">/* Stop if the key is greater than the one we are looking for */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * is_idx_node_in_tnc - determine if an index node is in the TNC.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @key: key of index node</span>
<span class="cm"> * @level: index node level</span>
<span class="cm"> * @lnum: LEB number of index node</span>
<span class="cm"> * @offs: offset of index node</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 if the index node is not referred to in the TNC, %1</span>
<span class="cm"> * if the index node is referred to in the TNC and the corresponding znode is</span>
<span class="cm"> * dirty, %2 if an index node is referred to in the TNC and the corresponding</span>
<span class="cm"> * znode is clean, and a negative error code in case of failure.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, the @key argument has to be the key of the first child. Also note,</span>
<span class="cm"> * this function relies on the fact that 0:0 is never a valid LEB number and</span>
<span class="cm"> * offset for a main-area node.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">is_idx_node_in_tnc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">;</span>

	<span class="n">znode</span> <span class="o">=</span> <span class="n">lookup_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">znode</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ubifs_zn_dirty</span><span class="p">(</span><span class="n">znode</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * is_leaf_node_in_tnc - determine if a non-indexing not is in the TNC.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @key: node key</span>
<span class="cm"> * @lnum: node LEB number</span>
<span class="cm"> * @offs: node offset</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %1 if the node is referred to in the TNC, %0 if it is</span>
<span class="cm"> * not, and a negative error code in case of failure.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, this function relies on the fact that 0:0 is never a valid LEB number</span>
<span class="cm"> * and offset for a main-area node.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_leaf_node_in_tnc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">,</span> <span class="o">*</span><span class="n">zn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">found</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">nn</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">unique</span> <span class="o">=</span> <span class="o">!</span><span class="n">is_hash_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

	<span class="n">found</span> <span class="o">=</span> <span class="n">ubifs_lookup_level0</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">found</span><span class="p">;</span> <span class="cm">/* Error code */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">&amp;&amp;</span> <span class="n">offs</span> <span class="o">==</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Found it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unique</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Because the key is not unique, we have to look left</span>
<span class="cm">	 * and right as well</span>
<span class="cm">	 */</span>
	<span class="n">zn</span> <span class="o">=</span> <span class="n">znode</span><span class="p">;</span>
	<span class="n">nn</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="cm">/* Look left */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_prev</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">key</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">&amp;&amp;</span> <span class="n">offs</span> <span class="o">==</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Found it */</span>
	<span class="p">}</span>
	<span class="cm">/* Look right */</span>
	<span class="n">znode</span> <span class="o">=</span> <span class="n">zn</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">nn</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_next</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">key</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">&amp;&amp;</span> <span class="n">offs</span> <span class="o">==</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Found it */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_tnc_has_node - determine whether a node is in the TNC.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @key: node key</span>
<span class="cm"> * @level: index node level (if it is an index node)</span>
<span class="cm"> * @lnum: node LEB number</span>
<span class="cm"> * @offs: node offset</span>
<span class="cm"> * @is_idx: non-zero if the node is an index node</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %1 if the node is in the TNC, %0 if it is not, and a</span>
<span class="cm"> * negative error code in case of failure. For index nodes, @key has to be the</span>
<span class="cm"> * key of the first child. An index node is considered to be in the TNC only if</span>
<span class="cm"> * the corresponding znode is clean or has not been loaded.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_tnc_has_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_idx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">is_idx_node_in_tnc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="cm">/* The index node was found but it was dirty */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
			<span class="cm">/* The index node was found and it was clean */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">is_leaf_node_in_tnc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_dirty_idx_node - dirty an index node.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @key: index node key</span>
<span class="cm"> * @level: index node level</span>
<span class="cm"> * @lnum: index node LEB number</span>
<span class="cm"> * @offs: index node offset</span>
<span class="cm"> *</span>
<span class="cm"> * This function loads and dirties an index node so that it can be garbage</span>
<span class="cm"> * collected. The @key argument has to be the key of the first child. This</span>
<span class="cm"> * function relies on the fact that 0:0 is never a valid LEB number and offset</span>
<span class="cm"> * for a main-area node. Returns %0 on success and a negative error code on</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_dirty_idx_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="n">znode</span> <span class="o">=</span> <span class="n">lookup_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">znode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">znode</span> <span class="o">=</span> <span class="n">dirty_cow_bottom_up</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_check_inode_size - check if inode size is correct.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @inum: inode number</span>
<span class="cm"> * @size: inode size</span>
<span class="cm"> *</span>
<span class="cm"> * This function makes sure that the inode size (@size) is correct and it does</span>
<span class="cm"> * not have any pages beyond @size. Returns zero if the inode is OK, %-EINVAL</span>
<span class="cm"> * if it has a data page beyond @size, and other negative error code in case of</span>
<span class="cm"> * other errors.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbg_check_inode_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			 <span class="n">loff_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">from_key</span><span class="p">,</span> <span class="n">to_key</span><span class="p">,</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_chk_gen</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">UBIFS_BLOCK_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">UBIFS_BLOCK_SHIFT</span><span class="p">;</span>
	<span class="n">data_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">from_key</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
	<span class="n">highest_data_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to_key</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_lookup_level0</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">from_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">key</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">from_key</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">tnc_next</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">key</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">key_in_range</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">from_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to_key</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

<span class="nl">out_dump:</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">key_block</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;inode %lu has size %lld, but there are data at offset %lld&quot;</span><span class="p">,</span>
		  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
		  <span class="p">((</span><span class="n">loff_t</span><span class="p">)</span><span class="n">block</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">UBIFS_BLOCK_SHIFT</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="n">ubifs_dump_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
