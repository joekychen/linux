<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ubifs › budget.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>budget.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is part of UBIFS.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Nokia Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="cm"> * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Adrian Hunter</span>
<span class="cm"> *          Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file implements the budgeting sub-system which is responsible for UBIFS</span>
<span class="cm"> * space management.</span>
<span class="cm"> *</span>
<span class="cm"> * Factors such as compression, wasted space at the ends of LEBs, space in other</span>
<span class="cm"> * journal heads, the effect of updates on the index, and so on, make it</span>
<span class="cm"> * impossible to accurately predict the amount of space needed. Consequently</span>
<span class="cm"> * approximations are used.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;ubifs.h&quot;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/math64.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * When pessimistic budget calculations say that there is no enough space,</span>
<span class="cm"> * UBIFS starts writing back dirty inodes and pages, doing garbage collection,</span>
<span class="cm"> * or committing. The below constant defines maximum number of times UBIFS</span>
<span class="cm"> * repeats the operations.</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_MKSPC_RETRIES 3</span>

<span class="cm">/*</span>
<span class="cm"> * The below constant defines amount of dirty pages which should be written</span>
<span class="cm"> * back at when trying to shrink the liability.</span>
<span class="cm"> */</span>
<span class="cp">#define NR_TO_WRITE 16</span>

<span class="cm">/**</span>
<span class="cm"> * shrink_liability - write-back some dirty pages/inodes.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @nr_to_write: how many dirty pages to write-back</span>
<span class="cm"> *</span>
<span class="cm"> * This function shrinks UBIFS liability by means of writing back some amount</span>
<span class="cm"> * of dirty inodes and their pages.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, this function synchronizes even VFS inodes which are locked</span>
<span class="cm"> * (@i_mutex) by the caller of the budgeting function, because write-back does</span>
<span class="cm"> * not touch @i_mutex.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">shrink_liability</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_to_write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vfs_sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
	<span class="n">writeback_inodes_sb</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vfs_sb</span><span class="p">,</span> <span class="n">WB_REASON_FS_FREE_SPACE</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vfs_sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * run_gc - run garbage collector.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function runs garbage collector to make some more free space. Returns</span>
<span class="cm"> * zero if a free LEB has been produced, %-EAGAIN if commit is required, and a</span>
<span class="cm"> * negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">run_gc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">lnum</span><span class="p">;</span>

	<span class="cm">/* Make some free space by garbage-collecting dirty space */</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">commit_sem</span><span class="p">);</span>
	<span class="n">lnum</span> <span class="o">=</span> <span class="n">ubifs_garbage_collect</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">commit_sem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">lnum</span><span class="p">;</span>

	<span class="cm">/* GC freed one LEB, return it to lprops */</span>
	<span class="n">dbg_budg</span><span class="p">(</span><span class="s">&quot;GC freed LEB %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_return_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_liability - calculate current liability.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function calculates and returns current UBIFS liability, i.e. the</span>
<span class="cm"> * amount of bytes UBIFS has &quot;promised&quot; to write to the media.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">get_liability</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">liab</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
	<span class="n">liab</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">idx_growth</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">data_growth</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">dd_growth</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">liab</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * make_free_space - make more free space on the file-system.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called when an operation cannot be budgeted because there</span>
<span class="cm"> * is supposedly no free space. But in most cases there is some free space:</span>
<span class="cm"> *   o budgeting is pessimistic, so it always budgets more than it is actually</span>
<span class="cm"> *     needed, so shrinking the liability is one way to make free space - the</span>
<span class="cm"> *     cached data will take less space then it was budgeted for;</span>
<span class="cm"> *   o GC may turn some dark space into free space (budgeting treats dark space</span>
<span class="cm"> *     as not available);</span>
<span class="cm"> *   o commit may free some LEB, i.e., turn freeable LEBs into free LEBs.</span>
<span class="cm"> *</span>
<span class="cm"> * So this function tries to do the above. Returns %-EAGAIN if some free space</span>
<span class="cm"> * was presumably made and the caller has to re-try budgeting the operation.</span>
<span class="cm"> * Returns %-ENOSPC if it couldn&#39;t do more free space, and other negative error</span>
<span class="cm"> * codes on failures.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">make_free_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">liab1</span><span class="p">,</span> <span class="n">liab2</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">liab1</span> <span class="o">=</span> <span class="n">get_liability</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We probably have some dirty pages or inodes (liability), try</span>
<span class="cm">		 * to write them back.</span>
<span class="cm">		 */</span>
		<span class="n">dbg_budg</span><span class="p">(</span><span class="s">&quot;liability %lld, run write-back&quot;</span><span class="p">,</span> <span class="n">liab1</span><span class="p">);</span>
		<span class="n">shrink_liability</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">NR_TO_WRITE</span><span class="p">);</span>

		<span class="n">liab2</span> <span class="o">=</span> <span class="n">get_liability</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">liab2</span> <span class="o">&lt;</span> <span class="n">liab1</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

		<span class="n">dbg_budg</span><span class="p">(</span><span class="s">&quot;new liability %lld (not shrunk)&quot;</span><span class="p">,</span> <span class="n">liab2</span><span class="p">);</span>

		<span class="cm">/* Liability did not shrink again, try GC */</span>
		<span class="n">dbg_budg</span><span class="p">(</span><span class="s">&quot;Run GC&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">run_gc</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
			<span class="cm">/* Some real error happened */</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">dbg_budg</span><span class="p">(</span><span class="s">&quot;Run commit (retries %d)&quot;</span><span class="p">,</span> <span class="n">retries</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_run_commit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">retries</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">MAX_MKSPC_RETRIES</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_calc_min_idx_lebs - calculate amount of LEBs for the index.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function calculates and returns the number of LEBs which should be kept</span>
<span class="cm"> * for index usage.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_calc_min_idx_lebs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx_lebs</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">idx_size</span><span class="p">;</span>

	<span class="n">idx_size</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">old_idx_sz</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">idx_growth</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">uncommitted_idx</span><span class="p">;</span>
	<span class="cm">/* And make sure we have thrice the index size of space reserved */</span>
	<span class="n">idx_size</span> <span class="o">+=</span> <span class="n">idx_size</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We do not maintain &#39;old_idx_size&#39; as &#39;old_idx_lebs&#39;/&#39;old_idx_bytes&#39;</span>
<span class="cm">	 * pair, nor similarly the two variables for the new index size, so we</span>
<span class="cm">	 * have to do this costly 64-bit division on fast-path.</span>
<span class="cm">	 */</span>
	<span class="n">idx_lebs</span> <span class="o">=</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">idx_size</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_leb_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_leb_size</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The index head is not available for the in-the-gaps method, so add an</span>
<span class="cm">	 * extra LEB to compensate.</span>
<span class="cm">	 */</span>
	<span class="n">idx_lebs</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx_lebs</span> <span class="o">&lt;</span> <span class="n">MIN_INDEX_LEBS</span><span class="p">)</span>
		<span class="n">idx_lebs</span> <span class="o">=</span> <span class="n">MIN_INDEX_LEBS</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">idx_lebs</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_calc_available - calculate available FS space.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @min_idx_lebs: minimum number of LEBs reserved for the index</span>
<span class="cm"> *</span>
<span class="cm"> * This function calculates and returns amount of FS space available for use.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="nf">ubifs_calc_available</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min_idx_lebs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">subtract_lebs</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">available</span><span class="p">;</span>

	<span class="n">available</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_bytes</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_used</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now &#39;available&#39; contains theoretically available flash space</span>
<span class="cm">	 * assuming there is no index, so we have to subtract the space which</span>
<span class="cm">	 * is reserved for the index.</span>
<span class="cm">	 */</span>
	<span class="n">subtract_lebs</span> <span class="o">=</span> <span class="n">min_idx_lebs</span><span class="p">;</span>

	<span class="cm">/* Take into account that GC reserves one LEB for its own needs */</span>
	<span class="n">subtract_lebs</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The GC journal head LEB is not really accessible. And since</span>
<span class="cm">	 * different write types go to different heads, we may count only on</span>
<span class="cm">	 * one head&#39;s space.</span>
<span class="cm">	 */</span>
	<span class="n">subtract_lebs</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* We also reserve one LEB for deletions, which bypass budgeting */</span>
	<span class="n">subtract_lebs</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">available</span> <span class="o">-=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">subtract_lebs</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">;</span>

	<span class="cm">/* Subtract the dead space which is not available for use */</span>
	<span class="n">available</span> <span class="o">-=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_dead</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Subtract dark space, which might or might not be usable - it depends</span>
<span class="cm">	 * on the data which we have on the media and which will be written. If</span>
<span class="cm">	 * this is a lot of uncompressed or not-compressible data, the dark</span>
<span class="cm">	 * space cannot be used.</span>
<span class="cm">	 */</span>
	<span class="n">available</span> <span class="o">-=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_dark</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * However, there is more dark space. The index may be bigger than</span>
<span class="cm">	 * @min_idx_lebs. Those extra LEBs are assumed to be available, but</span>
<span class="cm">	 * their dark space is not included in total_dark, so it is subtracted</span>
<span class="cm">	 * here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">idx_lebs</span> <span class="o">&gt;</span> <span class="n">min_idx_lebs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">subtract_lebs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">idx_lebs</span> <span class="o">-</span> <span class="n">min_idx_lebs</span><span class="p">;</span>
		<span class="n">available</span> <span class="o">-=</span> <span class="n">subtract_lebs</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dark_wm</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The calculations are rough and may end up with a negative number */</span>
	<span class="k">return</span> <span class="n">available</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">available</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * can_use_rp - check whether the user is allowed to use reserved pool.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS has so-called &quot;reserved pool&quot; which is flash space reserved</span>
<span class="cm"> * for the superuser and for uses whose UID/GID is recorded in UBIFS superblock.</span>
<span class="cm"> * This function checks whether current user is allowed to use reserved pool.</span>
<span class="cm"> * Returns %1  current user is allowed to use reserved pool and %0 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">can_use_rp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current_fsuid</span><span class="p">()</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">rp_uid</span> <span class="o">||</span> <span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_RESOURCE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rp_gid</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">in_group_p</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rp_gid</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * do_budget_space - reserve flash space for index and data growth.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function makes sure UBIFS has enough free LEBs for index growth and</span>
<span class="cm"> * data.</span>
<span class="cm"> *</span>
<span class="cm"> * When budgeting index space, UBIFS reserves thrice as many LEBs as the index</span>
<span class="cm"> * would take if it was consolidated and written to the flash. This guarantees</span>
<span class="cm"> * that the &quot;in-the-gaps&quot; commit method always succeeds and UBIFS will always</span>
<span class="cm"> * be able to commit dirty index. So this function basically adds amount of</span>
<span class="cm"> * budgeted index space to the size of the current index, multiplies this by 3,</span>
<span class="cm"> * and makes sure this does not exceed the amount of free LEBs.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes about @c-&gt;bi.min_idx_lebs and @c-&gt;lst.idx_lebs variables:</span>
<span class="cm"> * o @c-&gt;lst.idx_lebs is the number of LEBs the index currently uses. It might</span>
<span class="cm"> *    be large, because UBIFS does not do any index consolidation as long as</span>
<span class="cm"> *    there is free space. IOW, the index may take a lot of LEBs, but the LEBs</span>
<span class="cm"> *    will contain a lot of dirt.</span>
<span class="cm"> * o @c-&gt;bi.min_idx_lebs is the number of LEBS the index presumably takes. IOW,</span>
<span class="cm"> *    the index may be consolidated to take up to @c-&gt;bi.min_idx_lebs LEBs.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero in case of success, and %-ENOSPC in case of</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_budget_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">outstanding</span><span class="p">,</span> <span class="n">available</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lebs</span><span class="p">,</span> <span class="n">rsvd_idx_lebs</span><span class="p">,</span> <span class="n">min_idx_lebs</span><span class="p">;</span>

	<span class="cm">/* First budget index space */</span>
	<span class="n">min_idx_lebs</span> <span class="o">=</span> <span class="n">ubifs_calc_min_idx_lebs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="cm">/* Now &#39;min_idx_lebs&#39; contains number of LEBs to reserve */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">min_idx_lebs</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">idx_lebs</span><span class="p">)</span>
		<span class="n">rsvd_idx_lebs</span> <span class="o">=</span> <span class="n">min_idx_lebs</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">idx_lebs</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rsvd_idx_lebs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The number of LEBs that are available to be used by the index is:</span>
<span class="cm">	 *</span>
<span class="cm">	 *    @c-&gt;lst.empty_lebs + @c-&gt;freeable_cnt + @c-&gt;idx_gc_cnt -</span>
<span class="cm">	 *    @c-&gt;lst.taken_empty_lebs</span>
<span class="cm">	 *</span>
<span class="cm">	 * @c-&gt;lst.empty_lebs are available because they are empty.</span>
<span class="cm">	 * @c-&gt;freeable_cnt are available because they contain only free and</span>
<span class="cm">	 * dirty space, @c-&gt;idx_gc_cnt are available because they are index</span>
<span class="cm">	 * LEBs that have been garbage collected and are awaiting the commit</span>
<span class="cm">	 * before they can be used. And the in-the-gaps method will grab these</span>
<span class="cm">	 * if it needs them. @c-&gt;lst.taken_empty_lebs are empty LEBs that have</span>
<span class="cm">	 * already been allocated for some purpose.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note, @c-&gt;idx_gc_cnt is included to both @c-&gt;lst.empty_lebs (because</span>
<span class="cm">	 * these LEBs are empty) and to @c-&gt;lst.taken_empty_lebs (because they</span>
<span class="cm">	 * are taken until after the commit).</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note, @c-&gt;lst.taken_empty_lebs may temporarily be higher by one</span>
<span class="cm">	 * because of the way we serialize LEB allocations and budgeting. See a</span>
<span class="cm">	 * comment in &#39;ubifs_find_free_space()&#39;.</span>
<span class="cm">	 */</span>
	<span class="n">lebs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">empty_lebs</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_cnt</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_gc_cnt</span> <span class="o">-</span>
	       <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">taken_empty_lebs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rsvd_idx_lebs</span> <span class="o">&gt;</span> <span class="n">lebs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dbg_budg</span><span class="p">(</span><span class="s">&quot;out of indexing space: min_idx_lebs %d (old %d), &quot;</span>
			 <span class="s">&quot;rsvd_idx_lebs %d&quot;</span><span class="p">,</span> <span class="n">min_idx_lebs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">min_idx_lebs</span><span class="p">,</span>
			 <span class="n">rsvd_idx_lebs</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">available</span> <span class="o">=</span> <span class="n">ubifs_calc_available</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">min_idx_lebs</span><span class="p">);</span>
	<span class="n">outstanding</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">data_growth</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">dd_growth</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">available</span> <span class="o">&lt;</span> <span class="n">outstanding</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dbg_budg</span><span class="p">(</span><span class="s">&quot;out of data space: available %lld, outstanding %lld&quot;</span><span class="p">,</span>
			 <span class="n">available</span><span class="p">,</span> <span class="n">outstanding</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">available</span> <span class="o">-</span> <span class="n">outstanding</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">rp_size</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">can_use_rp</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">min_idx_lebs</span> <span class="o">=</span> <span class="n">min_idx_lebs</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * calc_idx_growth - calculate approximate index growth from budgeting request.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @req: budgeting request</span>
<span class="cm"> *</span>
<span class="cm"> * For now we assume each new node adds one znode. But this is rather poor</span>
<span class="cm"> * approximation, though.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">calc_idx_growth</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">znodes</span><span class="p">;</span>

	<span class="n">znodes</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">new_ino</span> <span class="o">+</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">new_page</span> <span class="o">&lt;&lt;</span> <span class="n">UBIFS_BLOCKS_PER_PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span>
		 <span class="n">req</span><span class="o">-&gt;</span><span class="n">new_dent</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">znodes</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_idx_node_sz</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * calc_data_growth - calculate approximate amount of new data from budgeting</span>
<span class="cm"> * request.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @req: budgeting request</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">calc_data_growth</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">data_growth</span><span class="p">;</span>

	<span class="n">data_growth</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">new_ino</span>  <span class="o">?</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">inode_budget</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">new_page</span><span class="p">)</span>
		<span class="n">data_growth</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">page_budget</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">new_dent</span><span class="p">)</span>
		<span class="n">data_growth</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">dent_budget</span><span class="p">;</span>
	<span class="n">data_growth</span> <span class="o">+=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">new_ino_d</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">data_growth</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * calc_dd_growth - calculate approximate amount of data which makes other data</span>
<span class="cm"> * dirty from budgeting request.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @req: budgeting request</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">calc_dd_growth</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dd_growth</span><span class="p">;</span>

	<span class="n">dd_growth</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dirtied_page</span> <span class="o">?</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">page_budget</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">dirtied_ino</span><span class="p">)</span>
		<span class="n">dd_growth</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">inode_budget</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">dirtied_ino</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">mod_dent</span><span class="p">)</span>
		<span class="n">dd_growth</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">dent_budget</span><span class="p">;</span>
	<span class="n">dd_growth</span> <span class="o">+=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dirtied_ino_d</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dd_growth</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_budget_space - ensure there is enough space to complete an operation.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @req: budget request</span>
<span class="cm"> *</span>
<span class="cm"> * This function allocates budget for an operation. It uses pessimistic</span>
<span class="cm"> * approximation of how much flash space the operation needs. The goal of this</span>
<span class="cm"> * function is to make sure UBIFS always has flash space to flush all dirty</span>
<span class="cm"> * pages, dirty inodes, and dirty znodes (liability). This function may force</span>
<span class="cm"> * commit, garbage-collection or write-back. Returns zero in case of success,</span>
<span class="cm"> * %-ENOSPC if there is no free space and other negative error codes in case of</span>
<span class="cm"> * failures.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_budget_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">cmt_retries</span><span class="p">),</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">wb_retries</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">idx_growth</span><span class="p">,</span> <span class="n">data_growth</span><span class="p">,</span> <span class="n">dd_growth</span><span class="p">,</span> <span class="n">retried</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">new_page</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">dirtied_page</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">new_dent</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">mod_dent</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">new_ino</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">new_ino_d</span> <span class="o">&lt;=</span> <span class="n">UBIFS_MAX_INO_DATA</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">dirtied_ino</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">dirtied_ino_d</span> <span class="o">&lt;=</span> <span class="n">UBIFS_MAX_INO_DATA</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">new_ino_d</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">dirtied_ino_d</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">));</span>

	<span class="n">data_growth</span> <span class="o">=</span> <span class="n">calc_data_growth</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="n">dd_growth</span> <span class="o">=</span> <span class="n">calc_dd_growth</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data_growth</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dd_growth</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">idx_growth</span> <span class="o">=</span> <span class="n">calc_idx_growth</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>

<span class="nl">again:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">idx_growth</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">data_growth</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">dd_growth</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">nospace</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">nospace_rp</span> <span class="o">||</span> <span class="o">!</span><span class="n">can_use_rp</span><span class="p">(</span><span class="n">c</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">dbg_budg</span><span class="p">(</span><span class="s">&quot;no space&quot;</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">idx_growth</span> <span class="o">+=</span> <span class="n">idx_growth</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">data_growth</span> <span class="o">+=</span> <span class="n">data_growth</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">dd_growth</span> <span class="o">+=</span> <span class="n">dd_growth</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">do_budget_space</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">idx_growth</span> <span class="o">=</span> <span class="n">idx_growth</span><span class="p">;</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">data_growth</span> <span class="o">=</span> <span class="n">data_growth</span><span class="p">;</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">dd_growth</span> <span class="o">=</span> <span class="n">dd_growth</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Restore the old values */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">idx_growth</span> <span class="o">-=</span> <span class="n">idx_growth</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">data_growth</span> <span class="o">-=</span> <span class="n">data_growth</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">dd_growth</span> <span class="o">-=</span> <span class="n">dd_growth</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">fast</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_budg</span><span class="p">(</span><span class="s">&quot;no space for fast budgeting&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">make_free_space</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">cond_resched</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_budg</span><span class="p">(</span><span class="s">&quot;try again&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retried</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retried</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">dbg_budg</span><span class="p">(</span><span class="s">&quot;-ENOSPC, but anyway try once again&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dbg_budg</span><span class="p">(</span><span class="s">&quot;FS is full, -ENOSPC&quot;</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">nospace</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">can_use_rp</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">rp_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">nospace_rp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot budget space, error %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_release_budget - release budgeted free space.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @req: budget request</span>
<span class="cm"> *</span>
<span class="cm"> * This function releases the space budgeted by &#39;ubifs_budget_space()&#39;. Note,</span>
<span class="cm"> * since the index changes (which were budgeted for in @req-&gt;idx_growth) will</span>
<span class="cm"> * only be written to the media on commit, this function moves the index budget</span>
<span class="cm"> * from @c-&gt;bi.idx_growth to @c-&gt;bi.uncommitted_idx. The latter will be zeroed</span>
<span class="cm"> * by the commit operation.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubifs_release_budget</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">new_page</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">dirtied_page</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">new_dent</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">mod_dent</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">new_ino</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">new_ino_d</span> <span class="o">&lt;=</span> <span class="n">UBIFS_MAX_INO_DATA</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">dirtied_ino</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">dirtied_ino_d</span> <span class="o">&lt;=</span> <span class="n">UBIFS_MAX_INO_DATA</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">new_ino_d</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">dirtied_ino_d</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">recalculate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">idx_growth</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">data_growth</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">dd_growth</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">recalculate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">data_growth</span> <span class="o">=</span> <span class="n">calc_data_growth</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">dd_growth</span> <span class="o">=</span> <span class="n">calc_dd_growth</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">idx_growth</span> <span class="o">=</span> <span class="n">calc_idx_growth</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">data_growth</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">dd_growth</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">nospace</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">nospace_rp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">idx_growth</span> <span class="o">-=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">idx_growth</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">uncommitted_idx</span> <span class="o">+=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">idx_growth</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">data_growth</span> <span class="o">-=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">data_growth</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">dd_growth</span> <span class="o">-=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dd_growth</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">min_idx_lebs</span> <span class="o">=</span> <span class="n">ubifs_calc_min_idx_lebs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">idx_growth</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">data_growth</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">dd_growth</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">min_idx_lebs</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_lebs</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">idx_growth</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">data_growth</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">dd_growth</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">));</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_convert_page_budget - convert budget of a new page.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function converts budget which was allocated for a new page of data to</span>
<span class="cm"> * the budget of changing an existing page of data. The latter is smaller than</span>
<span class="cm"> * the former, so this function only does simple re-calculation and does not</span>
<span class="cm"> * involve any write-back.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubifs_convert_page_budget</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
	<span class="cm">/* Release the index growth reservation */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">idx_growth</span> <span class="o">-=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_idx_node_sz</span> <span class="o">&lt;&lt;</span> <span class="n">UBIFS_BLOCKS_PER_PAGE_SHIFT</span><span class="p">;</span>
	<span class="cm">/* Release the data growth reservation */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">data_growth</span> <span class="o">-=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">page_budget</span><span class="p">;</span>
	<span class="cm">/* Increase the dirty data growth reservation instead */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">dd_growth</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">page_budget</span><span class="p">;</span>
	<span class="cm">/* And re-calculate the indexing space reservation */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">min_idx_lebs</span> <span class="o">=</span> <span class="n">ubifs_calc_min_idx_lebs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_release_dirty_inode_budget - release dirty inode budget.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @ui: UBIFS inode to release the budget for</span>
<span class="cm"> *</span>
<span class="cm"> * This function releases budget corresponding to a dirty inode. It is usually</span>
<span class="cm"> * called when after the inode has been written to the media and marked as</span>
<span class="cm"> * clean. It also causes the &quot;no space&quot; flags to be cleared.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubifs_release_dirty_inode_budget</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="n">req</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_budget_req</span><span class="p">));</span>
	<span class="cm">/* The &quot;no space&quot; flags will be cleared because dd_growth is &gt; 0 */</span>
	<span class="n">req</span><span class="p">.</span><span class="n">dd_growth</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">inode_budget</span> <span class="o">+</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_reported_space - calculate reported free space.</span>
<span class="cm"> * @c: the UBIFS file-system description object</span>
<span class="cm"> * @free: amount of free space</span>
<span class="cm"> *</span>
<span class="cm"> * This function calculates amount of free space which will be reported to</span>
<span class="cm"> * user-space. User-space application tend to expect that if the file-system</span>
<span class="cm"> * (e.g., via the &#39;statfs()&#39; call) reports that it has N bytes available, they</span>
<span class="cm"> * are able to write a file of size N. UBIFS attaches node headers to each data</span>
<span class="cm"> * node and it has to write indexing nodes as well. This introduces additional</span>
<span class="cm"> * overhead, and UBIFS has to report slightly less free space to meet the above</span>
<span class="cm"> * expectations.</span>
<span class="cm"> *</span>
<span class="cm"> * This function assumes free space is made up of uncompressed data nodes and</span>
<span class="cm"> * full index nodes (one per data node, tripled because we always allow enough</span>
<span class="cm"> * space to write the index thrice).</span>
<span class="cm"> *</span>
<span class="cm"> * Note, the calculation is pessimistic, which means that most of the time</span>
<span class="cm"> * UBIFS reports less space than it actually has.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="nf">ubifs_reported_space</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">free</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">divisor</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">f</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reported space size is @free * X, where X is UBIFS block size</span>
<span class="cm">	 * divided by UBIFS block size + all overhead one data block</span>
<span class="cm">	 * introduces. The overhead is the node header + indexing overhead.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Indexing overhead calculations are based on the following formula:</span>
<span class="cm">	 * I = N/(f - 1) + 1, where I - number of indexing nodes, N - number</span>
<span class="cm">	 * of data nodes, f - fanout. Because effective UBIFS fanout is twice</span>
<span class="cm">	 * as less than maximum fanout, we assume that each data node</span>
<span class="cm">	 * introduces 3 * @c-&gt;max_idx_node_sz / (@c-&gt;fanout/2 - 1) bytes.</span>
<span class="cm">	 * Note, the multiplier 3 is because UBIFS reserves thrice as more space</span>
<span class="cm">	 * for the index.</span>
<span class="cm">	 */</span>
	<span class="n">f</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="o">?</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">factor</span> <span class="o">=</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">;</span>
	<span class="n">divisor</span> <span class="o">=</span> <span class="n">UBIFS_MAX_DATA_NODE_SZ</span><span class="p">;</span>
	<span class="n">divisor</span> <span class="o">+=</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_idx_node_sz</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">f</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">free</span> <span class="o">*=</span> <span class="n">factor</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">free</span><span class="p">,</span> <span class="n">divisor</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_get_free_space_nolock - return amount of free space.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function calculates amount of free space to report to user-space.</span>
<span class="cm"> *</span>
<span class="cm"> * Because UBIFS may introduce substantial overhead (the index, node headers,</span>
<span class="cm"> * alignment, wastage at the end of LEBs, etc), it cannot report real amount of</span>
<span class="cm"> * free flash space it has (well, because not all dirty space is reclaimable,</span>
<span class="cm"> * UBIFS does not actually know the real amount). If UBIFS did so, it would</span>
<span class="cm"> * bread user expectations about what free space is. Users seem to accustomed</span>
<span class="cm"> * to assume that if the file-system reports N bytes of free space, they would</span>
<span class="cm"> * be able to fit a file of N bytes to the FS. This almost works for</span>
<span class="cm"> * traditional file-systems, because they have way less overhead than UBIFS.</span>
<span class="cm"> * So, to keep users happy, UBIFS tries to take the overhead into account.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="nf">ubifs_get_free_space_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rsvd_idx_lebs</span><span class="p">,</span> <span class="n">lebs</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">available</span><span class="p">,</span> <span class="n">outstanding</span><span class="p">,</span> <span class="n">free</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">min_idx_lebs</span> <span class="o">==</span> <span class="n">ubifs_calc_min_idx_lebs</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
	<span class="n">outstanding</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">data_growth</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">dd_growth</span><span class="p">;</span>
	<span class="n">available</span> <span class="o">=</span> <span class="n">ubifs_calc_available</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">min_idx_lebs</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * When reporting free space to user-space, UBIFS guarantees that it is</span>
<span class="cm">	 * possible to write a file of free space size. This means that for</span>
<span class="cm">	 * empty LEBs we may use more precise calculations than</span>
<span class="cm">	 * &#39;ubifs_calc_available()&#39; is using. Namely, we know that in empty</span>
<span class="cm">	 * LEBs we would waste only @c-&gt;leb_overhead bytes, not @c-&gt;dark_wm.</span>
<span class="cm">	 * Thus, amend the available space.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note, the calculations below are similar to what we have in</span>
<span class="cm">	 * &#39;do_budget_space()&#39;, so refer there for comments.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">min_idx_lebs</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">idx_lebs</span><span class="p">)</span>
		<span class="n">rsvd_idx_lebs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">min_idx_lebs</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">idx_lebs</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rsvd_idx_lebs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lebs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">empty_lebs</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_cnt</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_gc_cnt</span> <span class="o">-</span>
	       <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">taken_empty_lebs</span><span class="p">;</span>
	<span class="n">lebs</span> <span class="o">-=</span> <span class="n">rsvd_idx_lebs</span><span class="p">;</span>
	<span class="n">available</span> <span class="o">+=</span> <span class="n">lebs</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dark_wm</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_overhead</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">available</span> <span class="o">&gt;</span> <span class="n">outstanding</span><span class="p">)</span>
		<span class="n">free</span> <span class="o">=</span> <span class="n">ubifs_reported_space</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">available</span> <span class="o">-</span> <span class="n">outstanding</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">free</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_get_free_space - return amount of free space.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function calculates and returns amount of free space to report to</span>
<span class="cm"> * user-space.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="nf">ubifs_get_free_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">free</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
	<span class="n">free</span> <span class="o">=</span> <span class="n">ubifs_get_free_space_nolock</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">free</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
