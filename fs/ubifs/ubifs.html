<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ubifs › ubifs.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ubifs.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is part of UBIFS.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Nokia Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="cm"> * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> *          Adrian Hunter</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __UBIFS_H__</span>
<span class="cp">#define __UBIFS_H__</span>

<span class="cp">#include &lt;asm/div64.h&gt;</span>
<span class="cp">#include &lt;linux/statfs.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/rwsem.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/ubi.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &quot;ubifs-media.h&quot;</span>

<span class="cm">/* Version of this UBIFS implementation */</span>
<span class="cp">#define UBIFS_VERSION 1</span>

<span class="cm">/* Normal UBIFS messages */</span>
<span class="cp">#define ubifs_msg(fmt, ...) \</span>
<span class="cp">		printk(KERN_NOTICE &quot;UBIFS: &quot; fmt &quot;\n&quot;, ##__VA_ARGS__)</span>
<span class="cm">/* UBIFS error messages */</span>
<span class="cp">#define ubifs_err(fmt, ...)                                                  \</span>
<span class="cp">	printk(KERN_ERR &quot;UBIFS error (pid %d): %s: &quot; fmt &quot;\n&quot;, current-&gt;pid, \</span>
<span class="cp">	       __func__, ##__VA_ARGS__)</span>
<span class="cm">/* UBIFS warning messages */</span>
<span class="cp">#define ubifs_warn(fmt, ...)                                         \</span>
<span class="cp">	printk(KERN_WARNING &quot;UBIFS warning (pid %d): %s: &quot; fmt &quot;\n&quot;, \</span>
<span class="cp">	       current-&gt;pid, __func__, ##__VA_ARGS__)</span>

<span class="cm">/* UBIFS file system VFS magic number */</span>
<span class="cp">#define UBIFS_SUPER_MAGIC 0x24051905</span>

<span class="cm">/* Number of UBIFS blocks per VFS page */</span>
<span class="cp">#define UBIFS_BLOCKS_PER_PAGE (PAGE_CACHE_SIZE / UBIFS_BLOCK_SIZE)</span>
<span class="cp">#define UBIFS_BLOCKS_PER_PAGE_SHIFT (PAGE_CACHE_SHIFT - UBIFS_BLOCK_SHIFT)</span>

<span class="cm">/* &quot;File system end of life&quot; sequence number watermark */</span>
<span class="cp">#define SQNUM_WARN_WATERMARK 0xFFFFFFFF00000000ULL</span>
<span class="cp">#define SQNUM_WATERMARK      0xFFFFFFFFFF000000ULL</span>

<span class="cm">/*</span>
<span class="cm"> * Minimum amount of LEBs reserved for the index. At present the index needs at</span>
<span class="cm"> * least 2 LEBs: one for the index head and one for in-the-gaps method (which</span>
<span class="cm"> * currently does not cater for the index head and so excludes it from</span>
<span class="cm"> * consideration).</span>
<span class="cm"> */</span>
<span class="cp">#define MIN_INDEX_LEBS 2</span>

<span class="cm">/* Minimum amount of data UBIFS writes to the flash */</span>
<span class="cp">#define MIN_WRITE_SZ (UBIFS_DATA_NODE_SZ + 8)</span>

<span class="cm">/*</span>
<span class="cm"> * Currently we do not support inode number overlapping and re-using, so this</span>
<span class="cm"> * watermark defines dangerous inode number level. This should be fixed later,</span>
<span class="cm"> * although it is difficult to exceed current limit. Another option is to use</span>
<span class="cm"> * 64-bit inode numbers, but this means more overhead.</span>
<span class="cm"> */</span>
<span class="cp">#define INUM_WARN_WATERMARK 0xFFF00000</span>
<span class="cp">#define INUM_WATERMARK      0xFFFFFF00</span>

<span class="cm">/* Maximum number of entries in each LPT (LEB category) heap */</span>
<span class="cp">#define LPT_HEAP_SZ 256</span>

<span class="cm">/*</span>
<span class="cm"> * Background thread name pattern. The numbers are UBI device and volume</span>
<span class="cm"> * numbers.</span>
<span class="cm"> */</span>
<span class="cp">#define BGT_NAME_PATTERN &quot;ubifs_bgt%d_%d&quot;</span>

<span class="cm">/* Write-buffer synchronization timeout interval in seconds */</span>
<span class="cp">#define WBUF_TIMEOUT_SOFTLIMIT 3</span>
<span class="cp">#define WBUF_TIMEOUT_HARDLIMIT 5</span>

<span class="cm">/* Maximum possible inode number (only 32-bit inodes are supported now) */</span>
<span class="cp">#define MAX_INUM 0xFFFFFFFF</span>

<span class="cm">/* Number of non-data journal heads */</span>
<span class="cp">#define NONDATA_JHEADS_CNT 2</span>

<span class="cm">/* Shorter names for journal head numbers for internal usage */</span>
<span class="cp">#define GCHD   UBIFS_GC_HEAD</span>
<span class="cp">#define BASEHD UBIFS_BASE_HEAD</span>
<span class="cp">#define DATAHD UBIFS_DATA_HEAD</span>

<span class="cm">/* &#39;No change&#39; value for &#39;ubifs_change_lp()&#39; */</span>
<span class="cp">#define LPROPS_NC 0x80000001</span>

<span class="cm">/*</span>
<span class="cm"> * There is no notion of truncation key because truncation nodes do not exist</span>
<span class="cm"> * in TNC. However, when replaying, it is handy to introduce fake &quot;truncation&quot;</span>
<span class="cm"> * keys for truncation nodes because the code becomes simpler. So we define</span>
<span class="cm"> * %UBIFS_TRUN_KEY type.</span>
<span class="cm"> *</span>
<span class="cm"> * But otherwise, out of the journal reply scope, the truncation keys are</span>
<span class="cm"> * invalid.</span>
<span class="cm"> */</span>
<span class="cp">#define UBIFS_TRUN_KEY    UBIFS_KEY_TYPES_CNT</span>
<span class="cp">#define UBIFS_INVALID_KEY UBIFS_KEY_TYPES_CNT</span>

<span class="cm">/*</span>
<span class="cm"> * How much a directory entry/extended attribute entry adds to the parent/host</span>
<span class="cm"> * inode.</span>
<span class="cm"> */</span>
<span class="cp">#define CALC_DENT_SIZE(name_len) ALIGN(UBIFS_DENT_NODE_SZ + (name_len) + 1, 8)</span>

<span class="cm">/* How much an extended attribute adds to the host inode */</span>
<span class="cp">#define CALC_XATTR_BYTES(data_len) ALIGN(UBIFS_INO_NODE_SZ + (data_len) + 1, 8)</span>

<span class="cm">/*</span>
<span class="cm"> * Znodes which were not touched for &#39;OLD_ZNODE_AGE&#39; seconds are considered</span>
<span class="cm"> * &quot;old&quot;, and znode which were touched last &#39;YOUNG_ZNODE_AGE&#39; seconds ago are</span>
<span class="cm"> * considered &quot;young&quot;. This is used by shrinker when selecting znode to trim</span>
<span class="cm"> * off.</span>
<span class="cm"> */</span>
<span class="cp">#define OLD_ZNODE_AGE 20</span>
<span class="cp">#define YOUNG_ZNODE_AGE 5</span>

<span class="cm">/*</span>
<span class="cm"> * Some compressors, like LZO, may end up with more data then the input buffer.</span>
<span class="cm"> * So UBIFS always allocates larger output buffer, to be sure the compressor</span>
<span class="cm"> * will not corrupt memory in case of worst case compression.</span>
<span class="cm"> */</span>
<span class="cp">#define WORST_COMPR_FACTOR 2</span>

<span class="cm">/*</span>
<span class="cm"> * How much memory is needed for a buffer where we comress a data node.</span>
<span class="cm"> */</span>
<span class="cp">#define COMPRESSED_DATA_NODE_BUF_SZ \</span>
<span class="cp">	(UBIFS_DATA_NODE_SZ + UBIFS_BLOCK_SIZE * WORST_COMPR_FACTOR)</span>

<span class="cm">/* Maximum expected tree height for use by bottom_up_buf */</span>
<span class="cp">#define BOTTOM_UP_HEIGHT 64</span>

<span class="cm">/* Maximum number of data nodes to bulk-read */</span>
<span class="cp">#define UBIFS_MAX_BULK_READ 32</span>

<span class="cm">/*</span>
<span class="cm"> * Lockdep classes for UBIFS inode @ui_mutex.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">WB_MUTEX_1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">WB_MUTEX_2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">WB_MUTEX_3</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Znode flags (actually, bit numbers which store the flags).</span>
<span class="cm"> *</span>
<span class="cm"> * DIRTY_ZNODE: znode is dirty</span>
<span class="cm"> * COW_ZNODE: znode is being committed and a new instance of this znode has to</span>
<span class="cm"> *            be created before changing this znode</span>
<span class="cm"> * OBSOLETE_ZNODE: znode is obsolete, which means it was deleted, but it is</span>
<span class="cm"> *                 still in the commit list and the ongoing commit operation</span>
<span class="cm"> *                 will commit it, and delete this znode after it is done</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">DIRTY_ZNODE</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">COW_ZNODE</span>      <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">OBSOLETE_ZNODE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Commit states.</span>
<span class="cm"> *</span>
<span class="cm"> * COMMIT_RESTING: commit is not wanted</span>
<span class="cm"> * COMMIT_BACKGROUND: background commit has been requested</span>
<span class="cm"> * COMMIT_REQUIRED: commit is required</span>
<span class="cm"> * COMMIT_RUNNING_BACKGROUND: background commit is running</span>
<span class="cm"> * COMMIT_RUNNING_REQUIRED: commit is running and it is required</span>
<span class="cm"> * COMMIT_BROKEN: commit failed</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">COMMIT_RESTING</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">COMMIT_BACKGROUND</span><span class="p">,</span>
	<span class="n">COMMIT_REQUIRED</span><span class="p">,</span>
	<span class="n">COMMIT_RUNNING_BACKGROUND</span><span class="p">,</span>
	<span class="n">COMMIT_RUNNING_REQUIRED</span><span class="p">,</span>
	<span class="n">COMMIT_BROKEN</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * &#39;ubifs_scan_a_node()&#39; return values.</span>
<span class="cm"> *</span>
<span class="cm"> * SCANNED_GARBAGE:  scanned garbage</span>
<span class="cm"> * SCANNED_EMPTY_SPACE: scanned empty space</span>
<span class="cm"> * SCANNED_A_NODE: scanned a valid node</span>
<span class="cm"> * SCANNED_A_CORRUPT_NODE: scanned a corrupted node</span>
<span class="cm"> * SCANNED_A_BAD_PAD_NODE: scanned a padding node with invalid pad length</span>
<span class="cm"> *</span>
<span class="cm"> * Greater than zero means: &#39;scanned that number of padding bytes&#39;</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SCANNED_GARBAGE</span>        <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SCANNED_EMPTY_SPACE</span>    <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="n">SCANNED_A_NODE</span>         <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
	<span class="n">SCANNED_A_CORRUPT_NODE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>
	<span class="n">SCANNED_A_BAD_PAD_NODE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * LPT cnode flag bits.</span>
<span class="cm"> *</span>
<span class="cm"> * DIRTY_CNODE: cnode is dirty</span>
<span class="cm"> * OBSOLETE_CNODE: cnode is being committed and has been copied (or deleted),</span>
<span class="cm"> *                 so it can (and must) be freed when the commit is finished</span>
<span class="cm"> * COW_CNODE: cnode is being committed and must be copied before writing</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">DIRTY_CNODE</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">OBSOLETE_CNODE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">COW_CNODE</span>      <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Dirty flag bits (lpt_drty_flgs) for LPT special nodes.</span>
<span class="cm"> *</span>
<span class="cm"> * LTAB_DIRTY: ltab node is dirty</span>
<span class="cm"> * LSAVE_DIRTY: lsave node is dirty</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">LTAB_DIRTY</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">LSAVE_DIRTY</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Return codes used by the garbage collector.</span>
<span class="cm"> * @LEB_FREED: the logical eraseblock was freed and is ready to use</span>
<span class="cm"> * @LEB_FREED_IDX: indexing LEB was freed and can be used only after the commit</span>
<span class="cm"> * @LEB_RETAINED: the logical eraseblock was freed and retained for GC purposes</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">LEB_FREED</span><span class="p">,</span>
	<span class="n">LEB_FREED_IDX</span><span class="p">,</span>
	<span class="n">LEB_RETAINED</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_old_idx - index node obsoleted since last commit start.</span>
<span class="cm"> * @rb: rb-tree node</span>
<span class="cm"> * @lnum: LEB number of obsoleted index node</span>
<span class="cm"> * @offs: offset of obsoleted index node</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_old_idx</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offs</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The below union makes it easier to deal with keys */</span>
<span class="k">union</span> <span class="n">ubifs_key</span> <span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">u8</span><span class="p">[</span><span class="n">UBIFS_SK_LEN</span><span class="p">];</span>
	<span class="kt">uint32_t</span> <span class="n">u32</span><span class="p">[</span><span class="n">UBIFS_SK_LEN</span><span class="o">/</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">[</span><span class="n">UBIFS_SK_LEN</span><span class="o">/</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">__le32</span> <span class="n">j32</span><span class="p">[</span><span class="n">UBIFS_SK_LEN</span><span class="o">/</span><span class="mi">4</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_scan_node - UBIFS scanned node information.</span>
<span class="cm"> * @list: list of scanned nodes</span>
<span class="cm"> * @key: key of node scanned (if it has one)</span>
<span class="cm"> * @sqnum: sequence number</span>
<span class="cm"> * @type: type of node scanned</span>
<span class="cm"> * @offs: offset with LEB of node scanned</span>
<span class="cm"> * @len: length of node scanned</span>
<span class="cm"> * @node: raw node</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_scan_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sqnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_scan_leb - UBIFS scanned LEB information.</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> * @nodes_cnt: number of nodes scanned</span>
<span class="cm"> * @nodes: list of struct ubifs_scan_node</span>
<span class="cm"> * @endpt: end point (and therefore the start of empty space)</span>
<span class="cm"> * @ecc: read returned -EBADMSG</span>
<span class="cm"> * @buf: buffer containing entire LEB scanned</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nodes_cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">nodes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">endpt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ecc</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_gced_idx_leb - garbage-collected indexing LEB.</span>
<span class="cm"> * @list: list</span>
<span class="cm"> * @lnum: LEB number</span>
<span class="cm"> * @unmap: OK to unmap this LEB</span>
<span class="cm"> *</span>
<span class="cm"> * This data structure is used to temporary store garbage-collected indexing</span>
<span class="cm"> * LEBs - they are not released immediately, but only after the next commit.</span>
<span class="cm"> * This is needed to guarantee recoverability.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_gced_idx_leb</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">unmap</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_inode - UBIFS in-memory inode description.</span>
<span class="cm"> * @vfs_inode: VFS inode description object</span>
<span class="cm"> * @creat_sqnum: sequence number at time of creation</span>
<span class="cm"> * @del_cmtno: commit number corresponding to the time the inode was deleted,</span>
<span class="cm"> *             protected by @c-&gt;commit_sem;</span>
<span class="cm"> * @xattr_size: summarized size of all extended attributes in bytes</span>
<span class="cm"> * @xattr_cnt: count of extended attributes this inode has</span>
<span class="cm"> * @xattr_names: sum of lengths of all extended attribute names belonging to</span>
<span class="cm"> *               this inode</span>
<span class="cm"> * @dirty: non-zero if the inode is dirty</span>
<span class="cm"> * @xattr: non-zero if this is an extended attribute inode</span>
<span class="cm"> * @bulk_read: non-zero if bulk-read should be used</span>
<span class="cm"> * @ui_mutex: serializes inode write-back with the rest of VFS operations,</span>
<span class="cm"> *            serializes &quot;clean &lt;-&gt; dirty&quot; state changes, serializes bulk-read,</span>
<span class="cm"> *            protects @dirty, @bulk_read, @ui_size, and @xattr_size</span>
<span class="cm"> * @ui_lock: protects @synced_i_size</span>
<span class="cm"> * @synced_i_size: synchronized size of inode, i.e. the value of inode size</span>
<span class="cm"> *                 currently stored on the flash; used only for regular file</span>
<span class="cm"> *                 inodes</span>
<span class="cm"> * @ui_size: inode size used by UBIFS when writing to flash</span>
<span class="cm"> * @flags: inode flags (@UBIFS_COMPR_FL, etc)</span>
<span class="cm"> * @compr_type: default compression type used for this inode</span>
<span class="cm"> * @last_page_read: page number of last page read (for bulk read)</span>
<span class="cm"> * @read_in_a_row: number of consecutive pages read in a row (for bulk read)</span>
<span class="cm"> * @data_len: length of the data attached to the inode</span>
<span class="cm"> * @data: inode&#39;s data</span>
<span class="cm"> *</span>
<span class="cm"> * @ui_mutex exists for two main reasons. At first it prevents inodes from</span>
<span class="cm"> * being written back while UBIFS changing them, being in the middle of an VFS</span>
<span class="cm"> * operation. This way UBIFS makes sure the inode fields are consistent. For</span>
<span class="cm"> * example, in &#39;ubifs_rename()&#39; we change 3 inodes simultaneously, and</span>
<span class="cm"> * write-back must not write any of them before we have finished.</span>
<span class="cm"> *</span>
<span class="cm"> * The second reason is budgeting - UBIFS has to budget all operations. If an</span>
<span class="cm"> * operation is going to mark an inode dirty, it has to allocate budget for</span>
<span class="cm"> * this. It cannot just mark it dirty because there is no guarantee there will</span>
<span class="cm"> * be enough flash space to write the inode back later. This means UBIFS has</span>
<span class="cm"> * to have full control over inode &quot;clean &lt;-&gt; dirty&quot; transitions (and pages</span>
<span class="cm"> * actually). But unfortunately, VFS marks inodes dirty in many places, and it</span>
<span class="cm"> * does not ask the file-system if it is allowed to do so (there is a notifier,</span>
<span class="cm"> * but it is not enough), i.e., there is no mechanism to synchronize with this.</span>
<span class="cm"> * So UBIFS has its own inode dirty flag and its own mutex to serialize</span>
<span class="cm"> * &quot;clean &lt;-&gt; dirty&quot; transitions.</span>
<span class="cm"> *</span>
<span class="cm"> * The @synced_i_size field is used to make sure we never write pages which are</span>
<span class="cm"> * beyond last synchronized inode size. See &#39;ubifs_writepage()&#39; for more</span>
<span class="cm"> * information.</span>
<span class="cm"> *</span>
<span class="cm"> * The @ui_size is a &quot;shadow&quot; variable for @inode-&gt;i_size and UBIFS uses</span>
<span class="cm"> * @ui_size instead of @inode-&gt;i_size. The reason for this is that UBIFS cannot</span>
<span class="cm"> * make sure @inode-&gt;i_size is always changed under @ui_mutex, because it</span>
<span class="cm"> * cannot call &#39;truncate_setsize()&#39; with @ui_mutex locked, because it would</span>
<span class="cm"> * deadlock with &#39;ubifs_writepage()&#39; (see file.c). All the other inode fields</span>
<span class="cm"> * are changed under @ui_mutex, so they do not need &quot;shadow&quot; fields. Note, one</span>
<span class="cm"> * could consider to rework locking and base it on &quot;shadow&quot; fields.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="n">vfs_inode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">creat_sqnum</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">del_cmtno</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xattr_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xattr_cnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xattr_names</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dirty</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xattr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bulk_read</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">compr_type</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">ui_mutex</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">ui_lock</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">synced_i_size</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">ui_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">last_page_read</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">read_in_a_row</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">data_len</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_unclean_leb - records a LEB recovered under read-only mode.</span>
<span class="cm"> * @list: list</span>
<span class="cm"> * @lnum: LEB number of recovered LEB</span>
<span class="cm"> * @endpt: offset where recovery ended</span>
<span class="cm"> *</span>
<span class="cm"> * This structure records a LEB identified during recovery that needs to be</span>
<span class="cm"> * cleaned but was not because UBIFS was mounted read-only. The information</span>
<span class="cm"> * is used to clean the LEB when remounting to read-write mode.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_unclean_leb</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">endpt</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * LEB properties flags.</span>
<span class="cm"> *</span>
<span class="cm"> * LPROPS_UNCAT: not categorized</span>
<span class="cm"> * LPROPS_DIRTY: dirty &gt; free, dirty &gt;= @c-&gt;dead_wm, not index</span>
<span class="cm"> * LPROPS_DIRTY_IDX: dirty + free &gt; @c-&gt;min_idx_node_sze and index</span>
<span class="cm"> * LPROPS_FREE: free &gt; 0, dirty &lt; @c-&gt;dead_wm, not empty, not index</span>
<span class="cm"> * LPROPS_HEAP_CNT: number of heaps used for storing categorized LEBs</span>
<span class="cm"> * LPROPS_EMPTY: LEB is empty, not taken</span>
<span class="cm"> * LPROPS_FREEABLE: free + dirty == leb_size, not index, not taken</span>
<span class="cm"> * LPROPS_FRDI_IDX: free + dirty == leb_size and index, may be taken</span>
<span class="cm"> * LPROPS_CAT_MASK: mask for the LEB categories above</span>
<span class="cm"> * LPROPS_TAKEN: LEB was taken (this flag is not saved on the media)</span>
<span class="cm"> * LPROPS_INDEX: LEB contains indexing nodes (this flag also exists on flash)</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">LPROPS_UNCAT</span>     <span class="o">=</span>  <span class="mi">0</span><span class="p">,</span>
	<span class="n">LPROPS_DIRTY</span>     <span class="o">=</span>  <span class="mi">1</span><span class="p">,</span>
	<span class="n">LPROPS_DIRTY_IDX</span> <span class="o">=</span>  <span class="mi">2</span><span class="p">,</span>
	<span class="n">LPROPS_FREE</span>      <span class="o">=</span>  <span class="mi">3</span><span class="p">,</span>
	<span class="n">LPROPS_HEAP_CNT</span>  <span class="o">=</span>  <span class="mi">3</span><span class="p">,</span>
	<span class="n">LPROPS_EMPTY</span>     <span class="o">=</span>  <span class="mi">4</span><span class="p">,</span>
	<span class="n">LPROPS_FREEABLE</span>  <span class="o">=</span>  <span class="mi">5</span><span class="p">,</span>
	<span class="n">LPROPS_FRDI_IDX</span>  <span class="o">=</span>  <span class="mi">6</span><span class="p">,</span>
	<span class="n">LPROPS_CAT_MASK</span>  <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
	<span class="n">LPROPS_TAKEN</span>     <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	<span class="n">LPROPS_INDEX</span>     <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_lprops - logical eraseblock properties.</span>
<span class="cm"> * @free: amount of free space in bytes</span>
<span class="cm"> * @dirty: amount of dirty space in bytes</span>
<span class="cm"> * @flags: LEB properties flags (see above)</span>
<span class="cm"> * @lnum: LEB number</span>
<span class="cm"> * @list: list of same-category lprops (for LPROPS_EMPTY and LPROPS_FREEABLE)</span>
<span class="cm"> * @hpos: heap position in heap of same-category lprops (other categories)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">free</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dirty</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">hpos</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_lpt_lprops - LPT logical eraseblock properties.</span>
<span class="cm"> * @free: amount of free space in bytes</span>
<span class="cm"> * @dirty: amount of dirty space in bytes</span>
<span class="cm"> * @tgc: trivial GC flag (1 =&gt; unmap after commit end)</span>
<span class="cm"> * @cmt: commit flag (1 =&gt; reserved for commit)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_lpt_lprops</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">free</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dirty</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">tgc</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">cmt</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_lp_stats - statistics of eraseblocks in the main area.</span>
<span class="cm"> * @empty_lebs: number of empty LEBs</span>
<span class="cm"> * @taken_empty_lebs: number of taken LEBs</span>
<span class="cm"> * @idx_lebs: number of indexing LEBs</span>
<span class="cm"> * @total_free: total free space in bytes (includes all LEBs)</span>
<span class="cm"> * @total_dirty: total dirty space in bytes (includes all LEBs)</span>
<span class="cm"> * @total_used: total used space in bytes (does not include index LEBs)</span>
<span class="cm"> * @total_dead: total dead space in bytes (does not include index LEBs)</span>
<span class="cm"> * @total_dark: total dark space in bytes (does not include index LEBs)</span>
<span class="cm"> *</span>
<span class="cm"> * The @taken_empty_lebs field counts the LEBs that are in the transient state</span>
<span class="cm"> * of having been &quot;taken&quot; for use but not yet written to. @taken_empty_lebs is</span>
<span class="cm"> * needed to account correctly for @gc_lnum, otherwise @empty_lebs could be</span>
<span class="cm"> * used by itself (in which case &#39;unused_lebs&#39; would be a better name). In the</span>
<span class="cm"> * case of @gc_lnum, it is &quot;taken&quot; at mount time or whenever a LEB is retained</span>
<span class="cm"> * by GC, but unlike other empty LEBs that are &quot;taken&quot;, it may not be written</span>
<span class="cm"> * straight away (i.e. before the next commit start or unmount), so either</span>
<span class="cm"> * @gc_lnum must be specially accounted for, or the current approach followed</span>
<span class="cm"> * i.e. count it under @taken_empty_lebs.</span>
<span class="cm"> *</span>
<span class="cm"> * @empty_lebs includes @taken_empty_lebs.</span>
<span class="cm"> *</span>
<span class="cm"> * @total_used, @total_dead and @total_dark fields do not account indexing</span>
<span class="cm"> * LEBs.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_lp_stats</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">empty_lebs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">taken_empty_lebs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx_lebs</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">total_free</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">total_dirty</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">total_used</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">total_dead</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">total_dark</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ubifs_nnode</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_cnode - LEB Properties Tree common node.</span>
<span class="cm"> * @parent: parent nnode</span>
<span class="cm"> * @cnext: next cnode to commit</span>
<span class="cm"> * @flags: flags (%DIRTY_LPT_NODE or %OBSOLETE_LPT_NODE)</span>
<span class="cm"> * @iip: index in parent</span>
<span class="cm"> * @level: level in the tree (zero for pnodes, greater than zero for nnodes)</span>
<span class="cm"> * @num: node number</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_cnode</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_cnode</span> <span class="o">*</span><span class="n">cnext</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_pnode - LEB Properties Tree leaf node.</span>
<span class="cm"> * @parent: parent nnode</span>
<span class="cm"> * @cnext: next cnode to commit</span>
<span class="cm"> * @flags: flags (%DIRTY_LPT_NODE or %OBSOLETE_LPT_NODE)</span>
<span class="cm"> * @iip: index in parent</span>
<span class="cm"> * @level: level in the tree (always zero for pnodes)</span>
<span class="cm"> * @num: node number</span>
<span class="cm"> * @lprops: LEB properties array</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_pnode</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_cnode</span> <span class="o">*</span><span class="n">cnext</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="n">lprops</span><span class="p">[</span><span class="n">UBIFS_LPT_FANOUT</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_nbranch - LEB Properties Tree internal node branch.</span>
<span class="cm"> * @lnum: LEB number of child</span>
<span class="cm"> * @offs: offset of child</span>
<span class="cm"> * @nnode: nnode child</span>
<span class="cm"> * @pnode: pnode child</span>
<span class="cm"> * @cnode: cnode child</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_nbranch</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offs</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">nnode</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ubifs_pnode</span> <span class="o">*</span><span class="n">pnode</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ubifs_cnode</span> <span class="o">*</span><span class="n">cnode</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_nnode - LEB Properties Tree internal node.</span>
<span class="cm"> * @parent: parent nnode</span>
<span class="cm"> * @cnext: next cnode to commit</span>
<span class="cm"> * @flags: flags (%DIRTY_LPT_NODE or %OBSOLETE_LPT_NODE)</span>
<span class="cm"> * @iip: index in parent</span>
<span class="cm"> * @level: level in the tree (always greater than zero for nnodes)</span>
<span class="cm"> * @num: node number</span>
<span class="cm"> * @nbranch: branches to child nodes</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_cnode</span> <span class="o">*</span><span class="n">cnext</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_nbranch</span> <span class="n">nbranch</span><span class="p">[</span><span class="n">UBIFS_LPT_FANOUT</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_lpt_heap - heap of categorized lprops.</span>
<span class="cm"> * @arr: heap array</span>
<span class="cm"> * @cnt: number in heap</span>
<span class="cm"> * @max_cnt: maximum number allowed in heap</span>
<span class="cm"> *</span>
<span class="cm"> * There are %LPROPS_HEAP_CNT heaps.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_lpt_heap</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">**</span><span class="n">arr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_cnt</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Return codes for LPT scan callback function.</span>
<span class="cm"> *</span>
<span class="cm"> * LPT_SCAN_CONTINUE: continue scanning</span>
<span class="cm"> * LPT_SCAN_ADD: add the LEB properties scanned to the tree in memory</span>
<span class="cm"> * LPT_SCAN_STOP: stop scanning</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">LPT_SCAN_CONTINUE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">LPT_SCAN_ADD</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">LPT_SCAN_STOP</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ubifs_info</span><span class="p">;</span>

<span class="cm">/* Callback used by the &#39;ubifs_lpt_scan_nolock()&#39; function */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ubifs_lpt_scan_callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">in_tree</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_wbuf - UBIFS write-buffer.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @buf: write-buffer (of min. flash I/O unit size)</span>
<span class="cm"> * @lnum: logical eraseblock number the write-buffer points to</span>
<span class="cm"> * @offs: write-buffer offset in this logical eraseblock</span>
<span class="cm"> * @avail: number of bytes available in the write-buffer</span>
<span class="cm"> * @used:  number of used bytes in the write-buffer</span>
<span class="cm"> * @size: write-buffer size (in [@c-&gt;min_io_size, @c-&gt;max_write_size] range)</span>
<span class="cm"> * @jhead: journal head the mutex belongs to (note, needed only to shut lockdep</span>
<span class="cm"> *         up by &#39;mutex_lock_nested()).</span>
<span class="cm"> * @sync_callback: write-buffer synchronization callback</span>
<span class="cm"> * @io_mutex: serializes write-buffer I/O</span>
<span class="cm"> * @lock: serializes @buf, @lnum, @offs, @avail, @used, @next_ino and @inodes</span>
<span class="cm"> *        fields</span>
<span class="cm"> * @softlimit: soft write-buffer timeout interval</span>
<span class="cm"> * @delta: hard and soft timeouts delta (the timer expire inteval is @softlimit</span>
<span class="cm"> *         and @softlimit + @delta)</span>
<span class="cm"> * @timer: write-buffer timer</span>
<span class="cm"> * @no_timer: non-zero if this write-buffer does not have a timer</span>
<span class="cm"> * @need_sync: non-zero if the timer expired and the wbuf needs sync&#39;ing</span>
<span class="cm"> * @next_ino: points to the next position of the following inode number</span>
<span class="cm"> * @inodes: stores the inode numbers of the nodes which are in wbuf</span>
<span class="cm"> *</span>
<span class="cm"> * The write-buffer synchronization callback is called when the write-buffer is</span>
<span class="cm"> * synchronized in order to notify how much space was wasted due to</span>
<span class="cm"> * write-buffer padding and how much free space is left in the LEB.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: the fields @buf, @lnum, @offs, @avail and @used can be read under</span>
<span class="cm"> * spin-lock or mutex because they are written under both mutex and spin-lock.</span>
<span class="cm"> * @buf is appended to under mutex but overwritten under both mutex and</span>
<span class="cm"> * spin-lock. Thus the data between @buf and @buf + @used can be read under</span>
<span class="cm"> * spinlock.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">avail</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">used</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">jhead</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sync_callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">free</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pad</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">io_mutex</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">softlimit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hrtimer</span> <span class="n">timer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">no_timer</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">need_sync</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">next_ino</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="o">*</span><span class="n">inodes</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_bud - bud logical eraseblock.</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> * @start: where the (uncommitted) bud data starts</span>
<span class="cm"> * @jhead: journal head number this bud belongs to</span>
<span class="cm"> * @list: link in the list buds belonging to the same journal head</span>
<span class="cm"> * @rb: link in the tree of all buds</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_bud</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">jhead</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rb</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_jhead - journal head.</span>
<span class="cm"> * @wbuf: head&#39;s write-buffer</span>
<span class="cm"> * @buds_list: list of bud LEBs belonging to this journal head</span>
<span class="cm"> * @grouped: non-zero if UBIFS groups nodes when writing to this journal head</span>
<span class="cm"> *</span>
<span class="cm"> * Note, the @buds list is protected by the @c-&gt;buds_lock.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_jhead</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="n">wbuf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">buds_list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">grouped</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_zbranch - key/coordinate/length branch stored in znodes.</span>
<span class="cm"> * @key: key</span>
<span class="cm"> * @znode: znode address in memory</span>
<span class="cm"> * @lnum: LEB number of the target node (indexing node or data node)</span>
<span class="cm"> * @offs: target node offset within @lnum</span>
<span class="cm"> * @len: target node length</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="p">{</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_znode - in-memory representation of an indexing node.</span>
<span class="cm"> * @parent: parent znode or NULL if it is the root</span>
<span class="cm"> * @cnext: next znode to commit</span>
<span class="cm"> * @flags: znode flags (%DIRTY_ZNODE, %COW_ZNODE or %OBSOLETE_ZNODE)</span>
<span class="cm"> * @time: last access time (seconds)</span>
<span class="cm"> * @level: level of the entry in the TNC tree</span>
<span class="cm"> * @child_cnt: count of child znodes</span>
<span class="cm"> * @iip: index in parent&#39;s zbranch array</span>
<span class="cm"> * @alt: lower bound of key range has altered i.e. child inserted at slot 0</span>
<span class="cm"> * @lnum: LEB number of the corresponding indexing node</span>
<span class="cm"> * @offs: offset of the corresponding indexing node</span>
<span class="cm"> * @len: length  of the corresponding indexing node</span>
<span class="cm"> * @zbranch: array of znode branches (@c-&gt;fanout elements)</span>
<span class="cm"> *</span>
<span class="cm"> * Note! The @lnum, @offs, and @len fields are not really needed - we have them</span>
<span class="cm"> * only for internal consistency check. They could be removed to save some RAM.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">cnext</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">child_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">alt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="n">zbranch</span><span class="p">[];</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct bu_info - bulk-read information.</span>
<span class="cm"> * @key: first data node key</span>
<span class="cm"> * @zbranch: zbranches of data nodes to bulk read</span>
<span class="cm"> * @buf: buffer to read into</span>
<span class="cm"> * @buf_len: buffer length</span>
<span class="cm"> * @gc_seq: GC sequence number to detect races with GC</span>
<span class="cm"> * @cnt: number of data nodes for bulk read</span>
<span class="cm"> * @blk_cnt: number of data blocks including holes</span>
<span class="cm"> * @oef: end of file reached</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bu_info</span> <span class="p">{</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="n">zbranch</span><span class="p">[</span><span class="n">UBIFS_MAX_BULK_READ</span><span class="p">];</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">buf_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">gc_seq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">blk_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">eof</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_node_range - node length range description data structure.</span>
<span class="cm"> * @len: fixed node length</span>
<span class="cm"> * @min_len: minimum possible node length</span>
<span class="cm"> * @max_len: maximum possible node length</span>
<span class="cm"> *</span>
<span class="cm"> * If @max_len is %0, the node has fixed length @len.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_node_range</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">min_len</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">max_len</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_compressor - UBIFS compressor description structure.</span>
<span class="cm"> * @compr_type: compressor type (%UBIFS_COMPR_LZO, etc)</span>
<span class="cm"> * @cc: cryptoapi compressor handle</span>
<span class="cm"> * @comp_mutex: mutex used during compression</span>
<span class="cm"> * @decomp_mutex: mutex used during decompression</span>
<span class="cm"> * @name: compressor name</span>
<span class="cm"> * @capi_name: cryptoapi compressor name</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_compressor</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">compr_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">crypto_comp</span> <span class="o">*</span><span class="n">cc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">comp_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">decomp_mutex</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">capi_name</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_budget_req - budget requirements of an operation.</span>
<span class="cm"> *</span>
<span class="cm"> * @fast: non-zero if the budgeting should try to acquire budget quickly and</span>
<span class="cm"> *        should not try to call write-back</span>
<span class="cm"> * @recalculate: non-zero if @idx_growth, @data_growth, and @dd_growth fields</span>
<span class="cm"> *               have to be re-calculated</span>
<span class="cm"> * @new_page: non-zero if the operation adds a new page</span>
<span class="cm"> * @dirtied_page: non-zero if the operation makes a page dirty</span>
<span class="cm"> * @new_dent: non-zero if the operation adds a new directory entry</span>
<span class="cm"> * @mod_dent: non-zero if the operation removes or modifies an existing</span>
<span class="cm"> *            directory entry</span>
<span class="cm"> * @new_ino: non-zero if the operation adds a new inode</span>
<span class="cm"> * @new_ino_d: now much data newly created inode contains</span>
<span class="cm"> * @dirtied_ino: how many inodes the operation makes dirty</span>
<span class="cm"> * @dirtied_ino_d: now much data dirtied inode contains</span>
<span class="cm"> * @idx_growth: how much the index will supposedly grow</span>
<span class="cm"> * @data_growth: how much new data the operation will supposedly add</span>
<span class="cm"> * @dd_growth: how much data that makes other data dirty the operation will</span>
<span class="cm"> *             supposedly add</span>
<span class="cm"> *</span>
<span class="cm"> * @idx_growth, @data_growth and @dd_growth are not used in budget request. The</span>
<span class="cm"> * budgeting subsystem caches index and data growth values there to avoid</span>
<span class="cm"> * re-calculating them when the budget is released. However, if @idx_growth is</span>
<span class="cm"> * %-1, it is calculated by the release function using other fields.</span>
<span class="cm"> *</span>
<span class="cm"> * An inode may contain 4KiB of data at max., thus the widths of @new_ino_d</span>
<span class="cm"> * is 13 bits, and @dirtied_ino_d - 15, because up to 4 inodes may be made</span>
<span class="cm"> * dirty by the re-name operation.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, UBIFS aligns node lengths to 8-bytes boundary, so the requester has to</span>
<span class="cm"> * make sure the amount of inode data which contribute to @new_ino_d and</span>
<span class="cm"> * @dirtied_ino_d fields are aligned.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fast</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">recalculate</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifndef UBIFS_DEBUG</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_page</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dirtied_page</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_dent</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mod_dent</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_ino</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_ino_d</span><span class="o">:</span><span class="mi">13</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dirtied_ino</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dirtied_ino_d</span><span class="o">:</span><span class="mi">15</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="cm">/* Not bit-fields to check for overflows */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dirtied_page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_dent</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mod_dent</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_ino</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_ino_d</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dirtied_ino</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dirtied_ino_d</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">int</span> <span class="n">idx_growth</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">data_growth</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dd_growth</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_orphan - stores the inode number of an orphan.</span>
<span class="cm"> * @rb: rb-tree node of rb-tree of orphans sorted by inode number</span>
<span class="cm"> * @list: list head of list of orphans in order added</span>
<span class="cm"> * @new_list: list head of list of orphans added since the last commit</span>
<span class="cm"> * @cnext: next orphan to commit</span>
<span class="cm"> * @dnext: next orphan to delete</span>
<span class="cm"> * @inum: inode number</span>
<span class="cm"> * @new: %1 =&gt; added since the last commit, otherwise %0</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_orphan</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">new_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_orphan</span> <span class="o">*</span><span class="n">cnext</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_orphan</span> <span class="o">*</span><span class="n">dnext</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">inum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_mount_opts - UBIFS-specific mount options information.</span>
<span class="cm"> * @unmount_mode: selected unmount mode (%0 default, %1 normal, %2 fast)</span>
<span class="cm"> * @bulk_read: enable/disable bulk-reads (%0 default, %1 disabe, %2 enable)</span>
<span class="cm"> * @chk_data_crc: enable/disable CRC data checking when reading data nodes</span>
<span class="cm"> *                (%0 default, %1 disabe, %2 enable)</span>
<span class="cm"> * @override_compr: override default compressor (%0 - do not override and use</span>
<span class="cm"> *                  superblock compressor, %1 - override and use compressor</span>
<span class="cm"> *                  specified in @compr_type)</span>
<span class="cm"> * @compr_type: compressor type to override the superblock compressor with</span>
<span class="cm"> *              (%UBIFS_COMPR_NONE, etc)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_mount_opts</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unmount_mode</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bulk_read</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chk_data_crc</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">override_compr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">compr_type</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_budg_info - UBIFS budgeting information.</span>
<span class="cm"> * @idx_growth: amount of bytes budgeted for index growth</span>
<span class="cm"> * @data_growth: amount of bytes budgeted for cached data</span>
<span class="cm"> * @dd_growth: amount of bytes budgeted for cached data that will make</span>
<span class="cm"> *             other data dirty</span>
<span class="cm"> * @uncommitted_idx: amount of bytes were budgeted for growth of the index, but</span>
<span class="cm"> *                   which still have to be taken into account because the index</span>
<span class="cm"> *                   has not been committed so far</span>
<span class="cm"> * @old_idx_sz: size of index on flash</span>
<span class="cm"> * @min_idx_lebs: minimum number of LEBs required for the index</span>
<span class="cm"> * @nospace: non-zero if the file-system does not have flash space (used as</span>
<span class="cm"> *           optimization)</span>
<span class="cm"> * @nospace_rp: the same as @nospace, but additionally means that even reserved</span>
<span class="cm"> *              pool is full</span>
<span class="cm"> * @page_budget: budget for a page (constant, nenver changed after mount)</span>
<span class="cm"> * @inode_budget: budget for an inode (constant, nenver changed after mount)</span>
<span class="cm"> * @dent_budget: budget for a directory entry (constant, nenver changed after</span>
<span class="cm"> *               mount)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_budg_info</span> <span class="p">{</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">idx_growth</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">data_growth</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">dd_growth</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">uncommitted_idx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">old_idx_sz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">min_idx_lebs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nospace</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nospace_rp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">page_budget</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">inode_budget</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dent_budget</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ubifs_debug_info</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_info - UBIFS file-system description data structure</span>
<span class="cm"> * (per-superblock).</span>
<span class="cm"> * @vfs_sb: VFS @struct super_block object</span>
<span class="cm"> * @bdi: backing device info object to make VFS happy and disable read-ahead</span>
<span class="cm"> *</span>
<span class="cm"> * @highest_inum: highest used inode number</span>
<span class="cm"> * @max_sqnum: current global sequence number</span>
<span class="cm"> * @cmt_no: commit number of the last successfully completed commit, protected</span>
<span class="cm"> *          by @commit_sem</span>
<span class="cm"> * @cnt_lock: protects @highest_inum and @max_sqnum counters</span>
<span class="cm"> * @fmt_version: UBIFS on-flash format version</span>
<span class="cm"> * @ro_compat_version: R/O compatibility version</span>
<span class="cm"> * @uuid: UUID from super block</span>
<span class="cm"> *</span>
<span class="cm"> * @lhead_lnum: log head logical eraseblock number</span>
<span class="cm"> * @lhead_offs: log head offset</span>
<span class="cm"> * @ltail_lnum: log tail logical eraseblock number (offset is always 0)</span>
<span class="cm"> * @log_mutex: protects the log, @lhead_lnum, @lhead_offs, @ltail_lnum, and</span>
<span class="cm"> *             @bud_bytes</span>
<span class="cm"> * @min_log_bytes: minimum required number of bytes in the log</span>
<span class="cm"> * @cmt_bud_bytes: used during commit to temporarily amount of bytes in</span>
<span class="cm"> *                 committed buds</span>
<span class="cm"> *</span>
<span class="cm"> * @buds: tree of all buds indexed by bud LEB number</span>
<span class="cm"> * @bud_bytes: how many bytes of flash is used by buds</span>
<span class="cm"> * @buds_lock: protects the @buds tree, @bud_bytes, and per-journal head bud</span>
<span class="cm"> *             lists</span>
<span class="cm"> * @jhead_cnt: count of journal heads</span>
<span class="cm"> * @jheads: journal heads (head zero is base head)</span>
<span class="cm"> * @max_bud_bytes: maximum number of bytes allowed in buds</span>
<span class="cm"> * @bg_bud_bytes: number of bud bytes when background commit is initiated</span>
<span class="cm"> * @old_buds: buds to be released after commit ends</span>
<span class="cm"> * @max_bud_cnt: maximum number of buds</span>
<span class="cm"> *</span>
<span class="cm"> * @commit_sem: synchronizes committer with other processes</span>
<span class="cm"> * @cmt_state: commit state</span>
<span class="cm"> * @cs_lock: commit state lock</span>
<span class="cm"> * @cmt_wq: wait queue to sleep on if the log is full and a commit is running</span>
<span class="cm"> *</span>
<span class="cm"> * @big_lpt: flag that LPT is too big to write whole during commit</span>
<span class="cm"> * @space_fixup: flag indicating that free space in LEBs needs to be cleaned up</span>
<span class="cm"> * @no_chk_data_crc: do not check CRCs when reading data nodes (except during</span>
<span class="cm"> *                   recovery)</span>
<span class="cm"> * @bulk_read: enable bulk-reads</span>
<span class="cm"> * @default_compr: default compression algorithm (%UBIFS_COMPR_LZO, etc)</span>
<span class="cm"> * @rw_incompat: the media is not R/W compatible</span>
<span class="cm"> *</span>
<span class="cm"> * @tnc_mutex: protects the Tree Node Cache (TNC), @zroot, @cnext, @enext, and</span>
<span class="cm"> *             @calc_idx_sz</span>
<span class="cm"> * @zroot: zbranch which points to the root index node and znode</span>
<span class="cm"> * @cnext: next znode to commit</span>
<span class="cm"> * @enext: next znode to commit to empty space</span>
<span class="cm"> * @gap_lebs: array of LEBs used by the in-gaps commit method</span>
<span class="cm"> * @cbuf: commit buffer</span>
<span class="cm"> * @ileb_buf: buffer for commit in-the-gaps method</span>
<span class="cm"> * @ileb_len: length of data in ileb_buf</span>
<span class="cm"> * @ihead_lnum: LEB number of index head</span>
<span class="cm"> * @ihead_offs: offset of index head</span>
<span class="cm"> * @ilebs: pre-allocated index LEBs</span>
<span class="cm"> * @ileb_cnt: number of pre-allocated index LEBs</span>
<span class="cm"> * @ileb_nxt: next pre-allocated index LEBs</span>
<span class="cm"> * @old_idx: tree of index nodes obsoleted since the last commit start</span>
<span class="cm"> * @bottom_up_buf: a buffer which is used by &#39;dirty_cow_bottom_up()&#39; in tnc.c</span>
<span class="cm"> *</span>
<span class="cm"> * @mst_node: master node</span>
<span class="cm"> * @mst_offs: offset of valid master node</span>
<span class="cm"> * @mst_mutex: protects the master node area, @mst_node, and @mst_offs</span>
<span class="cm"> *</span>
<span class="cm"> * @max_bu_buf_len: maximum bulk-read buffer length</span>
<span class="cm"> * @bu_mutex: protects the pre-allocated bulk-read buffer and @c-&gt;bu</span>
<span class="cm"> * @bu: pre-allocated bulk-read information</span>
<span class="cm"> *</span>
<span class="cm"> * @write_reserve_mutex: protects @write_reserve_buf</span>
<span class="cm"> * @write_reserve_buf: on the write path we allocate memory, which might</span>
<span class="cm"> *                     sometimes be unavailable, in which case we use this</span>
<span class="cm"> *                     write reserve buffer</span>
<span class="cm"> *</span>
<span class="cm"> * @log_lebs: number of logical eraseblocks in the log</span>
<span class="cm"> * @log_bytes: log size in bytes</span>
<span class="cm"> * @log_last: last LEB of the log</span>
<span class="cm"> * @lpt_lebs: number of LEBs used for lprops table</span>
<span class="cm"> * @lpt_first: first LEB of the lprops table area</span>
<span class="cm"> * @lpt_last: last LEB of the lprops table area</span>
<span class="cm"> * @orph_lebs: number of LEBs used for the orphan area</span>
<span class="cm"> * @orph_first: first LEB of the orphan area</span>
<span class="cm"> * @orph_last: last LEB of the orphan area</span>
<span class="cm"> * @main_lebs: count of LEBs in the main area</span>
<span class="cm"> * @main_first: first LEB of the main area</span>
<span class="cm"> * @main_bytes: main area size in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * @key_hash_type: type of the key hash</span>
<span class="cm"> * @key_hash: direntry key hash function</span>
<span class="cm"> * @key_fmt: key format</span>
<span class="cm"> * @key_len: key length</span>
<span class="cm"> * @fanout: fanout of the index tree (number of links per indexing node)</span>
<span class="cm"> *</span>
<span class="cm"> * @min_io_size: minimal input/output unit size</span>
<span class="cm"> * @min_io_shift: number of bits in @min_io_size minus one</span>
<span class="cm"> * @max_write_size: maximum amount of bytes the underlying flash can write at a</span>
<span class="cm"> *                  time (MTD write buffer size)</span>
<span class="cm"> * @max_write_shift: number of bits in @max_write_size minus one</span>
<span class="cm"> * @leb_size: logical eraseblock size in bytes</span>
<span class="cm"> * @leb_start: starting offset of logical eraseblocks within physical</span>
<span class="cm"> *             eraseblocks</span>
<span class="cm"> * @half_leb_size: half LEB size</span>
<span class="cm"> * @idx_leb_size: how many bytes of an LEB are effectively available when it is</span>
<span class="cm"> *                used to store indexing nodes (@leb_size - @max_idx_node_sz)</span>
<span class="cm"> * @leb_cnt: count of logical eraseblocks</span>
<span class="cm"> * @max_leb_cnt: maximum count of logical eraseblocks</span>
<span class="cm"> * @old_leb_cnt: count of logical eraseblocks before re-size</span>
<span class="cm"> * @ro_media: the underlying UBI volume is read-only</span>
<span class="cm"> * @ro_mount: the file-system was mounted as read-only</span>
<span class="cm"> * @ro_error: UBIFS switched to R/O mode because an error happened</span>
<span class="cm"> *</span>
<span class="cm"> * @dirty_pg_cnt: number of dirty pages (not used)</span>
<span class="cm"> * @dirty_zn_cnt: number of dirty znodes</span>
<span class="cm"> * @clean_zn_cnt: number of clean znodes</span>
<span class="cm"> *</span>
<span class="cm"> * @space_lock: protects @bi and @lst</span>
<span class="cm"> * @lst: lprops statistics</span>
<span class="cm"> * @bi: budgeting information</span>
<span class="cm"> * @calc_idx_sz: temporary variable which is used to calculate new index size</span>
<span class="cm"> *               (contains accurate new index size at end of TNC commit start)</span>
<span class="cm"> *</span>
<span class="cm"> * @ref_node_alsz: size of the LEB reference node aligned to the min. flash</span>
<span class="cm"> *                 I/O unit</span>
<span class="cm"> * @mst_node_alsz: master node aligned size</span>
<span class="cm"> * @min_idx_node_sz: minimum indexing node aligned on 8-bytes boundary</span>
<span class="cm"> * @max_idx_node_sz: maximum indexing node aligned on 8-bytes boundary</span>
<span class="cm"> * @max_inode_sz: maximum possible inode size in bytes</span>
<span class="cm"> * @max_znode_sz: size of znode in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * @leb_overhead: how many bytes are wasted in an LEB when it is filled with</span>
<span class="cm"> *                data nodes of maximum size - used in free space reporting</span>
<span class="cm"> * @dead_wm: LEB dead space watermark</span>
<span class="cm"> * @dark_wm: LEB dark space watermark</span>
<span class="cm"> * @block_cnt: count of 4KiB blocks on the FS</span>
<span class="cm"> *</span>
<span class="cm"> * @ranges: UBIFS node length ranges</span>
<span class="cm"> * @ubi: UBI volume descriptor</span>
<span class="cm"> * @di: UBI device information</span>
<span class="cm"> * @vi: UBI volume information</span>
<span class="cm"> *</span>
<span class="cm"> * @orph_tree: rb-tree of orphan inode numbers</span>
<span class="cm"> * @orph_list: list of orphan inode numbers in order added</span>
<span class="cm"> * @orph_new: list of orphan inode numbers added since last commit</span>
<span class="cm"> * @orph_cnext: next orphan to commit</span>
<span class="cm"> * @orph_dnext: next orphan to delete</span>
<span class="cm"> * @orphan_lock: lock for orph_tree and orph_new</span>
<span class="cm"> * @orph_buf: buffer for orphan nodes</span>
<span class="cm"> * @new_orphans: number of orphans since last commit</span>
<span class="cm"> * @cmt_orphans: number of orphans being committed</span>
<span class="cm"> * @tot_orphans: number of orphans in the rb_tree</span>
<span class="cm"> * @max_orphans: maximum number of orphans allowed</span>
<span class="cm"> * @ohead_lnum: orphan head LEB number</span>
<span class="cm"> * @ohead_offs: orphan head offset</span>
<span class="cm"> * @no_orphs: non-zero if there are no orphans</span>
<span class="cm"> *</span>
<span class="cm"> * @bgt: UBIFS background thread</span>
<span class="cm"> * @bgt_name: background thread name</span>
<span class="cm"> * @need_bgt: if background thread should run</span>
<span class="cm"> * @need_wbuf_sync: if write-buffers have to be synchronized</span>
<span class="cm"> *</span>
<span class="cm"> * @gc_lnum: LEB number used for garbage collection</span>
<span class="cm"> * @sbuf: a buffer of LEB size used by GC and replay for scanning</span>
<span class="cm"> * @idx_gc: list of index LEBs that have been garbage collected</span>
<span class="cm"> * @idx_gc_cnt: number of elements on the idx_gc list</span>
<span class="cm"> * @gc_seq: incremented for every non-index LEB garbage collected</span>
<span class="cm"> * @gced_lnum: last non-index LEB that was garbage collected</span>
<span class="cm"> *</span>
<span class="cm"> * @infos_list: links all &#39;ubifs_info&#39; objects</span>
<span class="cm"> * @umount_mutex: serializes shrinker and un-mount</span>
<span class="cm"> * @shrinker_run_no: shrinker run number</span>
<span class="cm"> *</span>
<span class="cm"> * @space_bits: number of bits needed to record free or dirty space</span>
<span class="cm"> * @lpt_lnum_bits: number of bits needed to record a LEB number in the LPT</span>
<span class="cm"> * @lpt_offs_bits: number of bits needed to record an offset in the LPT</span>
<span class="cm"> * @lpt_spc_bits: number of bits needed to space in the LPT</span>
<span class="cm"> * @pcnt_bits: number of bits needed to record pnode or nnode number</span>
<span class="cm"> * @lnum_bits: number of bits needed to record LEB number</span>
<span class="cm"> * @nnode_sz: size of on-flash nnode</span>
<span class="cm"> * @pnode_sz: size of on-flash pnode</span>
<span class="cm"> * @ltab_sz: size of on-flash LPT lprops table</span>
<span class="cm"> * @lsave_sz: size of on-flash LPT save table</span>
<span class="cm"> * @pnode_cnt: number of pnodes</span>
<span class="cm"> * @nnode_cnt: number of nnodes</span>
<span class="cm"> * @lpt_hght: height of the LPT</span>
<span class="cm"> * @pnodes_have: number of pnodes in memory</span>
<span class="cm"> *</span>
<span class="cm"> * @lp_mutex: protects lprops table and all the other lprops-related fields</span>
<span class="cm"> * @lpt_lnum: LEB number of the root nnode of the LPT</span>
<span class="cm"> * @lpt_offs: offset of the root nnode of the LPT</span>
<span class="cm"> * @nhead_lnum: LEB number of LPT head</span>
<span class="cm"> * @nhead_offs: offset of LPT head</span>
<span class="cm"> * @lpt_drty_flgs: dirty flags for LPT special nodes e.g. ltab</span>
<span class="cm"> * @dirty_nn_cnt: number of dirty nnodes</span>
<span class="cm"> * @dirty_pn_cnt: number of dirty pnodes</span>
<span class="cm"> * @check_lpt_free: flag that indicates LPT GC may be needed</span>
<span class="cm"> * @lpt_sz: LPT size</span>
<span class="cm"> * @lpt_nod_buf: buffer for an on-flash nnode or pnode</span>
<span class="cm"> * @lpt_buf: buffer of LEB size used by LPT</span>
<span class="cm"> * @nroot: address in memory of the root nnode of the LPT</span>
<span class="cm"> * @lpt_cnext: next LPT node to commit</span>
<span class="cm"> * @lpt_heap: array of heaps of categorized lprops</span>
<span class="cm"> * @dirty_idx: a (reverse sorted) copy of the LPROPS_DIRTY_IDX heap as at</span>
<span class="cm"> *             previous commit start</span>
<span class="cm"> * @uncat_list: list of un-categorized LEBs</span>
<span class="cm"> * @empty_list: list of empty LEBs</span>
<span class="cm"> * @freeable_list: list of freeable non-index LEBs (free + dirty == @leb_size)</span>
<span class="cm"> * @frdi_idx_list: list of freeable index LEBs (free + dirty == @leb_size)</span>
<span class="cm"> * @freeable_cnt: number of freeable LEBs in @freeable_list</span>
<span class="cm"> *</span>
<span class="cm"> * @ltab_lnum: LEB number of LPT&#39;s own lprops table</span>
<span class="cm"> * @ltab_offs: offset of LPT&#39;s own lprops table</span>
<span class="cm"> * @ltab: LPT&#39;s own lprops table</span>
<span class="cm"> * @ltab_cmt: LPT&#39;s own lprops table (commit copy)</span>
<span class="cm"> * @lsave_cnt: number of LEB numbers in LPT&#39;s save table</span>
<span class="cm"> * @lsave_lnum: LEB number of LPT&#39;s save table</span>
<span class="cm"> * @lsave_offs: offset of LPT&#39;s save table</span>
<span class="cm"> * @lsave: LPT&#39;s save table</span>
<span class="cm"> * @lscan_lnum: LEB number of last LPT scan</span>
<span class="cm"> *</span>
<span class="cm"> * @rp_size: size of the reserved pool in bytes</span>
<span class="cm"> * @report_rp_size: size of the reserved pool reported to user-space</span>
<span class="cm"> * @rp_uid: reserved pool user ID</span>
<span class="cm"> * @rp_gid: reserved pool group ID</span>
<span class="cm"> *</span>
<span class="cm"> * @empty: %1 if the UBI device is empty</span>
<span class="cm"> * @need_recovery: %1 if the file-system needs recovery</span>
<span class="cm"> * @replaying: %1 during journal replay</span>
<span class="cm"> * @mounting: %1 while mounting</span>
<span class="cm"> * @remounting_rw: %1 while re-mounting from R/O mode to R/W mode</span>
<span class="cm"> * @replay_list: temporary list used during journal replay</span>
<span class="cm"> * @replay_buds: list of buds to replay</span>
<span class="cm"> * @cs_sqnum: sequence number of first node in the log (commit start node)</span>
<span class="cm"> * @replay_sqnum: sequence number of node currently being replayed</span>
<span class="cm"> * @unclean_leb_list: LEBs to recover when re-mounting R/O mounted FS to R/W</span>
<span class="cm"> *                    mode</span>
<span class="cm"> * @rcvrd_mst_node: recovered master node to write when re-mounting R/O mounted</span>
<span class="cm"> *                  FS to R/W mode</span>
<span class="cm"> * @size_tree: inode size information for recovery</span>
<span class="cm"> * @mount_opts: UBIFS-specific mount options</span>
<span class="cm"> *</span>
<span class="cm"> * @dbg: debugging-related information</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">vfs_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="n">bdi</span><span class="p">;</span>

	<span class="n">ino_t</span> <span class="n">highest_inum</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">max_sqnum</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">cmt_no</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">cnt_lock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fmt_version</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ro_compat_version</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

	<span class="kt">int</span> <span class="n">lhead_lnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lhead_offs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ltail_lnum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">log_mutex</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">min_log_bytes</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">cmt_bud_bytes</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">buds</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">bud_bytes</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">buds_lock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">jhead_cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_jhead</span> <span class="o">*</span><span class="n">jheads</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">max_bud_bytes</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">bg_bud_bytes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">old_buds</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_bud_cnt</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">commit_sem</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cmt_state</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">cs_lock</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">cmt_wq</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">big_lpt</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">space_fixup</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">no_chk_data_crc</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bulk_read</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">default_compr</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rw_incompat</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">tnc_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="n">zroot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">cnext</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">enext</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">gap_lebs</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cbuf</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ileb_buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ileb_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ihead_lnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ihead_offs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">ilebs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ileb_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ileb_nxt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">old_idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">bottom_up_buf</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ubifs_mst_node</span> <span class="o">*</span><span class="n">mst_node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mst_offs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mst_mutex</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">max_bu_buf_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">bu_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bu_info</span> <span class="n">bu</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">write_reserve_mutex</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">write_reserve_buf</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">log_lebs</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">log_bytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">log_last</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lpt_lebs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lpt_first</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lpt_last</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">orph_lebs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">orph_first</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">orph_last</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">main_lebs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">main_first</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">main_bytes</span><span class="p">;</span>

	<span class="kt">uint8_t</span> <span class="n">key_hash_type</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="p">(</span><span class="o">*</span><span class="n">key_hash</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">key_fmt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">key_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fanout</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">min_io_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">min_io_shift</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_write_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_write_shift</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">leb_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">leb_start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">half_leb_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx_leb_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">leb_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_leb_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_leb_cnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ro_media</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ro_mount</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ro_error</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">atomic_long_t</span> <span class="n">dirty_pg_cnt</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">dirty_zn_cnt</span><span class="p">;</span>
	<span class="n">atomic_long_t</span> <span class="n">clean_zn_cnt</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">space_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_lp_stats</span> <span class="n">lst</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_budg_info</span> <span class="n">bi</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">calc_idx_sz</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">ref_node_alsz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mst_node_alsz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">min_idx_node_sz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_idx_node_sz</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">max_inode_sz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_znode_sz</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">leb_overhead</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dead_wm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dark_wm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">block_cnt</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ubifs_node_range</span> <span class="n">ranges</span><span class="p">[</span><span class="n">UBIFS_NODE_TYPES_CNT</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">ubi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_device_info</span> <span class="n">di</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubi_volume_info</span> <span class="n">vi</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">orph_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">orph_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">orph_new</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_orphan</span> <span class="o">*</span><span class="n">orph_cnext</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_orphan</span> <span class="o">*</span><span class="n">orph_dnext</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">orphan_lock</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">orph_buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new_orphans</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cmt_orphans</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tot_orphans</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_orphans</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ohead_lnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ohead_offs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">no_orphs</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">bgt</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">bgt_name</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">BGT_NAME_PATTERN</span><span class="p">)</span> <span class="o">+</span> <span class="mi">9</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">need_bgt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">need_wbuf_sync</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">gc_lnum</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">sbuf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">idx_gc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx_gc_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">gc_seq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">gced_lnum</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">infos_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">umount_mutex</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">shrinker_run_no</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">space_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lpt_lnum_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lpt_offs_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lpt_spc_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pcnt_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lnum_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nnode_sz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pnode_sz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ltab_sz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lsave_sz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pnode_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nnode_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lpt_hght</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pnodes_have</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">lp_mutex</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lpt_lnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lpt_offs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nhead_lnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nhead_offs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lpt_drty_flgs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dirty_nn_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dirty_pn_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">check_lpt_free</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">lpt_sz</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">lpt_nod_buf</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">lpt_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">nroot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_cnode</span> <span class="o">*</span><span class="n">lpt_cnext</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_lpt_heap</span> <span class="n">lpt_heap</span><span class="p">[</span><span class="n">LPROPS_HEAP_CNT</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ubifs_lpt_heap</span> <span class="n">dirty_idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">uncat_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">empty_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">freeable_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">frdi_idx_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">freeable_cnt</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">ltab_lnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ltab_offs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_lpt_lprops</span> <span class="o">*</span><span class="n">ltab</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_lpt_lprops</span> <span class="o">*</span><span class="n">ltab_cmt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lsave_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lsave_lnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lsave_offs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">lsave</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lscan_lnum</span><span class="p">;</span>

	<span class="kt">long</span> <span class="kt">long</span> <span class="n">rp_size</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">report_rp_size</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">rp_uid</span><span class="p">;</span>
	<span class="n">gid_t</span> <span class="n">rp_gid</span><span class="p">;</span>

	<span class="cm">/* The below fields are used only during mounting and re-mounting */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">empty</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">need_recovery</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">replaying</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mounting</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">remounting_rw</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">replay_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">replay_buds</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">cs_sqnum</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">replay_sqnum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">unclean_leb_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_mst_node</span> <span class="o">*</span><span class="n">rcvrd_mst_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">size_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_mount_opts</span> <span class="n">mount_opts</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ubifs_debug_info</span> <span class="o">*</span><span class="n">dbg</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">ubifs_infos</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">spinlock_t</span> <span class="n">ubifs_infos_lock</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">atomic_long_t</span> <span class="n">ubifs_clean_zn_cnt</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ubifs_inode_slab</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="n">ubifs_super_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">ubifs_file_address_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ubifs_file_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ubifs_file_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ubifs_dir_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ubifs_dir_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ubifs_symlink_inode_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="n">ubifs_backing_dev_info</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ubifs_compressor</span> <span class="o">*</span><span class="n">ubifs_compressors</span><span class="p">[</span><span class="n">UBIFS_COMPR_TYPES_CNT</span><span class="p">];</span>

<span class="cm">/* io.c */</span>
<span class="kt">void</span> <span class="n">ubifs_ro_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_leb_read</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">even_ebadmsg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_leb_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_leb_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_leb_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_is_mapped</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_wbuf_write_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_wbuf_seek_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_wbuf_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_read_node</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_read_node_wbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_write_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">offs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_check_node</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">quiet</span><span class="p">,</span> <span class="kt">int</span> <span class="n">must_chk_crc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_prepare_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pad</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_prep_grp_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_io_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_pad</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pad</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_wbuf_sync_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_bg_wbufs_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_wbuf_add_ino_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">inum</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_sync_wbufs_by_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="cm">/* scan.c */</span>
<span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">ubifs_scan</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">quiet</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_scan_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">sleb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_scan_a_node</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">quiet</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">ubifs_start_scan</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sbuf</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_end_scan</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">sleb</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_add_snod</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">sleb</span><span class="p">,</span>
		   <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_scanned_corruption</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>

<span class="cm">/* log.c */</span>
<span class="kt">void</span> <span class="n">ubifs_add_bud</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_bud</span> <span class="o">*</span><span class="n">bud</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_create_buds_lists</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_add_bud_to_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">jhead</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ubifs_bud</span> <span class="o">*</span><span class="n">ubifs_search_bud</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">ubifs_get_wbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_log_start_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ltail_lnum</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_log_end_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_ltail_lnum</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_log_post_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">old_ltail_lnum</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_consolidate_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>

<span class="cm">/* journal.c */</span>
<span class="kt">int</span> <span class="n">ubifs_jnl_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">nm</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">deletion</span><span class="p">,</span> <span class="kt">int</span> <span class="n">xent</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_jnl_write_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_jnl_write_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_jnl_delete_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_jnl_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old_dir</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">new_dir</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_jnl_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		       <span class="n">loff_t</span> <span class="n">old_size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">new_size</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_jnl_delete_xattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">nm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_jnl_change_xattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode1</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode2</span><span class="p">);</span>

<span class="cm">/* budget.c */</span>
<span class="kt">int</span> <span class="n">ubifs_budget_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_release_budget</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_release_dirty_inode_budget</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_budget_inode_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_release_ino_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_cancel_ino_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="n">ubifs_get_free_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="n">ubifs_get_free_space_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_calc_min_idx_lebs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_convert_page_budget</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="n">ubifs_reported_space</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">free</span><span class="p">);</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="n">ubifs_calc_available</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min_idx_lebs</span><span class="p">);</span>

<span class="cm">/* find.c */</span>
<span class="kt">int</span> <span class="n">ubifs_find_free_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min_space</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">offs</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">squeeze</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_find_free_leb_for_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_find_dirty_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">ret_lp</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">min_space</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pick_free</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_find_dirty_idx_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_save_dirty_idx_lnums</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>

<span class="cm">/* tnc.c */</span>
<span class="kt">int</span> <span class="n">ubifs_lookup_level0</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">**</span><span class="n">zn</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_tnc_lookup_nm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">nm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_tnc_locate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
		     <span class="kt">void</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">offs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_tnc_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
		  <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_tnc_replace</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">old_lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">old_offs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_tnc_add_nm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">nm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_tnc_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_tnc_remove_nm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">nm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_tnc_remove_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">from_key</span><span class="p">,</span>
			   <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">to_key</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_tnc_remove_ino</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">inum</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">ubifs_tnc_next_ent</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
					   <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">nm</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_tnc_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_tnc_has_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_idx</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_dirty_idx_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">);</span>
<span class="cm">/* Shared by tnc.c for tnc_commit.c */</span>
<span class="kt">void</span> <span class="n">destroy_old_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">is_idx_node_in_tnc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">insert_old_idx_znode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_tnc_get_bu_keys</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bu_info</span> <span class="o">*</span><span class="n">bu</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_tnc_bulk_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bu_info</span> <span class="o">*</span><span class="n">bu</span><span class="p">);</span>

<span class="cm">/* tnc_misc.c */</span>
<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">ubifs_tnc_levelorder_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">zr</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_search_zbranch</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">ubifs_tnc_postorder_first</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">ubifs_tnc_postorder_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">);</span>
<span class="kt">long</span> <span class="n">ubifs_destroy_tnc_subtree</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">zr</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">ubifs_load_znode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iip</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_tnc_read_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>

<span class="cm">/* tnc_commit.c */</span>
<span class="kt">int</span> <span class="n">ubifs_tnc_start_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zroot</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_tnc_end_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>

<span class="cm">/* shrinker.c */</span>
<span class="kt">int</span> <span class="n">ubifs_shrinker</span><span class="p">(</span><span class="k">struct</span> <span class="n">shrinker</span> <span class="o">*</span><span class="n">shrink</span><span class="p">,</span> <span class="k">struct</span> <span class="n">shrink_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">);</span>

<span class="cm">/* commit.c */</span>
<span class="kt">int</span> <span class="n">ubifs_bg_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_commit_required</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_request_bg_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_run_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_recovery_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_gc_should_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_wait_for_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>

<span class="cm">/* master.c */</span>
<span class="kt">int</span> <span class="n">ubifs_read_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_write_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>

<span class="cm">/* sb.c */</span>
<span class="kt">int</span> <span class="n">ubifs_read_superblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ubifs_sb_node</span> <span class="o">*</span><span class="n">ubifs_read_sb_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_write_sb_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_sb_node</span> <span class="o">*</span><span class="n">sup</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_fixup_free_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>

<span class="cm">/* replay.c */</span>
<span class="kt">int</span> <span class="n">ubifs_validate_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">dent</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_replay_journal</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>

<span class="cm">/* gc.c */</span>
<span class="kt">int</span> <span class="n">ubifs_garbage_collect</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">anyway</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_gc_start_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_gc_end_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_destroy_idx_gc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_get_idx_gc_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_garbage_collect_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lp</span><span class="p">);</span>

<span class="cm">/* orphan.c */</span>
<span class="kt">int</span> <span class="n">ubifs_add_orphan</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">inum</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_delete_orphan</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">inum</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_orphan_start_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_orphan_end_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_mount_orphans</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unclean</span><span class="p">,</span> <span class="kt">int</span> <span class="n">read_only</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_clear_orphans</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>

<span class="cm">/* lpt.c */</span>
<span class="kt">int</span> <span class="n">ubifs_calc_lpt_geom</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_create_dflt_lpt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">main_lebs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lpt_first</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="o">*</span><span class="n">lpt_lebs</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">big_lpt</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_lpt_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wr</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">ubifs_lpt_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">ubifs_lpt_lookup_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_lpt_scan_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start_lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end_lnum</span><span class="p">,</span>
			  <span class="n">ubifs_lpt_scan_callback</span> <span class="n">scan_cb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cm">/* Shared by lpt.c for lpt_commit.c */</span>
<span class="kt">void</span> <span class="n">ubifs_pack_lsave</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">lsave</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_pack_ltab</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">ubifs_lpt_lprops</span> <span class="o">*</span><span class="n">ltab</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_pack_pnode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ubifs_pnode</span> <span class="o">*</span><span class="n">pnode</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_pack_nnode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">nnode</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ubifs_pnode</span> <span class="o">*</span><span class="n">ubifs_get_pnode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iip</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">ubifs_get_nnode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iip</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_read_nnode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iip</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_add_lpt_dirt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dirty</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_add_nnode_dirt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">nnode</span><span class="p">);</span>
<span class="kt">uint32_t</span> <span class="n">ubifs_unpack_bits</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">**</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nrbits</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">ubifs_first_nnode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">hght</span><span class="p">);</span>
<span class="cm">/* Needed only in debugging code in lpt_commit.c */</span>
<span class="kt">int</span> <span class="n">ubifs_unpack_nnode</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">nnode</span><span class="p">);</span>

<span class="cm">/* lpt_commit.c */</span>
<span class="kt">int</span> <span class="n">ubifs_lpt_start_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_lpt_end_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_lpt_post_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_lpt_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wr_only</span><span class="p">);</span>

<span class="cm">/* lprops.c */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">ubifs_change_lp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lp</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">free</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dirty</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">idx_gc_cnt</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_get_lp_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lp_stats</span> <span class="o">*</span><span class="n">lst</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_add_to_cat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">cat</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_replace_cat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">old_lprops</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">new_lprops</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_ensure_cat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_categorize_lprops</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_change_one_lp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">free</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dirty</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">flags_set</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags_clean</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx_gc_cnt</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_update_one_lp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">free</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dirty</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">flags_set</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags_clean</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_read_one_lp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lp</span><span class="p">);</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">ubifs_fast_find_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">ubifs_fast_find_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">ubifs_fast_find_freeable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">ubifs_fast_find_frdi_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_calc_dark</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">spc</span><span class="p">);</span>

<span class="cm">/* file.c */</span>
<span class="kt">int</span> <span class="n">ubifs_fsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datasync</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>

<span class="cm">/* dir.c */</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ubifs_new_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
			      <span class="n">umode_t</span> <span class="n">mode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_getattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">kstat</span> <span class="o">*</span><span class="n">stat</span><span class="p">);</span>

<span class="cm">/* xattr.c */</span>
<span class="kt">int</span> <span class="n">ubifs_setxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
		   <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="n">ubifs_getxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		       <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="n">ubifs_listxattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_removexattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="cm">/* super.c */</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ubifs_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">inum</span><span class="p">);</span>

<span class="cm">/* recovery.c */</span>
<span class="kt">int</span> <span class="n">ubifs_recover_master_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_write_rcvrd_mst_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">ubifs_recover_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">jhead</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">ubifs_recover_log_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sbuf</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_recover_inl_heads</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sbuf</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_clean_lebs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sbuf</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_rcvry_gc_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_recover_size_accum</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">deletion</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">new_size</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_recover_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_destroy_size_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>

<span class="cm">/* ioctl.c */</span>
<span class="kt">long</span> <span class="n">ubifs_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_set_inode_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="kt">long</span> <span class="n">ubifs_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* compressor.c */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="n">ubifs_compressors_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_compressors_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ubifs_compress</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">in_buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">in_len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">out_buf</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">out_len</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="o">*</span><span class="n">compr_type</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ubifs_decompress</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">out_len</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">compr_type</span><span class="p">);</span>

<span class="cp">#include &quot;debug.h&quot;</span>
<span class="cp">#include &quot;misc.h&quot;</span>
<span class="cp">#include &quot;key.h&quot;</span>

<span class="cp">#endif </span><span class="cm">/* !__UBIFS_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
