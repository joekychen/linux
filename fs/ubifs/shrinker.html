<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ubifs › shrinker.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>shrinker.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is part of UBIFS.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Nokia Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="cm"> * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> *          Adrian Hunter</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file implements UBIFS shrinker which evicts clean znodes from the TNC</span>
<span class="cm"> * tree when Linux VM needs more RAM.</span>
<span class="cm"> *</span>
<span class="cm"> * We do not implement any LRU lists to find oldest znodes to free because it</span>
<span class="cm"> * would add additional overhead to the file system fast paths. So the shrinker</span>
<span class="cm"> * just walks the TNC tree when searching for znodes to free.</span>
<span class="cm"> *</span>
<span class="cm"> * If the root of a TNC sub-tree is clean and old enough, then the children are</span>
<span class="cm"> * also clean and old enough. So the shrinker walks the TNC in level order and</span>
<span class="cm"> * dumps entire sub-trees.</span>
<span class="cm"> *</span>
<span class="cm"> * The age of znodes is just the time-stamp when they were last looked at.</span>
<span class="cm"> * The current shrinker first tries to evict old znodes, then young ones.</span>
<span class="cm"> *</span>
<span class="cm"> * Since the shrinker is global, it has to protect against races with FS</span>
<span class="cm"> * un-mounts, which is done by the &#39;ubifs_infos_lock&#39; and &#39;c-&gt;umount_mutex&#39;.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;ubifs.h&quot;</span>

<span class="cm">/* List of all UBIFS file-system instances */</span>
<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">ubifs_infos</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * We number each shrinker run and record the number on the ubifs_info structure</span>
<span class="cm"> * so that we can easily work out which ubifs_info structures have already been</span>
<span class="cm"> * done by the current run.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">shrinker_run_no</span><span class="p">;</span>

<span class="cm">/* Protects &#39;ubifs_infos&#39; list */</span>
<span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">ubifs_infos_lock</span><span class="p">);</span>

<span class="cm">/* Global clean znode counter (for all mounted UBIFS instances) */</span>
<span class="n">atomic_long_t</span> <span class="n">ubifs_clean_zn_cnt</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * shrink_tnc - shrink TNC tree.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @nr: number of znodes to free</span>
<span class="cm"> * @age: the age of znodes to free</span>
<span class="cm"> * @contention: if any contention, this is set to %1</span>
<span class="cm"> *</span>
<span class="cm"> * This function traverses TNC tree and frees clean znodes. It does not free</span>
<span class="cm"> * clean znodes which younger then @age. Returns number of freed znodes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">shrink_tnc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">age</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">contention</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">total_freed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">,</span> <span class="o">*</span><span class="n">zprev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">time</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">umount_mutex</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span> <span class="o">||</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">clean_zn_cnt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Traverse the TNC tree in levelorder manner, so that it is possible</span>
<span class="cm">	 * to destroy large sub-trees. Indeed, if a znode is old, then all its</span>
<span class="cm">	 * children are older or of the same age.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note, we are holding &#39;c-&gt;tnc_mutex&#39;, so we do not have to lock the</span>
<span class="cm">	 * &#39;c-&gt;space_lock&#39; when _reading_ &#39;c-&gt;clean_zn_cnt&#39;, because it is</span>
<span class="cm">	 * changed only when the &#39;c-&gt;tnc_mutex&#39; is held.</span>
<span class="cm">	 */</span>
	<span class="n">zprev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">znode</span> <span class="o">=</span> <span class="n">ubifs_tnc_levelorder_next</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">znode</span> <span class="o">&amp;&amp;</span> <span class="n">total_freed</span> <span class="o">&lt;</span> <span class="n">nr</span> <span class="o">&amp;&amp;</span>
	       <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">clean_zn_cnt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">freed</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the znode is clean, but it is in the &#39;c-&gt;cnext&#39; list, this</span>
<span class="cm">		 * means that this znode has just been written to flash as a</span>
<span class="cm">		 * part of commit and was marked clean. They will be removed</span>
<span class="cm">		 * from the list at end commit. We cannot change the list,</span>
<span class="cm">		 * because it is not protected by any mutex (design decision to</span>
<span class="cm">		 * make commit really independent and parallel to main I/O). So</span>
<span class="cm">		 * we just skip these znodes.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note, the &#39;clean_zn_cnt&#39; counters are not updated until</span>
<span class="cm">		 * after the commit, so the UBIFS shrinker does not report</span>
<span class="cm">		 * the znodes which are in the &#39;c-&gt;cnext&#39; list as freeable.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Also note, if the root of a sub-tree is not in &#39;c-&gt;cnext&#39;,</span>
<span class="cm">		 * then the whole sub-tree is not in &#39;c-&gt;cnext&#39; as well, so it</span>
<span class="cm">		 * is safe to dump whole sub-tree.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Very soon these znodes will be removed from the list</span>
<span class="cm">			 * and become freeable.</span>
<span class="cm">			 */</span>
			<span class="o">*</span><span class="n">contention</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubifs_zn_dirty</span><span class="p">(</span><span class="n">znode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			   <span class="n">abs</span><span class="p">(</span><span class="n">time</span> <span class="o">-</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">age</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
				<span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span><span class="p">].</span><span class="n">znode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="n">freed</span> <span class="o">=</span> <span class="n">ubifs_destroy_tnc_subtree</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
			<span class="n">atomic_long_sub</span><span class="p">(</span><span class="n">freed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubifs_clean_zn_cnt</span><span class="p">);</span>
			<span class="n">atomic_long_sub</span><span class="p">(</span><span class="n">freed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">clean_zn_cnt</span><span class="p">);</span>
			<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">clean_zn_cnt</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">total_freed</span> <span class="o">+=</span> <span class="n">freed</span><span class="p">;</span>
			<span class="n">znode</span> <span class="o">=</span> <span class="n">zprev</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">zprev</span> <span class="o">=</span> <span class="n">znode</span><span class="p">;</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">ubifs_tnc_levelorder_next</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">total_freed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * shrink_tnc_trees - shrink UBIFS TNC trees.</span>
<span class="cm"> * @nr: number of znodes to free</span>
<span class="cm"> * @age: the age of znodes to free</span>
<span class="cm"> * @contention: if any contention, this is set to %1</span>
<span class="cm"> *</span>
<span class="cm"> * This function walks the list of mounted UBIFS file-systems and frees clean</span>
<span class="cm"> * znodes which are older than @age, until at least @nr znodes are freed.</span>
<span class="cm"> * Returns the number of freed znodes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">shrink_tnc_trees</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">age</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">contention</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">run_no</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">freed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_infos_lock</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">run_no</span> <span class="o">=</span> <span class="o">++</span><span class="n">shrinker_run_no</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">run_no</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* Iterate over all mounted UBIFS file-systems and try to shrink them */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">ubifs_infos</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ubifs_infos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_info</span><span class="p">,</span> <span class="n">infos_list</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We move the ones we do to the end of the list, so we stop</span>
<span class="cm">		 * when we see one we have already done.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">shrinker_run_no</span> <span class="o">==</span> <span class="n">run_no</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">umount_mutex</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Some un-mount is in progress, try next FS */</span>
			<span class="o">*</span><span class="n">contention</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * We&#39;re holding &#39;c-&gt;umount_mutex&#39;, so the file-system won&#39;t go</span>
<span class="cm">		 * away.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">umount_mutex</span><span class="p">);</span>
			<span class="o">*</span><span class="n">contention</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_infos_lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * OK, now we have TNC locked, the file-system cannot go away -</span>
<span class="cm">		 * it is safe to reap the cache.</span>
<span class="cm">		 */</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">shrinker_run_no</span> <span class="o">=</span> <span class="n">run_no</span><span class="p">;</span>
		<span class="n">freed</span> <span class="o">+=</span> <span class="n">shrink_tnc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">contention</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_infos_lock</span><span class="p">);</span>
		<span class="cm">/* Get the next list element before we move this one */</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Move this one to the end of the list to provide some</span>
<span class="cm">		 * fairness.</span>
<span class="cm">		 */</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">infos_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubifs_infos</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">umount_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">freed</span> <span class="o">&gt;=</span> <span class="n">nr</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_infos_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">freed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kick_a_thread - kick a background thread to start commit.</span>
<span class="cm"> *</span>
<span class="cm"> * This function kicks a background thread to start background commit. Returns</span>
<span class="cm"> * %-1 if a thread was kicked or there is another reason to assume the memory</span>
<span class="cm"> * will soon be freed or become freeable. If there are no dirty znodes, returns</span>
<span class="cm"> * %0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">kick_a_thread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Iterate over all mounted UBIFS file-systems and find out if there is</span>
<span class="cm">	 * already an ongoing commit operation there. If no, then iterate for</span>
<span class="cm">	 * the second time and initiate background commit.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_infos_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubifs_infos</span><span class="p">,</span> <span class="n">infos_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">long</span> <span class="n">dirty_zn_cnt</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">umount_mutex</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Some un-mount is in progress, it will</span>
<span class="cm">				 * certainly free memory, so just return.</span>
<span class="cm">				 */</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_infos_lock</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">dirty_zn_cnt</span> <span class="o">=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_zn_cnt</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dirty_zn_cnt</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">==</span> <span class="n">COMMIT_BROKEN</span> <span class="o">||</span>
			    <span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_error</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">umount_mutex</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">!=</span> <span class="n">COMMIT_RESTING</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_infos_lock</span><span class="p">);</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">umount_mutex</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">infos_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubifs_infos</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_infos_lock</span><span class="p">);</span>

				<span class="n">ubifs_request_bg_commit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">umount_mutex</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">umount_mutex</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_infos_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ubifs_shrinker</span><span class="p">(</span><span class="k">struct</span> <span class="n">shrinker</span> <span class="o">*</span><span class="n">shrink</span><span class="p">,</span> <span class="k">struct</span> <span class="n">shrink_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_to_scan</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">freed</span><span class="p">,</span> <span class="n">contention</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">clean_zn_cnt</span> <span class="o">=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_clean_zn_cnt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Due to the way UBIFS updates the clean znode counter it may</span>
<span class="cm">		 * temporarily be negative.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">clean_zn_cnt</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">clean_zn_cnt</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clean_zn_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * No clean znodes, nothing to reap. All we can do in this case</span>
<span class="cm">		 * is to kick background threads to start commit, which will</span>
<span class="cm">		 * probably make clean znodes which, in turn, will be freeable.</span>
<span class="cm">		 * And we return -1 which means will make VM call us again</span>
<span class="cm">		 * later.</span>
<span class="cm">		 */</span>
		<span class="n">dbg_tnc</span><span class="p">(</span><span class="s">&quot;no clean znodes, kick a thread&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">kick_a_thread</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">freed</span> <span class="o">=</span> <span class="n">shrink_tnc_trees</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">OLD_ZNODE_AGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">contention</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">freed</span> <span class="o">&gt;=</span> <span class="n">nr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">dbg_tnc</span><span class="p">(</span><span class="s">&quot;not enough old znodes, try to free young ones&quot;</span><span class="p">);</span>
	<span class="n">freed</span> <span class="o">+=</span> <span class="n">shrink_tnc_trees</span><span class="p">(</span><span class="n">nr</span> <span class="o">-</span> <span class="n">freed</span><span class="p">,</span> <span class="n">YOUNG_ZNODE_AGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">contention</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">freed</span> <span class="o">&gt;=</span> <span class="n">nr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">dbg_tnc</span><span class="p">(</span><span class="s">&quot;not enough young znodes, free all&quot;</span><span class="p">);</span>
	<span class="n">freed</span> <span class="o">+=</span> <span class="n">shrink_tnc_trees</span><span class="p">(</span><span class="n">nr</span> <span class="o">-</span> <span class="n">freed</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">contention</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">freed</span> <span class="o">&amp;&amp;</span> <span class="n">contention</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_tnc</span><span class="p">(</span><span class="s">&quot;freed nothing, but contention&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">dbg_tnc</span><span class="p">(</span><span class="s">&quot;%d znodes were freed, requested %d&quot;</span><span class="p">,</span> <span class="n">freed</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">freed</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
