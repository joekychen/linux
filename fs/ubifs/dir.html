<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ubifs › dir.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>dir.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* * This file is part of UBIFS.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Nokia Corporation.</span>
<span class="cm"> * Copyright (C) 2006, 2007 University of Szeged, Hungary</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="cm"> * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> *          Adrian Hunter</span>
<span class="cm"> *          Zoltan Sogor</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file implements directory operations.</span>
<span class="cm"> *</span>
<span class="cm"> * All FS operations in this file allocate budget before writing anything to the</span>
<span class="cm"> * media. If they fail to allocate it, the error is returned. The only</span>
<span class="cm"> * exceptions are &#39;ubifs_unlink()&#39; and &#39;ubifs_rmdir()&#39; which keep working even</span>
<span class="cm"> * if they unable to allocate the budget, because deletion %-ENOSPC failure is</span>
<span class="cm"> * not what users are usually ready to get. UBIFS budgeting subsystem has some</span>
<span class="cm"> * space reserved for these purposes.</span>
<span class="cm"> *</span>
<span class="cm"> * All operations in this file write all inodes which they change straight</span>
<span class="cm"> * away, instead of marking them dirty. For example, &#39;ubifs_link()&#39; changes</span>
<span class="cm"> * @i_size of the parent inode and writes the parent inode together with the</span>
<span class="cm"> * target inode. This was done to simplify file-system recovery which would</span>
<span class="cm"> * otherwise be very difficult to do. The only exception is rename which marks</span>
<span class="cm"> * the re-named inode dirty (because its @i_ctime is updated) but does not</span>
<span class="cm"> * write it, but just marks it as dirty.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;ubifs.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * inherit_flags - inherit flags of the parent inode.</span>
<span class="cm"> * @dir: parent inode</span>
<span class="cm"> * @mode: new inode mode flags</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function for &#39;ubifs_new_inode()&#39; which inherits flag of the</span>
<span class="cm"> * parent directory inode @dir. UBIFS inodes inherit the following flags:</span>
<span class="cm"> * o %UBIFS_COMPR_FL, which is useful to switch compression on/of on</span>
<span class="cm"> *   sub-directory basis;</span>
<span class="cm"> * o %UBIFS_SYNC_FL - useful for the same reasons;</span>
<span class="cm"> * o %UBIFS_DIRSYNC_FL - similar, but relevant only to directories.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the inherited flags.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">inherit_flags</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="cm">/*</span>
<span class="cm">		 * The parent is not a directory, which means that an extended</span>
<span class="cm">		 * attribute inode is being created. No flags.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UBIFS_COMPR_FL</span> <span class="o">|</span> <span class="n">UBIFS_SYNC_FL</span> <span class="o">|</span> <span class="n">UBIFS_DIRSYNC_FL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
		<span class="cm">/* The &quot;DIRSYNC&quot; flag only applies to directories */</span>
		<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">UBIFS_DIRSYNC_FL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_new_inode - allocate new UBIFS inode object.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @dir: parent directory inode</span>
<span class="cm"> * @mode: inode mode flags</span>
<span class="cm"> *</span>
<span class="cm"> * This function finds an unused inode number, allocates new inode and</span>
<span class="cm"> * initializes it. Returns new inode in case of success and an error code in</span>
<span class="cm"> * case of failure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">ubifs_new_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
			      <span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">new_inode</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vfs_sb</span><span class="p">);</span>
	<span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set &#39;S_NOCMTIME&#39; to prevent VFS form updating [mc]time of inodes and</span>
<span class="cm">	 * marking them dirty in file write path (see &#39;file_update_time()&#39;).</span>
<span class="cm">	 * UBIFS has to fully control &quot;clean &lt;-&gt; dirty&quot; transitions of inodes</span>
<span class="cm">	 * to make budgeting work.</span>
<span class="cm">	 */</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_NOCMTIME</span><span class="p">;</span>

	<span class="n">inode_init_owner</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span>
			 <span class="n">ubifs_current_time</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Disable readahead */</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">S_IFREG</span>:
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ubifs_file_address_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ubifs_file_inode_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ubifs_file_operations</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFDIR</span>:
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">ubifs_dir_inode_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ubifs_dir_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">UBIFS_INO_NODE_SZ</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFLNK</span>:
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ubifs_symlink_inode_operations</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFSOCK</span>:
	<span class="k">case</span> <span class="n">S_IFIFO</span>:
	<span class="k">case</span> <span class="n">S_IFBLK</span>:
	<span class="k">case</span> <span class="n">S_IFCHR</span>:
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">ubifs_file_inode_operations</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">inherit_flags</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="n">ubifs_set_inode_flags</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
		<span class="n">ui</span><span class="o">-&gt;</span><span class="n">compr_type</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">default_compr</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ui</span><span class="o">-&gt;</span><span class="n">compr_type</span> <span class="o">=</span> <span class="n">UBIFS_COMPR_NONE</span><span class="p">;</span>
	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">synced_i_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cnt_lock</span><span class="p">);</span>
	<span class="cm">/* Inode number overflow is currently not supported */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">highest_inum</span> <span class="o">&gt;=</span> <span class="n">INUM_WARN_WATERMARK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">highest_inum</span> <span class="o">&gt;=</span> <span class="n">INUM_WATERMARK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cnt_lock</span><span class="p">);</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;out of inode numbers&quot;</span><span class="p">);</span>
			<span class="n">make_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;running out of inode numbers (current %lu, max %d)&quot;</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">highest_inum</span><span class="p">,</span> <span class="n">INUM_WATERMARK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="o">++</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">highest_inum</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The creation sequence number remains with this inode for its</span>
<span class="cm">	 * lifetime. All nodes for this inode have a greater sequence number,</span>
<span class="cm">	 * and so it is possible to distinguish obsolete nodes belonging to a</span>
<span class="cm">	 * previous incarnation of the same inode number - for example, for the</span>
<span class="cm">	 * purpose of rebuilding the index.</span>
<span class="cm">	 */</span>
	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">creat_sqnum</span> <span class="o">=</span> <span class="o">++</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_sqnum</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cnt_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_check_name</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">dent</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">nm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_chk_gen</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">nlen</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">ubifs_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">dent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;&#39;%.*s&#39; in dir ino %lu&quot;</span><span class="p">,</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">UBIFS_MAX_NLEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">);</span>

	<span class="n">dent</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">UBIFS_MAX_DENT_NODE_SZ</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dent</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">dent_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_lookup_nm</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">dent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;not found&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dbg_check_name</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">ubifs_iget</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This should not happen. Probably the file-system needs</span>
<span class="cm">		 * checking.</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;dead directory entry &#39;%.*s&#39;, error %d&quot;</span><span class="p">,</span>
			  <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">ubifs_ro_mode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dent</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Note, d_splice_alias() would be required instead if we supported</span>
<span class="cm">	 * NFS.</span>
<span class="cm">	 */</span>
	<span class="n">d_add</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dent</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">sz_change</span> <span class="o">=</span> <span class="n">CALC_DENT_SIZE</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="n">req</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">new_ino</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">new_dent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
					<span class="p">.</span><span class="n">dirtied_ino</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">dir_ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Budget request settings: new inode, new direntry, changing the</span>
<span class="cm">	 * parent directory inode.</span>
<span class="cm">	 */</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;dent &#39;%.*s&#39;, mode %#hx in dir ino %lu&quot;</span><span class="p">,</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_budget_space</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">ubifs_new_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_budg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+=</span> <span class="n">sz_change</span><span class="p">;</span>
	<span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_jnl_update</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_cancel</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>

	<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="n">insert_inode_hash</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_cancel:</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-=</span> <span class="n">sz_change</span><span class="p">;</span>
	<span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
	<span class="n">make_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="nl">out_budg:</span>
	<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot create regular file, error %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vfs_dent_type - get VFS directory entry type.</span>
<span class="cm"> * @type: UBIFS directory entry type</span>
<span class="cm"> *</span>
<span class="cm"> * This function converts UBIFS directory entry type into VFS directory entry</span>
<span class="cm"> * type.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">vfs_dent_type</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UBIFS_ITYPE_REG</span>:
		<span class="k">return</span> <span class="n">DT_REG</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_ITYPE_DIR</span>:
		<span class="k">return</span> <span class="n">DT_DIR</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_ITYPE_LNK</span>:
		<span class="k">return</span> <span class="n">DT_LNK</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_ITYPE_BLK</span>:
		<span class="k">return</span> <span class="n">DT_BLK</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_ITYPE_CHR</span>:
		<span class="k">return</span> <span class="n">DT_CHR</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_ITYPE_FIFO</span>:
		<span class="k">return</span> <span class="n">DT_FIFO</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_ITYPE_SOCK</span>:
		<span class="k">return</span> <span class="n">DT_SOCK</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The classical Unix view for directory is that it is a linear array of</span>
<span class="cm"> * (name, inode number) entries. Linux/VFS assumes this model as well.</span>
<span class="cm"> * Particularly, &#39;readdir()&#39; call wants us to return a directory entry offset</span>
<span class="cm"> * which later may be used to continue &#39;readdir()&#39;ing the directory or to</span>
<span class="cm"> * &#39;seek()&#39; to that specific direntry. Obviously UBIFS does not really fit this</span>
<span class="cm"> * model because directory entries are identified by keys, which may collide.</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS uses directory entry hash value for directory offsets, so</span>
<span class="cm"> * &#39;seekdir()&#39;/&#39;telldir()&#39; may not always work because of possible key</span>
<span class="cm"> * collisions. But UBIFS guarantees that consecutive &#39;readdir()&#39; calls work</span>
<span class="cm"> * properly by means of saving full directory entry name in the private field</span>
<span class="cm"> * of the file description object.</span>
<span class="cm"> *</span>
<span class="cm"> * This means that UBIFS cannot support NFS which requires full</span>
<span class="cm"> * &#39;seekdir()&#39;/&#39;telldir()&#39; support.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_readdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dirent</span><span class="p">,</span> <span class="n">filldir_t</span> <span class="n">filldir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">over</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">nm</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">dent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;dir ino %lu, f_pos %#llx&quot;</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">&gt;</span> <span class="n">UBIFS_S_KEY_HASH_MASK</span> <span class="o">||</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * The directory was seek&#39;ed to a senseless position or there</span>
<span class="cm">		 * are no more entries.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* File positions 0 and 1 correspond to &quot;.&quot; and &quot;..&quot; */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">);</span>
		<span class="n">over</span> <span class="o">=</span> <span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="s">&quot;.&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">DT_DIR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">over</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">);</span>
		<span class="n">over</span> <span class="o">=</span> <span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="s">&quot;..&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			       <span class="n">parent_ino</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">),</span> <span class="n">DT_DIR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">over</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Find the first entry in TNC and save it */</span>
		<span class="n">lowest_dent_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="n">nm</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">dent</span> <span class="o">=</span> <span class="n">ubifs_tnc_next_ent</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dent</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dent</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">key_hash_flash</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">dent</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dent</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dent</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The directory was seek&#39;ed to and is now readdir&#39;ed.</span>
<span class="cm">		 * Find the entry corresponding to @file-&gt;f_pos or the</span>
<span class="cm">		 * closest one.</span>
<span class="cm">		 */</span>
		<span class="n">dent_key_init_hash</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">);</span>
		<span class="n">nm</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">dent</span> <span class="o">=</span> <span class="n">ubifs_tnc_next_ent</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dent</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dent</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">key_hash_flash</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">dent</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;feed &#39;%s&#39;, ino %llu, new f_pos %#x&quot;</span><span class="p">,</span>
			<span class="n">dent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">),</span>
			<span class="n">key_hash_flash</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">));</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">sqnum</span><span class="p">)</span> <span class="o">&gt;</span>
			     <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">creat_sqnum</span><span class="p">);</span>

		<span class="n">nm</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">nlen</span><span class="p">);</span>
		<span class="n">over</span> <span class="o">=</span> <span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="n">dent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">nm</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">,</span>
			       <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">),</span>
			       <span class="n">vfs_dent_type</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">over</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Switch to the next entry */</span>
		<span class="n">key_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
		<span class="n">nm</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">dent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="n">dent</span> <span class="o">=</span> <span class="n">ubifs_tnc_next_ent</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dent</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dent</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">);</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">key_hash_flash</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">dent</span><span class="p">;</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot find next direntry, error %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">);</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* If a directory is seeked, we have to free saved readdir() state */</span>
<span class="k">static</span> <span class="n">loff_t</span> <span class="nf">ubifs_dir_llseek</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">);</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">generic_file_llseek</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">origin</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Free saved readdir() state when the directory is closed */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_dir_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">);</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lock_2_inodes - a wrapper for locking two UBIFS inodes.</span>
<span class="cm"> * @inode1: first inode</span>
<span class="cm"> * @inode2: second inode</span>
<span class="cm"> *</span>
<span class="cm"> * We do not implement any tricks to guarantee strict lock ordering, because</span>
<span class="cm"> * VFS has already done it for us on the @i_mutex. So this is just a simple</span>
<span class="cm"> * wrapper function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lock_2_inodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">,</span> <span class="n">WB_MUTEX_1</span><span class="p">);</span>
	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">,</span> <span class="n">WB_MUTEX_2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * unlock_2_inodes - a wrapper for unlocking two UBIFS inodes.</span>
<span class="cm"> * @inode1: first inode</span>
<span class="cm"> * @inode2: second inode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">unlock_2_inodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">dir_ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">sz_change</span> <span class="o">=</span> <span class="n">CALC_DENT_SIZE</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="n">req</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">new_dent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">dirtied_ino</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
				<span class="p">.</span><span class="n">dirtied_ino_d</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="p">};</span>

	<span class="cm">/*</span>
<span class="cm">	 * Budget request settings: new direntry, changing the target inode,</span>
<span class="cm">	 * changing the parent inode.</span>
<span class="cm">	 */</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;dent &#39;%.*s&#39; to ino %lu (nlink %d) in dir ino %lu&quot;</span><span class="p">,</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">));</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_synced_i_size</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_budget_space</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">lock_2_inodes</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">inc_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ihold</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">ubifs_current_time</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+=</span> <span class="n">sz_change</span><span class="p">;</span>
	<span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_jnl_update</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_cancel</span><span class="p">;</span>
	<span class="n">unlock_2_inodes</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_cancel:</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-=</span> <span class="n">sz_change</span><span class="p">;</span>
	<span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">drop_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">unlock_2_inodes</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">dir_ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">sz_change</span> <span class="o">=</span> <span class="n">CALC_DENT_SIZE</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">budgeted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="n">req</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">mod_dent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">dirtied_ino</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">saved_nlink</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Budget request settings: deletion direntry, deletion inode (+1 for</span>
<span class="cm">	 * @dirtied_ino), changing the parent directory inode. If budgeting</span>
<span class="cm">	 * fails, go ahead anyway because we have extra space reserved for</span>
<span class="cm">	 * deletions.</span>
<span class="cm">	 */</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;dent &#39;%.*s&#39; from ino %lu (nlink %d) in dir ino %lu&quot;</span><span class="p">,</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">));</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_synced_i_size</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_budget_space</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">budgeted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lock_2_inodes</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">ubifs_current_time</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="n">drop_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-=</span> <span class="n">sz_change</span><span class="p">;</span>
	<span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_jnl_update</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_cancel</span><span class="p">;</span>
	<span class="n">unlock_2_inodes</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">budgeted</span><span class="p">)</span>
		<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* We&#39;ve deleted something - clean the &quot;no space&quot; flags */</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">nospace</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">nospace_rp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_cancel:</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+=</span> <span class="n">sz_change</span><span class="p">;</span>
	<span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">saved_nlink</span><span class="p">);</span>
	<span class="n">unlock_2_inodes</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">budgeted</span><span class="p">)</span>
		<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * check_dir_empty - check if a directory is empty or not.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @dir: VFS inode object of the directory to check</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks if directory @dir is empty. Returns zero if the</span>
<span class="cm"> * directory is empty, %-ENOTEMPTY if it is not, and other negative error codes</span>
<span class="cm"> * in case of of errors.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_dir_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">nm</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">dent</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">lowest_dent_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">dent</span> <span class="o">=</span> <span class="n">ubifs_tnc_next_ent</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dent</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dent</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dent</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTEMPTY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_rmdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sz_change</span> <span class="o">=</span> <span class="n">CALC_DENT_SIZE</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">budgeted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">dir_ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="n">req</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">mod_dent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">dirtied_ino</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">};</span>

	<span class="cm">/*</span>
<span class="cm">	 * Budget request settings: deletion direntry, deletion inode and</span>
<span class="cm">	 * changing the parent inode. If budgeting fails, go ahead anyway</span>
<span class="cm">	 * because we have extra space reserved for deletions.</span>
<span class="cm">	 */</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;directory &#39;%.*s&#39;, ino %lu in dir ino %lu&quot;</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">));</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">check_dir_empty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_budget_space</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">budgeted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lock_2_inodes</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">ubifs_current_time</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="n">clear_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">drop_nlink</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-=</span> <span class="n">sz_change</span><span class="p">;</span>
	<span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_jnl_update</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_cancel</span><span class="p">;</span>
	<span class="n">unlock_2_inodes</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">budgeted</span><span class="p">)</span>
		<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* We&#39;ve deleted something - clean the &quot;no space&quot; flags */</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">nospace</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">nospace_rp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_cancel:</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+=</span> <span class="n">sz_change</span><span class="p">;</span>
	<span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">inc_nlink</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">unlock_2_inodes</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">budgeted</span><span class="p">)</span>
		<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_mkdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">dir_ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">sz_change</span> <span class="o">=</span> <span class="n">CALC_DENT_SIZE</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="n">req</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">new_ino</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">new_dent</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">};</span>

	<span class="cm">/*</span>
<span class="cm">	 * Budget request settings: new inode, new direntry and changing parent</span>
<span class="cm">	 * directory inode.</span>
<span class="cm">	 */</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;dent &#39;%.*s&#39;, mode %#hx in dir ino %lu&quot;</span><span class="p">,</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_budget_space</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">ubifs_new_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">S_IFDIR</span> <span class="o">|</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_budg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
	<span class="n">insert_inode_hash</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">inc_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">inc_nlink</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+=</span> <span class="n">sz_change</span><span class="p">;</span>
	<span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_jnl_update</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot create directory, error %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_cancel</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>

	<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_cancel:</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-=</span> <span class="n">sz_change</span><span class="p">;</span>
	<span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">drop_nlink</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
	<span class="n">make_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="nl">out_budg:</span>
	<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_mknod</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
		       <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dev_t</span> <span class="n">rdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">dir_ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_dev_desc</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sz_change</span> <span class="o">=</span> <span class="n">CALC_DENT_SIZE</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">devlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="n">req</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">new_ino</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">new_dent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
					<span class="p">.</span><span class="n">new_ino_d</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">devlen</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
					<span class="p">.</span><span class="n">dirtied_ino</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">};</span>

	<span class="cm">/*</span>
<span class="cm">	 * Budget request settings: new inode, new direntry and changing parent</span>
<span class="cm">	 * directory inode.</span>
<span class="cm">	 */</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;dent &#39;%.*s&#39; in dir ino %lu&quot;</span><span class="p">,</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_valid_dev</span><span class="p">(</span><span class="n">rdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISBLK</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISCHR</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">ubifs_dev_desc</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">devlen</span> <span class="o">=</span> <span class="n">ubifs_encode_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rdev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_budget_space</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">ubifs_new_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_budg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">init_special_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span> <span class="n">rdev</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">devlen</span><span class="p">;</span>
	<span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">devlen</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+=</span> <span class="n">sz_change</span><span class="p">;</span>
	<span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_jnl_update</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_cancel</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>

	<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="n">insert_inode_hash</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_cancel:</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-=</span> <span class="n">sz_change</span><span class="p">;</span>
	<span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
	<span class="n">make_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="nl">out_budg:</span>
	<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">dir_ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">symname</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">sz_change</span> <span class="o">=</span> <span class="n">CALC_DENT_SIZE</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="n">req</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">new_ino</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">new_dent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
					<span class="p">.</span><span class="n">new_ino_d</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
					<span class="p">.</span><span class="n">dirtied_ino</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">};</span>

	<span class="cm">/*</span>
<span class="cm">	 * Budget request settings: new inode, new direntry and changing parent</span>
<span class="cm">	 * directory inode.</span>
<span class="cm">	 */</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;dent &#39;%.*s&#39;, target &#39;%s&#39; in dir ino %lu&quot;</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">symname</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">UBIFS_MAX_INO_DATA</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_budget_space</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">ubifs_new_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">S_IFLNK</span> <span class="o">|</span> <span class="n">S_IRWXUGO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_budg</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_inode</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">symname</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The terminating zero byte is not written to the flash media and it</span>
<span class="cm">	 * is put just to make later in-memory string processing simpler. Thus,</span>
<span class="cm">	 * data length is @len, not @len + %1.</span>
<span class="cm">	 */</span>
	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+=</span> <span class="n">sz_change</span><span class="p">;</span>
	<span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_jnl_update</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_cancel</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>

	<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="n">insert_inode_hash</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_cancel:</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-=</span> <span class="n">sz_change</span><span class="p">;</span>
	<span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
<span class="nl">out_inode:</span>
	<span class="n">make_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="nl">out_budg:</span>
	<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lock_3_inodes - a wrapper for locking three UBIFS inodes.</span>
<span class="cm"> * @inode1: first inode</span>
<span class="cm"> * @inode2: second inode</span>
<span class="cm"> * @inode3: third inode</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used for &#39;ubifs_rename()&#39; and @inode1 may be the same as</span>
<span class="cm"> * @inode2 whereas @inode3 may be %NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * We do not implement any tricks to guarantee strict lock ordering, because</span>
<span class="cm"> * VFS has already done it for us on the @i_mutex. So this is just a simple</span>
<span class="cm"> * wrapper function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lock_3_inodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode2</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">,</span> <span class="n">WB_MUTEX_1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode2</span> <span class="o">!=</span> <span class="n">inode1</span><span class="p">)</span>
		<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">,</span> <span class="n">WB_MUTEX_2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode3</span><span class="p">)</span>
		<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode3</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">,</span> <span class="n">WB_MUTEX_3</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * unlock_3_inodes - a wrapper for unlocking three UBIFS inodes for rename.</span>
<span class="cm"> * @inode1: first inode</span>
<span class="cm"> * @inode2: second inode</span>
<span class="cm"> * @inode3: third inode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">unlock_3_inodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode2</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode3</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode3</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode1</span> <span class="o">!=</span> <span class="n">inode2</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">new_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old_inode</span> <span class="o">=</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">new_inode</span> <span class="o">=</span> <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">old_inode_ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">old_inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">release</span><span class="p">,</span> <span class="n">sync</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">move</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_dir</span> <span class="o">!=</span> <span class="n">old_dir</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">is_dir</span> <span class="o">=</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">old_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">unlink</span> <span class="o">=</span> <span class="o">!!</span><span class="n">new_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new_sz</span> <span class="o">=</span> <span class="n">CALC_DENT_SIZE</span><span class="p">(</span><span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">old_sz</span> <span class="o">=</span> <span class="n">CALC_DENT_SIZE</span><span class="p">(</span><span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="n">req</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">new_dent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">mod_dent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
					<span class="p">.</span><span class="n">dirtied_ino</span> <span class="o">=</span> <span class="mi">3</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="n">ino_req</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">dirtied_ino</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
			<span class="p">.</span><span class="n">dirtied_ino_d</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">old_inode_ui</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">saved_nlink</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Budget request settings: deletion direntry, new direntry, removing</span>
<span class="cm">	 * the old inode, and changing old and new parent directory inodes.</span>
<span class="cm">	 *</span>
<span class="cm">	 * However, this operation also marks the target inode as dirty and</span>
<span class="cm">	 * does not write it, so we allocate budget for the target inode</span>
<span class="cm">	 * separately.</span>
<span class="cm">	 */</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;dent &#39;%.*s&#39; ino %lu in dir ino %lu to dent &#39;%.*s&#39; in &quot;</span>
		<span class="s">&quot;dir ino %lu&quot;</span><span class="p">,</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
		<span class="n">old_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
		<span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlink</span><span class="p">)</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">));</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">unlink</span> <span class="o">&amp;&amp;</span> <span class="n">is_dir</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">check_dir_empty</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">new_inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_budget_space</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_budget_space</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ino_req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lock_3_inodes</span><span class="p">(</span><span class="n">old_dir</span><span class="p">,</span> <span class="n">new_dir</span><span class="p">,</span> <span class="n">new_inode</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Like most other Unix systems, set the @i_ctime for inodes on a</span>
<span class="cm">	 * rename.</span>
<span class="cm">	 */</span>
	<span class="n">time</span> <span class="o">=</span> <span class="n">ubifs_current_time</span><span class="p">(</span><span class="n">old_dir</span><span class="p">);</span>
	<span class="n">old_inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span>

	<span class="cm">/* We must adjust parent link count when renaming directories */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_dir</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">move</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * @old_dir loses a link because we are moving</span>
<span class="cm">			 * @old_inode to a different directory.</span>
<span class="cm">			 */</span>
			<span class="n">drop_nlink</span><span class="p">(</span><span class="n">old_dir</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * @new_dir only gains a link if we are not also</span>
<span class="cm">			 * overwriting an existing directory.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unlink</span><span class="p">)</span>
				<span class="n">inc_nlink</span><span class="p">(</span><span class="n">new_dir</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * @old_inode is not moving to a different directory,</span>
<span class="cm">			 * but @old_dir still loses a link if we are</span>
<span class="cm">			 * overwriting an existing directory.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlink</span><span class="p">)</span>
				<span class="n">drop_nlink</span><span class="p">(</span><span class="n">old_dir</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-=</span> <span class="n">old_sz</span><span class="p">;</span>
	<span class="n">ubifs_inode</span><span class="p">(</span><span class="n">old_dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span>
	<span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * And finally, if we unlinked a direntry which happened to have the</span>
<span class="cm">	 * same name as the moved direntry, we have to decrement @i_nlink of</span>
<span class="cm">	 * the unlinked inode and change its ctime.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlink</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Directories cannot have hard-links, so if this is a</span>
<span class="cm">		 * directory, just clear @i_nlink.</span>
<span class="cm">		 */</span>
		<span class="n">saved_nlink</span> <span class="o">=</span> <span class="n">new_inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_dir</span><span class="p">)</span>
			<span class="n">clear_nlink</span><span class="p">(</span><span class="n">new_inode</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">drop_nlink</span><span class="p">(</span><span class="n">new_inode</span><span class="p">);</span>
		<span class="n">new_inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+=</span> <span class="n">new_sz</span><span class="p">;</span>
		<span class="n">ubifs_inode</span><span class="p">(</span><span class="n">new_dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do not ask &#39;ubifs_jnl_rename()&#39; to flush write-buffer if @old_inode</span>
<span class="cm">	 * is dirty, because this will be done later on at the end of</span>
<span class="cm">	 * &#39;ubifs_rename()&#39;.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_SYNC</span><span class="p">(</span><span class="n">old_inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sync</span> <span class="o">=</span> <span class="n">IS_DIRSYNC</span><span class="p">(</span><span class="n">old_dir</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_DIRSYNC</span><span class="p">(</span><span class="n">new_dir</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlink</span> <span class="o">&amp;&amp;</span> <span class="n">IS_SYNC</span><span class="p">(</span><span class="n">new_inode</span><span class="p">))</span>
			<span class="n">sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_jnl_rename</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">old_dir</span><span class="p">,</span> <span class="n">old_dentry</span><span class="p">,</span> <span class="n">new_dir</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">,</span>
			       <span class="n">sync</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_cancel</span><span class="p">;</span>

	<span class="n">unlock_3_inodes</span><span class="p">(</span><span class="n">old_dir</span><span class="p">,</span> <span class="n">new_dir</span><span class="p">,</span> <span class="n">new_inode</span><span class="p">);</span>
	<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_inode_ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
	<span class="n">release</span> <span class="o">=</span> <span class="n">old_inode_ui</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">;</span>
	<span class="n">mark_inode_dirty_sync</span><span class="p">(</span><span class="n">old_inode</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_inode_ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">release</span><span class="p">)</span>
		<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ino_req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_SYNC</span><span class="p">(</span><span class="n">old_inode</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">old_inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">write_inode</span><span class="p">(</span><span class="n">old_inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_cancel:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlink</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_nlink</span><span class="p">(</span><span class="n">new_inode</span><span class="p">,</span> <span class="n">saved_nlink</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-=</span> <span class="n">new_sz</span><span class="p">;</span>
		<span class="n">ubifs_inode</span><span class="p">(</span><span class="n">new_dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+=</span> <span class="n">old_sz</span><span class="p">;</span>
	<span class="n">ubifs_inode</span><span class="p">(</span><span class="n">old_dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_dir</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">move</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">inc_nlink</span><span class="p">(</span><span class="n">old_dir</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unlink</span><span class="p">)</span>
				<span class="n">drop_nlink</span><span class="p">(</span><span class="n">new_dir</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlink</span><span class="p">)</span>
				<span class="n">inc_nlink</span><span class="p">(</span><span class="n">old_dir</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">unlock_3_inodes</span><span class="p">(</span><span class="n">old_dir</span><span class="p">,</span> <span class="n">new_dir</span><span class="p">,</span> <span class="n">new_inode</span><span class="p">);</span>
	<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ino_req</span><span class="p">);</span>
	<span class="n">ubifs_release_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ubifs_getattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">kstat</span> <span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
	<span class="n">generic_fillattr</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">blksize</span> <span class="o">=</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">;</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unfortunately, the &#39;stat()&#39; system call was designed for block</span>
<span class="cm">	 * device based file systems, and it is not appropriate for UBIFS,</span>
<span class="cm">	 * because UBIFS does not have notion of &quot;block&quot;. For example, it is</span>
<span class="cm">	 * difficult to tell how many block a directory takes - it actually</span>
<span class="cm">	 * takes less than 300 bytes, but we have to round it to block size,</span>
<span class="cm">	 * which introduces large mistake. This makes utilities like &#39;du&#39; to</span>
<span class="cm">	 * report completely senseless numbers. This is the reason why UBIFS</span>
<span class="cm">	 * goes the same way as JFFS2 - it reports zero blocks for everything</span>
<span class="cm">	 * but regular files, which makes more sense than reporting completely</span>
<span class="cm">	 * wrong sizes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">xattr_size</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Note, user-space expects 512-byte blocks count irrespectively</span>
<span class="cm">		 * of what was reported in @stat-&gt;size.</span>
<span class="cm">		 */</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">blocks</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">blocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">ubifs_dir_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">lookup</span>      <span class="o">=</span> <span class="n">ubifs_lookup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">create</span>      <span class="o">=</span> <span class="n">ubifs_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">link</span>        <span class="o">=</span> <span class="n">ubifs_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symlink</span>     <span class="o">=</span> <span class="n">ubifs_symlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlink</span>      <span class="o">=</span> <span class="n">ubifs_unlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mkdir</span>       <span class="o">=</span> <span class="n">ubifs_mkdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rmdir</span>       <span class="o">=</span> <span class="n">ubifs_rmdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mknod</span>       <span class="o">=</span> <span class="n">ubifs_mknod</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rename</span>      <span class="o">=</span> <span class="n">ubifs_rename</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>     <span class="o">=</span> <span class="n">ubifs_setattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getattr</span>     <span class="o">=</span> <span class="n">ubifs_getattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setxattr</span>    <span class="o">=</span> <span class="n">ubifs_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span>    <span class="o">=</span> <span class="n">ubifs_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span>   <span class="o">=</span> <span class="n">ubifs_listxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span> <span class="o">=</span> <span class="n">ubifs_removexattr</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ubifs_dir_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">llseek</span>         <span class="o">=</span> <span class="n">ubifs_dir_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>        <span class="o">=</span> <span class="n">ubifs_dir_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>           <span class="o">=</span> <span class="n">generic_read_dir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readdir</span>        <span class="o">=</span> <span class="n">ubifs_readdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fsync</span>          <span class="o">=</span> <span class="n">ubifs_fsync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">ubifs_ioctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span>   <span class="o">=</span> <span class="n">ubifs_compat_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
