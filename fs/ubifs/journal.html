<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ubifs › journal.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>journal.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is part of UBIFS.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Nokia Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="cm"> * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> *          Adrian Hunter</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file implements UBIFS journal.</span>
<span class="cm"> *</span>
<span class="cm"> * The journal consists of 2 parts - the log and bud LEBs. The log has fixed</span>
<span class="cm"> * length and position, while a bud logical eraseblock is any LEB in the main</span>
<span class="cm"> * area. Buds contain file system data - data nodes, inode nodes, etc. The log</span>
<span class="cm"> * contains only references to buds and some other stuff like commit</span>
<span class="cm"> * start node. The idea is that when we commit the journal, we do</span>
<span class="cm"> * not copy the data, the buds just become indexed. Since after the commit the</span>
<span class="cm"> * nodes in bud eraseblocks become leaf nodes of the file system index tree, we</span>
<span class="cm"> * use term &quot;bud&quot;. Analogy is obvious, bud eraseblocks contain nodes which will</span>
<span class="cm"> * become leafs in the future.</span>
<span class="cm"> *</span>
<span class="cm"> * The journal is multi-headed because we want to write data to the journal as</span>
<span class="cm"> * optimally as possible. It is nice to have nodes belonging to the same inode</span>
<span class="cm"> * in one LEB, so we may write data owned by different inodes to different</span>
<span class="cm"> * journal heads, although at present only one data head is used.</span>
<span class="cm"> *</span>
<span class="cm"> * For recovery reasons, the base head contains all inode nodes, all directory</span>
<span class="cm"> * entry nodes and all truncate nodes. This means that the other heads contain</span>
<span class="cm"> * only data nodes.</span>
<span class="cm"> *</span>
<span class="cm"> * Bud LEBs may be half-indexed. For example, if the bud was not full at the</span>
<span class="cm"> * time of commit, the bud is retained to continue to be used in the journal,</span>
<span class="cm"> * even though the &quot;front&quot; of the LEB is now indexed. In that case, the log</span>
<span class="cm"> * reference contains the offset where the bud starts for the purposes of the</span>
<span class="cm"> * journal.</span>
<span class="cm"> *</span>
<span class="cm"> * The journal size has to be limited, because the larger is the journal, the</span>
<span class="cm"> * longer it takes to mount UBIFS (scanning the journal) and the more memory it</span>
<span class="cm"> * takes (indexing in the TNC).</span>
<span class="cm"> *</span>
<span class="cm"> * All the journal write operations like &#39;ubifs_jnl_update()&#39; here, which write</span>
<span class="cm"> * multiple UBIFS nodes to the journal at one go, are atomic with respect to</span>
<span class="cm"> * unclean reboots. Should the unclean reboot happen, the recovery code drops</span>
<span class="cm"> * all the nodes.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;ubifs.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * zero_ino_node_unused - zero out unused fields of an on-flash inode node.</span>
<span class="cm"> * @ino: the inode to zero out</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">zero_ino_node_unused</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_ino_node</span> <span class="o">*</span><span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">padding1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">padding2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">26</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * zero_dent_node_unused - zero out unused fields of an on-flash directory</span>
<span class="cm"> *                         entry node.</span>
<span class="cm"> * @dent: the directory entry to zero out</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">zero_dent_node_unused</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">dent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dent</span><span class="o">-&gt;</span><span class="n">padding1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">padding2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * zero_data_node_unused - zero out unused fields of an on-flash data node.</span>
<span class="cm"> * @data: the data node to zero out</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">zero_data_node_unused</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_data_node</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">padding</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * zero_trun_node_unused - zero out unused fields of an on-flash truncation</span>
<span class="cm"> *                         node.</span>
<span class="cm"> * @trun: the truncation node to zero out</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">zero_trun_node_unused</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_trun_node</span> <span class="o">*</span><span class="n">trun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">trun</span><span class="o">-&gt;</span><span class="n">padding</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * reserve_space - reserve space in the journal.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @jhead: journal head number</span>
<span class="cm"> * @len: node length</span>
<span class="cm"> *</span>
<span class="cm"> * This function reserves space in journal head @head. If the reservation</span>
<span class="cm"> * succeeded, the journal head stays locked and later has to be unlocked using</span>
<span class="cm"> * &#39;release_head()&#39;. &#39;write_node()&#39; and &#39;write_head()&#39; functions also unlock</span>
<span class="cm"> * it. Returns zero in case of success, %-EAGAIN if commit has to be done, and</span>
<span class="cm"> * other negative error codes in case of other failures.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">reserve_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">jhead</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err1</span><span class="p">,</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">avail</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">squeeze</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">jhead</span><span class="p">].</span><span class="n">wbuf</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Typically, the base head has smaller nodes written to it, so it is</span>
<span class="cm">	 * better to try to allocate space at the ends of eraseblocks. This is</span>
<span class="cm">	 * what the squeeze parameter does.</span>
<span class="cm">	 */</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_media</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">);</span>
	<span class="n">squeeze</span> <span class="o">=</span> <span class="p">(</span><span class="n">jhead</span> <span class="o">==</span> <span class="n">BASEHD</span><span class="p">);</span>
<span class="nl">again:</span>
	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">avail</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">avail</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write buffer wasn&#39;t seek&#39;ed or there is no enough space - look for an</span>
<span class="cm">	 * LEB with some empty space.</span>
<span class="cm">	 */</span>
	<span class="n">lnum</span> <span class="o">=</span> <span class="n">ubifs_find_free_space</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offs</span><span class="p">,</span> <span class="n">squeeze</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * No free space, we have to run garbage collector to make</span>
<span class="cm">	 * some. But the write-buffer mutex has to be unlocked because</span>
<span class="cm">	 * GC also takes it.</span>
<span class="cm">	 */</span>
	<span class="n">dbg_jnl</span><span class="p">(</span><span class="s">&quot;no free space in jhead %s, run GC&quot;</span><span class="p">,</span> <span class="n">dbg_jhead</span><span class="p">(</span><span class="n">jhead</span><span class="p">));</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>

	<span class="n">lnum</span> <span class="o">=</span> <span class="n">ubifs_garbage_collect</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * GC could not make a free LEB. But someone else may</span>
<span class="cm">		 * have allocated new bud for this journal head,</span>
<span class="cm">		 * because we dropped @wbuf-&gt;io_mutex, so try once</span>
<span class="cm">		 * again.</span>
<span class="cm">		 */</span>
		<span class="n">dbg_jnl</span><span class="p">(</span><span class="s">&quot;GC couldn&#39;t make a free LEB for jhead %s&quot;</span><span class="p">,</span>
			<span class="n">dbg_jhead</span><span class="p">(</span><span class="n">jhead</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retries</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dbg_jnl</span><span class="p">(</span><span class="s">&quot;retry (%d)&quot;</span><span class="p">,</span> <span class="n">retries</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dbg_jnl</span><span class="p">(</span><span class="s">&quot;return -ENOSPC&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">);</span>
	<span class="n">dbg_jnl</span><span class="p">(</span><span class="s">&quot;got LEB %d for jhead %s&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">dbg_jhead</span><span class="p">(</span><span class="n">jhead</span><span class="p">));</span>
	<span class="n">avail</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">avail</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Someone else has switched the journal head and we have</span>
<span class="cm">		 * enough space now. This happens when more than one process is</span>
<span class="cm">		 * trying to write to the same journal head at the same time.</span>
<span class="cm">		 */</span>
		<span class="n">dbg_jnl</span><span class="p">(</span><span class="s">&quot;return LEB %d back, already have LEB %d:%d&quot;</span><span class="p">,</span>
			<span class="n">lnum</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">+</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_return_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">offs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make sure we synchronize the write-buffer before we add the new bud</span>
<span class="cm">	 * to the log. Otherwise we may have a power cut after the log</span>
<span class="cm">	 * reference node for the last bud (@lnum) is written but before the</span>
<span class="cm">	 * write-buffer data are written to the next-to-last bud</span>
<span class="cm">	 * (@wbuf-&gt;lnum). And the effect would be that the recovery would see</span>
<span class="cm">	 * that there is corruption in the next-to-last bud.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_wbuf_sync_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_return</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_add_bud_to_log</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jhead</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_return</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_wbuf_seek_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_return:</span>
	<span class="cm">/* An error occurred and the LEB has to be returned to lprops */</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">err1</span> <span class="o">=</span> <span class="n">ubifs_return_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err1</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Return original error code only if it is not %-EAGAIN,</span>
<span class="cm">		 * which is not really an error. Otherwise, return the error</span>
<span class="cm">		 * code of &#39;ubifs_return_leb()&#39;.</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">err1</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * write_node - write node to a journal head.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @jhead: journal head</span>
<span class="cm"> * @node: node to write</span>
<span class="cm"> * @len: node length</span>
<span class="cm"> * @lnum: LEB number written is returned here</span>
<span class="cm"> * @offs: offset written is returned here</span>
<span class="cm"> *</span>
<span class="cm"> * This function writes a node to reserved space of journal head @jhead.</span>
<span class="cm"> * Returns zero in case of success and a negative error code in case of</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">jhead</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="o">*</span><span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">jhead</span><span class="p">].</span><span class="n">wbuf</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">jhead</span> <span class="o">!=</span> <span class="n">GCHD</span><span class="p">);</span>

	<span class="o">*</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">jhead</span><span class="p">].</span><span class="n">wbuf</span><span class="p">.</span><span class="n">lnum</span><span class="p">;</span>
	<span class="o">*</span><span class="n">offs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">jhead</span><span class="p">].</span><span class="n">wbuf</span><span class="p">.</span><span class="n">offs</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">jhead</span><span class="p">].</span><span class="n">wbuf</span><span class="p">.</span><span class="n">used</span><span class="p">;</span>

	<span class="n">dbg_jnl</span><span class="p">(</span><span class="s">&quot;jhead %s, LEB %d:%d, len %d&quot;</span><span class="p">,</span>
		<span class="n">dbg_jhead</span><span class="p">(</span><span class="n">jhead</span><span class="p">),</span> <span class="o">*</span><span class="n">lnum</span><span class="p">,</span> <span class="o">*</span><span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">ubifs_prepare_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ubifs_wbuf_write_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * write_head - write data to a journal head.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @jhead: journal head</span>
<span class="cm"> * @buf: buffer to write</span>
<span class="cm"> * @len: length to write</span>
<span class="cm"> * @lnum: LEB number written is returned here</span>
<span class="cm"> * @offs: offset written is returned here</span>
<span class="cm"> * @sync: non-zero if the write-buffer has to by synchronized</span>
<span class="cm"> *</span>
<span class="cm"> * This function is the same as &#39;write_node()&#39; but it does not assume the</span>
<span class="cm"> * buffer it is writing is a node, so it does not prepare it (which means</span>
<span class="cm"> * initializing common header and calculating CRC).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">jhead</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="o">*</span><span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">offs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">jhead</span><span class="p">].</span><span class="n">wbuf</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">jhead</span> <span class="o">!=</span> <span class="n">GCHD</span><span class="p">);</span>

	<span class="o">*</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">jhead</span><span class="p">].</span><span class="n">wbuf</span><span class="p">.</span><span class="n">lnum</span><span class="p">;</span>
	<span class="o">*</span><span class="n">offs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">jhead</span><span class="p">].</span><span class="n">wbuf</span><span class="p">.</span><span class="n">offs</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">jhead</span><span class="p">].</span><span class="n">wbuf</span><span class="p">.</span><span class="n">used</span><span class="p">;</span>
	<span class="n">dbg_jnl</span><span class="p">(</span><span class="s">&quot;jhead %s, LEB %d:%d, len %d&quot;</span><span class="p">,</span>
		<span class="n">dbg_jhead</span><span class="p">(</span><span class="n">jhead</span><span class="p">),</span> <span class="o">*</span><span class="n">lnum</span><span class="p">,</span> <span class="o">*</span><span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_wbuf_write_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sync</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_wbuf_sync_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * make_reservation - reserve journal space.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @jhead: journal head</span>
<span class="cm"> * @len: how many bytes to reserve</span>
<span class="cm"> *</span>
<span class="cm"> * This function makes space reservation in journal head @jhead. The function</span>
<span class="cm"> * takes the commit lock and locks the journal head, and the caller has to</span>
<span class="cm"> * unlock the head and finish the reservation with &#39;finish_reservation()&#39;.</span>
<span class="cm"> * Returns zero in case of success and a negative error code in case of</span>
<span class="cm"> * failure.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, the journal head may be unlocked as soon as the data is written, while</span>
<span class="cm"> * the commit lock has to be released after the data has been added to the</span>
<span class="cm"> * TNC.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">make_reservation</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">jhead</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">cmt_retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nospc_retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">commit_sem</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">reserve_space</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jhead</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">commit_sem</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * GC could not make any progress. We should try to commit</span>
<span class="cm">		 * once because it could make some dirty space and GC would</span>
<span class="cm">		 * make progress, so make the error -EAGAIN so that the below</span>
<span class="cm">		 * will commit and re-try.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nospc_retries</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dbg_jnl</span><span class="p">(</span><span class="s">&quot;no space, retry&quot;</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * This means that the budgeting is incorrect. We always have</span>
<span class="cm">		 * to be able to write to the media, because all operations are</span>
<span class="cm">		 * budgeted. Deletions are not budgeted, though, but we reserve</span>
<span class="cm">		 * an extra LEB for them.</span>
<span class="cm">		 */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * -EAGAIN means that the journal is full or too large, or the above</span>
<span class="cm">	 * code wants to do one commit. Do this and re-try.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmt_retries</span> <span class="o">&gt;</span> <span class="mi">128</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This should not happen unless the journal size limitations</span>
<span class="cm">		 * are too tough.</span>
<span class="cm">		 */</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;stuck in space allocation&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmt_retries</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">)</span>
		<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;too many space allocation re-tries (%d)&quot;</span><span class="p">,</span>
			   <span class="n">cmt_retries</span><span class="p">);</span>

	<span class="n">dbg_jnl</span><span class="p">(</span><span class="s">&quot;-EAGAIN, commit and retry (retried %d times)&quot;</span><span class="p">,</span>
		<span class="n">cmt_retries</span><span class="p">);</span>
	<span class="n">cmt_retries</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_run_commit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot reserve %d bytes in jhead %d, error %d&quot;</span><span class="p">,</span>
		  <span class="n">len</span><span class="p">,</span> <span class="n">jhead</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This are some budgeting problems, print useful information */</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">commit_sem</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="n">ubifs_dump_budg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">);</span>
		<span class="n">ubifs_dump_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="n">cmt_retries</span> <span class="o">=</span> <span class="n">dbg_check_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">commit_sem</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * release_head - release a journal head.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @jhead: journal head</span>
<span class="cm"> *</span>
<span class="cm"> * This function releases journal head @jhead which was locked by</span>
<span class="cm"> * the &#39;make_reservation()&#39; function. It has to be called after each successful</span>
<span class="cm"> * &#39;make_reservation()&#39; invocation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">release_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">jhead</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">jhead</span><span class="p">].</span><span class="n">wbuf</span><span class="p">.</span><span class="n">io_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * finish_reservation - finish a reservation.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function finishes journal space reservation. It must be called after</span>
<span class="cm"> * &#39;make_reservation()&#39;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">finish_reservation</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">commit_sem</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_dent_type - translate VFS inode mode to UBIFS directory entry type.</span>
<span class="cm"> * @mode: inode mode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_dent_type</span><span class="p">(</span><span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">S_IFREG</span>:
		<span class="k">return</span> <span class="n">UBIFS_ITYPE_REG</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFDIR</span>:
		<span class="k">return</span> <span class="n">UBIFS_ITYPE_DIR</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFLNK</span>:
		<span class="k">return</span> <span class="n">UBIFS_ITYPE_LNK</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFBLK</span>:
		<span class="k">return</span> <span class="n">UBIFS_ITYPE_BLK</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFCHR</span>:
		<span class="k">return</span> <span class="n">UBIFS_ITYPE_CHR</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFIFO</span>:
		<span class="k">return</span> <span class="n">UBIFS_ITYPE_FIFO</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFSOCK</span>:
		<span class="k">return</span> <span class="n">UBIFS_ITYPE_SOCK</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pack_inode - pack an inode node.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @ino: buffer in which to pack inode node</span>
<span class="cm"> * @inode: inode to pack</span>
<span class="cm"> * @last: indicates the last node of the group</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pack_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_ino_node</span> <span class="o">*</span><span class="n">ino</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">data_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">last_reference</span> <span class="o">=</span> <span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">node_type</span> <span class="o">=</span> <span class="n">UBIFS_INO_NODE</span><span class="p">;</span>
	<span class="n">ino_key_init_flash</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">creat_sqnum</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">creat_sqnum</span><span class="p">);</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">atime_sec</span>  <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">atime_nsec</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">ctime_sec</span>  <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">ctime_nsec</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">mtime_sec</span>  <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">mtime_nsec</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">uid</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">);</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">gid</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">);</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">mode</span>  <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">size</span>  <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_size</span><span class="p">);</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">nlink</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">);</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">compr_type</span>  <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">compr_type</span><span class="p">);</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">data_len</span>    <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">);</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">xattr_cnt</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">xattr_cnt</span><span class="p">);</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">xattr_size</span>  <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">xattr_size</span><span class="p">);</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">xattr_names</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">xattr_names</span><span class="p">);</span>
	<span class="n">zero_ino_node_unused</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Drop the attached data if this is a deletion inode, the data is not</span>
<span class="cm">	 * needed anymore.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">last_reference</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">);</span>
		<span class="n">data_len</span> <span class="o">=</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ubifs_prep_grp_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">UBIFS_INO_NODE_SZ</span> <span class="o">+</span> <span class="n">data_len</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mark_inode_clean - mark UBIFS inode as clean.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @ui: UBIFS inode to mark as clean</span>
<span class="cm"> *</span>
<span class="cm"> * This helper function marks UBIFS inode @ui as clean by cleaning the</span>
<span class="cm"> * @ui-&gt;dirty flag and releasing its budget. Note, VFS may still treat the</span>
<span class="cm"> * inode as dirty and try to write it back, but &#39;ubifs_write_inode()&#39; would</span>
<span class="cm"> * just do nothing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mark_inode_clean</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">)</span>
		<span class="n">ubifs_release_dirty_inode_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ui</span><span class="p">);</span>
	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_jnl_update - update inode.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @dir: parent inode or host inode in case of extended attributes</span>
<span class="cm"> * @nm: directory entry name</span>
<span class="cm"> * @inode: inode to update</span>
<span class="cm"> * @deletion: indicates a directory entry deletion i.e unlink or rmdir</span>
<span class="cm"> * @xent: non-zero if the directory entry is an extended attribute entry</span>
<span class="cm"> *</span>
<span class="cm"> * This function updates an inode by writing a directory entry (or extended</span>
<span class="cm"> * attribute entry), the inode itself, and the parent directory inode (or the</span>
<span class="cm"> * host inode) to the journal.</span>
<span class="cm"> *</span>
<span class="cm"> * The function writes the host inode @dir last, which is important in case of</span>
<span class="cm"> * extended attributes. Indeed, then we guarantee that if the host inode gets</span>
<span class="cm"> * synchronized (with &#39;fsync()&#39;), and the write-buffer it sits in gets flushed,</span>
<span class="cm"> * the extended attribute inode gets flushed too. And this is exactly what the</span>
<span class="cm"> * user expects - synchronizing the host inode synchronizes its extended</span>
<span class="cm"> * attributes. Similarly, this guarantees that if @dir is synchronized, its</span>
<span class="cm"> * directory entry corresponding to @nm gets synchronized too.</span>
<span class="cm"> *</span>
<span class="cm"> * If the inode (@inode) or the parent directory (@dir) are synchronous, this</span>
<span class="cm"> * function synchronizes the write-buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function marks the @dir and @inode inodes as clean and returns zero on</span>
<span class="cm"> * success. In case of failure, a negative error code is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_jnl_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">nm</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">deletion</span><span class="p">,</span> <span class="kt">int</span> <span class="n">xent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">dlen</span><span class="p">,</span> <span class="n">ilen</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">ino_offs</span><span class="p">,</span> <span class="n">dent_offs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">aligned_dlen</span><span class="p">,</span> <span class="n">aligned_ilen</span><span class="p">,</span> <span class="n">sync</span> <span class="o">=</span> <span class="n">IS_DIRSYNC</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">last_reference</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">deletion</span> <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">dir_ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">dent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_ino_node</span> <span class="o">*</span><span class="n">ino</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">dent_key</span><span class="p">,</span> <span class="n">ino_key</span><span class="p">;</span>

	<span class="n">dbg_jnl</span><span class="p">(</span><span class="s">&quot;ino %lu, dent &#39;%.*s&#39;, data len %d in dir ino %lu&quot;</span><span class="p">,</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir_ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">));</span>

	<span class="n">dlen</span> <span class="o">=</span> <span class="n">UBIFS_DENT_NODE_SZ</span> <span class="o">+</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ilen</span> <span class="o">=</span> <span class="n">UBIFS_INO_NODE_SZ</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the last reference to the inode is being deleted, then there is</span>
<span class="cm">	 * no need to attach and write inode data, it is being deleted anyway.</span>
<span class="cm">	 * And if the inode is being deleted, no need to synchronize</span>
<span class="cm">	 * write-buffer even if the inode is synchronous.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">last_reference</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ilen</span> <span class="o">+=</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
		<span class="n">sync</span> <span class="o">|=</span> <span class="n">IS_SYNC</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">aligned_dlen</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">dlen</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">aligned_ilen</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">ilen</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">aligned_dlen</span> <span class="o">+</span> <span class="n">aligned_ilen</span> <span class="o">+</span> <span class="n">UBIFS_INO_NODE_SZ</span><span class="p">;</span>
	<span class="n">dent</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dent</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Make reservation before allocating sequence numbers */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">make_reservation</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dent</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">node_type</span> <span class="o">=</span> <span class="n">UBIFS_DENT_NODE</span><span class="p">;</span>
		<span class="n">dent_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dent_key</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">nm</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dent</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">node_type</span> <span class="o">=</span> <span class="n">UBIFS_XENT_NODE</span><span class="p">;</span>
		<span class="n">xent_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dent_key</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">nm</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">key_write</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dent_key</span><span class="p">,</span> <span class="n">dent</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
	<span class="n">dent</span><span class="o">-&gt;</span><span class="n">inum</span> <span class="o">=</span> <span class="n">deletion</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">dent</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">get_dent_type</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="n">dent</span><span class="o">-&gt;</span><span class="n">nlen</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">nm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">dent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">nm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">zero_dent_node_unused</span><span class="p">(</span><span class="n">dent</span><span class="p">);</span>
	<span class="n">ubifs_prep_grp_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dent</span><span class="p">,</span> <span class="n">dlen</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">ino</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dent</span> <span class="o">+</span> <span class="n">aligned_dlen</span><span class="p">;</span>
	<span class="n">pack_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ino</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ino</span> <span class="o">+</span> <span class="n">aligned_ilen</span><span class="p">;</span>
	<span class="n">pack_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last_reference</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_add_orphan</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">release_head</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_finish</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ui</span><span class="o">-&gt;</span><span class="n">del_cmtno</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_no</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">write_head</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">,</span> <span class="n">dent</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dent_offs</span><span class="p">,</span> <span class="n">sync</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sync</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">BASEHD</span><span class="p">].</span><span class="n">wbuf</span><span class="p">;</span>

		<span class="n">ubifs_wbuf_add_ino_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="n">ubifs_wbuf_add_ino_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">release_head</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dent</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">deletion</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_remove_nm</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dent_key</span><span class="p">,</span> <span class="n">nm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_add_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">dlen</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_add_nm</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dent_key</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">dent_offs</span><span class="p">,</span> <span class="n">dlen</span><span class="p">,</span> <span class="n">nm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note, we do not remove the inode from TNC even if the last reference</span>
<span class="cm">	 * to it has just been deleted, because the inode may still be opened.</span>
<span class="cm">	 * Instead, the inode has been added to orphan lists and the orphan</span>
<span class="cm">	 * subsystem will take further care about it.</span>
<span class="cm">	 */</span>
	<span class="n">ino_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ino_key</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">ino_offs</span> <span class="o">=</span> <span class="n">dent_offs</span> <span class="o">+</span> <span class="n">aligned_dlen</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_add</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ino_key</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">ino_offs</span><span class="p">,</span> <span class="n">ilen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>

	<span class="n">ino_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ino_key</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">ino_offs</span> <span class="o">+=</span> <span class="n">aligned_ilen</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_add</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ino_key</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">ino_offs</span><span class="p">,</span> <span class="n">UBIFS_INO_NODE_SZ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>

	<span class="n">finish_reservation</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_lock</span><span class="p">);</span>
	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">synced_i_size</span> <span class="o">=</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_size</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_lock</span><span class="p">);</span>
	<span class="n">mark_inode_clean</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ui</span><span class="p">);</span>
	<span class="n">mark_inode_clean</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dir_ui</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_finish:</span>
	<span class="n">finish_reservation</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dent</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_release:</span>
	<span class="n">release_head</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dent</span><span class="p">);</span>
<span class="nl">out_ro:</span>
	<span class="n">ubifs_ro_mode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_reference</span><span class="p">)</span>
		<span class="n">ubifs_delete_orphan</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">finish_reservation</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_jnl_write_data - write a data node to the journal.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @inode: inode the data node belongs to</span>
<span class="cm"> * @key: node key</span>
<span class="cm"> * @buf: buffer to write</span>
<span class="cm"> * @len: data length (must not exceed %UBIFS_BLOCK_SIZE)</span>
<span class="cm"> *</span>
<span class="cm"> * This function writes a data node to the journal. Returns %0 if the data node</span>
<span class="cm"> * was successfully written, and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_jnl_write_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_data_node</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">compr_type</span><span class="p">,</span> <span class="n">out_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dlen</span> <span class="o">=</span> <span class="n">COMPRESSED_DATA_NODE_BUF_SZ</span><span class="p">,</span> <span class="n">allocated</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">dbg_jnlk</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;ino %lu, blk %u, len %d, key &quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span> <span class="n">key_block</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">);</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">dlen</span><span class="p">,</span> <span class="n">GFP_NOFS</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Fall-back to the write reserve buffer. Note, we might be</span>
<span class="cm">		 * currently on the memory reclaim path, when the kernel is</span>
<span class="cm">		 * trying to free some memory by writing out dirty pages. The</span>
<span class="cm">		 * write reserve buffer helps us to guarantee that we are</span>
<span class="cm">		 * always able to write the data.</span>
<span class="cm">		 */</span>
		<span class="n">allocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">write_reserve_mutex</span><span class="p">);</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">write_reserve_buf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">data</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">node_type</span> <span class="o">=</span> <span class="n">UBIFS_DATA_NODE</span><span class="p">;</span>
	<span class="n">key_write</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="n">zero_data_node_unused</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UBIFS_COMPR_FL</span><span class="p">))</span>
		<span class="cm">/* Compression is disabled for this inode */</span>
		<span class="n">compr_type</span> <span class="o">=</span> <span class="n">UBIFS_COMPR_NONE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">compr_type</span> <span class="o">=</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">compr_type</span><span class="p">;</span>

	<span class="n">out_len</span> <span class="o">=</span> <span class="n">dlen</span> <span class="o">-</span> <span class="n">UBIFS_DATA_NODE_SZ</span><span class="p">;</span>
	<span class="n">ubifs_compress</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">compr_type</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">out_len</span> <span class="o">&lt;=</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">);</span>

	<span class="n">dlen</span> <span class="o">=</span> <span class="n">UBIFS_DATA_NODE_SZ</span> <span class="o">+</span> <span class="n">out_len</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">compr_type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">compr_type</span><span class="p">);</span>

	<span class="cm">/* Make reservation before allocating sequence numbers */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">make_reservation</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">DATAHD</span><span class="p">,</span> <span class="n">dlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">write_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">DATAHD</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">dlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>
	<span class="n">ubifs_wbuf_add_ino_nolock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">DATAHD</span><span class="p">].</span><span class="n">wbuf</span><span class="p">,</span> <span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">));</span>
	<span class="n">release_head</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">DATAHD</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_add</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">dlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>

	<span class="n">finish_reservation</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">allocated</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">write_reserve_mutex</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_release:</span>
	<span class="n">release_head</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">DATAHD</span><span class="p">);</span>
<span class="nl">out_ro:</span>
	<span class="n">ubifs_ro_mode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">finish_reservation</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">allocated</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">write_reserve_mutex</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_jnl_write_inode - flush inode to the journal.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @inode: inode to flush</span>
<span class="cm"> *</span>
<span class="cm"> * This function writes inode @inode to the journal. If the inode is</span>
<span class="cm"> * synchronous, it also synchronizes the write-buffer. Returns zero in case of</span>
<span class="cm"> * success and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_jnl_write_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_ino_node</span> <span class="o">*</span><span class="n">ino</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">sync</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">UBIFS_INO_NODE_SZ</span><span class="p">,</span> <span class="n">last_reference</span> <span class="o">=</span> <span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">;</span>

	<span class="n">dbg_jnl</span><span class="p">(</span><span class="s">&quot;ino %lu, nlink %u&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the inode is being deleted, do not write the attached data. No</span>
<span class="cm">	 * need to synchronize the write-buffer either.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">last_reference</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
		<span class="n">sync</span> <span class="o">=</span> <span class="n">IS_SYNC</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ino</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ino</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Make reservation before allocating sequence numbers */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">make_reservation</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">pack_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">write_head</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offs</span><span class="p">,</span> <span class="n">sync</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sync</span><span class="p">)</span>
		<span class="n">ubifs_wbuf_add_ino_nolock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">BASEHD</span><span class="p">].</span><span class="n">wbuf</span><span class="p">,</span>
					  <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">release_head</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last_reference</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_remove_ino</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>
		<span class="n">ubifs_delete_orphan</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_add_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">;</span>

		<span class="n">ino_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_add</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>

	<span class="n">finish_reservation</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_lock</span><span class="p">);</span>
	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">synced_i_size</span> <span class="o">=</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_size</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_lock</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_release:</span>
	<span class="n">release_head</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">);</span>
<span class="nl">out_ro:</span>
	<span class="n">ubifs_ro_mode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">finish_reservation</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_jnl_delete_inode - delete an inode.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @inode: inode to delete</span>
<span class="cm"> *</span>
<span class="cm"> * This function deletes inode @inode which includes removing it from orphans,</span>
<span class="cm"> * deleting it from TNC and, in some cases, writing a deletion inode to the</span>
<span class="cm"> * journal.</span>
<span class="cm"> *</span>
<span class="cm"> * When regular file inodes are unlinked or a directory inode is removed, the</span>
<span class="cm"> * &#39;ubifs_jnl_update()&#39; function writes a corresponding deletion inode and</span>
<span class="cm"> * direntry to the media, and adds the inode to orphans. After this, when the</span>
<span class="cm"> * last reference to this inode has been dropped, this function is called. In</span>
<span class="cm"> * general, it has to write one more deletion inode to the media, because if</span>
<span class="cm"> * a commit happened between &#39;ubifs_jnl_update()&#39; and</span>
<span class="cm"> * &#39;ubifs_jnl_delete_inode()&#39;, the deletion inode is not in the journal</span>
<span class="cm"> * anymore, and in fact it might not be on the flash anymore, because it might</span>
<span class="cm"> * have been garbage-collected already. And for optimization reasons UBIFS does</span>
<span class="cm"> * not read the orphan area if it has been unmounted cleanly, so it would have</span>
<span class="cm"> * no indication in the journal that there is a deleted inode which has to be</span>
<span class="cm"> * removed from TNC.</span>
<span class="cm"> *</span>
<span class="cm"> * However, if there was no commit between &#39;ubifs_jnl_update()&#39; and</span>
<span class="cm"> * &#39;ubifs_jnl_delete_inode()&#39;, then there is no need to write the deletion</span>
<span class="cm"> * inode to the media for the second time. And this is quite a typical case.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero in case of success and a negative error code in</span>
<span class="cm"> * case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_jnl_delete_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">del_cmtno</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_no</span><span class="p">)</span>
		<span class="cm">/* A commit happened for sure */</span>
		<span class="k">return</span> <span class="n">ubifs_jnl_write_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">commit_sem</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check commit number again, because the first test has been done</span>
<span class="cm">	 * without @c-&gt;commit_sem, so a commit might have happened.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">del_cmtno</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_no</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">commit_sem</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ubifs_jnl_write_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_remove_ino</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">ubifs_ro_mode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ubifs_delete_orphan</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">commit_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_jnl_rename - rename a directory entry.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @old_dir: parent inode of directory entry to rename</span>
<span class="cm"> * @old_dentry: directory entry to rename</span>
<span class="cm"> * @new_dir: parent inode of directory entry to rename</span>
<span class="cm"> * @new_dentry: new directory entry (or directory entry to replace)</span>
<span class="cm"> * @sync: non-zero if the write-buffer has to be synchronized</span>
<span class="cm"> *</span>
<span class="cm"> * This function implements the re-name operation which may involve writing up</span>
<span class="cm"> * to 3 inodes and 2 directory entries. It marks the written inodes as clean</span>
<span class="cm"> * and returns zero on success. In case of failure, a negative error code is</span>
<span class="cm"> * returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_jnl_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old_dir</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">new_dir</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">dent</span><span class="p">,</span> <span class="o">*</span><span class="n">dent2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">dlen1</span><span class="p">,</span> <span class="n">dlen2</span><span class="p">,</span> <span class="n">ilen</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old_inode</span> <span class="o">=</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">new_inode</span> <span class="o">=</span> <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">aligned_dlen1</span><span class="p">,</span> <span class="n">aligned_dlen2</span><span class="p">,</span> <span class="n">plen</span> <span class="o">=</span> <span class="n">UBIFS_INO_NODE_SZ</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_reference</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">new_inode</span> <span class="o">&amp;&amp;</span> <span class="n">new_inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">move</span> <span class="o">=</span> <span class="p">(</span><span class="n">old_dir</span> <span class="o">!=</span> <span class="n">new_dir</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">new_ui</span><span class="p">);</span>

	<span class="n">dbg_jnl</span><span class="p">(</span><span class="s">&quot;dent &#39;%.*s&#39; in dir ino %lu to dent &#39;%.*s&#39; in dir ino %lu&quot;</span><span class="p">,</span>
		<span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
		<span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
		<span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">ubifs_inode</span><span class="p">(</span><span class="n">old_dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">ubifs_inode</span><span class="p">(</span><span class="n">new_dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_inode</span><span class="p">(</span><span class="n">old_dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_inode</span><span class="p">(</span><span class="n">new_dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">));</span>

	<span class="n">dlen1</span> <span class="o">=</span> <span class="n">UBIFS_DENT_NODE_SZ</span> <span class="o">+</span> <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dlen2</span> <span class="o">=</span> <span class="n">UBIFS_DENT_NODE_SZ</span> <span class="o">+</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">new_inode</span><span class="p">);</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">));</span>
		<span class="n">ilen</span> <span class="o">=</span> <span class="n">UBIFS_INO_NODE_SZ</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">last_reference</span><span class="p">)</span>
			<span class="n">ilen</span> <span class="o">+=</span> <span class="n">new_ui</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ilen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">aligned_dlen1</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">dlen1</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">aligned_dlen2</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">dlen2</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">aligned_dlen1</span> <span class="o">+</span> <span class="n">aligned_dlen2</span> <span class="o">+</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">ilen</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">plen</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_dir</span> <span class="o">!=</span> <span class="n">new_dir</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">plen</span><span class="p">;</span>
	<span class="n">dent</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dent</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Make reservation before allocating sequence numbers */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">make_reservation</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="cm">/* Make new dent */</span>
	<span class="n">dent</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">node_type</span> <span class="o">=</span> <span class="n">UBIFS_DENT_NODE</span><span class="p">;</span>
	<span class="n">dent_key_init_flash</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
	<span class="n">dent</span><span class="o">-&gt;</span><span class="n">inum</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">old_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">dent</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">get_dent_type</span><span class="p">(</span><span class="n">old_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="n">dent</span><span class="o">-&gt;</span><span class="n">nlen</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="n">dent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">zero_dent_node_unused</span><span class="p">(</span><span class="n">dent</span><span class="p">);</span>
	<span class="n">ubifs_prep_grp_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dent</span><span class="p">,</span> <span class="n">dlen1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Make deletion dent */</span>
	<span class="n">dent2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dent</span> <span class="o">+</span> <span class="n">aligned_dlen1</span><span class="p">;</span>
	<span class="n">dent2</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">node_type</span> <span class="o">=</span> <span class="n">UBIFS_DENT_NODE</span><span class="p">;</span>
	<span class="n">dent_key_init_flash</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dent2</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
	<span class="n">dent2</span><span class="o">-&gt;</span><span class="n">inum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dent2</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">DT_UNKNOWN</span><span class="p">;</span>
	<span class="n">dent2</span><span class="o">-&gt;</span><span class="n">nlen</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dent2</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="n">dent2</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">zero_dent_node_unused</span><span class="p">(</span><span class="n">dent2</span><span class="p">);</span>
	<span class="n">ubifs_prep_grp_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dent2</span><span class="p">,</span> <span class="n">dlen2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dent2</span> <span class="o">+</span> <span class="n">aligned_dlen2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pack_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">new_inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">ilen</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">move</span><span class="p">)</span>
		<span class="n">pack_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">old_dir</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">pack_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">old_dir</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">plen</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">pack_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">new_dir</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last_reference</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_add_orphan</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">new_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">release_head</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_finish</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">new_ui</span><span class="o">-&gt;</span><span class="n">del_cmtno</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_no</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">write_head</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">,</span> <span class="n">dent</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offs</span><span class="p">,</span> <span class="n">sync</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sync</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">BASEHD</span><span class="p">].</span><span class="n">wbuf</span><span class="p">;</span>

		<span class="n">ubifs_wbuf_add_ino_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">,</span> <span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="n">ubifs_wbuf_add_ino_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">,</span> <span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_inode</span><span class="p">)</span>
			<span class="n">ubifs_wbuf_add_ino_nolock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">BASEHD</span><span class="p">].</span><span class="n">wbuf</span><span class="p">,</span>
						  <span class="n">new_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">release_head</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">);</span>

	<span class="n">dent_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_add_nm</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">dlen1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_add_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">dlen2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>

	<span class="n">dent_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_remove_nm</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>

	<span class="n">offs</span> <span class="o">+=</span> <span class="n">aligned_dlen1</span> <span class="o">+</span> <span class="n">aligned_dlen2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ino_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">new_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_add</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">ilen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>
		<span class="n">offs</span> <span class="o">+=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">ilen</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ino_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_add</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">plen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_dir</span> <span class="o">!=</span> <span class="n">new_dir</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offs</span> <span class="o">+=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">plen</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">ino_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_add</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">plen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">finish_reservation</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mark_inode_clean</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">new_ui</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ui</span><span class="o">-&gt;</span><span class="n">ui_lock</span><span class="p">);</span>
		<span class="n">new_ui</span><span class="o">-&gt;</span><span class="n">synced_i_size</span> <span class="o">=</span> <span class="n">new_ui</span><span class="o">-&gt;</span><span class="n">ui_size</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ui</span><span class="o">-&gt;</span><span class="n">ui_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mark_inode_clean</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">old_dir</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">move</span><span class="p">)</span>
		<span class="n">mark_inode_clean</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">new_dir</span><span class="p">));</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dent</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_release:</span>
	<span class="n">release_head</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">);</span>
<span class="nl">out_ro:</span>
	<span class="n">ubifs_ro_mode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_reference</span><span class="p">)</span>
		<span class="n">ubifs_delete_orphan</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">new_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
<span class="nl">out_finish:</span>
	<span class="n">finish_reservation</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dent</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * recomp_data_node - re-compress a truncated data node.</span>
<span class="cm"> * @dn: data node to re-compress</span>
<span class="cm"> * @new_len: new length</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used when an inode is truncated and the last data node of</span>
<span class="cm"> * the inode has to be re-compressed and re-written.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">recomp_data_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_data_node</span> <span class="o">*</span><span class="n">dn</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">new_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">compr_type</span><span class="p">,</span> <span class="n">out_len</span><span class="p">;</span>

	<span class="n">out_len</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">out_len</span> <span class="o">*</span> <span class="n">WORST_COMPR_FACTOR</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="o">-</span> <span class="n">UBIFS_DATA_NODE_SZ</span><span class="p">;</span>
	<span class="n">compr_type</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">compr_type</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_decompress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out_len</span><span class="p">,</span> <span class="n">compr_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ubifs_compress</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">*</span><span class="n">new_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">compr_type</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">out_len</span> <span class="o">&lt;=</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">);</span>
	<span class="n">dn</span><span class="o">-&gt;</span><span class="n">compr_type</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">compr_type</span><span class="p">);</span>
	<span class="n">dn</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">*</span><span class="n">new_len</span><span class="p">);</span>
	<span class="o">*</span><span class="n">new_len</span> <span class="o">=</span> <span class="n">UBIFS_DATA_NODE_SZ</span> <span class="o">+</span> <span class="n">out_len</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_jnl_truncate - update the journal for a truncation.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @inode: inode to truncate</span>
<span class="cm"> * @old_size: old size</span>
<span class="cm"> * @new_size: new size</span>
<span class="cm"> *</span>
<span class="cm"> * When the size of a file decreases due to truncation, a truncation node is</span>
<span class="cm"> * written, the journal tree is updated, and the last data block is re-written</span>
<span class="cm"> * if it has been affected. The inode is also updated in order to synchronize</span>
<span class="cm"> * the new inode size.</span>
<span class="cm"> *</span>
<span class="cm"> * This function marks the inode as clean and returns zero on success. In case</span>
<span class="cm"> * of failure, a negative error code is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_jnl_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		       <span class="n">loff_t</span> <span class="n">old_size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">new_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">,</span> <span class="n">to_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_ino_node</span> <span class="o">*</span><span class="n">ino</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_trun_node</span> <span class="o">*</span><span class="n">trun</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_data_node</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">dlen</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">bit</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">sync</span> <span class="o">=</span> <span class="n">IS_SYNC</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ino_t</span> <span class="n">inum</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blk</span><span class="p">;</span>

	<span class="n">dbg_jnl</span><span class="p">(</span><span class="s">&quot;ino %lu, size %lld -&gt; %lld&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inum</span><span class="p">,</span> <span class="n">old_size</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">));</span>

	<span class="n">sz</span> <span class="o">=</span> <span class="n">UBIFS_TRUN_NODE_SZ</span> <span class="o">+</span> <span class="n">UBIFS_INO_NODE_SZ</span> <span class="o">+</span>
	     <span class="n">UBIFS_MAX_DATA_NODE_SZ</span> <span class="o">*</span> <span class="n">WORST_COMPR_FACTOR</span><span class="p">;</span>
	<span class="n">ino</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ino</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">trun</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ino</span> <span class="o">+</span> <span class="n">UBIFS_INO_NODE_SZ</span><span class="p">;</span>
	<span class="n">trun</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">node_type</span> <span class="o">=</span> <span class="n">UBIFS_TRUN_NODE</span><span class="p">;</span>
	<span class="n">trun</span><span class="o">-&gt;</span><span class="n">inum</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inum</span><span class="p">);</span>
	<span class="n">trun</span><span class="o">-&gt;</span><span class="n">old_size</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">old_size</span><span class="p">);</span>
	<span class="n">trun</span><span class="o">-&gt;</span><span class="n">new_size</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">new_size</span><span class="p">);</span>
	<span class="n">zero_trun_node_unused</span><span class="p">(</span><span class="n">trun</span><span class="p">);</span>

	<span class="n">dlen</span> <span class="o">=</span> <span class="n">new_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UBIFS_BLOCK_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get last data block so it can be truncated */</span>
		<span class="n">dn</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">trun</span> <span class="o">+</span> <span class="n">UBIFS_TRUN_NODE_SZ</span><span class="p">;</span>
		<span class="n">blk</span> <span class="o">=</span> <span class="n">new_size</span> <span class="o">&gt;&gt;</span> <span class="n">UBIFS_BLOCK_SHIFT</span><span class="p">;</span>
		<span class="n">data_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">inum</span><span class="p">,</span> <span class="n">blk</span><span class="p">);</span>
		<span class="n">dbg_jnlk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="s">&quot;last block key &quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_lookup</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">dn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
			<span class="n">dlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Not found (so it is a hole) */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">dlen</span><span class="p">)</span>
				<span class="n">dlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Nothing to do */</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">compr_type</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">compr_type</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">compr_type</span> <span class="o">!=</span> <span class="n">UBIFS_COMPR_NONE</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">err</span> <span class="o">=</span> <span class="n">recomp_data_node</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlen</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">dn</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">dlen</span><span class="p">);</span>
					<span class="n">dlen</span> <span class="o">+=</span> <span class="n">UBIFS_DATA_NODE_SZ</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">zero_data_node_unused</span><span class="p">(</span><span class="n">dn</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Must make reservation before allocating sequence numbers */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">UBIFS_TRUN_NODE_SZ</span> <span class="o">+</span> <span class="n">UBIFS_INO_NODE_SZ</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlen</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">dlen</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">make_reservation</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">pack_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_prep_grp_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">trun</span><span class="p">,</span> <span class="n">UBIFS_TRUN_NODE_SZ</span><span class="p">,</span> <span class="n">dlen</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlen</span><span class="p">)</span>
		<span class="n">ubifs_prep_grp_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dn</span><span class="p">,</span> <span class="n">dlen</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">write_head</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offs</span><span class="p">,</span> <span class="n">sync</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sync</span><span class="p">)</span>
		<span class="n">ubifs_wbuf_add_ino_nolock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">BASEHD</span><span class="p">].</span><span class="n">wbuf</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
	<span class="n">release_head</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sz</span> <span class="o">=</span> <span class="n">offs</span> <span class="o">+</span> <span class="n">UBIFS_INO_NODE_SZ</span> <span class="o">+</span> <span class="n">UBIFS_TRUN_NODE_SZ</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_add</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">dlen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ino_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_add</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">UBIFS_INO_NODE_SZ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_add_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">UBIFS_TRUN_NODE_SZ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>

	<span class="n">bit</span> <span class="o">=</span> <span class="n">new_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UBIFS_BLOCK_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">blk</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">&gt;&gt;</span> <span class="n">UBIFS_BLOCK_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">bit</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">data_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">inum</span><span class="p">,</span> <span class="n">blk</span><span class="p">);</span>

	<span class="n">bit</span> <span class="o">=</span> <span class="n">old_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UBIFS_BLOCK_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">blk</span> <span class="o">=</span> <span class="p">(</span><span class="n">old_size</span> <span class="o">&gt;&gt;</span> <span class="n">UBIFS_BLOCK_SHIFT</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">bit</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">data_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to_key</span><span class="p">,</span> <span class="n">inum</span><span class="p">,</span> <span class="n">blk</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_remove_range</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">to_key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>

	<span class="n">finish_reservation</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_lock</span><span class="p">);</span>
	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">synced_i_size</span> <span class="o">=</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_size</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_lock</span><span class="p">);</span>
	<span class="n">mark_inode_clean</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ui</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_release:</span>
	<span class="n">release_head</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">);</span>
<span class="nl">out_ro:</span>
	<span class="n">ubifs_ro_mode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">finish_reservation</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * ubifs_jnl_delete_xattr - delete an extended attribute.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @host: host inode</span>
<span class="cm"> * @inode: extended attribute inode</span>
<span class="cm"> * @nm: extended attribute entry name</span>
<span class="cm"> *</span>
<span class="cm"> * This function delete an extended attribute which is very similar to</span>
<span class="cm"> * un-linking regular files - it writes a deletion xentry, a deletion inode and</span>
<span class="cm"> * updates the target inode. Returns zero in case of success and a negative</span>
<span class="cm"> * error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_jnl_delete_xattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">nm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">xlen</span><span class="p">,</span> <span class="n">hlen</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">xent_offs</span><span class="p">,</span> <span class="n">aligned_xlen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">xent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_ino_node</span> <span class="o">*</span><span class="n">ino</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">xent_key</span><span class="p">,</span> <span class="n">key1</span><span class="p">,</span> <span class="n">key2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sync</span> <span class="o">=</span> <span class="n">IS_DIRSYNC</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">host_ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="n">dbg_jnl</span><span class="p">(</span><span class="s">&quot;host %lu, xattr ino %lu, name &#39;%s&#39;, data len %d&quot;</span><span class="p">,</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		<span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host_ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since we are deleting the inode, we do not bother to attach any data</span>
<span class="cm">	 * to it and assume its length is %UBIFS_INO_NODE_SZ.</span>
<span class="cm">	 */</span>
	<span class="n">xlen</span> <span class="o">=</span> <span class="n">UBIFS_DENT_NODE_SZ</span> <span class="o">+</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">aligned_xlen</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">xlen</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">hlen</span> <span class="o">=</span> <span class="n">host_ui</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+</span> <span class="n">UBIFS_INO_NODE_SZ</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">aligned_xlen</span> <span class="o">+</span> <span class="n">UBIFS_INO_NODE_SZ</span> <span class="o">+</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">hlen</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">xent</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xent</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Make reservation before allocating sequence numbers */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">make_reservation</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">xent</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xent</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">node_type</span> <span class="o">=</span> <span class="n">UBIFS_XENT_NODE</span><span class="p">;</span>
	<span class="n">xent_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xent_key</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">nm</span><span class="p">);</span>
	<span class="n">key_write</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xent_key</span><span class="p">,</span> <span class="n">xent</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
	<span class="n">xent</span><span class="o">-&gt;</span><span class="n">inum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">xent</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">get_dent_type</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="n">xent</span><span class="o">-&gt;</span><span class="n">nlen</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">nm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">xent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">nm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">xent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">nm</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">zero_dent_node_unused</span><span class="p">(</span><span class="n">xent</span><span class="p">);</span>
	<span class="n">ubifs_prep_grp_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">xent</span><span class="p">,</span> <span class="n">xlen</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">ino</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">xent</span> <span class="o">+</span> <span class="n">aligned_xlen</span><span class="p">;</span>
	<span class="n">pack_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ino</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ino</span> <span class="o">+</span> <span class="n">UBIFS_INO_NODE_SZ</span><span class="p">;</span>
	<span class="n">pack_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">write_head</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">,</span> <span class="n">xent</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xent_offs</span><span class="p">,</span> <span class="n">sync</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sync</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">ubifs_wbuf_add_ino_nolock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">BASEHD</span><span class="p">].</span><span class="n">wbuf</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">release_head</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">xent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>

	<span class="cm">/* Remove the extended attribute entry from TNC */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_remove_nm</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xent_key</span><span class="p">,</span> <span class="n">nm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_add_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">xlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remove all nodes belonging to the extended attribute inode from TNC.</span>
<span class="cm">	 * Well, there actually must be only one node - the inode itself.</span>
<span class="cm">	 */</span>
	<span class="n">lowest_ino_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key1</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">highest_ino_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key2</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_remove_range</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_add_dirt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">UBIFS_INO_NODE_SZ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>

	<span class="cm">/* And update TNC with the new host inode position */</span>
	<span class="n">ino_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key1</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_add</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key1</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">xent_offs</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="n">hlen</span><span class="p">,</span> <span class="n">hlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>

	<span class="n">finish_reservation</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host_ui</span><span class="o">-&gt;</span><span class="n">ui_lock</span><span class="p">);</span>
	<span class="n">host_ui</span><span class="o">-&gt;</span><span class="n">synced_i_size</span> <span class="o">=</span> <span class="n">host_ui</span><span class="o">-&gt;</span><span class="n">ui_size</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host_ui</span><span class="o">-&gt;</span><span class="n">ui_lock</span><span class="p">);</span>
	<span class="n">mark_inode_clean</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">host_ui</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_ro:</span>
	<span class="n">ubifs_ro_mode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">finish_reservation</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_jnl_change_xattr - change an extended attribute.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @inode: extended attribute inode</span>
<span class="cm"> * @host: host inode</span>
<span class="cm"> *</span>
<span class="cm"> * This function writes the updated version of an extended attribute inode and</span>
<span class="cm"> * the host inode to the journal (to the base head). The host inode is written</span>
<span class="cm"> * after the extended attribute inode in order to guarantee that the extended</span>
<span class="cm"> * attribute will be flushed when the inode is synchronized by &#39;fsync()&#39; and</span>
<span class="cm"> * consequently, the write-buffer is synchronized. This function returns zero</span>
<span class="cm"> * in case of success and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_jnl_change_xattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">len1</span><span class="p">,</span> <span class="n">len2</span><span class="p">,</span> <span class="n">aligned_len</span><span class="p">,</span> <span class="n">aligned_len1</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">host_ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_ino_node</span> <span class="o">*</span><span class="n">ino</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sync</span> <span class="o">=</span> <span class="n">IS_DIRSYNC</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="n">dbg_jnl</span><span class="p">(</span><span class="s">&quot;ino %lu, ino %lu&quot;</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host_ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">));</span>

	<span class="n">len1</span> <span class="o">=</span> <span class="n">UBIFS_INO_NODE_SZ</span> <span class="o">+</span> <span class="n">host_ui</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
	<span class="n">len2</span> <span class="o">=</span> <span class="n">UBIFS_INO_NODE_SZ</span> <span class="o">+</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
	<span class="n">aligned_len1</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len1</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">aligned_len</span> <span class="o">=</span> <span class="n">aligned_len1</span> <span class="o">+</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len2</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">ino</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">aligned_len</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ino</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Make reservation before allocating sequence numbers */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">make_reservation</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">,</span> <span class="n">aligned_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">pack_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pack_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ino</span> <span class="o">+</span> <span class="n">aligned_len1</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">write_head</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">aligned_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sync</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">BASEHD</span><span class="p">].</span><span class="n">wbuf</span><span class="p">;</span>

		<span class="n">ubifs_wbuf_add_ino_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="n">ubifs_wbuf_add_ino_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">release_head</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BASEHD</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>

	<span class="n">ino_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_add</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>

	<span class="n">ino_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_add</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span> <span class="o">+</span> <span class="n">aligned_len1</span><span class="p">,</span> <span class="n">len2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ro</span><span class="p">;</span>

	<span class="n">finish_reservation</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host_ui</span><span class="o">-&gt;</span><span class="n">ui_lock</span><span class="p">);</span>
	<span class="n">host_ui</span><span class="o">-&gt;</span><span class="n">synced_i_size</span> <span class="o">=</span> <span class="n">host_ui</span><span class="o">-&gt;</span><span class="n">ui_size</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host_ui</span><span class="o">-&gt;</span><span class="n">ui_lock</span><span class="p">);</span>
	<span class="n">mark_inode_clean</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">host_ui</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_ro:</span>
	<span class="n">ubifs_ro_mode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">finish_reservation</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
