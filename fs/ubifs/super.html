<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ubifs › super.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>super.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is part of UBIFS.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Nokia Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="cm"> * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> *          Adrian Hunter</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file implements UBIFS initialization and VFS superblock operations. Some</span>
<span class="cm"> * initialization stuff which is rather large and complex is placed at</span>
<span class="cm"> * corresponding subsystems, but most of it is here.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/parser.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/math64.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &quot;ubifs.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum amount of memory we may &#39;kmalloc()&#39; without worrying that we are</span>
<span class="cm"> * allocating too much.</span>
<span class="cm"> */</span>
<span class="cp">#define UBIFS_KMALLOC_OK (128*1024)</span>

<span class="cm">/* Slab cache for UBIFS inodes */</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ubifs_inode_slab</span><span class="p">;</span>

<span class="cm">/* UBIFS TNC shrinker description */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">shrinker</span> <span class="n">ubifs_shrinker_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">shrink</span> <span class="o">=</span> <span class="n">ubifs_shrinker</span><span class="p">,</span>
	<span class="p">.</span><span class="n">seeks</span> <span class="o">=</span> <span class="n">DEFAULT_SEEKS</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * validate_inode - validate inode.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @inode: the inode to validate</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function for &#39;ubifs_iget()&#39; which validates various fields</span>
<span class="cm"> * of a newly built inode to make sure they contain sane values and prevent</span>
<span class="cm"> * possible vulnerabilities. Returns zero if the inode is all right and</span>
<span class="cm"> * a non-zero error code if not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">validate_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_inode_sz</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;inode is too large (%lld)&quot;</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">compr_type</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">compr_type</span> <span class="o">&gt;=</span> <span class="n">UBIFS_COMPR_TYPES_CNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;unknown compression type %d&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">compr_type</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">xattr_names</span> <span class="o">+</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">xattr_cnt</span> <span class="o">&gt;</span> <span class="n">XATTR_LIST_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">&gt;</span> <span class="n">UBIFS_MAX_INO_DATA</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">4</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">xattr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubifs_compr_present</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">compr_type</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;inode %lu uses &#39;%s&#39; compression, but it was not &quot;</span>
			   <span class="s">&quot;compiled in&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
			   <span class="n">ubifs_compr_name</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">compr_type</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_dir</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">ubifs_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">inum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_ino_node</span> <span class="o">*</span><span class="n">ino</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;inode %lu&quot;</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">iget_locked</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_NEW</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
	<span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">ino</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">UBIFS_MAX_INO_NODE_SZ</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ino</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ino_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_lookup</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ino</span><span class="p">;</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">S_NOCMTIME</span> <span class="o">|</span> <span class="n">S_NOATIME</span><span class="p">);</span>
	<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="p">));</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span>   <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span>   <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span>  <span class="o">=</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">atime_sec</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">atime_nsec</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span>  <span class="o">=</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">mtime_sec</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">mtime_nsec</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span>  <span class="o">=</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">ctime_sec</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">ctime_nsec</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span>    <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">);</span>
	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">flags</span>       <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">compr_type</span>  <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">compr_type</span><span class="p">);</span>
	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">creat_sqnum</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">creat_sqnum</span><span class="p">);</span>
	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">xattr_cnt</span>   <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">xattr_cnt</span><span class="p">);</span>
	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">xattr_size</span>  <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">xattr_size</span><span class="p">);</span>
	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">xattr_names</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">xattr_names</span><span class="p">);</span>
	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">synced_i_size</span> <span class="o">=</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>

	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">xattr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UBIFS_XATTR_FL</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">validate_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_invalid</span><span class="p">;</span>

	<span class="cm">/* Disable read-ahead */</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">S_IFREG</span>:
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ubifs_file_address_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ubifs_file_inode_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ubifs_file_operations</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">xattr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ui</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_ino</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">ino</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">);</span>
			<span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_invalid</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFDIR</span>:
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">ubifs_dir_inode_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ubifs_dir_operations</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_invalid</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFLNK</span>:
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ubifs_symlink_inode_operations</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">&gt;</span> <span class="n">UBIFS_MAX_INO_DATA</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_invalid</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ui</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_ino</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">ino</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">);</span>
		<span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFBLK</span>:
	<span class="k">case</span> <span class="n">S_IFCHR</span>:
	<span class="p">{</span>
		<span class="n">dev_t</span> <span class="n">rdev</span><span class="p">;</span>
		<span class="k">union</span> <span class="n">ubifs_dev_desc</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

		<span class="n">ui</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">ubifs_dev_desc</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_ino</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">ubifs_dev_desc</span> <span class="o">*</span><span class="p">)</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">))</span>
			<span class="n">rdev</span> <span class="o">=</span> <span class="n">new_decode_dev</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">));</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">huge</span><span class="p">))</span>
			<span class="n">rdev</span> <span class="o">=</span> <span class="n">huge_decode_dev</span><span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">huge</span><span class="p">));</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_invalid</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">ino</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ubifs_file_inode_operations</span><span class="p">;</span>
		<span class="n">init_special_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span> <span class="n">rdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">S_IFSOCK</span>:
	<span class="k">case</span> <span class="n">S_IFIFO</span>:
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ubifs_file_inode_operations</span><span class="p">;</span>
		<span class="n">init_special_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_invalid</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_invalid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="n">ubifs_set_inode_flags</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">unlock_new_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>

<span class="nl">out_invalid:</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;inode %lu validation failed, error %d&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="n">ubifs_dump_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="nl">out_ino:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;failed to read inode %lu, error %d&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">iget_failed</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">ubifs_alloc_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span><span class="p">;</span>

	<span class="n">ui</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">ubifs_inode_slab</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ui</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ui</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_inode</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span><span class="p">));</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ubifs_i_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span><span class="p">,</span> <span class="n">i_rcu</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">ubifs_inode_slab</span><span class="p">,</span> <span class="n">ui</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ubifs_destroy_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rcu</span><span class="p">,</span> <span class="n">ubifs_i_callback</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Note, Linux write-back code calls this without &#39;i_mutex&#39;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_write_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">xattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Due to races between write-back forced by budgeting</span>
<span class="cm">	 * (see &#39;sync_some_inodes()&#39;) and pdflush write-back, the inode may</span>
<span class="cm">	 * have already been synchronized, do not do this again. This might</span>
<span class="cm">	 * also happen if it was synchronized in an VFS operation, e.g.</span>
<span class="cm">	 * &#39;ubifs_link()&#39;.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * As an optimization, do not write orphan inodes to the media just</span>
<span class="cm">	 * because this is not needed.</span>
<span class="cm">	 */</span>
	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;inode %lu, mode %#x, nlink %u&quot;</span><span class="p">,</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_jnl_write_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;can&#39;t write inode %lu, error %d&quot;</span><span class="p">,</span>
				  <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_inode_size</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
	<span class="n">ubifs_release_dirty_inode_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ui</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ubifs_evict_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">xattr</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Extended attribute inode deletions are fully handled in</span>
<span class="cm">		 * &#39;ubifs_removexattr()&#39;. These inodes are special and have</span>
<span class="cm">		 * limited usage, so there is nothing to do here.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;inode %lu, mode %#x&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="p">));</span>

	<span class="n">truncate_inode_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_jnl_delete_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Worst case we have a lost orphan inode wasting space, so a</span>
<span class="cm">		 * simple error message is OK here.</span>
<span class="cm">		 */</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;can&#39;t delete inode %lu, error %d&quot;</span><span class="p">,</span>
			  <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">)</span>
		<span class="n">ubifs_release_dirty_inode_budget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ui</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* We&#39;ve deleted something - clean the &quot;no space&quot; flags */</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">nospace</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">nospace_rp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="p">}</span>
<span class="nl">done:</span>
	<span class="n">clear_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ubifs_dirty_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ui</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;inode %lu&quot;</span><span class="p">,</span>  <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_statfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstatfs</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">free</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">uuid</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">;</span>

	<span class="n">free</span> <span class="o">=</span> <span class="n">ubifs_get_free_space</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;free space %lld bytes (%lld blocks)&quot;</span><span class="p">,</span>
		<span class="n">free</span><span class="p">,</span> <span class="n">free</span> <span class="o">&gt;&gt;</span> <span class="n">UBIFS_BLOCK_SHIFT</span><span class="p">);</span>

	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_type</span> <span class="o">=</span> <span class="n">UBIFS_SUPER_MAGIC</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_bsize</span> <span class="o">=</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_blocks</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">block_cnt</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_bfree</span> <span class="o">=</span> <span class="n">free</span> <span class="o">&gt;&gt;</span> <span class="n">UBIFS_BLOCK_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">report_rp_size</span><span class="p">)</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_bavail</span> <span class="o">=</span> <span class="p">(</span><span class="n">free</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">report_rp_size</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">UBIFS_BLOCK_SHIFT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_bavail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_files</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_ffree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_namelen</span> <span class="o">=</span> <span class="n">UBIFS_MAX_NLEN</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_fsid</span><span class="p">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">uuid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">^</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">uuid</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_fsid</span><span class="p">.</span><span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">uuid</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">^</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">uuid</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_bfree</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">block_cnt</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_show_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">unmount_mode</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,fast_unmount&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">unmount_mode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,norm_unmount&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">bulk_read</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,bulk_read&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">bulk_read</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,no_bulk_read&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">chk_data_crc</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,chk_data_crc&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">chk_data_crc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,no_chk_data_crc&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">override_compr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,compr=%s&quot;</span><span class="p">,</span>
			   <span class="n">ubifs_compr_name</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">compr_type</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_sync_fs</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Zero @wait is just an advisory thing to help the file system shove</span>
<span class="cm">	 * lots of data into the queues, and there will be the second</span>
<span class="cm">	 * &#39;-&gt;sync_fs()&#39; call, with non-zero @wait.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Synchronize write buffers, because &#39;ubifs_run_commit()&#39; does not</span>
<span class="cm">	 * do this if it waits for an already running commit.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_wbuf_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wbuf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Strictly speaking, it is not necessary to commit the journal here,</span>
<span class="cm">	 * synchronizing write-buffers would be enough. But committing makes</span>
<span class="cm">	 * UBIFS free space predictions much more accurate, so we want to let</span>
<span class="cm">	 * the user be able to get more accurate results of &#39;statfs()&#39; after</span>
<span class="cm">	 * they synchronize the file system.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_run_commit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ubi_sync</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">ubi_num</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * init_constants_early - initialize UBIFS constants.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function initialize UBIFS constants which do not need the superblock to</span>
<span class="cm"> * be read. It also checks that the UBI volume satisfies basic UBIFS</span>
<span class="cm"> * requirements. Returns zero in case of success and a negative error code in</span>
<span class="cm"> * case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_constants_early</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">corrupted</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;UBI volume is corrupted - read-only mode&quot;</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_media</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">di</span><span class="p">.</span><span class="n">ro_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;read-only UBI device&quot;</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_media</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">vol_type</span> <span class="o">==</span> <span class="n">UBI_STATIC_VOLUME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;static UBI volume - read-only mode&quot;</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_media</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">usable_leb_size</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_start</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">di</span><span class="p">.</span><span class="n">leb_start</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">half_leb_size</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">di</span><span class="p">.</span><span class="n">min_io_size</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_shift</span> <span class="o">=</span> <span class="n">fls</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">di</span><span class="p">.</span><span class="n">max_write_size</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_shift</span> <span class="o">=</span> <span class="n">fls</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">&lt;</span> <span class="n">UBIFS_MIN_LEB_SZ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;too small LEBs (%d bytes), min. is %d bytes&quot;</span><span class="p">,</span>
			  <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">,</span> <span class="n">UBIFS_MIN_LEB_SZ</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">&lt;</span> <span class="n">UBIFS_MIN_LEB_CNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;too few LEBs (%d), min. is %d&quot;</span><span class="p">,</span>
			  <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">,</span> <span class="n">UBIFS_MIN_LEB_CNT</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad min. I/O size %d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Maximum write size has to be greater or equivalent to min. I/O</span>
<span class="cm">	 * size, and be multiple of min. I/O size.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">||</span>
	    <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span> <span class="o">%</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad write buffer size %d for %d min. I/O unit&quot;</span><span class="p">,</span>
			  <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * UBIFS aligns all node to 8-byte boundary, so to make function in</span>
<span class="cm">	 * io.c simpler, assume minimum I/O unit size to be 8 bytes if it is</span>
<span class="cm">	 * less than 8.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_shift</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_shift</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_shift</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ref_node_alsz</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">UBIFS_REF_NODE_SZ</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node_alsz</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">UBIFS_MST_NODE_SZ</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize node length ranges which are mostly needed for node</span>
<span class="cm">	 * length validation.</span>
<span class="cm">	 */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">UBIFS_PAD_NODE</span><span class="p">].</span><span class="n">len</span>  <span class="o">=</span> <span class="n">UBIFS_PAD_NODE_SZ</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">UBIFS_SB_NODE</span><span class="p">].</span><span class="n">len</span>   <span class="o">=</span> <span class="n">UBIFS_SB_NODE_SZ</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">UBIFS_MST_NODE</span><span class="p">].</span><span class="n">len</span>  <span class="o">=</span> <span class="n">UBIFS_MST_NODE_SZ</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">UBIFS_REF_NODE</span><span class="p">].</span><span class="n">len</span>  <span class="o">=</span> <span class="n">UBIFS_REF_NODE_SZ</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">UBIFS_TRUN_NODE</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">UBIFS_TRUN_NODE_SZ</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">UBIFS_CS_NODE</span><span class="p">].</span><span class="n">len</span>   <span class="o">=</span> <span class="n">UBIFS_CS_NODE_SZ</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">UBIFS_INO_NODE</span><span class="p">].</span><span class="n">min_len</span>  <span class="o">=</span> <span class="n">UBIFS_INO_NODE_SZ</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">UBIFS_INO_NODE</span><span class="p">].</span><span class="n">max_len</span>  <span class="o">=</span> <span class="n">UBIFS_MAX_INO_NODE_SZ</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">UBIFS_ORPH_NODE</span><span class="p">].</span><span class="n">min_len</span> <span class="o">=</span>
				<span class="n">UBIFS_ORPH_NODE_SZ</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__le64</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">UBIFS_ORPH_NODE</span><span class="p">].</span><span class="n">max_len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">UBIFS_DENT_NODE</span><span class="p">].</span><span class="n">min_len</span> <span class="o">=</span> <span class="n">UBIFS_DENT_NODE_SZ</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">UBIFS_DENT_NODE</span><span class="p">].</span><span class="n">max_len</span> <span class="o">=</span> <span class="n">UBIFS_MAX_DENT_NODE_SZ</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">UBIFS_XENT_NODE</span><span class="p">].</span><span class="n">min_len</span> <span class="o">=</span> <span class="n">UBIFS_XENT_NODE_SZ</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">UBIFS_XENT_NODE</span><span class="p">].</span><span class="n">max_len</span> <span class="o">=</span> <span class="n">UBIFS_MAX_XENT_NODE_SZ</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">UBIFS_DATA_NODE</span><span class="p">].</span><span class="n">min_len</span> <span class="o">=</span> <span class="n">UBIFS_DATA_NODE_SZ</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">UBIFS_DATA_NODE</span><span class="p">].</span><span class="n">max_len</span> <span class="o">=</span> <span class="n">UBIFS_MAX_DATA_NODE_SZ</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Minimum indexing node size is amended later when superblock is</span>
<span class="cm">	 * read and the key length is known.</span>
<span class="cm">	 */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">UBIFS_IDX_NODE</span><span class="p">].</span><span class="n">min_len</span> <span class="o">=</span> <span class="n">UBIFS_IDX_NODE_SZ</span> <span class="o">+</span> <span class="n">UBIFS_BRANCH_SZ</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Maximum indexing node size is amended later when superblock is</span>
<span class="cm">	 * read and the fanout is known.</span>
<span class="cm">	 */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">UBIFS_IDX_NODE</span><span class="p">].</span><span class="n">max_len</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize dead and dark LEB space watermarks. See gc.c for comments</span>
<span class="cm">	 * about these values.</span>
<span class="cm">	 */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">dead_wm</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">MIN_WRITE_SZ</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">dark_wm</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">UBIFS_MAX_NODE_SZ</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate how many bytes would be wasted at the end of LEB if it was</span>
<span class="cm">	 * fully filled with data nodes of maximum size. This is used in</span>
<span class="cm">	 * calculations when reporting free space.</span>
<span class="cm">	 */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_overhead</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">%</span> <span class="n">UBIFS_MAX_DATA_NODE_SZ</span><span class="p">;</span>

	<span class="cm">/* Buffer size for bulk-reads */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bu_buf_len</span> <span class="o">=</span> <span class="n">UBIFS_MAX_BULK_READ</span> <span class="o">*</span> <span class="n">UBIFS_MAX_DATA_NODE_SZ</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bu_buf_len</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bu_buf_len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bud_wbuf_callback - bud LEB write-buffer synchronization call-back.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB the write-buffer was synchronized to</span>
<span class="cm"> * @free: how many free bytes left in this LEB</span>
<span class="cm"> * @pad: how many bytes were padded</span>
<span class="cm"> *</span>
<span class="cm"> * This is a callback function which is called by the I/O unit when the</span>
<span class="cm"> * write-buffer is synchronized. We need this to correctly maintain space</span>
<span class="cm"> * accounting in bud logical eraseblocks. This function returns zero in case of</span>
<span class="cm"> * success and a negative error code in case of failure.</span>
<span class="cm"> *</span>
<span class="cm"> * This function actually belongs to the journal, but we keep it here because</span>
<span class="cm"> * we want to keep it static.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bud_wbuf_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">free</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pad</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ubifs_update_one_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * init_constants_sb - initialize UBIFS constants.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function which initializes various UBIFS constants after</span>
<span class="cm"> * the superblock has been read. It also checks various UBIFS parameters and</span>
<span class="cm"> * makes sure they are all right. Returns zero in case of success and a</span>
<span class="cm"> * negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_constants_sb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">tmp64</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">main_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">main_lebs</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">max_znode_sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_znode</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_zbranch</span><span class="p">);</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">ubifs_idx_node_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">UBIFS_IDX_NODE</span><span class="p">].</span><span class="n">min_len</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">min_idx_node_sz</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">ubifs_idx_node_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">UBIFS_IDX_NODE</span><span class="p">].</span><span class="n">max_len</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">max_idx_node_sz</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

	<span class="cm">/* Make sure LEB size is large enough to fit full commit */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">UBIFS_CS_NODE_SZ</span> <span class="o">+</span> <span class="n">UBIFS_REF_NODE_SZ</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;too small LEB size %d, at least %d needed&quot;</span><span class="p">,</span>
			  <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure that the log is large enough to fit reference nodes for</span>
<span class="cm">	 * all buds plus one reserved LEB.</span>
<span class="cm">	 */</span>
	<span class="n">tmp64</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bud_bytes</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bud_cnt</span> <span class="o">=</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">tmp64</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ref_node_alsz</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bud_cnt</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">/=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">log_lebs</span> <span class="o">&lt;</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;too small log %d LEBs, required min. %d LEBs&quot;</span><span class="p">,</span>
			  <span class="n">c</span><span class="o">-&gt;</span><span class="n">log_lebs</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * When budgeting we assume worst-case scenarios when the pages are not</span>
<span class="cm">	 * be compressed and direntries are of the maximum size.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note, data, which may be stored in inodes is budgeted separately, so</span>
<span class="cm">	 * it is not included into &#39;c-&gt;bi.inode_budget&#39;.</span>
<span class="cm">	 */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">page_budget</span> <span class="o">=</span> <span class="n">UBIFS_MAX_DATA_NODE_SZ</span> <span class="o">*</span> <span class="n">UBIFS_BLOCKS_PER_PAGE</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">inode_budget</span> <span class="o">=</span> <span class="n">UBIFS_INO_NODE_SZ</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">dent_budget</span> <span class="o">=</span> <span class="n">UBIFS_MAX_DENT_NODE_SZ</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When the amount of flash space used by buds becomes</span>
<span class="cm">	 * &#39;c-&gt;max_bud_bytes&#39;, UBIFS just blocks all writers and starts commit.</span>
<span class="cm">	 * The writers are unblocked when the commit is finished. To avoid</span>
<span class="cm">	 * writers to be blocked UBIFS initiates background commit in advance,</span>
<span class="cm">	 * when number of bud bytes becomes above the limit defined below.</span>
<span class="cm">	 */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bg_bud_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bud_bytes</span> <span class="o">*</span> <span class="mi">13</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure minimum journal size. All the bytes in the journal heads are</span>
<span class="cm">	 * considered to be used, when calculating the current journal usage.</span>
<span class="cm">	 * Consequently, if the journal is too small, UBIFS will treat it as</span>
<span class="cm">	 * always full.</span>
<span class="cm">	 */</span>
	<span class="n">tmp64</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bg_bud_bytes</span> <span class="o">&lt;</span> <span class="n">tmp64</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">bg_bud_bytes</span> <span class="o">=</span> <span class="n">tmp64</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bud_bytes</span> <span class="o">&lt;</span> <span class="n">tmp64</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bud_bytes</span> <span class="o">=</span> <span class="n">tmp64</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_calc_lpt_geom</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Initialize effective LEB size used in budgeting calculations */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_leb_size</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_idx_node_sz</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * init_constants_master - initialize UBIFS constants.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function which initializes various UBIFS constants after</span>
<span class="cm"> * the master node has been read. It also checks various UBIFS parameters and</span>
<span class="cm"> * makes sure they are all right.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_constants_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">tmp64</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">min_idx_lebs</span> <span class="o">=</span> <span class="n">ubifs_calc_min_idx_lebs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">report_rp_size</span> <span class="o">=</span> <span class="n">ubifs_reported_space</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">rp_size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate total amount of FS blocks. This number is not used</span>
<span class="cm">	 * internally because it does not make much sense for UBIFS, but it is</span>
<span class="cm">	 * necessary to report something for the &#39;statfs()&#39; call.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Subtract the LEB reserved for GC, the LEB which is reserved for</span>
<span class="cm">	 * deletions, minimum LEBs for the index, and assume only one journal</span>
<span class="cm">	 * head is available.</span>
<span class="cm">	 */</span>
	<span class="n">tmp64</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_lebs</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">MIN_INDEX_LEBS</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tmp64</span> <span class="o">*=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_overhead</span><span class="p">;</span>
	<span class="n">tmp64</span> <span class="o">=</span> <span class="n">ubifs_reported_space</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">tmp64</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">block_cnt</span> <span class="o">=</span> <span class="n">tmp64</span> <span class="o">&gt;&gt;</span> <span class="n">UBIFS_BLOCK_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * take_gc_lnum - reserve GC LEB.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function ensures that the LEB reserved for garbage collection is marked</span>
<span class="cm"> * as &quot;taken&quot; in lprops. We also have to set free space to LEB size and dirty</span>
<span class="cm"> * space to zero, because lprops may contain out-of-date information if the</span>
<span class="cm"> * file-system was un-mounted before it has been committed. This function</span>
<span class="cm"> * returns zero in case of success and a negative error code in case of</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">take_gc_lnum</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_lnum</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;no LEB for GC&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* And we have to tell lprops that this LEB is taken */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_change_one_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				  <span class="n">LPROPS_TAKEN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * alloc_wbufs - allocate write-buffers.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This helper function allocates and initializes UBIFS write-buffers. Returns</span>
<span class="cm"> * zero in case of success and %-ENOMEM in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_wbufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_jhead</span><span class="p">),</span>
			   <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Initialize journal heads */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buds_list</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_wbuf_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wbuf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wbuf</span><span class="p">.</span><span class="n">sync_callback</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bud_wbuf_callback</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wbuf</span><span class="p">.</span><span class="n">jhead</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">grouped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Garbage Collector head does not need to be synchronized by timer.</span>
<span class="cm">	 * Also GC head nodes are not grouped.</span>
<span class="cm">	 */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">GCHD</span><span class="p">].</span><span class="n">wbuf</span><span class="p">.</span><span class="n">no_timer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">GCHD</span><span class="p">].</span><span class="n">grouped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * free_wbufs - free write-buffers.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_wbufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wbuf</span><span class="p">.</span><span class="n">buf</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wbuf</span><span class="p">.</span><span class="n">inodes</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * free_orphans - free orphans.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_orphans</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_orphan</span> <span class="o">*</span><span class="n">orph</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_dnext</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">orph</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_dnext</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_dnext</span> <span class="o">=</span> <span class="n">orph</span><span class="o">-&gt;</span><span class="n">dnext</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orph</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">orph</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">orph</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_orphan</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orph</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">orph</span><span class="p">);</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;orphan list not empty at unmount&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_buf</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * free_buds - free per-bud objects.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_buds</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">buds</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_bud</span> <span class="o">*</span><span class="n">bud</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">)</span>
			<span class="n">this</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">)</span>
			<span class="n">this</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">bud</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_bud</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
			<span class="n">this</span> <span class="o">=</span> <span class="n">rb_parent</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">bud</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">)</span>
					<span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">bud</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * check_volume_empty - check if the UBI volume is empty.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks if the UBIFS volume is empty by looking if its LEBs are</span>
<span class="cm"> * mapped or not. The result of checking is stored in the @c-&gt;empty variable.</span>
<span class="cm"> * Returns zero in case of success and a negative error code in case of</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_volume_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">empty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lnum</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">;</span> <span class="n">lnum</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_is_mapped</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">empty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * UBIFS mount options.</span>
<span class="cm"> *</span>
<span class="cm"> * Opt_fast_unmount: do not run a journal commit before un-mounting</span>
<span class="cm"> * Opt_norm_unmount: run a journal commit before un-mounting</span>
<span class="cm"> * Opt_bulk_read: enable bulk-reads</span>
<span class="cm"> * Opt_no_bulk_read: disable bulk-reads</span>
<span class="cm"> * Opt_chk_data_crc: check CRCs when reading data nodes</span>
<span class="cm"> * Opt_no_chk_data_crc: do not check CRCs when reading data nodes</span>
<span class="cm"> * Opt_override_compr: override default compressor</span>
<span class="cm"> * Opt_err: just end of array marker</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">Opt_fast_unmount</span><span class="p">,</span>
	<span class="n">Opt_norm_unmount</span><span class="p">,</span>
	<span class="n">Opt_bulk_read</span><span class="p">,</span>
	<span class="n">Opt_no_bulk_read</span><span class="p">,</span>
	<span class="n">Opt_chk_data_crc</span><span class="p">,</span>
	<span class="n">Opt_no_chk_data_crc</span><span class="p">,</span>
	<span class="n">Opt_override_compr</span><span class="p">,</span>
	<span class="n">Opt_err</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">match_table_t</span> <span class="n">tokens</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">Opt_fast_unmount</span><span class="p">,</span> <span class="s">&quot;fast_unmount&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_norm_unmount</span><span class="p">,</span> <span class="s">&quot;norm_unmount&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_bulk_read</span><span class="p">,</span> <span class="s">&quot;bulk_read&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_no_bulk_read</span><span class="p">,</span> <span class="s">&quot;no_bulk_read&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_chk_data_crc</span><span class="p">,</span> <span class="s">&quot;chk_data_crc&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_no_chk_data_crc</span><span class="p">,</span> <span class="s">&quot;no_chk_data_crc&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_override_compr</span><span class="p">,</span> <span class="s">&quot;compr=%s&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_err</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">},</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * parse_standard_option - parse a standard mount option.</span>
<span class="cm"> * @option: the option to parse</span>
<span class="cm"> *</span>
<span class="cm"> * Normally, standard mount options like &quot;sync&quot; are passed to file-systems as</span>
<span class="cm"> * flags. However, when a &quot;rootflags=&quot; kernel boot parameter is used, they may</span>
<span class="cm"> * be present in the options string. This function tries to deal with this</span>
<span class="cm"> * situation and parse standard options. Returns 0 if the option was not</span>
<span class="cm"> * recognized, and the corresponding integer flag if it was.</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS is only interested in the &quot;sync&quot; option, so do not check for anything</span>
<span class="cm"> * else.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">parse_standard_option</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">option</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;parse %s&quot;</span><span class="p">,</span> <span class="n">option</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="s">&quot;sync&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">MS_SYNCHRONOUS</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_parse_options - parse mount parameters.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @options: parameters to parse</span>
<span class="cm"> * @is_remount: non-zero if this is FS re-mount</span>
<span class="cm"> *</span>
<span class="cm"> * This function parses UBIFS mount options and returns zero in case success</span>
<span class="cm"> * and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_parse_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">is_remount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">substring_t</span> <span class="n">args</span><span class="p">[</span><span class="n">MAX_OPT_ARGS</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">options</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">options</span><span class="p">,</span> <span class="s">&quot;,&quot;</span><span class="p">)))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">token</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">p</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">token</span> <span class="o">=</span> <span class="n">match_token</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * %Opt_fast_unmount and %Opt_norm_unmount options are ignored.</span>
<span class="cm">		 * We accept them in order to be backward-compatible. But this</span>
<span class="cm">		 * should be removed at some point.</span>
<span class="cm">		 */</span>
		<span class="k">case</span> <span class="n">Opt_fast_unmount</span>:
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">unmount_mode</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_norm_unmount</span>:
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">unmount_mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_bulk_read</span>:
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">bulk_read</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">bulk_read</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_no_bulk_read</span>:
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">bulk_read</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">bulk_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_chk_data_crc</span>:
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">chk_data_crc</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">no_chk_data_crc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_no_chk_data_crc</span>:
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">chk_data_crc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">no_chk_data_crc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_override_compr</span>:
		<span class="p">{</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">match_strdup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;none&quot;</span><span class="p">))</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">compr_type</span> <span class="o">=</span> <span class="n">UBIFS_COMPR_NONE</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;lzo&quot;</span><span class="p">))</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">compr_type</span> <span class="o">=</span> <span class="n">UBIFS_COMPR_LZO</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;zlib&quot;</span><span class="p">))</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">compr_type</span> <span class="o">=</span> <span class="n">UBIFS_COMPR_ZLIB</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;unknown compressor </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">override_compr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">default_compr</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">compr_type</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="nl">default:</span>
		<span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flag</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vfs_sb</span><span class="p">;</span>

			<span class="n">flag</span> <span class="o">=</span> <span class="n">parse_standard_option</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;unrecognized mount option </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> &quot;</span>
					  <span class="s">&quot;or missing value&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">flag</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * destroy_journal - destroy journal data structures.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function destroys journal data structures including those that may have</span>
<span class="cm"> * been created by recovery functions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_journal</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">unclean_leb_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_unclean_leb</span> <span class="o">*</span><span class="n">ucleb</span><span class="p">;</span>

		<span class="n">ucleb</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">unclean_leb_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">ubifs_unclean_leb</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ucleb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ucleb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">old_buds</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_bud</span> <span class="o">*</span><span class="n">bud</span><span class="p">;</span>

		<span class="n">bud</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">old_buds</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_bud</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bud</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bud</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ubifs_destroy_idx_gc</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">ubifs_destroy_size_tree</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">ubifs_tnc_close</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">free_buds</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bu_init - initialize bulk-read information.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bu_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bulk_read</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bu</span><span class="p">.</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* Already initialized */</span>

<span class="nl">again:</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bu</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bu_buf_len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bu</span><span class="p">.</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bu_buf_len</span> <span class="o">&gt;</span> <span class="n">UBIFS_KMALLOC_OK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bu_buf_len</span> <span class="o">=</span> <span class="n">UBIFS_KMALLOC_OK</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Just disable bulk-read */</span>
		<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;Cannot allocate %d bytes of memory for bulk-read, &quot;</span>
			   <span class="s">&quot;disabling it&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bu_buf_len</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">bulk_read</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">bulk_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * check_free_space - check if there is enough free space to mount.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function makes sure UBIFS has enough free space to be mounted in</span>
<span class="cm"> * read/write mode. UBIFS must always have some free space to allow deletions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_free_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dark_wm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_free</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">total_dirty</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dark_wm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;insufficient free space to mount in R/W mode&quot;</span><span class="p">);</span>
		<span class="n">ubifs_dump_budg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">);</span>
		<span class="n">ubifs_dump_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mount_ubifs - mount UBIFS file-system.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function mounts UBIFS file system. Returns zero in case of success and</span>
<span class="cm"> * a negative error code in case of failure.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, the function does not de-allocate resources it it fails half way</span>
<span class="cm"> * through, and the caller has to do this instead.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mount_ubifs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">x</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">sz</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vfs_sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">init_constants_early</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_debugging_init</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">check_volume_empty</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">empty</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_media</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This UBI volume is empty, and read-only, or the file system</span>
<span class="cm">		 * is mounted read-only - we cannot format it.</span>
<span class="cm">		 */</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;can&#39;t format empty UBI volume: read-only %s&quot;</span><span class="p">,</span>
			  <span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_media</span> <span class="o">?</span> <span class="s">&quot;UBI volume&quot;</span> <span class="o">:</span> <span class="s">&quot;mount&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_media</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot mount read-write - read-only media&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The requirement for the buffer is that it should fit indexing B-tree</span>
<span class="cm">	 * height amount of integers. We assume the height if the TNC tree will</span>
<span class="cm">	 * never exceed 64.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bottom_up_buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">BOTTOM_UP_HEIGHT</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bottom_up_buf</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">sbuf</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">sbuf</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_buf</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_buf</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bulk_read</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">bu_init</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">write_reserve_buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">COMPRESSED_DATA_NODE_BUF_SZ</span><span class="p">,</span>
					       <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">write_reserve_buf</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mounting</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_read_superblock</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure the compressor which is set as default in the superblock</span>
<span class="cm">	 * or overridden by mount options is actually compiled in.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubifs_compr_present</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">default_compr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;&#39;compressor </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> is not compiled in&quot;</span><span class="p">,</span>
			  <span class="n">ubifs_compr_name</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">default_compr</span><span class="p">));</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTSUPP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">init_constants_sb</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">sz</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_idx_node_sz</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="n">sz</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">sz</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_idx_node_sz</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">cbuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">alloc_wbufs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_cbuf</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt_name</span><span class="p">,</span> <span class="n">BGT_NAME_PATTERN</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">ubi_num</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">vol_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Create background thread */</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt</span> <span class="o">=</span> <span class="n">kthread_create</span><span class="p">(</span><span class="n">ubifs_bg_thread</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt_name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt</span><span class="p">);</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot spawn </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">, error %d&quot;</span><span class="p">,</span>
				  <span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt_name</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_wbufs</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_read_master</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_master</span><span class="p">;</span>

	<span class="n">init_constants_master</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UBIFS_MST_DIRTY</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;recovery needed&quot;</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">need_recovery</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">need_recovery</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_recover_inl_heads</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sbuf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_master</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_lpt_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_master</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">space_fixup</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_fixup_free_space</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_lpt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set the &quot;dirty&quot; flag so that if we reboot uncleanly we</span>
<span class="cm">		 * will notice this immediately on the next mount.</span>
<span class="cm">		 */</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UBIFS_MST_DIRTY</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_write_master</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_lpt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_idx_size</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">old_idx_sz</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_lpt</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_replay_journal</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_journal</span><span class="p">;</span>

	<span class="cm">/* Calculate &#39;min_idx_lebs&#39; after journal replay */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">min_idx_lebs</span> <span class="o">=</span> <span class="n">ubifs_calc_min_idx_lebs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_mount_orphans</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">need_recovery</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_orphans</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">lnum</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">check_free_space</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_orphans</span><span class="p">;</span>

		<span class="cm">/* Check for enough log space */</span>
		<span class="n">lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lhead_lnum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">UBIFS_LOG_LNUM</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">log_lebs</span><span class="p">)</span>
			<span class="n">lnum</span> <span class="o">=</span> <span class="n">UBIFS_LOG_LNUM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltail_lnum</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_consolidate_log</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_orphans</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">need_recovery</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_recover_size</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_orphans</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_rcvry_gc_commit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_orphans</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">take_gc_lnum</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_orphans</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * GC LEB may contain garbage if there was an unclean</span>
<span class="cm">			 * reboot, and it should be un-mapped.</span>
<span class="cm">			 */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_lnum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_orphans</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_orphans</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">need_recovery</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_recover_size</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_orphans</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Even if we mount read-only, we have to set space in GC LEB</span>
<span class="cm">		 * to proper value because this affects UBIFS free space</span>
<span class="cm">		 * reporting. We do not want to have a situation when</span>
<span class="cm">		 * re-mounting from R/O to R/W changes amount of free space.</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">take_gc_lnum</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_orphans</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_infos_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">infos_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubifs_infos</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_infos_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">need_recovery</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">)</span>
			<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;recovery deferred&quot;</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">need_recovery</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;recovery completed&quot;</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * GC LEB has to be empty and taken at this point. But</span>
<span class="cm">			 * the journal head LEBs may also be accounted as</span>
<span class="cm">			 * &quot;empty taken&quot; if they are empty.</span>
<span class="cm">			 */</span>
			<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">taken_empty_lebs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">taken_empty_lebs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_filesystem</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_infos</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_debugfs_init_fs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_infos</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mounting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;mounted UBI device %d, volume %d, name </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">ubi_num</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">vol_id</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">)</span>
		<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;mounted read-only&quot;</span><span class="p">);</span>
	<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">main_lebs</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">;</span>
	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;file system size:   %lld bytes (%lld KiB, %lld MiB, %d &quot;</span>
		  <span class="s">&quot;LEBs)&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_lebs</span><span class="p">);</span>
	<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">log_lebs</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bud_bytes</span><span class="p">;</span>
	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;journal size:       %lld bytes (%lld KiB, %lld MiB, %d &quot;</span>
		  <span class="s">&quot;LEBs)&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">log_lebs</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bud_cnt</span><span class="p">);</span>
	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;media format:       w%d/r%d (latest is w%d/r%d)&quot;</span><span class="p">,</span>
		  <span class="n">c</span><span class="o">-&gt;</span><span class="n">fmt_version</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_compat_version</span><span class="p">,</span>
		  <span class="n">UBIFS_FORMAT_VERSION</span><span class="p">,</span> <span class="n">UBIFS_RO_COMPAT_VERSION</span><span class="p">);</span>
	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;default compressor: %s&quot;</span><span class="p">,</span> <span class="n">ubifs_compr_name</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">default_compr</span><span class="p">));</span>
	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;reserved for root:  %llu bytes (%llu KiB)&quot;</span><span class="p">,</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">report_rp_size</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">report_rp_size</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>

	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;compiled on:         &quot;</span> <span class="n">__DATE__</span> <span class="s">&quot; at &quot;</span> <span class="n">__TIME__</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;min. I/O unit size:  %d bytes&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;max. write size:     %d bytes&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;LEB size:            %d bytes (%d KiB)&quot;</span><span class="p">,</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;data journal heads:  %d&quot;</span><span class="p">,</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span> <span class="o">-</span> <span class="n">NONDATA_JHEADS_CNT</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;UUID:                %pUB&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;big_lpt              %d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">big_lpt</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;log LEBs:            %d (%d - %d)&quot;</span><span class="p">,</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">log_lebs</span><span class="p">,</span> <span class="n">UBIFS_LOG_LNUM</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">log_last</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;LPT area LEBs:       %d (%d - %d)&quot;</span><span class="p">,</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lebs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_last</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;orphan area LEBs:    %d (%d - %d)&quot;</span><span class="p">,</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_lebs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_first</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_last</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;main area LEBs:      %d (%d - %d)&quot;</span><span class="p">,</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">main_lebs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_first</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;index LEBs:          %d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">idx_lebs</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;total index bytes:   %lld (%lld KiB, %lld MiB)&quot;</span><span class="p">,</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">old_idx_sz</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">old_idx_sz</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">old_idx_sz</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;key hash type:       %d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">key_hash_type</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;tree fanout:         %d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;reserved GC LEB:     %d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_lnum</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;first main LEB:      %d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_first</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;max. znode size      %d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_znode_sz</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;max. index node size %d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_idx_node_sz</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;node sizes:          data %zu, inode %zu, dentry %zu&quot;</span><span class="p">,</span>
		<span class="n">UBIFS_DATA_NODE_SZ</span><span class="p">,</span> <span class="n">UBIFS_INO_NODE_SZ</span><span class="p">,</span> <span class="n">UBIFS_DENT_NODE_SZ</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;node sizes:          trun %zu, sb %zu, master %zu&quot;</span><span class="p">,</span>
		<span class="n">UBIFS_TRUN_NODE_SZ</span><span class="p">,</span> <span class="n">UBIFS_SB_NODE_SZ</span><span class="p">,</span> <span class="n">UBIFS_MST_NODE_SZ</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;node sizes:          ref %zu, cmt. start %zu, orph %zu&quot;</span><span class="p">,</span>
		<span class="n">UBIFS_REF_NODE_SZ</span><span class="p">,</span> <span class="n">UBIFS_CS_NODE_SZ</span><span class="p">,</span> <span class="n">UBIFS_ORPH_NODE_SZ</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;max. node sizes:     data %zu, inode %zu dentry %zu, idx %d&quot;</span><span class="p">,</span>
		<span class="n">UBIFS_MAX_DATA_NODE_SZ</span><span class="p">,</span> <span class="n">UBIFS_MAX_INO_NODE_SZ</span><span class="p">,</span>
		<span class="n">UBIFS_MAX_DENT_NODE_SZ</span><span class="p">,</span> <span class="n">ubifs_idx_node_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span><span class="p">));</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;dead watermark:      %d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dead_wm</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;dark watermark:      %d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dark_wm</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;LEB overhead:        %d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_overhead</span><span class="p">);</span>
	<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">main_lebs</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dark_wm</span><span class="p">;</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;max. dark space:     %lld (%lld KiB, %lld MiB)&quot;</span><span class="p">,</span>
		<span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;maximum bud bytes:   %lld (%lld KiB, %lld MiB)&quot;</span><span class="p">,</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bud_bytes</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bud_bytes</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bud_bytes</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;BG commit bud bytes: %lld (%lld KiB, %lld MiB)&quot;</span><span class="p">,</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">bg_bud_bytes</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bg_bud_bytes</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">bg_bud_bytes</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;current bud bytes    %lld (%lld KiB, %lld MiB)&quot;</span><span class="p">,</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">bud_bytes</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bud_bytes</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bud_bytes</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;max. seq. number:    %llu&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_sqnum</span><span class="p">);</span>
	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;commit number:       %llu&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_no</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_infos:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_infos_lock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">infos_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_infos_lock</span><span class="p">);</span>
<span class="nl">out_orphans:</span>
	<span class="n">free_orphans</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="nl">out_journal:</span>
	<span class="n">destroy_journal</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="nl">out_lpt:</span>
	<span class="n">ubifs_lpt_free</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">out_master:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rcvrd_mst_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt</span><span class="p">)</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt</span><span class="p">);</span>
<span class="nl">out_wbufs:</span>
	<span class="n">free_wbufs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="nl">out_cbuf:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cbuf</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">write_reserve_buf</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bu</span><span class="p">.</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_buf</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">sbuf</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bottom_up_buf</span><span class="p">);</span>
	<span class="n">ubifs_debugging_exit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_umount - un-mount UBIFS file-system.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * Note, this function is called to free allocated resourced when un-mounting,</span>
<span class="cm"> * as well as free resources when an error occurred while we were half way</span>
<span class="cm"> * through mounting (error path cleanup function). So it has to make sure the</span>
<span class="cm"> * resource was actually allocated before freeing it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ubifs_umount</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;un-mounting UBI device %d, volume %d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">ubi_num</span><span class="p">,</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">vol_id</span><span class="p">);</span>

	<span class="n">dbg_debugfs_exit_fs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_infos_lock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">infos_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_infos_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt</span><span class="p">)</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt</span><span class="p">);</span>

	<span class="n">destroy_journal</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">free_wbufs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">free_orphans</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">ubifs_lpt_free</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cbuf</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rcvrd_mst_node</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">write_reserve_buf</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bu</span><span class="p">.</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_buf</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">sbuf</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bottom_up_buf</span><span class="p">);</span>
	<span class="n">ubifs_debugging_exit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_remount_rw - re-mount in read-write mode.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS avoids allocating many unnecessary resources when mounted in read-only</span>
<span class="cm"> * mode. This function allocates the needed resources and re-mounts UBIFS in</span>
<span class="cm"> * read-write mode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_remount_rw</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">lnum</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rw_incompat</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;the file-system is not R/W-compatible&quot;</span><span class="p">);</span>
		<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;on-flash format version is w%d/r%d, but software &quot;</span>
			  <span class="s">&quot;only supports up to version w%d/r%d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fmt_version</span><span class="p">,</span>
			  <span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_compat_version</span><span class="p">,</span> <span class="n">UBIFS_FORMAT_VERSION</span><span class="p">,</span>
			  <span class="n">UBIFS_RO_COMPAT_VERSION</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">umount_mutex</span><span class="p">);</span>
	<span class="n">dbg_save_space_info</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">remounting_rw</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">check_free_space</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">old_leb_cnt</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_sb_node</span> <span class="o">*</span><span class="n">sup</span><span class="p">;</span>

		<span class="n">sup</span> <span class="o">=</span> <span class="n">ubifs_read_sb_node</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sup</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sup</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sup</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_write_sb_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sup</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sup</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">need_recovery</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;completing deferred recovery&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_write_rcvrd_mst_node</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_recover_size</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_clean_lebs</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sbuf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_recover_inl_heads</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sbuf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* A readonly mount is not allowed to have orphans */</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tot_orphans</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_clear_orphans</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UBIFS_MST_DIRTY</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UBIFS_MST_DIRTY</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_write_master</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_buf</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">write_reserve_buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">COMPRESSED_DATA_NODE_BUF_SZ</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">write_reserve_buf</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_lpt_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Create background thread */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt</span> <span class="o">=</span> <span class="n">kthread_create</span><span class="p">(</span><span class="n">ubifs_bg_thread</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot spawn </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">, error %d&quot;</span><span class="p">,</span>
			  <span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt_name</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt</span><span class="p">);</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_buf</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check for enough log space */</span>
	<span class="n">lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lhead_lnum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">UBIFS_LOG_LNUM</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">log_lebs</span><span class="p">)</span>
		<span class="n">lnum</span> <span class="o">=</span> <span class="n">UBIFS_LOG_LNUM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltail_lnum</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_consolidate_log</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">need_recovery</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_rcvry_gc_commit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;re-mounted read-write&quot;</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">remounting_rw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">need_recovery</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">need_recovery</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;deferred recovery completed&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Do not run the debugging space check if the were doing</span>
<span class="cm">		 * recovery, because when we saved the information we had the</span>
<span class="cm">		 * file-system in a state where the TNC and lprops has been</span>
<span class="cm">		 * modified in memory, but all the I/O operations (including a</span>
<span class="cm">		 * commit) were deferred. So the file-system was in</span>
<span class="cm">		 * &quot;non-committed&quot; state. Now the file-system is in committed</span>
<span class="cm">		 * state, and of course the amount of free space will change</span>
<span class="cm">		 * because, for example, the old index size was imprecise.</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_space_info</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_fixup</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_fixup_free_space</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">umount_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_buf</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">free_wbufs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">write_reserve_buf</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">write_reserve_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_buf</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ubifs_lpt_free</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">remounting_rw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">umount_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_remount_ro - re-mount in read-only mode.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * We assume VFS has stopped writing. Possibly the background thread could be</span>
<span class="cm"> * running a commit, however kthread_stop will wait in that case.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ubifs_remount_ro</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">need_recovery</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">umount_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dbg_save_space_info</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ubifs_wbuf_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wbuf</span><span class="p">);</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UBIFS_MST_DIRTY</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UBIFS_MST_NO_ORPHS</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">gc_lnum</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_lnum</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_write_master</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">ubifs_ro_mode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_buf</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">write_reserve_buf</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">write_reserve_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_buf</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ubifs_lpt_free</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_space_info</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">ubifs_ro_mode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">umount_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ubifs_put_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>

	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;un-mount UBI device %d, volume %d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">ubi_num</span><span class="p">,</span>
		  <span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">vol_id</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The following asserts are only valid if there has not been a failure</span>
<span class="cm">	 * of the media. For example, there will be dirty inodes if we failed</span>
<span class="cm">	 * to write them back because of I/O errors.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">idx_growth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">dd_growth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">data_growth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The &#39;c-&gt;umount_lock&#39; prevents races between UBIFS memory shrinker</span>
<span class="cm">	 * and file system un-mount. Namely, it prevents the shrinker from</span>
<span class="cm">	 * picking this superblock for shrinking - it will be just skipped if</span>
<span class="cm">	 * the mutex is locked.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">umount_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * First of all kill the background thread to make sure it does</span>
<span class="cm">		 * not interfere with un-mounting and freeing resources.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kthread_stop</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt</span><span class="p">);</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * On fatal errors c-&gt;ro_error is set to 1, in which case we do</span>
<span class="cm">		 * not write the master node.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_error</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

			<span class="cm">/* Synchronize write-buffers */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">ubifs_wbuf_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wbuf</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * We are being cleanly unmounted which means the</span>
<span class="cm">			 * orphans were killed - indicate this in the master</span>
<span class="cm">			 * node. Also save the reserved GC LEB number.</span>
<span class="cm">			 */</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UBIFS_MST_DIRTY</span><span class="p">);</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UBIFS_MST_NO_ORPHS</span><span class="p">);</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">gc_lnum</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_lnum</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_write_master</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="cm">/*</span>
<span class="cm">				 * Recovery will attempt to fix the master area</span>
<span class="cm">				 * next mount, so we just print a message and</span>
<span class="cm">				 * continue to unmount normally.</span>
<span class="cm">				 */</span>
				<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;failed to write master node, &quot;</span>
					  <span class="s">&quot;error %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="cm">/* Make sure write-buffer timers are canceled */</span>
				<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wbuf</span><span class="p">.</span><span class="n">timer</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ubifs_umount</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">bdi_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">);</span>
	<span class="n">ubi_close_volume</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ubi</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">umount_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_remount_fs</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;old flags %#lx, new flags %#x&quot;</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_parse_options</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;invalid or unknown remount parameter&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;cannot re-mount R/W due to prior errors&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_media</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;cannot re-mount R/W - UBI volume is R/O&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_remount_rw</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;cannot re-mount R/O due to prior errors&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ubifs_remount_ro</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bulk_read</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">bu_init</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;disable bulk-read&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bu</span><span class="p">.</span><span class="n">buf</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">bu</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">taken_empty_lebs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="n">ubifs_super_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">alloc_inode</span>   <span class="o">=</span> <span class="n">ubifs_alloc_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">destroy_inode</span> <span class="o">=</span> <span class="n">ubifs_destroy_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put_super</span>     <span class="o">=</span> <span class="n">ubifs_put_super</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_inode</span>   <span class="o">=</span> <span class="n">ubifs_write_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">evict_inode</span>   <span class="o">=</span> <span class="n">ubifs_evict_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">statfs</span>        <span class="o">=</span> <span class="n">ubifs_statfs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dirty_inode</span>   <span class="o">=</span> <span class="n">ubifs_dirty_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remount_fs</span>    <span class="o">=</span> <span class="n">ubifs_remount_fs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_options</span>  <span class="o">=</span> <span class="n">ubifs_show_options</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync_fs</span>       <span class="o">=</span> <span class="n">ubifs_sync_fs</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * open_ubi - parse UBI device name string and open the UBI device.</span>
<span class="cm"> * @name: UBI volume name</span>
<span class="cm"> * @mode: UBI volume open mode</span>
<span class="cm"> *</span>
<span class="cm"> * The primary method of mounting UBIFS is by specifying the UBI volume</span>
<span class="cm"> * character device node path. However, UBIFS may also be mounted withoug any</span>
<span class="cm"> * character device node using one of the following methods:</span>
<span class="cm"> *</span>
<span class="cm"> * o ubiX_Y    - mount UBI device number X, volume Y;</span>
<span class="cm"> * o ubiY      - mount UBI device number 0, volume Y;</span>
<span class="cm"> * o ubiX:NAME - mount UBI device X, volume with name NAME;</span>
<span class="cm"> * o ubi:NAME  - mount UBI device 0, volume with name NAME.</span>
<span class="cm"> *</span>
<span class="cm"> * Alternative &#39;!&#39; separator may be used instead of &#39;:&#39; (because some shells</span>
<span class="cm"> * like busybox may interpret &#39;:&#39; as an NFS host name separator). This function</span>
<span class="cm"> * returns UBI volume description object in case of success and a negative</span>
<span class="cm"> * error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="nf">open_ubi</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">ubi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dev</span><span class="p">,</span> <span class="n">vol</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">endptr</span><span class="p">;</span>

	<span class="cm">/* First, try to open using the device node path method */</span>
	<span class="n">ubi</span> <span class="o">=</span> <span class="n">ubi_open_volume_path</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ubi</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ubi</span><span class="p">;</span>

	<span class="cm">/* Try the &quot;nodev&quot; method */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;u&#39;</span> <span class="o">||</span> <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;b&#39;</span> <span class="o">||</span> <span class="n">name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;i&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="cm">/* ubi:NAME method */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">name</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;:&#39;</span> <span class="o">||</span> <span class="n">name</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;!&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">name</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ubi_open_volume_nm</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isdigit</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* ubiY method */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">endptr</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ubi_open_volume</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>

	<span class="cm">/* ubiX_Y method */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">endptr</span> <span class="o">==</span> <span class="sc">&#39;_&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">isdigit</span><span class="p">(</span><span class="n">endptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">vol</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">endptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">endptr</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ubi_open_volume</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">vol</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* ubiX:NAME method */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">endptr</span> <span class="o">==</span> <span class="sc">&#39;:&#39;</span> <span class="o">||</span> <span class="o">*</span><span class="n">endptr</span> <span class="o">==</span> <span class="sc">&#39;!&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">endptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ubi_open_volume_nm</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">++</span><span class="n">endptr</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="nf">alloc_ubifs_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">ubi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cnt_lock</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">buds_lock</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
		<span class="n">init_rwsem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">commit_sem</span><span class="p">);</span>
		<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lp_mutex</span><span class="p">);</span>
		<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
		<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">log_mutex</span><span class="p">);</span>
		<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_mutex</span><span class="p">);</span>
		<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">umount_mutex</span><span class="p">);</span>
		<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bu_mutex</span><span class="p">);</span>
		<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">write_reserve_mutex</span><span class="p">);</span>
		<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_wq</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">buds</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">old_idx</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">size_tree</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_tree</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">infos_list</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_gc</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">replay_list</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">replay_buds</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">uncat_list</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">empty_list</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_list</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">frdi_idx_list</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">unclean_leb_list</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">old_buds</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_list</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_new</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">no_chk_data_crc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">c</span><span class="o">-&gt;</span><span class="n">highest_inum</span> <span class="o">=</span> <span class="n">UBIFS_FIRST_INO</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">lhead_lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltail_lnum</span> <span class="o">=</span> <span class="n">UBIFS_LOG_LNUM</span><span class="p">;</span>

		<span class="n">ubi_get_volume_info</span><span class="p">(</span><span class="n">ubi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">);</span>
		<span class="n">ubi_get_device_info</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">ubi_num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">di</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ubifs_fill_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">silent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">vfs_sb</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>
	<span class="cm">/* Re-open the UBI device in read-write mode */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ubi</span> <span class="o">=</span> <span class="n">ubi_open_volume</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">ubi_num</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">vol_id</span><span class="p">,</span> <span class="n">UBI_READWRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ubi</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ubi</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * UBIFS provides &#39;backing_dev_info&#39; in order to disable read-ahead. For</span>
<span class="cm">	 * UBIFS, I/O is not deferred, it is done immediately in readpage,</span>
<span class="cm">	 * which means the user would have to wait not just for their own I/O</span>
<span class="cm">	 * but the read-ahead I/O as well i.e. completely pointless.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Read-ahead will be disabled because @c-&gt;bdi.ra_pages is 0.</span>
<span class="cm">	 */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;ubifs&quot;</span><span class="p">,</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">.</span><span class="n">capabilities</span> <span class="o">=</span> <span class="n">BDI_CAP_MAP_COPY</span><span class="p">;</span>
	<span class="n">err</span>  <span class="o">=</span> <span class="n">bdi_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_close</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">bdi_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;ubifs_%d_%d&quot;</span><span class="p">,</span>
			   <span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">ubi_num</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">vol_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_bdi</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_parse_options</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_bdi</span><span class="p">;</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_magic</span> <span class="o">=</span> <span class="n">UBIFS_SUPER_MAGIC</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">=</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span> <span class="o">=</span> <span class="n">UBIFS_BLOCK_SHIFT</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_maxbytes</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_inode_sz</span> <span class="o">=</span> <span class="n">key_max_inode_size</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_inode_sz</span> <span class="o">&gt;</span> <span class="n">MAX_LFS_FILESIZE</span><span class="p">)</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_maxbytes</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_inode_sz</span> <span class="o">=</span> <span class="n">MAX_LFS_FILESIZE</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ubifs_super_operations</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">umount_mutex</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">mount_ubifs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Read the root inode */</span>
	<span class="n">root</span> <span class="o">=</span> <span class="n">ubifs_iget</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UBIFS_ROOT_INO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">root</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_umount</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span> <span class="o">=</span> <span class="n">d_make_root</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_umount</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">umount_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_umount:</span>
	<span class="n">ubifs_umount</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">umount_mutex</span><span class="p">);</span>
<span class="nl">out_bdi:</span>
	<span class="n">bdi_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">);</span>
<span class="nl">out_close:</span>
	<span class="n">ubi_close_volume</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ubi</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sb_test</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c1</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">cdev</span> <span class="o">==</span> <span class="n">c1</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">cdev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sb_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">set_anon_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">ubifs_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubi_volume_desc</span> <span class="o">*</span><span class="n">ubi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;name %s, flags %#x&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get UBI device number and volume ID. Mount it read-only so far</span>
<span class="cm">	 * because this might be a new mount point, and UBI allows only one</span>
<span class="cm">	 * read-write user at a time.</span>
<span class="cm">	 */</span>
	<span class="n">ubi</span> <span class="o">=</span> <span class="n">open_ubi</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">UBI_READONLY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ubi</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot open </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">, error %d&quot;</span><span class="p">,</span>
			  <span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ubi</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">alloc_ubifs_info</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_close</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;opened ubi%d_%d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">ubi_num</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">vol_id</span><span class="p">);</span>

	<span class="n">sb</span> <span class="o">=</span> <span class="n">sget</span><span class="p">(</span><span class="n">fs_type</span><span class="p">,</span> <span class="n">sb_test</span><span class="p">,</span> <span class="n">sb_set</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_close</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c1</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="cm">/* A new mount point for already mounted UBIFS */</span>
		<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;this ubi volume is already mounted&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span> <span class="o">!=</span> <span class="n">c1</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_deact</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_fill_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_SILENT</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_deact</span><span class="p">;</span>
		<span class="cm">/* We do not support atime */</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_ACTIVE</span> <span class="o">|</span> <span class="n">MS_NOATIME</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* &#39;fill_super()&#39; opens ubi again so we must close it here */</span>
	<span class="n">ubi_close_volume</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dget</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">);</span>

<span class="nl">out_deact:</span>
	<span class="n">deactivate_locked_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="nl">out_close:</span>
	<span class="n">ubi_close_volume</span><span class="p">(</span><span class="n">ubi</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kill_ubifs_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="n">kill_anon_super</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">file_system_type</span> <span class="n">ubifs_fs_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>    <span class="o">=</span> <span class="s">&quot;ubifs&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>   <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mount</span>   <span class="o">=</span> <span class="n">ubifs_mount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">kill_sb</span> <span class="o">=</span> <span class="n">kill_ubifs_super</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Inode slab cache constructor.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">inode_slab_ctor</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
	<span class="n">inode_init_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ubifs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_ch</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">24</span><span class="p">);</span>

	<span class="cm">/* Make sure node sizes are 8-byte aligned */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_CH_SZ</span>        <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_INO_NODE_SZ</span>  <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_DENT_NODE_SZ</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_XENT_NODE_SZ</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_DATA_NODE_SZ</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_TRUN_NODE_SZ</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_SB_NODE_SZ</span>   <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_MST_NODE_SZ</span>  <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_REF_NODE_SZ</span>  <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_CS_NODE_SZ</span>   <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_ORPH_NODE_SZ</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_MAX_DENT_NODE_SZ</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_MAX_XENT_NODE_SZ</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_MAX_DATA_NODE_SZ</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_MAX_INO_NODE_SZ</span>  <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_MAX_NODE_SZ</span>      <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">MIN_WRITE_SZ</span>           <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>

	<span class="cm">/* Check min. node size */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_INO_NODE_SZ</span>  <span class="o">&lt;</span> <span class="n">MIN_WRITE_SZ</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_DENT_NODE_SZ</span> <span class="o">&lt;</span> <span class="n">MIN_WRITE_SZ</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_XENT_NODE_SZ</span> <span class="o">&lt;</span> <span class="n">MIN_WRITE_SZ</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_TRUN_NODE_SZ</span> <span class="o">&lt;</span> <span class="n">MIN_WRITE_SZ</span><span class="p">);</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_MAX_DENT_NODE_SZ</span> <span class="o">&gt;</span> <span class="n">UBIFS_MAX_NODE_SZ</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_MAX_XENT_NODE_SZ</span> <span class="o">&gt;</span> <span class="n">UBIFS_MAX_NODE_SZ</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_MAX_DATA_NODE_SZ</span> <span class="o">&gt;</span> <span class="n">UBIFS_MAX_NODE_SZ</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_MAX_INO_NODE_SZ</span>  <span class="o">&gt;</span> <span class="n">UBIFS_MAX_NODE_SZ</span><span class="p">);</span>

	<span class="cm">/* Defined node sizes */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_SB_NODE_SZ</span>  <span class="o">!=</span> <span class="mi">4096</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_MST_NODE_SZ</span> <span class="o">!=</span> <span class="mi">512</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_INO_NODE_SZ</span> <span class="o">!=</span> <span class="mi">160</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_REF_NODE_SZ</span> <span class="o">!=</span> <span class="mi">64</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We use 2 bit wide bit-fields to store compression type, which should</span>
<span class="cm">	 * be amended if more compressors are added. The bit-fields are:</span>
<span class="cm">	 * @compr_type in &#39;struct ubifs_inode&#39;, @default_compr in</span>
<span class="cm">	 * &#39;struct ubifs_info&#39; and @compr_type in &#39;struct ubifs_mount_opts&#39;.</span>
<span class="cm">	 */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">UBIFS_COMPR_TYPES_CNT</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We require that PAGE_CACHE_SIZE is greater-than-or-equal-to</span>
<span class="cm">	 * UBIFS_BLOCK_SIZE. It is assumed that both are powers of 2.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">&lt;</span> <span class="n">UBIFS_BLOCK_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;VFS page cache size is %u bytes, but UBIFS requires&quot;</span>
			  <span class="s">&quot; at least 4096 bytes&quot;</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ubifs_inode_slab</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;ubifs_inode_slab&quot;</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_inode</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">SLAB_MEM_SPREAD</span> <span class="o">|</span> <span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">inode_slab_ctor</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubifs_inode_slab</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">register_shrinker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_shrinker_info</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_compressors_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_shrinker</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_debugfs_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_compr</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">register_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_fs_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot register file system, error %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_dbg</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_dbg:</span>
	<span class="n">dbg_debugfs_exit</span><span class="p">();</span>
<span class="nl">out_compr:</span>
	<span class="n">ubifs_compressors_exit</span><span class="p">();</span>
<span class="nl">out_shrinker:</span>
	<span class="n">unregister_shrinker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_shrinker_info</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">ubifs_inode_slab</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* late_initcall to let compressors initialize first */</span>
<span class="n">late_initcall</span><span class="p">(</span><span class="n">ubifs_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">ubifs_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_infos</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_clean_zn_cnt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">dbg_debugfs_exit</span><span class="p">();</span>
	<span class="n">ubifs_compressors_exit</span><span class="p">();</span>
	<span class="n">unregister_shrinker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_shrinker_info</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">ubifs_inode_slab</span><span class="p">);</span>
	<span class="n">unregister_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_fs_type</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">ubifs_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">__stringify</span><span class="p">(</span><span class="n">UBIFS_VERSION</span><span class="p">));</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Artem Bityutskiy, Adrian Hunter&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;UBIFS - UBI File System&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
