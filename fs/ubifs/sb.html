<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ubifs › sb.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>sb.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is part of UBIFS.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Nokia Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="cm"> * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> *          Adrian Hunter</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file implements UBIFS superblock. The superblock is stored at the first</span>
<span class="cm"> * LEB of the volume and is never changed by UBIFS. Only user-space tools may</span>
<span class="cm"> * change it. The superblock node mostly contains geometry information.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;ubifs.h&quot;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/math64.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Default journal size in logical eraseblocks as a percent of total</span>
<span class="cm"> * flash size.</span>
<span class="cm"> */</span>
<span class="cp">#define DEFAULT_JNL_PERCENT 5</span>

<span class="cm">/* Default maximum journal size in bytes */</span>
<span class="cp">#define DEFAULT_MAX_JNL (32*1024*1024)</span>

<span class="cm">/* Default indexing tree fanout */</span>
<span class="cp">#define DEFAULT_FANOUT 8</span>

<span class="cm">/* Default number of data journal heads */</span>
<span class="cp">#define DEFAULT_JHEADS_CNT 1</span>

<span class="cm">/* Default positions of different LEBs in the main area */</span>
<span class="cp">#define DEFAULT_IDX_LEB  0</span>
<span class="cp">#define DEFAULT_DATA_LEB 1</span>
<span class="cp">#define DEFAULT_GC_LEB   2</span>

<span class="cm">/* Default number of LEB numbers in LPT&#39;s save table */</span>
<span class="cp">#define DEFAULT_LSAVE_CNT 256</span>

<span class="cm">/* Default reserved pool size as a percent of maximum free space */</span>
<span class="cp">#define DEFAULT_RP_PERCENT 5</span>

<span class="cm">/* The default maximum size of reserved pool in bytes */</span>
<span class="cp">#define DEFAULT_MAX_RP_SIZE (5*1024*1024)</span>

<span class="cm">/* Default time granularity in nanoseconds */</span>
<span class="cp">#define DEFAULT_TIME_GRAN 1000000000</span>

<span class="cm">/**</span>
<span class="cm"> * create_default_filesystem - format empty UBI volume.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates default empty file-system. Returns zero in case of</span>
<span class="cm"> * success and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_default_filesystem</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_sb_node</span> <span class="o">*</span><span class="n">sup</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_mst_node</span> <span class="o">*</span><span class="n">mst</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_idx_node</span> <span class="o">*</span><span class="n">idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_branch</span> <span class="o">*</span><span class="n">br</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_ino_node</span> <span class="o">*</span><span class="n">ino</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_cs_node</span> <span class="o">*</span><span class="n">cs</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">jnl_lebs</span><span class="p">,</span> <span class="n">log_lebs</span><span class="p">,</span> <span class="n">max_buds</span><span class="p">,</span> <span class="n">main_lebs</span><span class="p">,</span> <span class="n">main_first</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lpt_lebs</span><span class="p">,</span> <span class="n">lpt_first</span><span class="p">,</span> <span class="n">orph_lebs</span><span class="p">,</span> <span class="n">big_lpt</span><span class="p">,</span> <span class="n">ino_waste</span><span class="p">,</span> <span class="n">sup_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">min_leb_cnt</span> <span class="o">=</span> <span class="n">UBIFS_MIN_LEB_CNT</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">tmp64</span><span class="p">,</span> <span class="n">main_bytes</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">tmp_le64</span><span class="p">;</span>

	<span class="cm">/* Some functions called from here depend on the @c-&gt;key_len filed */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">key_len</span> <span class="o">=</span> <span class="n">UBIFS_SK_LEN</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First of all, we have to calculate default file-system geometry -</span>
<span class="cm">	 * log size, journal size, etc.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">&lt;</span> <span class="mh">0x7FFFFFFF</span> <span class="o">/</span> <span class="n">DEFAULT_JNL_PERCENT</span><span class="p">)</span>
		<span class="cm">/* We can first multiply then divide and have no overflow */</span>
		<span class="n">jnl_lebs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">*</span> <span class="n">DEFAULT_JNL_PERCENT</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">jnl_lebs</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span> <span class="o">*</span> <span class="n">DEFAULT_JNL_PERCENT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">jnl_lebs</span> <span class="o">&lt;</span> <span class="n">UBIFS_MIN_JNL_LEBS</span><span class="p">)</span>
		<span class="n">jnl_lebs</span> <span class="o">=</span> <span class="n">UBIFS_MIN_JNL_LEBS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jnl_lebs</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">&gt;</span> <span class="n">DEFAULT_MAX_JNL</span><span class="p">)</span>
		<span class="n">jnl_lebs</span> <span class="o">=</span> <span class="n">DEFAULT_MAX_JNL</span> <span class="o">/</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The log should be large enough to fit reference nodes for all bud</span>
<span class="cm">	 * LEBs. Because buds do not have to start from the beginning of LEBs</span>
<span class="cm">	 * (half of the LEB may contain committed data), the log should</span>
<span class="cm">	 * generally be larger, make it twice as large.</span>
<span class="cm">	 */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ref_node_alsz</span> <span class="o">*</span> <span class="n">jnl_lebs</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">log_lebs</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">/</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">;</span>
	<span class="cm">/* Plus one LEB reserved for commit */</span>
	<span class="n">log_lebs</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">-</span> <span class="n">min_leb_cnt</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* And some extra space to allow writes while committing */</span>
		<span class="n">log_lebs</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">min_leb_cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">max_buds</span> <span class="o">=</span> <span class="n">jnl_lebs</span> <span class="o">-</span> <span class="n">log_lebs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_buds</span> <span class="o">&lt;</span> <span class="n">UBIFS_MIN_BUD_LEBS</span><span class="p">)</span>
		<span class="n">max_buds</span> <span class="o">=</span> <span class="n">UBIFS_MIN_BUD_LEBS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Orphan nodes are stored in a separate area. One node can store a lot</span>
<span class="cm">	 * of orphan inode numbers, but when new orphan comes we just add a new</span>
<span class="cm">	 * orphan node. At some point the nodes are consolidated into one</span>
<span class="cm">	 * orphan node.</span>
<span class="cm">	 */</span>
	<span class="n">orph_lebs</span> <span class="o">=</span> <span class="n">UBIFS_MIN_ORPH_LEBS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">-</span> <span class="n">min_leb_cnt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * For debugging purposes it is better to have at least 2</span>
<span class="cm">		 * orphan LEBs, because the orphan subsystem would need to do</span>
<span class="cm">		 * consolidations and would be stressed more.</span>
<span class="cm">		 */</span>
		<span class="n">orph_lebs</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">main_lebs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">-</span> <span class="n">UBIFS_SB_LEBS</span> <span class="o">-</span> <span class="n">UBIFS_MST_LEBS</span> <span class="o">-</span> <span class="n">log_lebs</span><span class="p">;</span>
	<span class="n">main_lebs</span> <span class="o">-=</span> <span class="n">orph_lebs</span><span class="p">;</span>

	<span class="n">lpt_first</span> <span class="o">=</span> <span class="n">UBIFS_LOG_LNUM</span> <span class="o">+</span> <span class="n">log_lebs</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span> <span class="o">=</span> <span class="n">DEFAULT_LSAVE_CNT</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">max_leb_cnt</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_create_dflt_lpt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">main_lebs</span><span class="p">,</span> <span class="n">lpt_first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lpt_lebs</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">big_lpt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;LEB Properties Tree created (LEBs %d-%d)&quot;</span><span class="p">,</span> <span class="n">lpt_first</span><span class="p">,</span>
		<span class="n">lpt_first</span> <span class="o">+</span> <span class="n">lpt_lebs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">main_first</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">-</span> <span class="n">main_lebs</span><span class="p">;</span>

	<span class="cm">/* Create default superblock */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">UBIFS_SB_NODE_SZ</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="n">sup</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sup</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">tmp64</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">max_buds</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">big_lpt</span><span class="p">)</span>
		<span class="n">sup_flags</span> <span class="o">|=</span> <span class="n">UBIFS_FLG_BIGLPT</span><span class="p">;</span>

	<span class="n">sup</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">node_type</span>  <span class="o">=</span> <span class="n">UBIFS_SB_NODE</span><span class="p">;</span>
	<span class="n">sup</span><span class="o">-&gt;</span><span class="n">key_hash</span>      <span class="o">=</span> <span class="n">UBIFS_KEY_HASH_R5</span><span class="p">;</span>
	<span class="n">sup</span><span class="o">-&gt;</span><span class="n">flags</span>         <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sup_flags</span><span class="p">);</span>
	<span class="n">sup</span><span class="o">-&gt;</span><span class="n">min_io_size</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="n">sup</span><span class="o">-&gt;</span><span class="n">leb_size</span>      <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
	<span class="n">sup</span><span class="o">-&gt;</span><span class="n">leb_cnt</span>       <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">);</span>
	<span class="n">sup</span><span class="o">-&gt;</span><span class="n">max_leb_cnt</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_leb_cnt</span><span class="p">);</span>
	<span class="n">sup</span><span class="o">-&gt;</span><span class="n">max_bud_bytes</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">tmp64</span><span class="p">);</span>
	<span class="n">sup</span><span class="o">-&gt;</span><span class="n">log_lebs</span>      <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">log_lebs</span><span class="p">);</span>
	<span class="n">sup</span><span class="o">-&gt;</span><span class="n">lpt_lebs</span>      <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lpt_lebs</span><span class="p">);</span>
	<span class="n">sup</span><span class="o">-&gt;</span><span class="n">orph_lebs</span>     <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">orph_lebs</span><span class="p">);</span>
	<span class="n">sup</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span>     <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DEFAULT_JHEADS_CNT</span><span class="p">);</span>
	<span class="n">sup</span><span class="o">-&gt;</span><span class="n">fanout</span>        <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DEFAULT_FANOUT</span><span class="p">);</span>
	<span class="n">sup</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span>     <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span><span class="p">);</span>
	<span class="n">sup</span><span class="o">-&gt;</span><span class="n">fmt_version</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UBIFS_FORMAT_VERSION</span><span class="p">);</span>
	<span class="n">sup</span><span class="o">-&gt;</span><span class="n">time_gran</span>     <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DEFAULT_TIME_GRAN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">override_compr</span><span class="p">)</span>
		<span class="n">sup</span><span class="o">-&gt;</span><span class="n">default_compr</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">compr_type</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sup</span><span class="o">-&gt;</span><span class="n">default_compr</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">UBIFS_COMPR_LZO</span><span class="p">);</span>

	<span class="n">generate_random_uuid</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">);</span>

	<span class="n">main_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">main_lebs</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">;</span>
	<span class="n">tmp64</span> <span class="o">=</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">main_bytes</span> <span class="o">*</span> <span class="n">DEFAULT_RP_PERCENT</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp64</span> <span class="o">&gt;</span> <span class="n">DEFAULT_MAX_RP_SIZE</span><span class="p">)</span>
		<span class="n">tmp64</span> <span class="o">=</span> <span class="n">DEFAULT_MAX_RP_SIZE</span><span class="p">;</span>
	<span class="n">sup</span><span class="o">-&gt;</span><span class="n">rp_size</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">tmp64</span><span class="p">);</span>
	<span class="n">sup</span><span class="o">-&gt;</span><span class="n">ro_compat_version</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UBIFS_RO_COMPAT_VERSION</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_write_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sup</span><span class="p">,</span> <span class="n">UBIFS_SB_NODE_SZ</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sup</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;default superblock created at LEB 0:0&quot;</span><span class="p">);</span>

	<span class="cm">/* Create default master node */</span>
	<span class="n">mst</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node_alsz</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mst</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">node_type</span> <span class="o">=</span> <span class="n">UBIFS_MST_NODE</span><span class="p">;</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">log_lnum</span>     <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UBIFS_LOG_LNUM</span><span class="p">);</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">highest_inum</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">UBIFS_FIRST_INO</span><span class="p">);</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">cmt_no</span>       <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">root_lnum</span>    <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">main_first</span> <span class="o">+</span> <span class="n">DEFAULT_IDX_LEB</span><span class="p">);</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">root_offs</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">ubifs_idx_node_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">root_len</span>     <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">gc_lnum</span>      <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">main_first</span> <span class="o">+</span> <span class="n">DEFAULT_GC_LEB</span><span class="p">);</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">ihead_lnum</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">main_first</span> <span class="o">+</span> <span class="n">DEFAULT_IDX_LEB</span><span class="p">);</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">ihead_offs</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ALIGN</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">));</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">index_size</span>   <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">ALIGN</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">8</span><span class="p">));</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">lpt_lnum</span>     <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lnum</span><span class="p">);</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">lpt_offs</span>     <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_offs</span><span class="p">);</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">nhead_lnum</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_lnum</span><span class="p">);</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">nhead_offs</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_offs</span><span class="p">);</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">ltab_lnum</span>    <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_lnum</span><span class="p">);</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">ltab_offs</span>    <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_offs</span><span class="p">);</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">lsave_lnum</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_lnum</span><span class="p">);</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">lsave_offs</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_offs</span><span class="p">);</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">lscan_lnum</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">main_first</span><span class="p">);</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">empty_lebs</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">main_lebs</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">idx_lebs</span>     <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">leb_cnt</span>      <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">);</span>

	<span class="cm">/* Calculate lprops statistics */</span>
	<span class="n">tmp64</span> <span class="o">=</span> <span class="n">main_bytes</span><span class="p">;</span>
	<span class="n">tmp64</span> <span class="o">-=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">ubifs_idx_node_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="n">tmp64</span> <span class="o">-=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">UBIFS_INO_NODE_SZ</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">total_free</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">tmp64</span><span class="p">);</span>

	<span class="n">tmp64</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">ubifs_idx_node_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="n">ino_waste</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">UBIFS_INO_NODE_SZ</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">)</span> <span class="o">-</span>
			  <span class="n">UBIFS_INO_NODE_SZ</span><span class="p">;</span>
	<span class="n">tmp64</span> <span class="o">+=</span> <span class="n">ino_waste</span><span class="p">;</span>
	<span class="n">tmp64</span> <span class="o">-=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">ubifs_idx_node_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">total_dirty</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">tmp64</span><span class="p">);</span>

	<span class="cm">/*  The indexing LEB does not contribute to dark space */</span>
	<span class="n">tmp64</span> <span class="o">=</span> <span class="p">((</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">main_lebs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dark_wm</span><span class="p">);</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">total_dark</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">tmp64</span><span class="p">);</span>

	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">total_used</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">UBIFS_INO_NODE_SZ</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_write_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">mst</span><span class="p">,</span> <span class="n">UBIFS_MST_NODE_SZ</span><span class="p">,</span> <span class="n">UBIFS_MST_LNUM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mst</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_write_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">mst</span><span class="p">,</span> <span class="n">UBIFS_MST_NODE_SZ</span><span class="p">,</span> <span class="n">UBIFS_MST_LNUM</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
			       <span class="mi">0</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mst</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;default master node created at LEB %d:0&quot;</span><span class="p">,</span> <span class="n">UBIFS_MST_LNUM</span><span class="p">);</span>

	<span class="cm">/* Create the root indexing node */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">ubifs_idx_node_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">ALIGN</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idx</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">key_fmt</span> <span class="o">=</span> <span class="n">UBIFS_SIMPLE_KEY_FMT</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">key_hash</span> <span class="o">=</span> <span class="n">key_r5_hash</span><span class="p">;</span>

	<span class="n">idx</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">node_type</span> <span class="o">=</span> <span class="n">UBIFS_IDX_NODE</span><span class="p">;</span>
	<span class="n">idx</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">ino_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">UBIFS_ROOT_INO</span><span class="p">);</span>
	<span class="n">br</span> <span class="o">=</span> <span class="n">ubifs_idx_branch</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">key_write_idx</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
	<span class="n">br</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">main_first</span> <span class="o">+</span> <span class="n">DEFAULT_DATA_LEB</span><span class="p">);</span>
	<span class="n">br</span><span class="o">-&gt;</span><span class="n">len</span>  <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UBIFS_INO_NODE_SZ</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_write_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">main_first</span> <span class="o">+</span> <span class="n">DEFAULT_IDX_LEB</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;default root indexing node created LEB %d:0&quot;</span><span class="p">,</span>
		<span class="n">main_first</span> <span class="o">+</span> <span class="n">DEFAULT_IDX_LEB</span><span class="p">);</span>

	<span class="cm">/* Create default root inode */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">UBIFS_INO_NODE_SZ</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="n">ino</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ino</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ino_key_init_flash</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">UBIFS_ROOT_INO</span><span class="p">);</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">node_type</span> <span class="o">=</span> <span class="n">UBIFS_INO_NODE</span><span class="p">;</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">creat_sqnum</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="o">++</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_sqnum</span><span class="p">);</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">nlink</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="n">tmp_le64</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">CURRENT_TIME_SEC</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">atime_sec</span>   <span class="o">=</span> <span class="n">tmp_le64</span><span class="p">;</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">ctime_sec</span>   <span class="o">=</span> <span class="n">tmp_le64</span><span class="p">;</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">mtime_sec</span>   <span class="o">=</span> <span class="n">tmp_le64</span><span class="p">;</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">atime_nsec</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">ctime_nsec</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">mtime_nsec</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">S_IFDIR</span> <span class="o">|</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span> <span class="o">|</span> <span class="n">S_IXUGO</span><span class="p">);</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">UBIFS_INO_NODE_SZ</span><span class="p">);</span>

	<span class="cm">/* Set compression enabled by default */</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UBIFS_COMPR_FL</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_write_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">UBIFS_INO_NODE_SZ</span><span class="p">,</span>
			       <span class="n">main_first</span> <span class="o">+</span> <span class="n">DEFAULT_DATA_LEB</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dbg_gen</span><span class="p">(</span><span class="s">&quot;root inode created at LEB %d:0&quot;</span><span class="p">,</span>
		<span class="n">main_first</span> <span class="o">+</span> <span class="n">DEFAULT_DATA_LEB</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The first node in the log has to be the commit start node. This is</span>
<span class="cm">	 * always the case during normal file-system operation. Write a fake</span>
<span class="cm">	 * commit start node to the log.</span>
<span class="cm">	 */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">UBIFS_CS_NODE_SZ</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="n">cs</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">cs</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">node_type</span> <span class="o">=</span> <span class="n">UBIFS_CS_NODE</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_write_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">UBIFS_CS_NODE_SZ</span><span class="p">,</span> <span class="n">UBIFS_LOG_LNUM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cs</span><span class="p">);</span>

	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;default file-system created&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * validate_sb - validate superblock node.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @sup: superblock node</span>
<span class="cm"> *</span>
<span class="cm"> * This function validates superblock node @sup. Since most of data was read</span>
<span class="cm"> * from the superblock and stored in @c, the function validates fields in @c</span>
<span class="cm"> * instead. Returns zero in case of success and %-EINVAL in case of validation</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">validate_sb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_sb_node</span> <span class="o">*</span><span class="n">sup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">max_bytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">min_leb_cnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">key_hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">key_fmt</span> <span class="o">!=</span> <span class="n">UBIFS_SIMPLE_KEY_FMT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">)</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;min. I/O unit mismatch: %d in superblock, %d real&quot;</span><span class="p">,</span>
			  <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">),</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;LEB size mismatch: %d in superblock, %d real&quot;</span><span class="p">,</span>
			  <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">),</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">log_lebs</span> <span class="o">&lt;</span> <span class="n">UBIFS_MIN_LOG_LEBS</span> <span class="o">||</span>
	    <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lebs</span> <span class="o">&lt;</span> <span class="n">UBIFS_MIN_LPT_LEBS</span> <span class="o">||</span>
	    <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_lebs</span> <span class="o">&lt;</span> <span class="n">UBIFS_MIN_ORPH_LEBS</span> <span class="o">||</span>
	    <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_lebs</span> <span class="o">&lt;</span> <span class="n">UBIFS_MIN_MAIN_LEBS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate minimum allowed amount of main area LEBs. This is very</span>
<span class="cm">	 * similar to %UBIFS_MIN_LEB_CNT, but we take into account real what we</span>
<span class="cm">	 * have just read from the superblock.</span>
<span class="cm">	 */</span>
	<span class="n">min_leb_cnt</span> <span class="o">=</span> <span class="n">UBIFS_SB_LEBS</span> <span class="o">+</span> <span class="n">UBIFS_MST_LEBS</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">log_lebs</span><span class="p">;</span>
	<span class="n">min_leb_cnt</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lebs</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_lebs</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span> <span class="o">+</span> <span class="mi">6</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">&lt;</span> <span class="n">min_leb_cnt</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad LEB count: %d in superblock, %d on UBI volume, &quot;</span>
			  <span class="s">&quot;%d minimum required&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">size</span><span class="p">,</span>
			  <span class="n">min_leb_cnt</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_leb_cnt</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;max. LEB count %d less than LEB count %d&quot;</span><span class="p">,</span>
			  <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_leb_cnt</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">main_lebs</span> <span class="o">&lt;</span> <span class="n">UBIFS_MIN_MAIN_LEBS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;too few main LEBs count %d, must be at least %d&quot;</span><span class="p">,</span>
			  <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_lebs</span><span class="p">,</span> <span class="n">UBIFS_MIN_MAIN_LEBS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">max_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">*</span> <span class="n">UBIFS_MIN_BUD_LEBS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bud_bytes</span> <span class="o">&lt;</span> <span class="n">max_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;too small journal (%lld bytes), must be at least &quot;</span>
			  <span class="s">&quot;%lld bytes&quot;</span><span class="p">,</span>  <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bud_bytes</span><span class="p">,</span> <span class="n">max_bytes</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">max_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_lebs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bud_bytes</span> <span class="o">&gt;</span> <span class="n">max_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;too large journal size (%lld bytes), only %lld bytes&quot;</span>
			  <span class="s">&quot;available in the main area&quot;</span><span class="p">,</span>
			  <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bud_bytes</span><span class="p">,</span> <span class="n">max_bytes</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span> <span class="o">&lt;</span> <span class="n">NONDATA_JHEADS_CNT</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">||</span>
	    <span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span> <span class="o">&gt;</span> <span class="n">NONDATA_JHEADS_CNT</span> <span class="o">+</span> <span class="n">UBIFS_MAX_JHEADS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span> <span class="o">&lt;</span> <span class="n">UBIFS_MIN_FANOUT</span> <span class="o">||</span>
	    <span class="n">ubifs_idx_node_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span> <span class="o">&gt;</span> <span class="n">DEFAULT_LSAVE_CNT</span> <span class="o">&amp;&amp;</span>
	    <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_leb_cnt</span> <span class="o">-</span> <span class="n">UBIFS_SB_LEBS</span> <span class="o">-</span> <span class="n">UBIFS_MST_LEBS</span> <span class="o">-</span>
	    <span class="n">c</span><span class="o">-&gt;</span><span class="n">log_lebs</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lebs</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_lebs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">UBIFS_SB_LEBS</span> <span class="o">+</span> <span class="n">UBIFS_MST_LEBS</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">log_lebs</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lebs</span> <span class="o">+</span>
	    <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_lebs</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_lebs</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">default_compr</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">default_compr</span> <span class="o">&gt;=</span> <span class="n">UBIFS_COMPR_TYPES_CNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rp_size</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">max_bytes</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">rp_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">time_gran</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1000000000</span> <span class="o">||</span>
	    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">time_gran</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">failed:</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad superblock, error %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sup</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_read_sb_node - read superblock node.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns a pointer to the superblock node or a negative error</span>
<span class="cm"> * code. Note, the user of this function is responsible of kfree()&#39;ing the</span>
<span class="cm"> * returned superblock buffer.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_sb_node</span> <span class="o">*</span><span class="nf">ubifs_read_sb_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_sb_node</span> <span class="o">*</span><span class="n">sup</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">sup</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">ALIGN</span><span class="p">(</span><span class="n">UBIFS_SB_NODE_SZ</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sup</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_read_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sup</span><span class="p">,</span> <span class="n">UBIFS_SB_NODE</span><span class="p">,</span> <span class="n">UBIFS_SB_NODE_SZ</span><span class="p">,</span>
			      <span class="n">UBIFS_SB_LNUM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sup</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sup</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_write_sb_node - write superblock node.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @sup: superblock node read with &#39;ubifs_read_sb_node()&#39;</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_write_sb_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_sb_node</span> <span class="o">*</span><span class="n">sup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">UBIFS_SB_NODE_SZ</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>

	<span class="n">ubifs_prepare_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sup</span><span class="p">,</span> <span class="n">UBIFS_SB_NODE_SZ</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ubifs_leb_change</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">UBIFS_SB_LNUM</span><span class="p">,</span> <span class="n">sup</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_read_superblock - read superblock.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function finds, reads and checks the superblock. If an empty UBI volume</span>
<span class="cm"> * is being mounted, this function creates default superblock. Returns zero in</span>
<span class="cm"> * case of success, and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_read_superblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">sup_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_sb_node</span> <span class="o">*</span><span class="n">sup</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">create_default_filesystem</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sup</span> <span class="o">=</span> <span class="n">ubifs_read_sb_node</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sup</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sup</span><span class="p">);</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">fmt_version</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">fmt_version</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_compat_version</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">ro_compat_version</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The software supports all previous versions but not future versions,</span>
<span class="cm">	 * due to the unavailability of time-travelling equipment.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">fmt_version</span> <span class="o">&gt;</span> <span class="n">UBIFS_FORMAT_VERSION</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_media</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span> <span class="o">||</span>
		    <span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_compat_version</span> <span class="o">&gt;</span> <span class="n">UBIFS_RO_COMPAT_VERSION</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;on-flash format version is w%d/r%d, but &quot;</span>
				  <span class="s">&quot;software only supports up to version &quot;</span>
				  <span class="s">&quot;w%d/r%d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fmt_version</span><span class="p">,</span>
				  <span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_compat_version</span><span class="p">,</span> <span class="n">UBIFS_FORMAT_VERSION</span><span class="p">,</span>
				  <span class="n">UBIFS_RO_COMPAT_VERSION</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_compat_version</span> <span class="o">&lt;=</span> <span class="n">UBIFS_RO_COMPAT_VERSION</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;only R/O mounting is possible&quot;</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * The FS is mounted R/O, and the media format is</span>
<span class="cm">		 * R/O-compatible with the UBIFS implementation, so we can</span>
<span class="cm">		 * mount.</span>
<span class="cm">		 */</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">rw_incompat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">fmt_version</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;on-flash format version %d is not supported&quot;</span><span class="p">,</span>
			  <span class="n">c</span><span class="o">-&gt;</span><span class="n">fmt_version</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">key_hash</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UBIFS_KEY_HASH_R5</span>:
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">key_hash</span> <span class="o">=</span> <span class="n">key_r5_hash</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">key_hash_type</span> <span class="o">=</span> <span class="n">UBIFS_KEY_HASH_R5</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">UBIFS_KEY_HASH_TEST</span>:
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">key_hash</span> <span class="o">=</span> <span class="n">key_test_hash</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">key_hash_type</span> <span class="o">=</span> <span class="n">UBIFS_KEY_HASH_TEST</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">key_fmt</span> <span class="o">=</span> <span class="n">sup</span><span class="o">-&gt;</span><span class="n">key_fmt</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">key_fmt</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UBIFS_SIMPLE_KEY_FMT</span>:
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">key_len</span> <span class="o">=</span> <span class="n">UBIFS_SK_LEN</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;unsupported key format&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span>       <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">max_leb_cnt</span>   <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">max_leb_cnt</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">max_bud_bytes</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">max_bud_bytes</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">log_lebs</span>      <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">log_lebs</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lebs</span>      <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">lpt_lebs</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_lebs</span>     <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">orph_lebs</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span>     <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span><span class="p">)</span> <span class="o">+</span> <span class="n">NONDATA_JHEADS_CNT</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span>        <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">fanout</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span>     <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">rp_size</span>       <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">rp_size</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">rp_uid</span>        <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">rp_uid</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">rp_gid</span>        <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">rp_gid</span><span class="p">);</span>
	<span class="n">sup_flags</span>        <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">override_compr</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">default_compr</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">default_compr</span><span class="p">);</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">vfs_sb</span><span class="o">-&gt;</span><span class="n">s_time_gran</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">time_gran</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">big_lpt</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">sup_flags</span> <span class="o">&amp;</span> <span class="n">UBIFS_FLG_BIGLPT</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">space_fixup</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">sup_flags</span> <span class="o">&amp;</span> <span class="n">UBIFS_FLG_SPACE_FIXUP</span><span class="p">);</span>

	<span class="cm">/* Automatically increase file system size to the maximum size */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">old_leb_cnt</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_leb_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_leb_cnt</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">)</span>
			<span class="n">dbg_mnt</span><span class="p">(</span><span class="s">&quot;Auto resizing (ro) from %d LEBs to %d LEBs&quot;</span><span class="p">,</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">old_leb_cnt</span><span class="p">,</span>	<span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">dbg_mnt</span><span class="p">(</span><span class="s">&quot;Auto resizing (sb) from %d LEBs to %d LEBs&quot;</span><span class="p">,</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">old_leb_cnt</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">);</span>
			<span class="n">sup</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_write_sb_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sup</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">old_leb_cnt</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">log_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">log_lebs</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">log_last</span> <span class="o">=</span> <span class="n">UBIFS_LOG_LNUM</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">log_lebs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span> <span class="o">=</span> <span class="n">UBIFS_LOG_LNUM</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">log_lebs</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_last</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lebs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_first</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_last</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_last</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_first</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_lebs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">main_lebs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">-</span> <span class="n">UBIFS_SB_LEBS</span> <span class="o">-</span> <span class="n">UBIFS_MST_LEBS</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">main_lebs</span> <span class="o">-=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">log_lebs</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lebs</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_lebs</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">main_first</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_lebs</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">validate_sb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sup</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sup</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fixup_leb - fixup/unmap an LEB containing free space.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lnum: the LEB number to fix up</span>
<span class="cm"> * @len: number of used bytes in LEB (starting at offset 0)</span>
<span class="cm"> *</span>
<span class="cm"> * This function reads the contents of the given LEB number @lnum, then fixes</span>
<span class="cm"> * it up, so that empty min. I/O units in the end of LEB are actually erased on</span>
<span class="cm"> * flash (rather than being just all-0xff real data). If the LEB is completely</span>
<span class="cm"> * empty, it is simply unmapped.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fixup_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">len</span> <span class="o">%</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_mnt</span><span class="p">(</span><span class="s">&quot;unmap empty LEB %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dbg_mnt</span><span class="p">(</span><span class="s">&quot;fixup LEB %d, data len %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ubifs_leb_change</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sbuf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fixup_free_space - find &amp; remap all LEBs containing free space.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function walks through all LEBs in the filesystem and fiexes up those</span>
<span class="cm"> * containing free/empty space.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fixup_free_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span><span class="p">;</span>

	<span class="n">ubifs_get_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="cm">/* Fixup LEBs in the master area */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">UBIFS_MST_LNUM</span><span class="p">;</span> <span class="n">lnum</span> <span class="o">&lt;</span> <span class="n">UBIFS_LOG_LNUM</span><span class="p">;</span> <span class="n">lnum</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">fixup_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_offs</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node_alsz</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Unmap unused log LEBs */</span>
	<span class="n">lnum</span> <span class="o">=</span> <span class="n">ubifs_next_log_lnum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lhead_lnum</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltail_lnum</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">fixup_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">lnum</span> <span class="o">=</span> <span class="n">ubifs_next_log_lnum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Fixup the current log head */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">fixup_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lhead_lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lhead_offs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Fixup LEBs in the LPT area */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span><span class="p">;</span> <span class="n">lnum</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_last</span><span class="p">;</span> <span class="n">lnum</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">free</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">lnum</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span><span class="p">].</span><span class="n">free</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">fixup_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">free</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Unmap LEBs in the orphans area */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_first</span><span class="p">;</span> <span class="n">lnum</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_last</span><span class="p">;</span> <span class="n">lnum</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">fixup_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fixup LEBs in the main area */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_first</span><span class="p">;</span> <span class="n">lnum</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">;</span> <span class="n">lnum</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lprops</span> <span class="o">=</span> <span class="n">ubifs_lpt_lookup</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lprops</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lprops</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">fixup_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">ubifs_release_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_fixup_free_space - find &amp; fix all LEBs with free space.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function fixes up LEBs containing free space on first mount, if the</span>
<span class="cm"> * appropriate flag was set when the FS was created. Each LEB with one or more</span>
<span class="cm"> * empty min. I/O unit (i.e. free-space-count &gt; 0) is re-written, to make sure</span>
<span class="cm"> * the free space is actually erased. E.g., this is necessary for some NAND</span>
<span class="cm"> * chips, since the free space may have been programmed like real &quot;0xff&quot; data</span>
<span class="cm"> * (generating a non-0xff ECC), causing future writes to the not-really-erased</span>
<span class="cm"> * NAND pages to behave badly. After the space is fixed up, the superblock flag</span>
<span class="cm"> * is cleared, so that this is skipped for all future mounts.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_fixup_free_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_sb_node</span> <span class="o">*</span><span class="n">sup</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_fixup</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">);</span>

	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;start fixing up free space&quot;</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">fixup_free_space</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">sup</span> <span class="o">=</span> <span class="n">ubifs_read_sb_node</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sup</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sup</span><span class="p">);</span>

	<span class="cm">/* Free-space fixup is no longer required */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">space_fixup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sup</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="n">UBIFS_FLG_SPACE_FIXUP</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_write_sb_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sup</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sup</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;free space fixup complete&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
