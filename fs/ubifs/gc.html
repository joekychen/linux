<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ubifs › gc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>gc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is part of UBIFS.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Nokia Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="cm"> * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Adrian Hunter</span>
<span class="cm"> *          Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file implements garbage collection. The procedure for garbage collection</span>
<span class="cm"> * is different depending on whether a LEB as an index LEB (contains index</span>
<span class="cm"> * nodes) or not. For non-index LEBs, garbage collection finds a LEB which</span>
<span class="cm"> * contains a lot of dirty space (obsolete nodes), and copies the non-obsolete</span>
<span class="cm"> * nodes to the journal, at which point the garbage-collected LEB is free to be</span>
<span class="cm"> * reused. For index LEBs, garbage collection marks the non-obsolete index nodes</span>
<span class="cm"> * dirty in the TNC, and after the next commit, the garbage-collected LEB is</span>
<span class="cm"> * to be reused. Garbage collection will cause the number of dirty index nodes</span>
<span class="cm"> * to grow, however sufficient space is reserved for the index to ensure the</span>
<span class="cm"> * commit will never run out of space.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes about dead watermark. At current UBIFS implementation we assume that</span>
<span class="cm"> * LEBs which have less than @c-&gt;dead_wm bytes of free + dirty space are full</span>
<span class="cm"> * and not worth garbage-collecting. The dead watermark is one min. I/O unit</span>
<span class="cm"> * size, or min. UBIFS node size, depending on what is greater. Indeed, UBIFS</span>
<span class="cm"> * Garbage Collector has to synchronize the GC head&#39;s write buffer before</span>
<span class="cm"> * returning, so this is about wasting one min. I/O unit. However, UBIFS GC can</span>
<span class="cm"> * actually reclaim even very small pieces of dirty space by garbage collecting</span>
<span class="cm"> * enough dirty LEBs, but we do not bother doing this at this implementation.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes about dark watermark. The results of GC work depends on how big are</span>
<span class="cm"> * the UBIFS nodes GC deals with. Large nodes make GC waste more space. Indeed,</span>
<span class="cm"> * if GC move data from LEB A to LEB B and nodes in LEB A are large, GC would</span>
<span class="cm"> * have to waste large pieces of free space at the end of LEB B, because nodes</span>
<span class="cm"> * from LEB A would not fit. And the worst situation is when all nodes are of</span>
<span class="cm"> * maximum size. So dark watermark is the amount of free + dirty space in LEB</span>
<span class="cm"> * which are guaranteed to be reclaimable. If LEB has less space, the GC might</span>
<span class="cm"> * be unable to reclaim it. So, LEBs with free + dirty greater than dark</span>
<span class="cm"> * watermark are &quot;good&quot; LEBs from GC&#39;s point of few. The other LEBs are not so</span>
<span class="cm"> * good, and GC takes extra care when moving them.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/list_sort.h&gt;</span>
<span class="cp">#include &quot;ubifs.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * GC may need to move more than one LEB to make progress. The below constants</span>
<span class="cm"> * define &quot;soft&quot; and &quot;hard&quot; limits on the number of LEBs the garbage collector</span>
<span class="cm"> * may move.</span>
<span class="cm"> */</span>
<span class="cp">#define SOFT_LEBS_LIMIT 4</span>
<span class="cp">#define HARD_LEBS_LIMIT 32</span>

<span class="cm">/**</span>
<span class="cm"> * switch_gc_head - switch the garbage collection journal head.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @buf: buffer to write</span>
<span class="cm"> * @len: length of the buffer to write</span>
<span class="cm"> * @lnum: LEB number written is returned here</span>
<span class="cm"> * @offs: offset written is returned here</span>
<span class="cm"> *</span>
<span class="cm"> * This function switch the GC head to the next LEB which is reserved in</span>
<span class="cm"> * @c-&gt;gc_lnum. Returns %0 in case of success, %-EAGAIN if commit is required,</span>
<span class="cm"> * and other negative error code in case of failures.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">switch_gc_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">gc_lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_lnum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">GCHD</span><span class="p">].</span><span class="n">wbuf</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">gc_lnum</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">dbg_gc</span><span class="p">(</span><span class="s">&quot;switch GC head from LEB %d:%d to LEB %d (waste %d bytes)&quot;</span><span class="p">,</span>
	       <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">+</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">,</span> <span class="n">gc_lnum</span><span class="p">,</span>
	       <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_wbuf_sync_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The GC write-buffer was synchronized, we may safely unmap</span>
<span class="cm">	 * &#39;c-&gt;gc_lnum&#39;.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">gc_lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_wbuf_sync_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_add_bud_to_log</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">GCHD</span><span class="p">,</span> <span class="n">gc_lnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_lnum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_wbuf_seek_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">,</span> <span class="n">gc_lnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * data_nodes_cmp - compare 2 data nodes.</span>
<span class="cm"> * @priv: UBIFS file-system description object</span>
<span class="cm"> * @a: first data node</span>
<span class="cm"> * @a: second data node</span>
<span class="cm"> *</span>
<span class="cm"> * This function compares data nodes @a and @b. Returns %1 if @a has greater</span>
<span class="cm"> * inode or block number, and %-1 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">data_nodes_cmp</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ino_t</span> <span class="n">inuma</span><span class="p">,</span> <span class="n">inumb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_scan_node</span> <span class="o">*</span><span class="n">sa</span><span class="p">,</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>

	<span class="n">cond_resched</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sa</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_scan_node</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">sb</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_scan_node</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">UBIFS_DATA_KEY</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">UBIFS_DATA_KEY</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_DATA_NODE</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_DATA_NODE</span><span class="p">);</span>

	<span class="n">inuma</span> <span class="o">=</span> <span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
	<span class="n">inumb</span> <span class="o">=</span> <span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inuma</span> <span class="o">==</span> <span class="n">inumb</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blka</span> <span class="o">=</span> <span class="n">key_block</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blkb</span> <span class="o">=</span> <span class="n">key_block</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">blka</span> <span class="o">&lt;=</span> <span class="n">blkb</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inuma</span> <span class="o">&lt;=</span> <span class="n">inumb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * nondata_nodes_cmp - compare 2 non-data nodes.</span>
<span class="cm"> * @priv: UBIFS file-system description object</span>
<span class="cm"> * @a: first node</span>
<span class="cm"> * @a: second node</span>
<span class="cm"> *</span>
<span class="cm"> * This function compares nodes @a and @b. It makes sure that inode nodes go</span>
<span class="cm"> * first and sorted by length in descending order. Directory entry nodes go</span>
<span class="cm"> * after inode nodes and are sorted in ascending hash valuer order.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nondata_nodes_cmp</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ino_t</span> <span class="n">inuma</span><span class="p">,</span> <span class="n">inumb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_scan_node</span> <span class="o">*</span><span class="n">sa</span><span class="p">,</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>

	<span class="n">cond_resched</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sa</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_scan_node</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">sb</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_scan_node</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="n">UBIFS_DATA_KEY</span> <span class="o">&amp;&amp;</span>
		     <span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="n">UBIFS_DATA_KEY</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">UBIFS_DATA_NODE</span> <span class="o">&amp;&amp;</span>
		     <span class="n">sb</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">UBIFS_DATA_NODE</span><span class="p">);</span>

	<span class="cm">/* Inodes go before directory entries */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_INO_NODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_INO_NODE</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_INO_NODE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">UBIFS_DENT_KEY</span> <span class="o">||</span>
		     <span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">UBIFS_XENT_KEY</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">UBIFS_DENT_KEY</span> <span class="o">||</span>
		     <span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">UBIFS_XENT_KEY</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_DENT_NODE</span> <span class="o">||</span>
		     <span class="n">sa</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_XENT_NODE</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_DENT_NODE</span> <span class="o">||</span>
		     <span class="n">sb</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_XENT_NODE</span><span class="p">);</span>

	<span class="n">inuma</span> <span class="o">=</span> <span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
	<span class="n">inumb</span> <span class="o">=</span> <span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inuma</span> <span class="o">==</span> <span class="n">inumb</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">hasha</span> <span class="o">=</span> <span class="n">key_hash</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
		<span class="kt">uint32_t</span> <span class="n">hashb</span> <span class="o">=</span> <span class="n">key_hash</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hasha</span> <span class="o">&lt;=</span> <span class="n">hashb</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inuma</span> <span class="o">&lt;=</span> <span class="n">inumb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sort_nodes - sort nodes for GC.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @sleb: describes nodes to sort and contains the result on exit</span>
<span class="cm"> * @nondata: contains non-data nodes on exit</span>
<span class="cm"> * @min: minimum node size is returned here</span>
<span class="cm"> *</span>
<span class="cm"> * This function sorts the list of inodes to garbage collect. First of all, it</span>
<span class="cm"> * kills obsolete nodes and separates data and non-data nodes to the</span>
<span class="cm"> * @sleb-&gt;nodes and @nondata lists correspondingly.</span>
<span class="cm"> *</span>
<span class="cm"> * Data nodes are then sorted in block number order - this is important for</span>
<span class="cm"> * bulk-read; data nodes with lower inode number go before data nodes with</span>
<span class="cm"> * higher inode number, and data nodes with lower block number go before data</span>
<span class="cm"> * nodes with higher block number;</span>
<span class="cm"> *</span>
<span class="cm"> * Non-data nodes are sorted as follows.</span>
<span class="cm"> *   o First go inode nodes - they are sorted in descending length order.</span>
<span class="cm"> *   o Then go directory entry nodes - they are sorted in hash order, which</span>
<span class="cm"> *     should supposedly optimize &#39;readdir()&#39;. Direntry nodes with lower parent</span>
<span class="cm"> *     inode number go before direntry nodes with higher parent inode number,</span>
<span class="cm"> *     and direntry nodes with lower name hash values go before direntry nodes</span>
<span class="cm"> *     with higher name hash values.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero in case of success and a negative error code in</span>
<span class="cm"> * case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sort_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">sleb</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">nondata</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">min</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_scan_node</span> <span class="o">*</span><span class="n">snod</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="o">*</span><span class="n">min</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>

	<span class="cm">/* Separate data nodes and non-data nodes */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">snod</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_INO_NODE</span>  <span class="o">||</span>
			     <span class="n">snod</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_DATA_NODE</span> <span class="o">||</span>
			     <span class="n">snod</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_DENT_NODE</span> <span class="o">||</span>
			     <span class="n">snod</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_XENT_NODE</span> <span class="o">||</span>
			     <span class="n">snod</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_TRUN_NODE</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">UBIFS_INO_NODE</span>  <span class="o">&amp;&amp;</span>
		    <span class="n">snod</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">UBIFS_DATA_NODE</span> <span class="o">&amp;&amp;</span>
		    <span class="n">snod</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">UBIFS_DENT_NODE</span> <span class="o">&amp;&amp;</span>
		    <span class="n">snod</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">UBIFS_XENT_NODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Probably truncation node, zap it */</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">snod</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">UBIFS_DATA_KEY</span> <span class="o">||</span>
			     <span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">UBIFS_INO_KEY</span>  <span class="o">||</span>
			     <span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">UBIFS_DENT_KEY</span> <span class="o">||</span>
			     <span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">UBIFS_XENT_KEY</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_has_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span>
					 <span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* The node is obsolete, remove it from the list */</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">snod</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">min</span><span class="p">)</span>
			<span class="o">*</span><span class="n">min</span> <span class="o">=</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="n">UBIFS_DATA_KEY</span><span class="p">)</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">nondata</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Sort data and non-data nodes */</span>
	<span class="n">list_sort</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data_nodes_cmp</span><span class="p">);</span>
	<span class="n">list_sort</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">nondata</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nondata_nodes_cmp</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_data_nodes_order</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_nondata_nodes_order</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">nondata</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * move_node - move a node.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @sleb: describes the LEB to move nodes from</span>
<span class="cm"> * @snod: the mode to move</span>
<span class="cm"> * @wbuf: write-buffer to move node to</span>
<span class="cm"> *</span>
<span class="cm"> * This function moves node @snod to @wbuf, changes TNC correspondingly, and</span>
<span class="cm"> * destroys @snod. Returns zero in case of success and a negative error code in</span>
<span class="cm"> * case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">move_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">sleb</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">ubifs_scan_node</span> <span class="o">*</span><span class="n">snod</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">new_lnum</span> <span class="o">=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">new_offs</span> <span class="o">=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">+</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">;</span>

	<span class="n">cond_resched</span><span class="p">();</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_wbuf_write_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_replace</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span>
				<span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">new_lnum</span><span class="p">,</span> <span class="n">new_offs</span><span class="p">,</span>
				<span class="n">snod</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">snod</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * move_nodes - move nodes.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @sleb: describes the LEB to move nodes from</span>
<span class="cm"> *</span>
<span class="cm"> * This function moves valid nodes from data LEB described by @sleb to the GC</span>
<span class="cm"> * journal head. This function returns zero in case of success, %-EAGAIN if</span>
<span class="cm"> * commit is required, and other negative error codes in case of other</span>
<span class="cm"> * failures.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">move_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">sleb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">min</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">nondata</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">GCHD</span><span class="p">].</span><span class="n">wbuf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The GC journal head is not set, because it is the first GC</span>
<span class="cm">		 * invocation since mount.</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">switch_gc_head</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sort_nodes</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sleb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nondata</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">min</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Write nodes to their new location. Use the first-fit strategy */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">avail</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ubifs_scan_node</span> <span class="o">*</span><span class="n">snod</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

		<span class="cm">/* Move data nodes */</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">snod</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">avail</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">;</span>
			<span class="k">if</span>  <span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">avail</span><span class="p">)</span>
				<span class="cm">/*</span>
<span class="cm">				 * Do not skip data nodes in order to optimize</span>
<span class="cm">				 * bulk-read.</span>
<span class="cm">				 */</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">move_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sleb</span><span class="p">,</span> <span class="n">snod</span><span class="p">,</span> <span class="n">wbuf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Move non-data nodes */</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">snod</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nondata</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">avail</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">avail</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span>  <span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">avail</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Keep going only if this is an inode with</span>
<span class="cm">				 * some data. Otherwise stop and switch the GC</span>
<span class="cm">				 * head. IOW, we assume that data-less inode</span>
<span class="cm">				 * nodes and direntry nodes are roughly of the</span>
<span class="cm">				 * same size.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">UBIFS_DENT_KEY</span> <span class="o">||</span>
				    <span class="n">snod</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="n">UBIFS_INO_NODE_SZ</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">move_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sleb</span><span class="p">,</span> <span class="n">snod</span><span class="p">,</span> <span class="n">wbuf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nondata</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Waste the rest of the space in the LEB and switch to the</span>
<span class="cm">		 * next LEB.</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">switch_gc_head</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">list_splice_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nondata</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * gc_sync_wbufs - sync write-buffers for GC.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * We must guarantee that obsoleting nodes are on flash. Unfortunately they may</span>
<span class="cm"> * be in a write-buffer instead. That is, a node could be written to a</span>
<span class="cm"> * write-buffer, obsoleting another node in a LEB that is GC&#39;d. If that LEB is</span>
<span class="cm"> * erased before the write-buffer is sync&#39;d and then there is an unclean</span>
<span class="cm"> * unmount, then an existing node is lost. To avoid this, we sync all</span>
<span class="cm"> * write-buffers.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success or a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gc_sync_wbufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">GCHD</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_wbuf_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wbuf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_garbage_collect_leb - garbage-collect a logical eraseblock.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lp: describes the LEB to garbage collect</span>
<span class="cm"> *</span>
<span class="cm"> * This function garbage-collects an LEB and returns one of the @LEB_FREED,</span>
<span class="cm"> * @LEB_RETAINED, etc positive codes in case of success, %-EAGAIN if commit is</span>
<span class="cm"> * required, and other negative error codes in case of failures.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_garbage_collect_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">sleb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_scan_node</span> <span class="o">*</span><span class="n">snod</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">GCHD</span><span class="p">].</span><span class="n">wbuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lnum</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_lnum</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">+</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
		     <span class="n">c</span><span class="o">-&gt;</span><span class="n">need_recovery</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_lnum</span> <span class="o">!=</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">!=</span> <span class="n">lnum</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Special case - a free LEB  */</span>
		<span class="n">dbg_gc</span><span class="p">(</span><span class="s">&quot;LEB %d is free, return it&quot;</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Write buffers must be sync&#39;d before unmapping</span>
<span class="cm">			 * freeable LEBs, because one of them may contain data</span>
<span class="cm">			 * which obsoletes something in &#39;lp-&gt;pnum&#39;.</span>
<span class="cm">			 */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">gc_sync_wbufs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_change_one_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">,</span>
						  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_lnum</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">LEB_RETAINED</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="n">LEB_FREED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We scan the entire LEB even though we only really need to scan up to</span>
<span class="cm">	 * (c-&gt;leb_size - lp-&gt;free).</span>
<span class="cm">	 */</span>
	<span class="n">sleb</span> <span class="o">=</span> <span class="n">ubifs_scan</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sleb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">));</span>
	<span class="n">snod</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_scan_node</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_IDX_NODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_gced_idx_leb</span> <span class="o">*</span><span class="n">idx_gc</span><span class="p">;</span>

		<span class="n">dbg_gc</span><span class="p">(</span><span class="s">&quot;indexing LEB %d (free %d, dirty %d)&quot;</span><span class="p">,</span>
		       <span class="n">lnum</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">snod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ubifs_idx_node</span> <span class="o">*</span><span class="n">idx</span> <span class="o">=</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">idx</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>

			<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_IDX_NODE</span><span class="p">);</span>
			<span class="n">key_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ubifs_idx_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_dirty_idx_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span>
						   <span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">idx_gc</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_gced_idx_leb</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idx_gc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">idx_gc</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
		<span class="n">idx_gc</span><span class="o">-&gt;</span><span class="n">unmap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idx_gc</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_gc</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t release the LEB until after the next commit, because</span>
<span class="cm">		 * it may contain data which is needed for recovery. So</span>
<span class="cm">		 * although we freed this LEB, it will become usable only after</span>
<span class="cm">		 * the commit.</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_change_one_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					  <span class="n">LPROPS_INDEX</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">LEB_FREED_IDX</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dbg_gc</span><span class="p">(</span><span class="s">&quot;data LEB %d (free %d, dirty %d)&quot;</span><span class="p">,</span>
		       <span class="n">lnum</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">move_nodes</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sleb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_inc_seq</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">gc_sync_wbufs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_inc_seq</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_change_one_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_inc_seq</span><span class="p">;</span>

		<span class="cm">/* Allow for races with TNC */</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">gced_lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
		<span class="n">smp_wmb</span><span class="p">();</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_seq</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">smp_wmb</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_lnum</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">LEB_RETAINED</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_wbuf_sync_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">LEB_FREED</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">ubifs_scan_destroy</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_inc_seq:</span>
	<span class="cm">/* We may have moved at least some nodes so allow for races with TNC */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">gced_lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_seq</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_garbage_collect - UBIFS garbage collector.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @anyway: do GC even if there are free LEBs</span>
<span class="cm"> *</span>
<span class="cm"> * This function does out-of-place garbage collection. The return codes are:</span>
<span class="cm"> *   o positive LEB number if the LEB has been freed and may be used;</span>
<span class="cm"> *   o %-EAGAIN if the caller has to run commit;</span>
<span class="cm"> *   o %-ENOSPC if GC failed to make any progress;</span>
<span class="cm"> *   o other negative error codes in case of other errors.</span>
<span class="cm"> *</span>
<span class="cm"> * Garbage collector writes data to the journal when GC&#39;ing data LEBs, and just</span>
<span class="cm"> * marking indexing nodes dirty when GC&#39;ing indexing LEBs. Thus, at some point</span>
<span class="cm"> * commit may be required. But commit cannot be run from inside GC, because the</span>
<span class="cm"> * caller might be holding the commit lock, so %-EAGAIN is returned instead;</span>
<span class="cm"> * And this error code means that the caller has to run commit, and re-run GC</span>
<span class="cm"> * if there is still no free space.</span>
<span class="cm"> *</span>
<span class="cm"> * There are many reasons why this function may return %-EAGAIN:</span>
<span class="cm"> * o the log is full and there is no space to write an LEB reference for</span>
<span class="cm"> *   @c-&gt;gc_lnum;</span>
<span class="cm"> * o the journal is too large and exceeds size limitations;</span>
<span class="cm"> * o GC moved indexing LEBs, but they can be used only after the commit;</span>
<span class="cm"> * o the shrinker fails to find clean znodes to free and requests the commit;</span>
<span class="cm"> * o etc.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, if the file-system is close to be full, this function may return</span>
<span class="cm"> * %-EAGAIN infinitely, so the caller has to limit amount of re-invocations of</span>
<span class="cm"> * the function. E.g., this happens if the limits on the journal size are too</span>
<span class="cm"> * tough and GC writes too much to the journal before an LEB is freed. This</span>
<span class="cm"> * might also mean that the journal is too large, and the TNC becomes to big,</span>
<span class="cm"> * so that the shrinker is constantly called, finds not clean znodes to free,</span>
<span class="cm"> * and requests commit. Well, this may also happen if the journal is all right,</span>
<span class="cm"> * but another kernel process consumes too much memory. Anyway, infinite</span>
<span class="cm"> * %-EAGAIN may happen, but in some extreme/misconfiguration cases.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_garbage_collect</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">anyway</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">min_space</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dead_wm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="n">lp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">GCHD</span><span class="p">].</span><span class="n">wbuf</span><span class="p">;</span>

	<span class="n">ubifs_assert_cmt_locked</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_media</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubifs_gc_should_commit</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We expect the write-buffer to be empty on entry */</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">space_before</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">space_after</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="cm">/* Give the commit an opportunity to run */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ubifs_gc_should_commit</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">SOFT_LEBS_LIMIT</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_gc</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We&#39;ve done enough iterations. Indexing LEBs were</span>
<span class="cm">			 * moved and will be available after the commit.</span>
<span class="cm">			 */</span>
			<span class="n">dbg_gc</span><span class="p">(</span><span class="s">&quot;soft limit, some index LEBs GC&#39;ed, -EAGAIN&quot;</span><span class="p">);</span>
			<span class="n">ubifs_commit_required</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">HARD_LEBS_LIMIT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We&#39;ve moved too many LEBs and have not made</span>
<span class="cm">			 * progress, give up.</span>
<span class="cm">			 */</span>
			<span class="n">dbg_gc</span><span class="p">(</span><span class="s">&quot;hard limit, -ENOSPC&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Empty and freeable LEBs can turn up while we waited for</span>
<span class="cm">		 * the wbuf lock, or while we have been running GC. In that</span>
<span class="cm">		 * case, we should just return one of those instead of</span>
<span class="cm">		 * continuing to GC dirty LEBs. Hence we request</span>
<span class="cm">		 * &#39;ubifs_find_dirty_leb()&#39; to return an empty LEB if it can.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ubifs_find_dirty_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lp</span><span class="p">,</span> <span class="n">min_space</span><span class="p">,</span> <span class="n">anyway</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
				<span class="n">dbg_gc</span><span class="p">(</span><span class="s">&quot;no more dirty LEBs&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dbg_gc</span><span class="p">(</span><span class="s">&quot;found LEB %d: free %d, dirty %d, sum %d &quot;</span>
		       <span class="s">&quot;(min. space %d)&quot;</span><span class="p">,</span> <span class="n">lp</span><span class="p">.</span><span class="n">lnum</span><span class="p">,</span> <span class="n">lp</span><span class="p">.</span><span class="n">free</span><span class="p">,</span> <span class="n">lp</span><span class="p">.</span><span class="n">dirty</span><span class="p">,</span>
		       <span class="n">lp</span><span class="p">.</span><span class="n">free</span> <span class="o">+</span> <span class="n">lp</span><span class="p">.</span><span class="n">dirty</span><span class="p">,</span> <span class="n">min_space</span><span class="p">);</span>

		<span class="n">space_before</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">space_before</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">ubifs_garbage_collect_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * This is not error, so we have to return the</span>
<span class="cm">				 * LEB to lprops. But if &#39;ubifs_return_leb()&#39;</span>
<span class="cm">				 * fails, its failure code is propagated to the</span>
<span class="cm">				 * caller instead of the original &#39;-EAGAIN&#39;.</span>
<span class="cm">				 */</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_return_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lp</span><span class="p">.</span><span class="n">lnum</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">LEB_FREED</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* An LEB has been freed and is ready for use */</span>
			<span class="n">dbg_gc</span><span class="p">(</span><span class="s">&quot;LEB %d freed, return&quot;</span><span class="p">,</span> <span class="n">lp</span><span class="p">.</span><span class="n">lnum</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">lp</span><span class="p">.</span><span class="n">lnum</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">LEB_FREED_IDX</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This was an indexing LEB and it cannot be</span>
<span class="cm">			 * immediately used. And instead of requesting the</span>
<span class="cm">			 * commit straight away, we try to garbage collect some</span>
<span class="cm">			 * more.</span>
<span class="cm">			 */</span>
			<span class="n">dbg_gc</span><span class="p">(</span><span class="s">&quot;indexing LEB %d freed, continue&quot;</span><span class="p">,</span> <span class="n">lp</span><span class="p">.</span><span class="n">lnum</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">LEB_RETAINED</span><span class="p">);</span>
		<span class="n">space_after</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">;</span>
		<span class="n">dbg_gc</span><span class="p">(</span><span class="s">&quot;LEB %d retained, freed %d bytes&quot;</span><span class="p">,</span> <span class="n">lp</span><span class="p">.</span><span class="n">lnum</span><span class="p">,</span>
		       <span class="n">space_after</span> <span class="o">-</span> <span class="n">space_before</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">space_after</span> <span class="o">&gt;</span> <span class="n">space_before</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* GC makes progress, keep working */</span>
			<span class="n">min_space</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">min_space</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dead_wm</span><span class="p">)</span>
				<span class="n">min_space</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dead_wm</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dbg_gc</span><span class="p">(</span><span class="s">&quot;did not make progress&quot;</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * GC moved an LEB bud have not done any progress. This means</span>
<span class="cm">		 * that the previous GC head LEB contained too few free space</span>
<span class="cm">		 * and the LEB which was GC&#39;ed contained only large nodes which</span>
<span class="cm">		 * did not fit that space.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We can do 2 things:</span>
<span class="cm">		 * 1. pick another LEB in a hope it&#39;ll contain a small node</span>
<span class="cm">		 *    which will fit the space we have at the end of current GC</span>
<span class="cm">		 *    head LEB, but there is no guarantee, so we try this out</span>
<span class="cm">		 *    unless we have already been working for too long;</span>
<span class="cm">		 * 2. request an LEB with more dirty space, which will force</span>
<span class="cm">		 *    &#39;ubifs_find_dirty_leb()&#39; to start scanning the lprops</span>
<span class="cm">		 *    table, instead of just picking one from the heap</span>
<span class="cm">		 *    (previously it already picked the dirtiest LEB).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">SOFT_LEBS_LIMIT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dbg_gc</span><span class="p">(</span><span class="s">&quot;try again&quot;</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">min_space</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">min_space</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dark_wm</span><span class="p">)</span>
			<span class="n">min_space</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dark_wm</span><span class="p">;</span>
		<span class="n">dbg_gc</span><span class="p">(</span><span class="s">&quot;set min. space to %d&quot;</span><span class="p">,</span> <span class="n">min_space</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_gc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dbg_gc</span><span class="p">(</span><span class="s">&quot;no space, some index LEBs GC&#39;ed, -EAGAIN&quot;</span><span class="p">);</span>
		<span class="n">ubifs_commit_required</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_wbuf_sync_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>
	<span class="n">ubifs_wbuf_sync_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">);</span>
	<span class="n">ubifs_ro_mode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="n">ubifs_return_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lp</span><span class="p">.</span><span class="n">lnum</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_gc_start_commit - garbage collection at start of commit.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * If a LEB has only dirty and free space, then we may safely unmap it and make</span>
<span class="cm"> * it free.  Note, we cannot do this with indexing LEBs because dirty space may</span>
<span class="cm"> * correspond index nodes that are required for recovery.  In that case, the</span>
<span class="cm"> * LEB cannot be unmapped until after the next commit.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 upon success and a negative error code upon failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_gc_start_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_gced_idx_leb</span> <span class="o">*</span><span class="n">idx_gc</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">ubifs_get_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unmap (non-index) freeable LEBs. Note that recovery requires that all</span>
<span class="cm">	 * wbufs are sync&#39;d before this, which is done in &#39;do_commit()&#39;.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lp</span> <span class="o">=</span> <span class="n">ubifs_fast_find_freeable</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">));</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">));</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">lp</span> <span class="o">=</span> <span class="n">ubifs_change_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lp</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">));</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* Mark GC&#39;d index LEBs OK to unmap after this commit finishes */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">idx_gc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_gc</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">idx_gc</span><span class="o">-&gt;</span><span class="n">unmap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Record index freeable LEBs for unmapping after commit */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lp</span> <span class="o">=</span> <span class="n">ubifs_fast_find_frdi_idx</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">idx_gc</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_gced_idx_leb</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idx_gc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">));</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">);</span>
		<span class="cm">/* Don&#39;t release the LEB until after the next commit */</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|</span> <span class="n">LPROPS_TAKEN</span><span class="p">)</span> <span class="o">^</span> <span class="n">LPROPS_INDEX</span><span class="p">;</span>
		<span class="n">lp</span> <span class="o">=</span> <span class="n">ubifs_change_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lp</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">idx_gc</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">);</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">));</span>
		<span class="n">idx_gc</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>
		<span class="n">idx_gc</span><span class="o">-&gt;</span><span class="n">unmap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idx_gc</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_gc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">ubifs_release_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_gc_end_commit - garbage collection at end of commit.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function completes out-of-place garbage collection of index LEBs.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_gc_end_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_gced_idx_leb</span> <span class="o">*</span><span class="n">idx_gc</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">wbuf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">GCHD</span><span class="p">].</span><span class="n">wbuf</span><span class="p">;</span>
	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">idx_gc</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_gc</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx_gc</span><span class="o">-&gt;</span><span class="n">unmap</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dbg_gc</span><span class="p">(</span><span class="s">&quot;LEB %d&quot;</span><span class="p">,</span> <span class="n">idx_gc</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">idx_gc</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_change_one_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">idx_gc</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">LPROPS_NC</span><span class="p">,</span>
					  <span class="n">LPROPS_NC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LPROPS_TAKEN</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idx_gc</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">idx_gc</span><span class="p">);</span>
		<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_destroy_idx_gc - destroy idx_gc list.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function destroys the @c-&gt;idx_gc list. It is called when unmounting</span>
<span class="cm"> * so locks are not needed. Returns zero in case of success and a negative</span>
<span class="cm"> * error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubifs_destroy_idx_gc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_gc</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_gced_idx_leb</span> <span class="o">*</span><span class="n">idx_gc</span><span class="p">;</span>

		<span class="n">idx_gc</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_gc</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_gced_idx_leb</span><span class="p">,</span>
				    <span class="n">list</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_gc_cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idx_gc</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">idx_gc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_get_idx_gc_leb - get a LEB from GC&#39;d index LEB list.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * Called during start commit so locks are not needed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_get_idx_gc_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_gced_idx_leb</span> <span class="o">*</span><span class="n">idx_gc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_gc</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="n">idx_gc</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_gc</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_gced_idx_leb</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">lnum</span> <span class="o">=</span> <span class="n">idx_gc</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">;</span>
	<span class="cm">/* c-&gt;idx_gc_cnt is updated by the caller when lprops are updated */</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idx_gc</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">idx_gc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">lnum</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
