<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ubifs › io.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>io.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is part of UBIFS.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Nokia Corporation.</span>
<span class="cm"> * Copyright (C) 2006, 2007 University of Szeged, Hungary</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="cm"> * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> *          Adrian Hunter</span>
<span class="cm"> *          Zoltan Sogor</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file implements UBIFS I/O subsystem which provides various I/O-related</span>
<span class="cm"> * helper functions (reading/writing/checking/validating nodes) and implements</span>
<span class="cm"> * write-buffering support. Write buffers help to save space which otherwise</span>
<span class="cm"> * would have been wasted for padding to the nearest minimal I/O unit boundary.</span>
<span class="cm"> * Instead, data first goes to the write-buffer and is flushed when the</span>
<span class="cm"> * buffer is full or when it is not used for some time (by timer). This is</span>
<span class="cm"> * similar to the mechanism is used by JFFS2.</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS distinguishes between minimum write size (@c-&gt;min_io_size) and maximum</span>
<span class="cm"> * write size (@c-&gt;max_write_size). The latter is the maximum amount of bytes</span>
<span class="cm"> * the underlying flash is able to program at a time, and writing in</span>
<span class="cm"> * @c-&gt;max_write_size units should presumably be faster. Obviously,</span>
<span class="cm"> * @c-&gt;min_io_size &lt;= @c-&gt;max_write_size. Write-buffers are of</span>
<span class="cm"> * @c-&gt;max_write_size bytes in size for maximum performance. However, when a</span>
<span class="cm"> * write-buffer is flushed, only the portion of it (aligned to @c-&gt;min_io_size</span>
<span class="cm"> * boundary) which contains data is written, not the whole write-buffer,</span>
<span class="cm"> * because this is more space-efficient.</span>
<span class="cm"> *</span>
<span class="cm"> * This optimization adds few complications to the code. Indeed, on the one</span>
<span class="cm"> * hand, we want to write in optimal @c-&gt;max_write_size bytes chunks, which</span>
<span class="cm"> * also means aligning writes at the @c-&gt;max_write_size bytes offsets. On the</span>
<span class="cm"> * other hand, we do not want to waste space when synchronizing the write</span>
<span class="cm"> * buffer, so during synchronization we writes in smaller chunks. And this makes</span>
<span class="cm"> * the next write offset to be not aligned to @c-&gt;max_write_size bytes. So the</span>
<span class="cm"> * have to make sure that the write-buffer offset (@wbuf-&gt;offs) becomes aligned</span>
<span class="cm"> * to @c-&gt;max_write_size bytes again. We do this by temporarily shrinking</span>
<span class="cm"> * write-buffer size (@wbuf-&gt;size).</span>
<span class="cm"> *</span>
<span class="cm"> * Write-buffers are defined by &#39;struct ubifs_wbuf&#39; objects and protected by</span>
<span class="cm"> * mutexes defined inside these objects. Since sometimes upper-level code</span>
<span class="cm"> * has to lock the write-buffer (e.g. journal space reservation code), many</span>
<span class="cm"> * functions related to write-buffers have &quot;nolock&quot; suffix which means that the</span>
<span class="cm"> * caller has to lock the write-buffer before calling this function.</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS stores nodes at 64 bit-aligned addresses. If the node length is not</span>
<span class="cm"> * aligned, UBIFS starts the next node from the aligned address, and the padded</span>
<span class="cm"> * bytes may contain any rubbish. In other words, UBIFS does not put padding</span>
<span class="cm"> * bytes in those small gaps. Common headers of nodes store real node lengths,</span>
<span class="cm"> * not aligned lengths. Indexing nodes also store real lengths in branches.</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS uses padding when it pads to the next min. I/O unit. In this case it</span>
<span class="cm"> * uses padding nodes or padding bytes, if the padding node does not fit.</span>
<span class="cm"> *</span>
<span class="cm"> * All UBIFS nodes are protected by CRC checksums and UBIFS checks CRC when</span>
<span class="cm"> * they are read from the flash media.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &quot;ubifs.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_ro_mode - switch UBIFS to read read-only mode.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @err: error code which is the reason of switching to R/O mode</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubifs_ro_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">no_chk_data_crc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">vfs_sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_RDONLY</span><span class="p">;</span>
		<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;switched to read-only mode, error %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Below are simple wrappers over UBI I/O functions which include some</span>
<span class="cm"> * additional checks and UBIFS debugging stuff. See corresponding UBI function</span>
<span class="cm"> * for more information.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">ubifs_leb_read</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">even_ebadmsg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_read</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ubi</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * In case of %-EBADMSG print the error message only if the</span>
<span class="cm">	 * @even_ebadmsg is true.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EBADMSG</span> <span class="o">||</span> <span class="n">even_ebadmsg</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;reading %d bytes from LEB %d:%d failed, error %d&quot;</span><span class="p">,</span>
			  <span class="n">len</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ubifs_leb_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_media</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_error</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_tst_rcvry</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_leb_write</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ubi</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_leb_write</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;writing %d bytes to LEB %d:%d failed, error %d&quot;</span><span class="p">,</span>
			  <span class="n">len</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">ubifs_ro_mode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ubifs_leb_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_media</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_error</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_tst_rcvry</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_leb_change</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ubi</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_leb_change</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;changing %d bytes in LEB %d failed, error %d&quot;</span><span class="p">,</span>
			  <span class="n">len</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">ubifs_ro_mode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ubifs_leb_unmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_media</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_error</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_tst_rcvry</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ubi</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;unmap LEB %d failed, error %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">ubifs_ro_mode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ubifs_leb_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_media</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_error</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_tst_rcvry</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_leb_map</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ubi</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_leb_map</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;mapping LEB %d failed, error %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">ubifs_ro_mode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ubifs_is_mapped</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_is_mapped</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ubi</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;ubi_is_mapped failed for LEB %d, error %d&quot;</span><span class="p">,</span>
			  <span class="n">lnum</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_check_node - check node.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @buf: node to check</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> * @offs: offset within the logical eraseblock</span>
<span class="cm"> * @quiet: print no messages</span>
<span class="cm"> * @must_chk_crc: indicates whether to always check the CRC</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks node magic number and CRC checksum. This function also</span>
<span class="cm"> * validates node length to prevent UBIFS from becoming crazy when an attacker</span>
<span class="cm"> * feeds it a file-system image with incorrect nodes. For example, too large</span>
<span class="cm"> * node length in the common header could cause UBIFS to read memory outside of</span>
<span class="cm"> * allocated buffer when checking the CRC checksum.</span>
<span class="cm"> *</span>
<span class="cm"> * This function may skip data nodes CRC checking if @c-&gt;no_chk_data_crc is</span>
<span class="cm"> * true, which is controlled by corresponding UBIFS mount option. However, if</span>
<span class="cm"> * @must_chk_crc is true, then @c-&gt;no_chk_data_crc is ignored and CRC is</span>
<span class="cm"> * checked. Similarly, if @c-&gt;mounting or @c-&gt;remounting_rw is true (we are</span>
<span class="cm"> * mounting or re-mounting to R/W mode), @c-&gt;no_chk_data_crc is ignored and CRC</span>
<span class="cm"> * is checked. This is because during mounting or re-mounting from R/O mode to</span>
<span class="cm"> * R/W mode we may read journal nodes (when replying the journal or doing the</span>
<span class="cm"> * recovery) and the journal nodes may potentially be corrupted, so checking is</span>
<span class="cm"> * required.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero in case of success and %-EUCLEAN in case of bad</span>
<span class="cm"> * CRC or magic.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_check_node</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">quiet</span><span class="p">,</span> <span class="kt">int</span> <span class="n">must_chk_crc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">node_len</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">crc</span><span class="p">,</span> <span class="n">node_crc</span><span class="p">,</span> <span class="n">magic</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="o">*</span><span class="n">ch</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">lnum</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">&amp;&amp;</span> <span class="n">offs</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">offs</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">offs</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>

	<span class="n">magic</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">UBIFS_NODE_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">quiet</span><span class="p">)</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad magic %#08x, expected %#08x&quot;</span><span class="p">,</span>
				  <span class="n">magic</span><span class="p">,</span> <span class="n">UBIFS_NODE_MAGIC</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EUCLEAN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">type</span> <span class="o">=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">node_type</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">type</span> <span class="o">&gt;=</span> <span class="n">UBIFS_NODE_TYPES_CNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">quiet</span><span class="p">)</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad node type %d&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">node_len</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node_len</span> <span class="o">+</span> <span class="n">offs</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">max_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node_len</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">len</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node_len</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">min_len</span> <span class="o">||</span>
		   <span class="n">node_len</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ranges</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">max_len</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">must_chk_crc</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_DATA_NODE</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mounting</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">remounting_rw</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">no_chk_data_crc</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="n">UBIFS_CRC32_INIT</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="n">node_len</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">node_crc</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">crc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">crc</span> <span class="o">!=</span> <span class="n">node_crc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">quiet</span><span class="p">)</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad CRC: calculated %#08x, read %#08x&quot;</span><span class="p">,</span>
				  <span class="n">crc</span><span class="p">,</span> <span class="n">node_crc</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EUCLEAN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_len:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">quiet</span><span class="p">)</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad node length %d&quot;</span><span class="p">,</span> <span class="n">node_len</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">quiet</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad node at LEB %d:%d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
		<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_pad - pad flash space.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @buf: buffer to put padding to</span>
<span class="cm"> * @pad: how many bytes to pad</span>
<span class="cm"> *</span>
<span class="cm"> * The flash media obliges us to write only in chunks of %c-&gt;min_io_size and</span>
<span class="cm"> * when we have to write less data we add padding node to the write-buffer and</span>
<span class="cm"> * pad it to the next minimal I/O unit&#39;s boundary. Padding nodes help when the</span>
<span class="cm"> * media is being scanned. If the amount of wasted space is not enough to fit a</span>
<span class="cm"> * padding node which takes %UBIFS_PAD_NODE_SZ bytes, we write padding bytes</span>
<span class="cm"> * pattern (%UBIFS_PADDING_BYTE).</span>
<span class="cm"> *</span>
<span class="cm"> * Padding nodes are also used to fill gaps when the &quot;commit-in-gaps&quot; method is</span>
<span class="cm"> * used.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubifs_pad</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pad</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">crc</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">pad</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">pad</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pad</span> <span class="o">&gt;=</span> <span class="n">UBIFS_PAD_NODE_SZ</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="o">*</span><span class="n">ch</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ubifs_pad_node</span> <span class="o">*</span><span class="n">pad_node</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UBIFS_NODE_MAGIC</span><span class="p">);</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">node_type</span> <span class="o">=</span> <span class="n">UBIFS_PAD_NODE</span><span class="p">;</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">group_type</span> <span class="o">=</span> <span class="n">UBIFS_NO_NODE_GROUP</span><span class="p">;</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">padding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">padding</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UBIFS_PAD_NODE_SZ</span><span class="p">);</span>
		<span class="n">pad</span> <span class="o">-=</span> <span class="n">UBIFS_PAD_NODE_SZ</span><span class="p">;</span>
		<span class="n">pad_node</span><span class="o">-&gt;</span><span class="n">pad_len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">pad</span><span class="p">);</span>
		<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="n">UBIFS_CRC32_INIT</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="n">UBIFS_PAD_NODE_SZ</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">crc</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">crc</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">UBIFS_PAD_NODE_SZ</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pad</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pad</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* Too little space, padding node won&#39;t fit */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">UBIFS_PADDING_BYTE</span><span class="p">,</span> <span class="n">pad</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * next_sqnum - get next sequence number.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">next_sqnum</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sqnum</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cnt_lock</span><span class="p">);</span>
	<span class="n">sqnum</span> <span class="o">=</span> <span class="o">++</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_sqnum</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cnt_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sqnum</span> <span class="o">&gt;=</span> <span class="n">SQNUM_WARN_WATERMARK</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sqnum</span> <span class="o">&gt;=</span> <span class="n">SQNUM_WATERMARK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;sequence number overflow %llu, end of life&quot;</span><span class="p">,</span>
				  <span class="n">sqnum</span><span class="p">);</span>
			<span class="n">ubifs_ro_mode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;running out of sequence numbers, end of life soon&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sqnum</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_prepare_node - prepare node to be written to flash.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @node: the node to pad</span>
<span class="cm"> * @len: node length</span>
<span class="cm"> * @pad: if the buffer has to be padded</span>
<span class="cm"> *</span>
<span class="cm"> * This function prepares node at @node to be written to the media - it</span>
<span class="cm"> * calculates node CRC, fills the common header, and adds proper padding up to</span>
<span class="cm"> * the next minimum I/O unit if @pad is not zero.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubifs_prepare_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pad</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">crc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="o">*</span><span class="n">ch</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sqnum</span> <span class="o">=</span> <span class="n">next_sqnum</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">UBIFS_CH_SZ</span><span class="p">);</span>

	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UBIFS_NODE_MAGIC</span><span class="p">);</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">group_type</span> <span class="o">=</span> <span class="n">UBIFS_NO_NODE_GROUP</span><span class="p">;</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">sqnum</span><span class="p">);</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">padding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">padding</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="n">UBIFS_CRC32_INIT</span><span class="p">,</span> <span class="n">node</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">crc</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">crc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pad</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">pad</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">)</span> <span class="o">-</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">ubifs_pad</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">pad</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_prep_grp_node - prepare node of a group to be written to flash.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @node: the node to pad</span>
<span class="cm"> * @len: node length</span>
<span class="cm"> * @last: indicates the last node of the group</span>
<span class="cm"> *</span>
<span class="cm"> * This function prepares node at @node to be written to the media - it</span>
<span class="cm"> * calculates node CRC and fills the common header.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubifs_prep_grp_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">crc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="o">*</span><span class="n">ch</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sqnum</span> <span class="o">=</span> <span class="n">next_sqnum</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">UBIFS_CH_SZ</span><span class="p">);</span>

	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UBIFS_NODE_MAGIC</span><span class="p">);</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">group_type</span> <span class="o">=</span> <span class="n">UBIFS_LAST_OF_NODE_GROUP</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ch</span><span class="o">-&gt;</span><span class="n">group_type</span> <span class="o">=</span> <span class="n">UBIFS_IN_NODE_GROUP</span><span class="p">;</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">sqnum</span><span class="p">);</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">padding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">padding</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="n">UBIFS_CRC32_INIT</span><span class="p">,</span> <span class="n">node</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">ch</span><span class="o">-&gt;</span><span class="n">crc</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">crc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wbuf_timer_callback - write-buffer timer callback function.</span>
<span class="cm"> * @data: timer data (write-buffer descriptor)</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called when the write-buffer timer expires.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="nf">wbuf_timer_callback_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_wbuf</span><span class="p">,</span> <span class="n">timer</span><span class="p">);</span>

	<span class="n">dbg_io</span><span class="p">(</span><span class="s">&quot;jhead %s&quot;</span><span class="p">,</span> <span class="n">dbg_jhead</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">));</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">need_sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">need_wbuf_sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ubifs_wake_up_bgt</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">HRTIMER_NORESTART</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * new_wbuf_timer - start new write-buffer timer.</span>
<span class="cm"> * @wbuf: write-buffer descriptor</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">new_wbuf_timer_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">hrtimer_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">no_timer</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">dbg_io</span><span class="p">(</span><span class="s">&quot;set timer for jhead %s, %llu-%llu millisecs&quot;</span><span class="p">,</span>
	       <span class="n">dbg_jhead</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">),</span>
	       <span class="n">div_u64</span><span class="p">(</span><span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">softlimit</span><span class="p">),</span> <span class="n">USEC_PER_SEC</span><span class="p">),</span>
	       <span class="n">div_u64</span><span class="p">(</span><span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">softlimit</span><span class="p">)</span> <span class="o">+</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">delta</span><span class="p">,</span>
		       <span class="n">USEC_PER_SEC</span><span class="p">));</span>
	<span class="n">hrtimer_start_range_ns</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">softlimit</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">delta</span><span class="p">,</span>
			       <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cancel_wbuf_timer - cancel write-buffer timer.</span>
<span class="cm"> * @wbuf: write-buffer descriptor</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cancel_wbuf_timer_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">no_timer</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">need_sync</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_wbuf_sync_nolock - synchronize write-buffer.</span>
<span class="cm"> * @wbuf: write-buffer to synchronize</span>
<span class="cm"> *</span>
<span class="cm"> * This function synchronizes write-buffer @buf and returns zero in case of</span>
<span class="cm"> * success or a negative error code in case of failure.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, although write-buffers are of @c-&gt;max_write_size, this function does</span>
<span class="cm"> * not necessarily writes all @c-&gt;max_write_size bytes to the flash. Instead,</span>
<span class="cm"> * if the write-buffer is only partially filled with data, only the used part</span>
<span class="cm"> * of the write-buffer (aligned on @c-&gt;min_io_size boundary) is synchronized.</span>
<span class="cm"> * This way we waste less space.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_wbuf_sync_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">dirt</span><span class="p">,</span> <span class="n">sync_len</span><span class="p">;</span>

	<span class="n">cancel_wbuf_timer_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">||</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="cm">/* Write-buffer is empty or not seeked */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dbg_io</span><span class="p">(</span><span class="s">&quot;LEB %d:%d, %d bytes, jhead %s&quot;</span><span class="p">,</span>
	       <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">,</span> <span class="n">dbg_jhead</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">+</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">%</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_media</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">)</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">+</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">%</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_error</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do not write whole write buffer but write only the minimum necessary</span>
<span class="cm">	 * amount of min. I/O units.</span>
<span class="cm">	 */</span>
	<span class="n">sync_len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="n">dirt</span> <span class="o">=</span> <span class="n">sync_len</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dirt</span><span class="p">)</span>
		<span class="n">ubifs_pad</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">,</span> <span class="n">dirt</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_write</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">sync_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">+=</span> <span class="n">sync_len</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Now @wbuf-&gt;offs is not necessarily aligned to @c-&gt;max_write_size.</span>
<span class="cm">	 * But our goal is to optimize writes and make sure we write in</span>
<span class="cm">	 * @c-&gt;max_write_size chunks and to @c-&gt;max_write_size-aligned offset.</span>
<span class="cm">	 * Thus, if @wbuf-&gt;offs is not aligned to @c-&gt;max_write_size now, make</span>
<span class="cm">	 * sure that @wbuf-&gt;offs + @wbuf-&gt;size is aligned to</span>
<span class="cm">	 * @c-&gt;max_write_size. This way we make sure that after next</span>
<span class="cm">	 * write-buffer flush we are again at the optimal offset (aligned to</span>
<span class="cm">	 * @c-&gt;max_write_size).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">)</span>
		<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">)</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">;</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">next_ino</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">sync_callback</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">sync_callback</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span>
					  <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">dirt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_wbuf_seek_nolock - seek write-buffer.</span>
<span class="cm"> * @wbuf: write-buffer</span>
<span class="cm"> * @lnum: logical eraseblock number to seek to</span>
<span class="cm"> * @offs: logical eraseblock offset to seek to</span>
<span class="cm"> *</span>
<span class="cm"> * This function targets the write-buffer to logical eraseblock @lnum:@offs.</span>
<span class="cm"> * The write-buffer has to be empty. Returns zero in case of success and a</span>
<span class="cm"> * negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_wbuf_seek_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">;</span>

	<span class="n">dbg_io</span><span class="p">(</span><span class="s">&quot;LEB %d:%d, jhead %s&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">dbg_jhead</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">lnum</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">offs</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">offs</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">offs</span> <span class="o">%</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">offs</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lnum</span> <span class="o">!=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">)</span>
		<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">)</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">;</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_bg_wbufs_sync - synchronize write-buffers.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by background thread to synchronize write-buffers.</span>
<span class="cm"> * Returns zero in case of success and a negative error code in case of</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_bg_wbufs_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_media</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">need_wbuf_sync</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">need_wbuf_sync</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_timers</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dbg_io</span><span class="p">(</span><span class="s">&quot;synchronize&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wbuf</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the mutex is locked then wbuf is being changed, so</span>
<span class="cm">		 * synchronization is not necessary.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">need_sync</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_wbuf_sync_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot sync write-buffer, error %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="n">ubifs_ro_mode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_timers</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_timers:</span>
	<span class="cm">/* Cancel all timers to prevent repeated errors */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wbuf</span><span class="p">;</span>

		<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">);</span>
		<span class="n">cancel_wbuf_timer_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_wbuf_write_nolock - write data to flash via write-buffer.</span>
<span class="cm"> * @wbuf: write-buffer</span>
<span class="cm"> * @buf: node to write</span>
<span class="cm"> * @len: node length</span>
<span class="cm"> *</span>
<span class="cm"> * This function writes data to flash via write-buffer @wbuf. This means that</span>
<span class="cm"> * the last piece of the node won&#39;t reach the flash media immediately if it</span>
<span class="cm"> * does not take whole max. write unit (@c-&gt;max_write_size). Instead, the node</span>
<span class="cm"> * will sit in RAM until the write-buffer is synchronized (e.g., by timer, or</span>
<span class="cm"> * because more data are appended to the write-buffer).</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero in case of success and a negative error code in</span>
<span class="cm"> * case of failure. If the node cannot be written because there is no more</span>
<span class="cm"> * space in this logical eraseblock, %-ENOSPC is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_wbuf_write_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">written</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">aligned_len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">dbg_io</span><span class="p">(</span><span class="s">&quot;%d bytes (%s) to jhead %s wbuf at LEB %d:%d&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
	       <span class="n">dbg_ntype</span><span class="p">(((</span><span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node_type</span><span class="p">),</span>
	       <span class="n">dbg_jhead</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">),</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">+</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">%</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">&lt;=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">%</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_media</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_fixup</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">)</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">+</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">%</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">&lt;</span> <span class="n">aligned_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cancel_wbuf_timer_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_error</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">aligned_len</span> <span class="o">&lt;=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The node is not very large and fits entirely within</span>
<span class="cm">		 * write-buffer.</span>
<span class="cm">		 */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">aligned_len</span> <span class="o">==</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dbg_io</span><span class="p">(</span><span class="s">&quot;flush jhead %s wbuf to LEB %d:%d&quot;</span><span class="p">,</span>
			       <span class="n">dbg_jhead</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">),</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_write</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span>
					      <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">+=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">)</span>
				<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">;</span>
			<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
			<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">next_ino</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">-=</span> <span class="n">aligned_len</span><span class="p">;</span>
			<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">+=</span> <span class="n">aligned_len</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The node is large enough and does not fit entirely within</span>
<span class="cm">		 * current available space. We have to fill and flush</span>
<span class="cm">		 * write-buffer and switch to the next max. write unit.</span>
<span class="cm">		 */</span>
		<span class="n">dbg_io</span><span class="p">(</span><span class="s">&quot;flush jhead %s wbuf to LEB %d:%d&quot;</span><span class="p">,</span>
		       <span class="n">dbg_jhead</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">),</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_write</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span>
				      <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">+=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">;</span>
		<span class="n">aligned_len</span> <span class="o">-=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">;</span>
		<span class="n">written</span> <span class="o">+=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The write-buffer offset is not aligned to</span>
<span class="cm">		 * @c-&gt;max_write_size and @wbuf-&gt;size is less than</span>
<span class="cm">		 * @c-&gt;max_write_size. Write @wbuf-&gt;size bytes to make sure the</span>
<span class="cm">		 * following writes are done in optimal @c-&gt;max_write_size</span>
<span class="cm">		 * chunks.</span>
<span class="cm">		 */</span>
		<span class="n">dbg_io</span><span class="p">(</span><span class="s">&quot;write %d bytes to LEB %d:%d&quot;</span><span class="p">,</span>
		       <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_write</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span>
				      <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">+=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">aligned_len</span> <span class="o">-=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">written</span> <span class="o">+=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The remaining data may take more whole max. write units, so write the</span>
<span class="cm">	 * remains multiple to max. write unit size directly to the flash media.</span>
<span class="cm">	 * We align node length to 8-byte boundary because we anyway flash wbuf</span>
<span class="cm">	 * if the remaining space is less than 8 bytes.</span>
<span class="cm">	 */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">aligned_len</span> <span class="o">&gt;&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_shift</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_shift</span><span class="p">;</span>
		<span class="n">dbg_io</span><span class="p">(</span><span class="s">&quot;write %d bytes to LEB %d:%d&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span>
		       <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_write</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">written</span><span class="p">,</span>
				      <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">aligned_len</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">written</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">aligned_len</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * And now we have what&#39;s left and what does not take whole</span>
<span class="cm">		 * max. write unit, so write it to the write-buffer and we are</span>
<span class="cm">		 * done.</span>
<span class="cm">		 */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">written</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">)</span>
		<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">;</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">aligned_len</span><span class="p">;</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">=</span> <span class="n">aligned_len</span><span class="p">;</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">next_ino</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="nl">exit:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">sync_callback</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">free</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">sync_callback</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">)</span>
		<span class="n">new_wbuf_timer_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot write %d bytes to LEB %d:%d, error %d&quot;</span><span class="p">,</span>
		  <span class="n">len</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
	<span class="n">ubifs_dump_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_write_node - write node to the media.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @buf: the node to write</span>
<span class="cm"> * @len: node length</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> * @offs: offset within the logical eraseblock</span>
<span class="cm"> *</span>
<span class="cm"> * This function automatically fills node magic number, assigns sequence</span>
<span class="cm"> * number, and calculates node CRC checksum. The length of the @buf buffer has</span>
<span class="cm"> * to be aligned to the minimal I/O unit size. This function automatically</span>
<span class="cm"> * appends padding node and padding bytes if needed. Returns zero in case of</span>
<span class="cm"> * success and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_write_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">buf_len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>

	<span class="n">dbg_io</span><span class="p">(</span><span class="s">&quot;LEB %d:%d, %s, length %d (aligned %d)&quot;</span><span class="p">,</span>
	       <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">dbg_ntype</span><span class="p">(((</span><span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node_type</span><span class="p">),</span> <span class="n">len</span><span class="p">,</span>
	       <span class="n">buf_len</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">lnum</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">&amp;&amp;</span> <span class="n">offs</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">offs</span> <span class="o">%</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">offs</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_media</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_fixup</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_error</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="n">ubifs_prepare_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_write</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_read_node_wbuf - read node from the media or write-buffer.</span>
<span class="cm"> * @wbuf: wbuf to check for un-written data</span>
<span class="cm"> * @buf: buffer to read to</span>
<span class="cm"> * @type: node type</span>
<span class="cm"> * @len: node length</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> * @offs: offset within the logical eraseblock</span>
<span class="cm"> *</span>
<span class="cm"> * This function reads a node of known type and length, checks it and stores</span>
<span class="cm"> * in @buf. If the node partially or fully sits in the write-buffer, this</span>
<span class="cm"> * function takes data from the buffer, otherwise it reads the flash media.</span>
<span class="cm"> * Returns zero in case of success, %-EUCLEAN if CRC mismatched and a negative</span>
<span class="cm"> * error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_read_node_wbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">rlen</span><span class="p">,</span> <span class="n">overlap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="o">*</span><span class="n">ch</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

	<span class="n">dbg_io</span><span class="p">(</span><span class="s">&quot;LEB %d:%d, %s, length %d, jhead %s&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span>
	       <span class="n">dbg_ntype</span><span class="p">(</span><span class="n">type</span><span class="p">),</span> <span class="n">len</span><span class="p">,</span> <span class="n">dbg_jhead</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">wbuf</span> <span class="o">&amp;&amp;</span> <span class="n">lnum</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">lnum</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">&amp;&amp;</span> <span class="n">offs</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">offs</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">offs</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">&lt;</span> <span class="n">UBIFS_NODE_TYPES_CNT</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">overlap</span> <span class="o">=</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">&amp;&amp;</span> <span class="n">offs</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">overlap</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We may safely unlock the write-buffer and read the data */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ubifs_read_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Don&#39;t read under wbuf */</span>
	<span class="n">rlen</span> <span class="o">=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">-</span> <span class="n">offs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rlen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Copy the rest from the write-buffer */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">rlen</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">offs</span> <span class="o">+</span> <span class="n">rlen</span> <span class="o">-</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">rlen</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rlen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read everything that goes before write-buffer */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">rlen</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EBADMSG</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">node_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad node type (%d but expected %d)&quot;</span><span class="p">,</span>
			  <span class="n">ch</span><span class="o">-&gt;</span><span class="n">node_type</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_check_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;expected node type %d&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rlen</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rlen</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad node length %d, expected %d&quot;</span><span class="p">,</span> <span class="n">rlen</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad node at LEB %d:%d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
	<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_read_node - read node.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @buf: buffer to read to</span>
<span class="cm"> * @type: node type</span>
<span class="cm"> * @len: node length (not aligned)</span>
<span class="cm"> * @lnum: logical eraseblock number</span>
<span class="cm"> * @offs: offset within the logical eraseblock</span>
<span class="cm"> *</span>
<span class="cm"> * This function reads a node of known type and and length, checks it and</span>
<span class="cm"> * stores in @buf. Returns zero in case of success, %-EUCLEAN if CRC mismatched</span>
<span class="cm"> * and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_read_node</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">l</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="o">*</span><span class="n">ch</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

	<span class="n">dbg_io</span><span class="p">(</span><span class="s">&quot;LEB %d:%d, %s, length %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">dbg_ntype</span><span class="p">(</span><span class="n">type</span><span class="p">),</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">lnum</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span> <span class="o">&amp;&amp;</span> <span class="n">offs</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">UBIFS_CH_SZ</span> <span class="o">&amp;&amp;</span> <span class="n">offs</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">offs</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">offs</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">&lt;</span> <span class="n">UBIFS_NODE_TYPES_CNT</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EBADMSG</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">node_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad node type (%d but expected %d)&quot;</span><span class="p">,</span>
			  <span class="n">ch</span><span class="o">-&gt;</span><span class="n">node_type</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_check_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;expected node type %d&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">l</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad node length %d, expected %d&quot;</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad node at LEB %d:%d, LEB mapping status %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span>
		  <span class="n">ubi_is_mapped</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ubi</span><span class="p">,</span> <span class="n">lnum</span><span class="p">));</span>
	<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_wbuf_init - initialize write-buffer.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @wbuf: write-buffer to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * This function initializes write-buffer. Returns zero in case of success</span>
<span class="cm"> * %-ENOMEM in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_wbuf_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span> <span class="o">/</span> <span class="n">UBIFS_CH_SZ</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ino_t</span><span class="p">);</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">inodes</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">inodes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
		<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the LEB starts at the max. write size aligned address, then</span>
<span class="cm">	 * write-buffer size has to be set to @c-&gt;max_write_size. Otherwise,</span>
<span class="cm">	 * set it to something smaller so that it ends at the closest max.</span>
<span class="cm">	 * write size boundary.</span>
<span class="cm">	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_start</span> <span class="o">%</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">);</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">sync_callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">next_ino</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hrtimer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">wbuf_timer_callback_nolock</span><span class="p">;</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">softlimit</span> <span class="o">=</span> <span class="n">ktime_set</span><span class="p">(</span><span class="n">WBUF_TIMEOUT_SOFTLIMIT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">delta</span> <span class="o">=</span> <span class="n">WBUF_TIMEOUT_HARDLIMIT</span> <span class="o">-</span> <span class="n">WBUF_TIMEOUT_SOFTLIMIT</span><span class="p">;</span>
	<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">delta</span> <span class="o">*=</span> <span class="mi">1000000000ULL</span><span class="p">;</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">delta</span> <span class="o">&lt;=</span> <span class="n">ULONG_MAX</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_wbuf_add_ino_nolock - add an inode number into the wbuf inode array.</span>
<span class="cm"> * @wbuf: the write-buffer where to add</span>
<span class="cm"> * @inum: the inode number</span>
<span class="cm"> *</span>
<span class="cm"> * This function adds an inode number to the inode array of the write-buffer.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubifs_wbuf_add_ino_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">inum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">)</span>
		<span class="cm">/* NOR flash or something similar */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">)</span>
		<span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">inodes</span><span class="p">[</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">next_ino</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">inum</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wbuf_has_ino - returns if the wbuf contains data from the inode.</span>
<span class="cm"> * @wbuf: the write-buffer</span>
<span class="cm"> * @inum: the inode number</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns with %1 if the write-buffer contains some data from the</span>
<span class="cm"> * given inode otherwise it returns with %0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wbuf_has_ino</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">inum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">next_ino</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">==</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">inodes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_sync_wbufs_by_inode - synchronize write-buffers for an inode.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @inode: inode to synchronize</span>
<span class="cm"> *</span>
<span class="cm"> * This function synchronizes write-buffers which contain nodes belonging to</span>
<span class="cm"> * @inode. Returns zero in case of success and a negative error code in case of</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_sync_wbufs_by_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wbuf</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">GCHD</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * GC head is special, do not look at it. Even if the</span>
<span class="cm">			 * head contains something related to this inode, it is</span>
<span class="cm">			 * a _copy_ of corresponding on-flash node which sits</span>
<span class="cm">			 * somewhere else.</span>
<span class="cm">			 */</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wbuf_has_ino</span><span class="p">(</span><span class="n">wbuf</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wbuf_has_ino</span><span class="p">(</span><span class="n">wbuf</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_wbuf_sync_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_ro_mode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
