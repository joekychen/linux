<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ubifs › tnc_commit.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>tnc_commit.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is part of UBIFS.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Nokia Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="cm"> * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Adrian Hunter</span>
<span class="cm"> *          Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> */</span>

<span class="cm">/* This file implements TNC functions for committing */</span>

<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &quot;ubifs.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * make_idx_node - make an index node for fill-the-gaps method of TNC commit.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @idx: buffer in which to place new index node</span>
<span class="cm"> * @znode: znode from which to make new index node</span>
<span class="cm"> * @lnum: LEB number where new index node will be written</span>
<span class="cm"> * @offs: offset where new index node will be written</span>
<span class="cm"> * @len: length of new index node</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">make_idx_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_idx_node</span> <span class="o">*</span><span class="n">idx</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">zp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Make index node */</span>
	<span class="n">idx</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">node_type</span> <span class="o">=</span> <span class="n">UBIFS_IDX_NODE</span><span class="p">;</span>
	<span class="n">idx</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">);</span>
	<span class="n">idx</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_branch</span> <span class="o">*</span><span class="n">br</span> <span class="o">=</span> <span class="n">ubifs_idx_branch</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">key_write_idx</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
		<span class="n">br</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>
		<span class="n">br</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
		<span class="n">br</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">||</span> <span class="o">!</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad ref in znode&quot;</span><span class="p">);</span>
			<span class="n">ubifs_dump_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="p">)</span>
				<span class="n">ubifs_dump_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ubifs_prepare_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">znode</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="n">znode</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
	<span class="n">znode</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">insert_old_idx_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>

	<span class="cm">/* Update the parent */</span>
	<span class="n">zp</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">;</span>

		<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zp</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span><span class="p">];</span>
		<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
		<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
		<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">calc_idx_sz</span> <span class="o">+=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">atomic_long_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_zn_cnt</span><span class="p">);</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">ubifs_zn_dirty</span><span class="p">(</span><span class="n">znode</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">ubifs_zn_cow</span><span class="p">(</span><span class="n">znode</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note, unlike &#39;write_index()&#39; we do not add memory barriers here</span>
<span class="cm">	 * because this function is called with @c-&gt;tnc_mutex locked.</span>
<span class="cm">	 */</span>
	<span class="n">__clear_bit</span><span class="p">(</span><span class="n">DIRTY_ZNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">__clear_bit</span><span class="p">(</span><span class="n">COW_ZNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fill_gap - make index nodes in gaps in dirty index LEBs.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB number that gap appears in</span>
<span class="cm"> * @gap_start: offset of start of gap</span>
<span class="cm"> * @gap_end: offset of end of gap</span>
<span class="cm"> * @dirt: adds dirty space to this</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the number of index nodes written into the gap.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fill_gap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gap_start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gap_end</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="o">*</span><span class="n">dirt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">gap_remains</span><span class="p">,</span> <span class="n">gap_pos</span><span class="p">,</span> <span class="n">written</span><span class="p">,</span> <span class="n">pad_len</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">((</span><span class="n">gap_start</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">((</span><span class="n">gap_end</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">gap_end</span> <span class="o">&gt;=</span> <span class="n">gap_start</span><span class="p">);</span>

	<span class="n">gap_remains</span> <span class="o">=</span> <span class="n">gap_end</span> <span class="o">-</span> <span class="n">gap_start</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gap_remains</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">gap_pos</span> <span class="o">=</span> <span class="n">gap_start</span><span class="p">;</span>
	<span class="n">written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">enext</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">ubifs_idx_node_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">enext</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">gap_remains</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">enext</span><span class="p">;</span>
			<span class="k">const</span> <span class="kt">int</span> <span class="n">alen</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
			<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

			<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">alen</span> <span class="o">&lt;=</span> <span class="n">gap_remains</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">make_idx_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_buf</span> <span class="o">+</span> <span class="n">gap_pos</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span>
					    <span class="n">lnum</span><span class="p">,</span> <span class="n">gap_pos</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="n">gap_remains</span> <span class="o">-=</span> <span class="n">alen</span><span class="p">;</span>
			<span class="n">gap_pos</span> <span class="o">+=</span> <span class="n">alen</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">enext</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">enext</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">)</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">enext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">written</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gap_end</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">gap_pos</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
		<span class="cm">/* Pad to end of min_io_size */</span>
		<span class="n">pad_len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_len</span> <span class="o">-</span> <span class="n">gap_pos</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* Pad to end of gap */</span>
		<span class="n">pad_len</span> <span class="o">=</span> <span class="n">gap_remains</span><span class="p">;</span>
	<span class="n">dbg_gc</span><span class="p">(</span><span class="s">&quot;LEB %d:%d to %d len %d nodes written %d wasted bytes %d&quot;</span><span class="p">,</span>
	       <span class="n">lnum</span><span class="p">,</span> <span class="n">gap_start</span><span class="p">,</span> <span class="n">gap_end</span><span class="p">,</span> <span class="n">gap_end</span> <span class="o">-</span> <span class="n">gap_start</span><span class="p">,</span> <span class="n">written</span><span class="p">,</span> <span class="n">pad_len</span><span class="p">);</span>
	<span class="n">ubifs_pad</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_buf</span> <span class="o">+</span> <span class="n">gap_pos</span><span class="p">,</span> <span class="n">pad_len</span><span class="p">);</span>
	<span class="o">*</span><span class="n">dirt</span> <span class="o">+=</span> <span class="n">pad_len</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">written</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_old_idx - find an index node obsoleted since the last commit start.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB number of obsoleted index node</span>
<span class="cm"> * @offs: offset of obsoleted index node</span>
<span class="cm"> *</span>
<span class="cm"> * Returns %1 if found and %0 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_old_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_old_idx</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">old_idx</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">o</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_old_idx</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&lt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&gt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">offs</span> <span class="o">&lt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">offs</span> <span class="o">&gt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * is_idx_node_in_use - determine if an index node can be overwritten.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @key: key of index node</span>
<span class="cm"> * @level: index node level</span>
<span class="cm"> * @lnum: LEB number of index node</span>
<span class="cm"> * @offs: offset of index node</span>
<span class="cm"> *</span>
<span class="cm"> * If @key / @lnum / @offs identify an index node that was not part of the old</span>
<span class="cm"> * index, then this function returns %0 (obsolete).  Else if the index node was</span>
<span class="cm"> * part of the old index but is now dirty %1 is returned, else if it is clean %2</span>
<span class="cm"> * is returned. A negative error code is returned on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_idx_node_in_use</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">is_idx_node_in_tnc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span> <span class="cm">/* Error code */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">find_old_idx</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * layout_leb_in_gaps - layout index nodes using in-the-gaps method.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @p: return LEB number here</span>
<span class="cm"> *</span>
<span class="cm"> * This function lays out new index nodes for dirty znodes using in-the-gaps</span>
<span class="cm"> * method of TNC commit.</span>
<span class="cm"> * This function merely puts the next znode into the next gap, making no attempt</span>
<span class="cm"> * to try to maximise the number of znodes that fit.</span>
<span class="cm"> * This function returns the number of index nodes written into the gaps, or a</span>
<span class="cm"> * negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">layout_leb_in_gaps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">sleb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_scan_node</span> <span class="o">*</span><span class="n">snod</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">dirt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gap_start</span><span class="p">,</span> <span class="n">gap_end</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">written</span><span class="p">,</span> <span class="n">tot_written</span><span class="p">;</span>

	<span class="n">tot_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Get an index LEB with lots of obsolete index nodes */</span>
	<span class="n">lnum</span> <span class="o">=</span> <span class="n">ubifs_find_dirty_idx_leb</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * There also may be dirt in the index head that could be</span>
<span class="cm">		 * filled, however we do not check there at present.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">lnum</span><span class="p">;</span> <span class="cm">/* Error code */</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="n">dbg_gc</span><span class="p">(</span><span class="s">&quot;LEB %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Scan the index LEB.  We use the generic scan for this even though</span>
<span class="cm">	 * it is more comprehensive and less efficient than is needed for this</span>
<span class="cm">	 * purpose.</span>
<span class="cm">	 */</span>
	<span class="n">sleb</span> <span class="o">=</span> <span class="n">ubifs_scan</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sleb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>
	<span class="n">gap_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">snod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_idx_node</span> <span class="o">*</span><span class="n">idx</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">in_use</span><span class="p">,</span> <span class="n">level</span><span class="p">;</span>

		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_IDX_NODE</span><span class="p">);</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
		<span class="n">key_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ubifs_idx_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
		<span class="n">level</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">idx</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
		<span class="cm">/* Determine if the index node is in use (not obsolete) */</span>
		<span class="n">in_use</span> <span class="o">=</span> <span class="n">is_idx_node_in_use</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span>
					    <span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_use</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_scan_destroy</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">in_use</span><span class="p">;</span> <span class="cm">/* Error code */</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_use</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">in_use</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">dirt</span> <span class="o">+=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * The obsolete index nodes form gaps that can be</span>
<span class="cm">			 * overwritten.  This gap has ended because we have</span>
<span class="cm">			 * found an index node that is still in use</span>
<span class="cm">			 * i.e. not obsolete</span>
<span class="cm">			 */</span>
			<span class="n">gap_end</span> <span class="o">=</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">;</span>
			<span class="cm">/* Try to fill gap */</span>
			<span class="n">written</span> <span class="o">=</span> <span class="n">fill_gap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">gap_start</span><span class="p">,</span> <span class="n">gap_end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dirt</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">written</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_scan_destroy</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">written</span><span class="p">;</span> <span class="cm">/* Error code */</span>
			<span class="p">}</span>
			<span class="n">tot_written</span> <span class="o">+=</span> <span class="n">written</span><span class="p">;</span>
			<span class="n">gap_start</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">+</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ubifs_scan_destroy</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">;</span>
	<span class="n">gap_end</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">;</span>
	<span class="cm">/* Try to fill gap */</span>
	<span class="n">written</span> <span class="o">=</span> <span class="n">fill_gap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">gap_start</span><span class="p">,</span> <span class="n">gap_end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dirt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">written</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">written</span><span class="p">;</span> <span class="cm">/* Error code */</span>
	<span class="n">tot_written</span> <span class="o">+=</span> <span class="n">written</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tot_written</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="n">lp</span><span class="p">;</span>

		<span class="n">dbg_gc</span><span class="p">(</span><span class="s">&quot;LEB %d wrote %d index nodes&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">tot_written</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_read_one_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="p">.</span><span class="n">free</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We must have snatched this LEB from the idx_gc list</span>
<span class="cm">			 * so we need to correct the free and dirty space.</span>
<span class="cm">			 */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_change_one_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span>
						  <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_len</span><span class="p">,</span>
						  <span class="n">dirt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_change_one_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_len</span><span class="p">,</span> <span class="n">dirt</span><span class="p">,</span>
				  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_change</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_buf</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">dbg_gc</span><span class="p">(</span><span class="s">&quot;LEB %d wrote %d index nodes&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">tot_written</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tot_written</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_leb_cnt - calculate the number of empty LEBs needed to commit.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @cnt: number of znodes to commit</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the number of empty LEBs needed to commit @cnt znodes</span>
<span class="cm"> * to the current index head.  The number is not exact and may be more than</span>
<span class="cm"> * needed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_leb_cnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">d</span><span class="p">;</span>

	<span class="cm">/* Assume maximum index node size (i.e. overestimate space needed) */</span>
	<span class="n">cnt</span> <span class="o">-=</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ihead_offs</span><span class="p">)</span> <span class="o">/</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_idx_node_sz</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">d</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">/</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_idx_node_sz</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * layout_in_gaps - in-the-gaps method of committing TNC.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @cnt: number of dirty znodes to commit.</span>
<span class="cm"> *</span>
<span class="cm"> * This function lays out new index nodes for dirty znodes using in-the-gaps</span>
<span class="cm"> * method of TNC commit.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">layout_in_gaps</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">leb_needed_cnt</span><span class="p">,</span> <span class="n">written</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">dbg_gc</span><span class="p">(</span><span class="s">&quot;%d znodes to write&quot;</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">gap_lebs</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">idx_lebs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">gap_lebs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">gap_lebs</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">gap_lebs</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">idx_lebs</span><span class="p">);</span>
		<span class="n">written</span> <span class="o">=</span> <span class="n">layout_leb_in_gaps</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">written</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">written</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">gap_lebs</span><span class="p">);</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">gap_lebs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_chk_index</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Do not print scary warnings if the debugging</span>
<span class="cm">				 * option which forces in-the-gaps is enabled.</span>
<span class="cm">				 */</span>
				<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;out of space&quot;</span><span class="p">);</span>
				<span class="n">ubifs_dump_budg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">);</span>
				<span class="n">ubifs_dump_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* Try to commit anyway */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">p</span><span class="o">++</span><span class="p">;</span>
		<span class="n">cnt</span> <span class="o">-=</span> <span class="n">written</span><span class="p">;</span>
		<span class="n">leb_needed_cnt</span> <span class="o">=</span> <span class="n">get_leb_cnt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
		<span class="n">dbg_gc</span><span class="p">(</span><span class="s">&quot;%d znodes remaining, need %d LEBs, have %d&quot;</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span>
		       <span class="n">leb_needed_cnt</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_cnt</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">leb_needed_cnt</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_cnt</span><span class="p">);</span>

	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * layout_in_empty_space - layout index nodes in empty space.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function lays out new index nodes for dirty znodes using empty LEBs.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">layout_in_empty_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">,</span> <span class="o">*</span><span class="n">cnext</span><span class="p">,</span> <span class="o">*</span><span class="n">zp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">next_len</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">,</span> <span class="n">buf_offs</span><span class="p">,</span> <span class="n">used</span><span class="p">,</span> <span class="n">avail</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wlen</span><span class="p">,</span> <span class="n">blen</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">cnext</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">enext</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cnext</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ihead_lnum</span><span class="p">;</span>
	<span class="n">buf_offs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ihead_offs</span><span class="p">;</span>

	<span class="n">buf_len</span> <span class="o">=</span> <span class="n">ubifs_idx_node_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span><span class="p">);</span>
	<span class="n">buf_len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">buf_len</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">avail</span> <span class="o">=</span> <span class="n">buf_len</span><span class="p">;</span>

	<span class="cm">/* Ensure there is enough room for first write */</span>
	<span class="n">next_len</span> <span class="o">=</span> <span class="n">ubifs_idx_node_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">cnext</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf_offs</span> <span class="o">+</span> <span class="n">next_len</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span>
		<span class="n">lnum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">cnext</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">ubifs_idx_node_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">);</span>

		<span class="cm">/* Determine the index node position */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_nxt</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_cnt</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;out of space&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ilebs</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_nxt</span><span class="o">++</span><span class="p">];</span>
			<span class="n">buf_offs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">avail</span> <span class="o">=</span> <span class="n">buf_len</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">offs</span> <span class="o">=</span> <span class="n">buf_offs</span> <span class="o">+</span> <span class="n">used</span><span class="p">;</span>

		<span class="n">znode</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
		<span class="n">znode</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
		<span class="n">znode</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

		<span class="cm">/* Update the parent */</span>
		<span class="n">zp</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

			<span class="n">i</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span><span class="p">;</span>
			<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zp</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
			<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
			<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">offs</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">calc_idx_sz</span> <span class="o">+=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Once lprops is updated, we can decrease the dirty znode count</span>
<span class="cm">		 * but it is easier to just do it here.</span>
<span class="cm">		 */</span>
		<span class="n">atomic_long_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_zn_cnt</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Calculate the next index node length to see if there is</span>
<span class="cm">		 * enough room for it</span>
<span class="cm">		 */</span>
		<span class="n">cnext</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnext</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">)</span>
			<span class="n">next_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">next_len</span> <span class="o">=</span> <span class="n">ubifs_idx_node_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">cnext</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">);</span>

		<span class="cm">/* Update buffer positions */</span>
		<span class="n">wlen</span> <span class="o">=</span> <span class="n">used</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">used</span> <span class="o">+=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">avail</span> <span class="o">-=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">next_len</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">buf_offs</span> <span class="o">+</span> <span class="n">used</span> <span class="o">+</span> <span class="n">next_len</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">&amp;&amp;</span>
		    <span class="n">avail</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">avail</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">next_len</span> <span class="o">&amp;&amp;</span>
		    <span class="n">buf_offs</span> <span class="o">+</span> <span class="n">used</span> <span class="o">+</span> <span class="n">next_len</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span>
			<span class="n">blen</span> <span class="o">=</span> <span class="n">buf_len</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">blen</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">wlen</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>

		<span class="cm">/* The buffer is full or there are no more znodes to do */</span>
		<span class="n">buf_offs</span> <span class="o">+=</span> <span class="n">blen</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buf_offs</span> <span class="o">+</span> <span class="n">next_len</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_update_one_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span>
					<span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">buf_offs</span><span class="p">,</span> <span class="n">blen</span> <span class="o">-</span> <span class="n">used</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
				<span class="n">lnum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">used</span> <span class="o">-=</span> <span class="n">blen</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">used</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">avail</span> <span class="o">=</span> <span class="n">buf_len</span> <span class="o">-</span> <span class="n">used</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_update_one_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">buf_offs</span><span class="p">,</span>
					  <span class="n">blen</span> <span class="o">-</span> <span class="n">used</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="o">-&gt;</span><span class="n">new_ihead_lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="o">-&gt;</span><span class="n">new_ihead_offs</span> <span class="o">=</span> <span class="n">buf_offs</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * layout_commit - determine positions of index nodes to commit.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @no_space: indicates that insufficient empty LEBs were allocated</span>
<span class="cm"> * @cnt: number of znodes to commit</span>
<span class="cm"> *</span>
<span class="cm"> * Calculate and update the positions of index nodes to commit.  If there were</span>
<span class="cm"> * an insufficient number of empty LEBs allocated, then index nodes are placed</span>
<span class="cm"> * into the gaps created by obsolete index nodes in non-empty index LEBs.  For</span>
<span class="cm"> * this purpose, an obsolete index node is one that was not in the index as at</span>
<span class="cm"> * the end of the last commit.  To write &quot;in-the-gaps&quot; requires that those index</span>
<span class="cm"> * LEBs are updated atomically in-place.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">layout_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">no_space</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">no_space</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">layout_in_gaps</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">layout_in_empty_space</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_first_dirty - find first dirty znode.</span>
<span class="cm"> * @znode: znode to begin searching from</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="nf">find_first_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">cont</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">znode</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ubifs_zn_dirty</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">znode</span><span class="p">;</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cont</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span> <span class="o">&amp;&amp;</span> <span class="n">ubifs_zn_dirty</span><span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">znode</span> <span class="o">=</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="p">;</span>
				<span class="n">cont</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cont</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ubifs_zn_dirty</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">znode</span><span class="p">;</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_next_dirty - find next dirty znode.</span>
<span class="cm"> * @znode: znode to begin searching from</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="nf">find_next_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">znode</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">znode</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span> <span class="o">&amp;&amp;</span> <span class="n">ubifs_zn_dirty</span><span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">find_first_dirty</span><span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">znode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_znodes_to_commit - create list of dirty znodes to commit.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the number of znodes to commit.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_znodes_to_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">,</span> <span class="o">*</span><span class="n">cnext</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">cnext</span> <span class="o">=</span> <span class="n">find_first_dirty</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="p">);</span>
	<span class="n">znode</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">enext</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">znode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;no znodes to commit&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">ubifs_zn_cow</span><span class="p">(</span><span class="n">znode</span><span class="p">));</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">COW_ZNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">znode</span><span class="o">-&gt;</span><span class="n">alt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cnext</span> <span class="o">=</span> <span class="n">find_next_dirty</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cnext</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">znode</span><span class="o">-&gt;</span><span class="n">cnext</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">znode</span><span class="o">-&gt;</span><span class="n">cnext</span> <span class="o">=</span> <span class="n">cnext</span><span class="p">;</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">cnext</span><span class="p">;</span>
		<span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;committing %d znodes&quot;</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_zn_cnt</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * alloc_idx_lebs - allocate empty LEBs to be used to commit.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @cnt: number of znodes to commit</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %-ENOSPC if it cannot allocate a sufficient number of</span>
<span class="cm"> * empty LEBs.  %0 is returned on success, otherwise a negative error code</span>
<span class="cm"> * is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_idx_lebs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">leb_cnt</span><span class="p">,</span> <span class="n">lnum</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_nxt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">leb_cnt</span> <span class="o">=</span> <span class="n">get_leb_cnt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
	<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;need about %d empty LEBS for TNC commit&quot;</span><span class="p">,</span> <span class="n">leb_cnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">leb_cnt</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ilebs</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">leb_cnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ilebs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">leb_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lnum</span> <span class="o">=</span> <span class="n">ubifs_find_free_leb_for_idx</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">lnum</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">ilebs</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_cnt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
		<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;LEB %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dbg_is_chk_index</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">random32</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * free_unused_idx_lebs - free unused LEBs that were allocated for the commit.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * It is possible that we allocate more empty LEBs for the commit than we need.</span>
<span class="cm"> * This functions frees the surplus.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">free_unused_idx_lebs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">er</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_nxt</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ileb_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ilebs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;LEB %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="n">er</span> <span class="o">=</span> <span class="n">ubifs_change_one_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">LPROPS_NC</span><span class="p">,</span> <span class="n">LPROPS_NC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					 <span class="n">LPROPS_INDEX</span> <span class="o">|</span> <span class="n">LPROPS_TAKEN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">er</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * free_idx_lebs - free unused LEBs after commit end.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">free_idx_lebs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">free_unused_idx_lebs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ilebs</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ilebs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_tnc_start_commit - start TNC commit.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @zroot: new index root position is returned here</span>
<span class="cm"> *</span>
<span class="cm"> * This function prepares the list of indexing nodes to commit and lays out</span>
<span class="cm"> * their positions on flash. If there is not enough free space it uses the</span>
<span class="cm"> * in-gap commit method. Returns zero in case of success and a negative error</span>
<span class="cm"> * code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_tnc_start_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zroot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_tnc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">cnt</span> <span class="o">=</span> <span class="n">get_znodes_to_commit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">no_space</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">alloc_idx_lebs</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
			<span class="n">no_space</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">layout_commit</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">no_space</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_zn_cnt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">free_unused_idx_lebs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">destroy_old_idx</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">zroot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_zbranch</span><span class="p">));</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_save_dirty_idx_lnums</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Although we have not finished committing yet, update size of the</span>
<span class="cm">	 * committed index (&#39;c-&gt;bi.old_idx_sz&#39;) and zero out the index growth</span>
<span class="cm">	 * budget. It is OK to do this now, because we&#39;ve reserved all the</span>
<span class="cm">	 * space which is needed to commit the index, and it is save for the</span>
<span class="cm">	 * budgeting subsystem to assume the index is already committed,</span>
<span class="cm">	 * even though it is not.</span>
<span class="cm">	 */</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">min_idx_lebs</span> <span class="o">==</span> <span class="n">ubifs_calc_min_idx_lebs</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">old_idx_sz</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">calc_idx_sz</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">uncommitted_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">min_idx_lebs</span> <span class="o">=</span> <span class="n">ubifs_calc_min_idx_lebs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>

	<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;number of index LEBs %d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">.</span><span class="n">idx_lebs</span><span class="p">);</span>
	<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;size of index %llu&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">calc_idx_sz</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">free_idx_lebs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * write_index - write index nodes.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function writes the index nodes whose positions were laid out in the</span>
<span class="cm"> * layout_in_empty_space function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_idx_node</span> <span class="o">*</span><span class="n">idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">,</span> <span class="o">*</span><span class="n">cnext</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">next_len</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">,</span> <span class="n">buf_offs</span><span class="p">,</span> <span class="n">used</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">avail</span><span class="p">,</span> <span class="n">wlen</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">lnum_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">blen</span><span class="p">,</span> <span class="n">nxt_offs</span><span class="p">;</span>

	<span class="n">cnext</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">enext</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cnext</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Always write index nodes to the index head so that index nodes and</span>
<span class="cm">	 * other types of nodes are never mixed in the same erase block.</span>
<span class="cm">	 */</span>
	<span class="n">lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ihead_lnum</span><span class="p">;</span>
	<span class="n">buf_offs</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ihead_offs</span><span class="p">;</span>

	<span class="cm">/* Allocate commit buffer */</span>
	<span class="n">buf_len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_idx_node_sz</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">avail</span> <span class="o">=</span> <span class="n">buf_len</span><span class="p">;</span>

	<span class="cm">/* Ensure there is enough room for first write */</span>
	<span class="n">next_len</span> <span class="o">=</span> <span class="n">ubifs_idx_node_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">cnext</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf_offs</span> <span class="o">+</span> <span class="n">next_len</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_update_one_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">LPROPS_NC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					  <span class="n">LPROPS_TAKEN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">lnum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="n">znode</span> <span class="o">=</span> <span class="n">cnext</span><span class="p">;</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cbuf</span> <span class="o">+</span> <span class="n">used</span><span class="p">;</span>

		<span class="cm">/* Make index node */</span>
		<span class="n">idx</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">node_type</span> <span class="o">=</span> <span class="n">UBIFS_IDX_NODE</span><span class="p">;</span>
		<span class="n">idx</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">);</span>
		<span class="n">idx</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ubifs_branch</span> <span class="o">*</span><span class="n">br</span> <span class="o">=</span> <span class="n">ubifs_idx_branch</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="n">key_write_idx</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
			<span class="n">br</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>
			<span class="n">br</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
			<span class="n">br</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">||</span> <span class="o">!</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad ref in znode&quot;</span><span class="p">);</span>
				<span class="n">ubifs_dump_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="p">)</span>
					<span class="n">ubifs_dump_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">ubifs_idx_node_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">);</span>
		<span class="n">ubifs_prepare_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Determine the index node position */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ilebs</span><span class="p">[</span><span class="n">lnum_pos</span><span class="o">++</span><span class="p">];</span>
			<span class="n">buf_offs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">avail</span> <span class="o">=</span> <span class="n">buf_len</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">offs</span> <span class="o">=</span> <span class="n">buf_offs</span> <span class="o">+</span> <span class="n">used</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">!=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">||</span> <span class="n">offs</span> <span class="o">!=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">||</span>
		    <span class="n">len</span> <span class="o">!=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;inconsistent znode posn&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Grab some stuff from znode while we still can */</span>
		<span class="n">cnext</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">;</span>

		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">ubifs_zn_dirty</span><span class="p">(</span><span class="n">znode</span><span class="p">));</span>
		<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">ubifs_zn_cow</span><span class="p">(</span><span class="n">znode</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * It is important that other threads should see %DIRTY_ZNODE</span>
<span class="cm">		 * flag cleared before %COW_ZNODE. Specifically, it matters in</span>
<span class="cm">		 * the &#39;dirty_cow_znode()&#39; function. This is the reason for the</span>
<span class="cm">		 * first barrier. Also, we want the bit changes to be seen to</span>
<span class="cm">		 * other threads ASAP, to avoid unnecesarry copying, which is</span>
<span class="cm">		 * the reason for the second barrier.</span>
<span class="cm">		 */</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">DIRTY_ZNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">smp_mb__before_clear_bit</span><span class="p">();</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">COW_ZNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * We have marked the znode as clean but have not updated the</span>
<span class="cm">		 * @c-&gt;clean_zn_cnt counter. If this znode becomes dirty again</span>
<span class="cm">		 * before &#39;free_obsolete_znodes()&#39; is called, then</span>
<span class="cm">		 * @c-&gt;clean_zn_cnt will be decremented before it gets</span>
<span class="cm">		 * incremented (resulting in 2 decrements for the same znode).</span>
<span class="cm">		 * This means that @c-&gt;clean_zn_cnt may become negative for a</span>
<span class="cm">		 * while.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Q: why we cannot increment @c-&gt;clean_zn_cnt?</span>
<span class="cm">		 * A: because we do not have the @c-&gt;tnc_mutex locked, and the</span>
<span class="cm">		 *    following code would be racy and buggy:</span>
<span class="cm">		 *</span>
<span class="cm">		 *    if (!ubifs_zn_obsolete(znode)) {</span>
<span class="cm">		 *            atomic_long_inc(&amp;c-&gt;clean_zn_cnt);</span>
<span class="cm">		 *            atomic_long_inc(&amp;ubifs_clean_zn_cnt);</span>
<span class="cm">		 *    }</span>
<span class="cm">		 *</span>
<span class="cm">		 *    Thus, we just delay the @c-&gt;clean_zn_cnt update until we</span>
<span class="cm">		 *    have the mutex locked.</span>
<span class="cm">		 */</span>

		<span class="cm">/* Do not access znode from this point on */</span>

		<span class="cm">/* Update buffer positions */</span>
		<span class="n">wlen</span> <span class="o">=</span> <span class="n">used</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">used</span> <span class="o">+=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">avail</span> <span class="o">-=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Calculate the next index node length to see if there is</span>
<span class="cm">		 * enough room for it</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnext</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">)</span>
			<span class="n">next_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">next_len</span> <span class="o">=</span> <span class="n">ubifs_idx_node_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">cnext</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">);</span>

		<span class="n">nxt_offs</span> <span class="o">=</span> <span class="n">buf_offs</span> <span class="o">+</span> <span class="n">used</span> <span class="o">+</span> <span class="n">next_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next_len</span> <span class="o">&amp;&amp;</span> <span class="n">nxt_offs</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">avail</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">blen</span> <span class="o">=</span> <span class="n">buf_len</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">wlen</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">wlen</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
			<span class="n">blen</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">wlen</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
			<span class="n">ubifs_pad</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cbuf</span> <span class="o">+</span> <span class="n">wlen</span><span class="p">,</span> <span class="n">blen</span> <span class="o">-</span> <span class="n">wlen</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* The buffer is full or there are no more znodes to do */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_write</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cbuf</span><span class="p">,</span> <span class="n">buf_offs</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">buf_offs</span> <span class="o">+=</span> <span class="n">blen</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nxt_offs</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_update_one_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">LPROPS_NC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
							  <span class="mi">0</span><span class="p">,</span> <span class="n">LPROPS_TAKEN</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
				<span class="n">lnum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">used</span> <span class="o">-=</span> <span class="n">blen</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">used</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">avail</span> <span class="o">=</span> <span class="n">buf_len</span> <span class="o">-</span> <span class="n">used</span><span class="p">;</span>
			<span class="n">memmove</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cbuf</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cbuf</span> <span class="o">+</span> <span class="n">blen</span><span class="p">,</span> <span class="n">used</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="o">-&gt;</span><span class="n">new_ihead_lnum</span> <span class="o">||</span>
	    <span class="n">buf_offs</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="o">-&gt;</span><span class="n">new_ihead_offs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;inconsistent ihead&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ihead_lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ihead_offs</span> <span class="o">=</span> <span class="n">buf_offs</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * free_obsolete_znodes - free obsolete znodes.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * At the end of commit end, obsolete znodes are freed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_obsolete_znodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">,</span> <span class="o">*</span><span class="n">cnext</span><span class="p">;</span>

	<span class="n">cnext</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">cnext</span><span class="p">;</span>
		<span class="n">cnext</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ubifs_zn_obsolete</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">znode</span><span class="o">-&gt;</span><span class="n">cnext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">clean_zn_cnt</span><span class="p">);</span>
			<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ubifs_clean_zn_cnt</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">cnext</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * return_gap_lebs - return LEBs used by the in-gap commit method.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function clears the &quot;taken&quot; flag for the LEBs which were used by the</span>
<span class="cm"> * &quot;commit in-the-gaps&quot; method.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">return_gap_lebs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">gap_lebs</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">gap_lebs</span><span class="p">;</span> <span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_change_one_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">LPROPS_NC</span><span class="p">,</span> <span class="n">LPROPS_NC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					  <span class="n">LPROPS_TAKEN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">gap_lebs</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">gap_lebs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_tnc_end_commit - update the TNC for commit end.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * Write the dirty znodes.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_tnc_end_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">return_gap_lebs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">write_index</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>

	<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;TNC height is %d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">free_obsolete_znodes</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">cnext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ilebs</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">ilebs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
