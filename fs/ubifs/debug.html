<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ubifs › debug.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>debug.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is part of UBIFS.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Nokia Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="cm"> * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> *          Adrian Hunter</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file implements most of the debugging stuff which is compiled in only</span>
<span class="cm"> * when it is enabled. But some debugging check functions are implemented in</span>
<span class="cm"> * corresponding subsystem, just because they are closely related and utilize</span>
<span class="cm"> * various local functions of those subsystems.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/math64.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &quot;ubifs.h&quot;</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">dbg_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">get_key_fmt</span><span class="p">(</span><span class="kt">int</span> <span class="n">fmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">fmt</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UBIFS_SIMPLE_KEY_FMT</span>:
		<span class="k">return</span> <span class="s">&quot;simple&quot;</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="s">&quot;unknown/invalid format&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">get_key_hash</span><span class="p">(</span><span class="kt">int</span> <span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hash</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UBIFS_KEY_HASH_R5</span>:
		<span class="k">return</span> <span class="s">&quot;R5&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_KEY_HASH_TEST</span>:
		<span class="k">return</span> <span class="s">&quot;test&quot;</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="s">&quot;unknown/invalid name hash&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">get_key_type</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UBIFS_INO_KEY</span>:
		<span class="k">return</span> <span class="s">&quot;inode&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_DENT_KEY</span>:
		<span class="k">return</span> <span class="s">&quot;direntry&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_XENT_KEY</span>:
		<span class="k">return</span> <span class="s">&quot;xentry&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_DATA_KEY</span>:
		<span class="k">return</span> <span class="s">&quot;data&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_TRUN_KEY</span>:
		<span class="k">return</span> <span class="s">&quot;truncate&quot;</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="s">&quot;unknown/invalid key&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">get_dent_type</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UBIFS_ITYPE_REG</span>:
		<span class="k">return</span> <span class="s">&quot;file&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_ITYPE_DIR</span>:
		<span class="k">return</span> <span class="s">&quot;dir&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_ITYPE_LNK</span>:
		<span class="k">return</span> <span class="s">&quot;symlink&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_ITYPE_BLK</span>:
		<span class="k">return</span> <span class="s">&quot;blkdev&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_ITYPE_CHR</span>:
		<span class="k">return</span> <span class="s">&quot;char dev&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_ITYPE_FIFO</span>:
		<span class="k">return</span> <span class="s">&quot;fifo&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_ITYPE_SOCK</span>:
		<span class="k">return</span> <span class="s">&quot;socket&quot;</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="s">&quot;unknown/invalid type&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">dbg_snprintf_key</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">key_fmt</span> <span class="o">==</span> <span class="n">UBIFS_SIMPLE_KEY_FMT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">UBIFS_INO_KEY</span>:
			<span class="n">len</span> <span class="o">-=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;(%lu, %s)&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span>
					<span class="n">get_key_type</span><span class="p">(</span><span class="n">type</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">UBIFS_DENT_KEY</span>:
		<span class="k">case</span> <span class="n">UBIFS_XENT_KEY</span>:
			<span class="n">len</span> <span class="o">-=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;(%lu, %s, %#08x)&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span>
					<span class="n">get_key_type</span><span class="p">(</span><span class="n">type</span><span class="p">),</span> <span class="n">key_hash</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">UBIFS_DATA_KEY</span>:
			<span class="n">len</span> <span class="o">-=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;(%lu, %s, %u)&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span>
					<span class="n">get_key_type</span><span class="p">(</span><span class="n">type</span><span class="p">),</span> <span class="n">key_block</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">UBIFS_TRUN_KEY</span>:
			<span class="n">len</span> <span class="o">-=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;(%lu, %s)&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span>
					<span class="n">get_key_type</span><span class="p">(</span><span class="n">type</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">len</span> <span class="o">-=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;(bad key type: %#08x, %#08x)&quot;</span><span class="p">,</span>
					<span class="n">key</span><span class="o">-&gt;</span><span class="n">u32</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">u32</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;bad key format %d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">key_fmt</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">dbg_ntype</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UBIFS_PAD_NODE</span>:
		<span class="k">return</span> <span class="s">&quot;padding node&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_SB_NODE</span>:
		<span class="k">return</span> <span class="s">&quot;superblock node&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_MST_NODE</span>:
		<span class="k">return</span> <span class="s">&quot;master node&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_REF_NODE</span>:
		<span class="k">return</span> <span class="s">&quot;reference node&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_INO_NODE</span>:
		<span class="k">return</span> <span class="s">&quot;inode node&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_DENT_NODE</span>:
		<span class="k">return</span> <span class="s">&quot;direntry node&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_XENT_NODE</span>:
		<span class="k">return</span> <span class="s">&quot;xentry node&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_DATA_NODE</span>:
		<span class="k">return</span> <span class="s">&quot;data node&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_TRUN_NODE</span>:
		<span class="k">return</span> <span class="s">&quot;truncate node&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_IDX_NODE</span>:
		<span class="k">return</span> <span class="s">&quot;indexing node&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_CS_NODE</span>:
		<span class="k">return</span> <span class="s">&quot;commit start node&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_ORPH_NODE</span>:
		<span class="k">return</span> <span class="s">&quot;orphan node&quot;</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="s">&quot;unknown node&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">dbg_gtype</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UBIFS_NO_NODE_GROUP</span>:
		<span class="k">return</span> <span class="s">&quot;no node group&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_IN_NODE_GROUP</span>:
		<span class="k">return</span> <span class="s">&quot;in node group&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_LAST_OF_NODE_GROUP</span>:
		<span class="k">return</span> <span class="s">&quot;last of node group&quot;</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">dbg_cstate</span><span class="p">(</span><span class="kt">int</span> <span class="n">cmt_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmt_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">COMMIT_RESTING</span>:
		<span class="k">return</span> <span class="s">&quot;commit resting&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMMIT_BACKGROUND</span>:
		<span class="k">return</span> <span class="s">&quot;background commit requested&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMMIT_REQUIRED</span>:
		<span class="k">return</span> <span class="s">&quot;commit required&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMMIT_RUNNING_BACKGROUND</span>:
		<span class="k">return</span> <span class="s">&quot;BACKGROUND commit running&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMMIT_RUNNING_REQUIRED</span>:
		<span class="k">return</span> <span class="s">&quot;commit running and required&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMMIT_BROKEN</span>:
		<span class="k">return</span> <span class="s">&quot;broken commit&quot;</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="s">&quot;unknown commit state&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">dbg_jhead</span><span class="p">(</span><span class="kt">int</span> <span class="n">jhead</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">jhead</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">GCHD</span>:
		<span class="k">return</span> <span class="s">&quot;0 (GC)&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BASEHD</span>:
		<span class="k">return</span> <span class="s">&quot;1 (base)&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DATAHD</span>:
		<span class="k">return</span> <span class="s">&quot;2 (data)&quot;</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="s">&quot;unknown journal head&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dump_ch</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="o">*</span><span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">magic          %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">crc            %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">crc</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">node_type      %d (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">node_type</span><span class="p">,</span>
	       <span class="n">dbg_ntype</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">node_type</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">group_type     %d (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ch</span><span class="o">-&gt;</span><span class="n">group_type</span><span class="p">,</span>
	       <span class="n">dbg_gtype</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">group_type</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">sqnum          %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">sqnum</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">len            %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ubifs_dump_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">nm</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">};</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">dent</span><span class="p">,</span> <span class="o">*</span><span class="n">pdent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Dump in-memory inode:&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">inode          %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">size           %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">nlink          %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">uid            %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">gid            %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">atime          %u.%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">mtime          %u.%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">ctime          %u.%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">creat_sqnum    %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">creat_sqnum</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">xattr_size     %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">xattr_size</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">xattr_cnt      %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">xattr_cnt</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">xattr_names    %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">xattr_names</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">dirty          %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">xattr          %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">xattr</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">bulk_read      %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">xattr</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">synced_i_size  %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">synced_i_size</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">ui_size        %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_size</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">flags          %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">compr_type     %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">compr_type</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">last_page_read %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">last_page_read</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">read_in_a_row  %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">read_in_a_row</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">data_len       %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;List of directory entries:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">));</span>

	<span class="n">lowest_dent_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dent</span> <span class="o">=</span> <span class="n">ubifs_tnc_next_ent</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dent</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dent</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;error %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dent</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">%d: %s (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">count</span><span class="o">++</span><span class="p">,</span> <span class="n">dent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">get_dent_type</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">));</span>

		<span class="n">nm</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">dent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="n">nm</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">nlen</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pdent</span><span class="p">);</span>
		<span class="n">pdent</span> <span class="o">=</span> <span class="n">dent</span><span class="p">;</span>
		<span class="n">key_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pdent</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ubifs_dump_node</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="o">*</span><span class="n">ch</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">key_buf</span><span class="p">[</span><span class="n">DBG_KEY_BUF_LEN</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dbg_is_tst_rcvry</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* If the magic is incorrect, just hexdump the first bytes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">)</span> <span class="o">!=</span> <span class="n">UBIFS_NODE_MAGIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Not a node, first %zu bytes:&quot;</span><span class="p">,</span> <span class="n">UBIFS_CH_SZ</span><span class="p">);</span>
		<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_OFFSET</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">node</span><span class="p">,</span> <span class="n">UBIFS_CH_SZ</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbg_lock</span><span class="p">);</span>
	<span class="n">dump_ch</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">node_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UBIFS_PAD_NODE</span>:
	<span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_pad_node</span> <span class="o">*</span><span class="n">pad</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">pad_len        %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">pad</span><span class="o">-&gt;</span><span class="n">pad_len</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">UBIFS_SB_NODE</span>:
	<span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_sb_node</span> <span class="o">*</span><span class="n">sup</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sup_flags</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">key_hash       %d (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">key_hash</span><span class="p">,</span> <span class="n">get_key_hash</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">key_hash</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">key_fmt        %d (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">key_fmt</span><span class="p">,</span> <span class="n">get_key_fmt</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">key_fmt</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">flags          %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sup_flags</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">  big_lpt      %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="o">!!</span><span class="p">(</span><span class="n">sup_flags</span> <span class="o">&amp;</span> <span class="n">UBIFS_FLG_BIGLPT</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">  space_fixup  %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="o">!!</span><span class="p">(</span><span class="n">sup_flags</span> <span class="o">&amp;</span> <span class="n">UBIFS_FLG_SPACE_FIXUP</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">min_io_size    %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">leb_size       %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">leb_cnt        %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">max_leb_cnt    %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">max_leb_cnt</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">max_bud_bytes  %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">max_bud_bytes</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">log_lebs       %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">log_lebs</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">lpt_lebs       %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">lpt_lebs</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">orph_lebs      %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">orph_lebs</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">jhead_cnt      %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">fanout         %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">fanout</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">lsave_cnt      %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">default_compr  %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">default_compr</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">rp_size        %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">rp_size</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">rp_uid         %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">rp_uid</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">rp_gid         %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">rp_gid</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">fmt_version    %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">fmt_version</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">time_gran      %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sup</span><span class="o">-&gt;</span><span class="n">time_gran</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">UUID           %pUB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">sup</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">UBIFS_MST_NODE</span>:
	<span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_mst_node</span> <span class="o">*</span><span class="n">mst</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">highest_inum   %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">highest_inum</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">commit number  %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">cmt_no</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">flags          %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">log_lnum       %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">log_lnum</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">root_lnum      %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">root_lnum</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">root_offs      %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">root_offs</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">root_len       %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">root_len</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">gc_lnum        %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">gc_lnum</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">ihead_lnum     %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">ihead_lnum</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">ihead_offs     %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">ihead_offs</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">index_size     %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">index_size</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">lpt_lnum       %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">lpt_lnum</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">lpt_offs       %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">lpt_offs</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">nhead_lnum     %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">nhead_lnum</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">nhead_offs     %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">nhead_offs</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">ltab_lnum      %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">ltab_lnum</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">ltab_offs      %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">ltab_offs</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">lsave_lnum     %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">lsave_lnum</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">lsave_offs     %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">lsave_offs</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">lscan_lnum     %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">lscan_lnum</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">leb_cnt        %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">empty_lebs     %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">empty_lebs</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">idx_lebs       %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">idx_lebs</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">total_free     %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">total_free</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">total_dirty    %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">total_dirty</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">total_used     %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">total_used</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">total_dead     %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">total_dead</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">total_dark     %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">total_dark</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">UBIFS_REF_NODE</span>:
	<span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_ref_node</span> <span class="o">*</span><span class="n">ref</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">lnum           %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">offs           %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">jhead          %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">UBIFS_INO_NODE</span>:
	<span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_ino_node</span> <span class="o">*</span><span class="n">ino</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

		<span class="n">key_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">key            %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dbg_snprintf_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">key_buf</span><span class="p">,</span> <span class="n">DBG_KEY_BUF_LEN</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">creat_sqnum    %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">creat_sqnum</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">size           %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">nlink          %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">atime          %lld.%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">atime_sec</span><span class="p">),</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">atime_nsec</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">mtime          %lld.%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">mtime_sec</span><span class="p">),</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">mtime_nsec</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">ctime          %lld.%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">ctime_sec</span><span class="p">),</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">ctime_nsec</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">uid            %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">gid            %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">mode           %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">flags          %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">xattr_cnt      %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">xattr_cnt</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">xattr_size     %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">xattr_size</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">xattr_names    %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">xattr_names</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">compr_type     %#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">compr_type</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">data len       %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">UBIFS_DENT_NODE</span>:
	<span class="k">case</span> <span class="n">UBIFS_XENT_NODE</span>:
	<span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">dent</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nlen</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">nlen</span><span class="p">);</span>

		<span class="n">key_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">key            %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dbg_snprintf_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">key_buf</span><span class="p">,</span> <span class="n">DBG_KEY_BUF_LEN</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">inum           %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">type           %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">nlen           %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nlen</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">name           &quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nlen</span> <span class="o">&gt;</span> <span class="n">UBIFS_MAX_NLEN</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;(bad name length, not printing, &quot;</span>
					  <span class="s">&quot;bad or corrupted node)&quot;</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nlen</span> <span class="o">&amp;&amp;</span> <span class="n">dent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="n">dent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">UBIFS_DATA_NODE</span>:
	<span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_data_node</span> <span class="o">*</span><span class="n">dn</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">dlen</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">-</span> <span class="n">UBIFS_DATA_NODE_SZ</span><span class="p">;</span>

		<span class="n">key_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">key            %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dbg_snprintf_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">key_buf</span><span class="p">,</span> <span class="n">DBG_KEY_BUF_LEN</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">size           %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">compr_typ      %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">compr_type</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">data size      %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dlen</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">data:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_OFFSET</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">dlen</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">UBIFS_TRUN_NODE</span>:
	<span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_trun_node</span> <span class="o">*</span><span class="n">trun</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">inum           %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">trun</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">old_size       %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">trun</span><span class="o">-&gt;</span><span class="n">old_size</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">new_size       %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">trun</span><span class="o">-&gt;</span><span class="n">new_size</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">UBIFS_IDX_NODE</span>:
	<span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_idx_node</span> <span class="o">*</span><span class="n">idx</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

		<span class="n">n</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">idx</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">child_cnt      %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">level          %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">idx</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">Branches:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_branch</span> <span class="o">*</span><span class="n">br</span><span class="p">;</span>

			<span class="n">br</span> <span class="o">=</span> <span class="n">ubifs_idx_branch</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">key_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">%d: LEB %d:%d len %d key %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">i</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">),</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">),</span>
			       <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">),</span>
			       <span class="n">dbg_snprintf_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">key_buf</span><span class="p">,</span>
						<span class="n">DBG_KEY_BUF_LEN</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">UBIFS_CS_NODE</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_ORPH_NODE</span>:
	<span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_orph_node</span> <span class="o">*</span><span class="n">orph</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">commit number  %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
				<span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">orph</span><span class="o">-&gt;</span><span class="n">cmt_no</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LLONG_MAX</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">last node flag %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">orph</span><span class="o">-&gt;</span><span class="n">cmt_no</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">63</span><span class="p">);</span>
		<span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">-</span> <span class="n">UBIFS_ORPH_NODE_SZ</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">%d orphan inode numbers:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">  ino %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">orph</span><span class="o">-&gt;</span><span class="n">inos</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;node type %d was not recognized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">node_type</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbg_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ubifs_dump_budget_req</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_budget_req</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbg_lock</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Budgeting request: new_ino %d, dirtied_ino %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">req</span><span class="o">-&gt;</span><span class="n">new_ino</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dirtied_ino</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">new_ino_d   %d, dirtied_ino_d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">req</span><span class="o">-&gt;</span><span class="n">new_ino_d</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dirtied_ino_d</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">new_page    %d, dirtied_page %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">req</span><span class="o">-&gt;</span><span class="n">new_page</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dirtied_page</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">new_dent    %d, mod_dent     %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">req</span><span class="o">-&gt;</span><span class="n">new_dent</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">mod_dent</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">idx_growth  %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">idx_growth</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">data_growth %d dd_growth     %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">req</span><span class="o">-&gt;</span><span class="n">data_growth</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">dd_growth</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbg_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ubifs_dump_lstats</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lp_stats</span> <span class="o">*</span><span class="n">lst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbg_lock</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;(pid %d) Lprops statistics: empty_lebs %d, &quot;</span>
	       <span class="s">&quot;idx_lebs  %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">lst</span><span class="o">-&gt;</span><span class="n">empty_lebs</span><span class="p">,</span> <span class="n">lst</span><span class="o">-&gt;</span><span class="n">idx_lebs</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">taken_empty_lebs %d, total_free %lld, &quot;</span>
	       <span class="s">&quot;total_dirty %lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lst</span><span class="o">-&gt;</span><span class="n">taken_empty_lebs</span><span class="p">,</span> <span class="n">lst</span><span class="o">-&gt;</span><span class="n">total_free</span><span class="p">,</span>
	       <span class="n">lst</span><span class="o">-&gt;</span><span class="n">total_dirty</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">total_used %lld, total_dark %lld, &quot;</span>
	       <span class="s">&quot;total_dead %lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lst</span><span class="o">-&gt;</span><span class="n">total_used</span><span class="p">,</span> <span class="n">lst</span><span class="o">-&gt;</span><span class="n">total_dark</span><span class="p">,</span>
	       <span class="n">lst</span><span class="o">-&gt;</span><span class="n">total_dead</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbg_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ubifs_dump_budg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_budg_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">rb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_bud</span> <span class="o">*</span><span class="n">bud</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_gced_idx_leb</span> <span class="o">*</span><span class="n">idx_gc</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">available</span><span class="p">,</span> <span class="n">outstanding</span><span class="p">,</span> <span class="n">free</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbg_lock</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;(pid %d) Budgeting info: data budget sum %lld, &quot;</span>
	       <span class="s">&quot;total budget sum %lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
	       <span class="n">bi</span><span class="o">-&gt;</span><span class="n">data_growth</span> <span class="o">+</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">dd_growth</span><span class="p">,</span>
	       <span class="n">bi</span><span class="o">-&gt;</span><span class="n">data_growth</span> <span class="o">+</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">dd_growth</span> <span class="o">+</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">idx_growth</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">budg_data_growth %lld, budg_dd_growth %lld, &quot;</span>
	       <span class="s">&quot;budg_idx_growth %lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">data_growth</span><span class="p">,</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">dd_growth</span><span class="p">,</span>
	       <span class="n">bi</span><span class="o">-&gt;</span><span class="n">idx_growth</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">min_idx_lebs %d, old_idx_sz %llu, &quot;</span>
	       <span class="s">&quot;uncommitted_idx %lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">min_idx_lebs</span><span class="p">,</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">old_idx_sz</span><span class="p">,</span>
	       <span class="n">bi</span><span class="o">-&gt;</span><span class="n">uncommitted_idx</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">page_budget %d, inode_budget %d, dent_budget %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">bi</span><span class="o">-&gt;</span><span class="n">page_budget</span><span class="p">,</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">inode_budget</span><span class="p">,</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">dent_budget</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">nospace %u, nospace_rp %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">bi</span><span class="o">-&gt;</span><span class="n">nospace</span><span class="p">,</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">nospace_rp</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">dark_wm %d, dead_wm %d, max_idx_node_sz %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">c</span><span class="o">-&gt;</span><span class="n">dark_wm</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dead_wm</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_idx_node_sz</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bi</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we are dumping saved budgeting data, do not print</span>
<span class="cm">		 * additional information which is about the current state, not</span>
<span class="cm">		 * the old one which corresponded to the saved budgeting data.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">freeable_cnt %d, calc_idx_sz %lld, idx_gc_cnt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_cnt</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">calc_idx_sz</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_gc_cnt</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">dirty_pg_cnt %ld, dirty_zn_cnt %ld, &quot;</span>
	       <span class="s">&quot;clean_zn_cnt %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_pg_cnt</span><span class="p">),</span>
	       <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_zn_cnt</span><span class="p">),</span>
	       <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">clean_zn_cnt</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">gc_lnum %d, ihead_lnum %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ihead_lnum</span><span class="p">);</span>

	<span class="cm">/* If we are in R/O mode, journal heads do not exist */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">jhead %s</span><span class="se">\t</span><span class="s"> LEB %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">dbg_jhead</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wbuf</span><span class="p">.</span><span class="n">jhead</span><span class="p">),</span>
			       <span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wbuf</span><span class="p">.</span><span class="n">lnum</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">rb</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">buds</span><span class="p">);</span> <span class="n">rb</span><span class="p">;</span> <span class="n">rb</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">rb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bud</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">rb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_bud</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">bud LEB %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bud</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">bud</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">old_buds</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">old bud LEB %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bud</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">idx_gc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_gc</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">GC&#39;ed idx LEB %d unmap %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">idx_gc</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">idx_gc</span><span class="o">-&gt;</span><span class="n">unmap</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">commit state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span><span class="p">);</span>

	<span class="cm">/* Print budgeting predictions */</span>
	<span class="n">available</span> <span class="o">=</span> <span class="n">ubifs_calc_available</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">min_idx_lebs</span><span class="p">);</span>
	<span class="n">outstanding</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">data_growth</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">dd_growth</span><span class="p">;</span>
	<span class="n">free</span> <span class="o">=</span> <span class="n">ubifs_get_free_space_nolock</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Budgeting predictions:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">available: %lld, outstanding %lld, free %lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">available</span><span class="p">,</span> <span class="n">outstanding</span><span class="p">,</span> <span class="n">free</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbg_lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ubifs_dump_lprop</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">spc</span><span class="p">,</span> <span class="n">dark</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">rb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_bud</span> <span class="o">*</span><span class="n">bud</span><span class="p">;</span>

	<span class="n">spc</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">+</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spc</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dead_wm</span><span class="p">)</span>
		<span class="n">dead</span> <span class="o">=</span> <span class="n">spc</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">dark</span> <span class="o">=</span> <span class="n">ubifs_calc_dark</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">spc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;LEB %-7d free %-8d dirty %-8d used %-8d &quot;</span>
		       <span class="s">&quot;free + dirty %-8d flags %#x (&quot;</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span>
		       <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">spc</span><span class="p">,</span> <span class="n">spc</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;LEB %-7d free %-8d dirty %-8d used %-8d &quot;</span>
		       <span class="s">&quot;free + dirty %-8d dark %-4d dead %-4d nodes fit %-3d &quot;</span>
		       <span class="s">&quot;flags %#-4x (&quot;</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">,</span>
		       <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">spc</span><span class="p">,</span> <span class="n">spc</span><span class="p">,</span> <span class="n">dark</span><span class="p">,</span> <span class="n">dead</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">spc</span> <span class="o">/</span> <span class="n">UBIFS_MAX_NODE_SZ</span><span class="p">),</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_TAKEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;index, taken&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;taken&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_CAT_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">LPROPS_DIRTY_IDX</span>:
				<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;dirty index&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">LPROPS_FRDI_IDX</span>:
				<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;freeable index&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;index&quot;</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_CAT_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">LPROPS_UNCAT</span>:
				<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;not categorized&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">LPROPS_DIRTY</span>:
				<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;dirty&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">LPROPS_FREE</span>:
				<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;free&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">LPROPS_EMPTY</span>:
				<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;empty&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">LPROPS_FREEABLE</span>:
				<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;freeable&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">rb</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">((</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">buds</span><span class="p">);</span> <span class="n">rb</span><span class="p">;</span> <span class="n">rb</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">rb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bud</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">rb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_bud</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bud</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Note, if we are in R/O mode or in the middle</span>
<span class="cm">				 * of mounting/re-mounting, the write-buffers do</span>
<span class="cm">				 * not exist.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span> <span class="o">&amp;&amp;</span>
				    <span class="n">lp</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wbuf</span><span class="p">.</span><span class="n">lnum</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;, jhead %s&quot;</span><span class="p">,</span>
					       <span class="n">dbg_jhead</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
					<span class="n">head</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;, bud of jhead %s&quot;</span><span class="p">,</span>
				       <span class="n">dbg_jhead</span><span class="p">(</span><span class="n">bud</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_lnum</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;, GC LEB&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ubifs_dump_lprops</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="n">lp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_lp_stats</span> <span class="n">lst</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;(pid %d) start dumping LEB properties</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">ubifs_get_lp_stats</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lst</span><span class="p">);</span>
	<span class="n">ubifs_dump_lstats</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lst</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">main_first</span><span class="p">;</span> <span class="n">lnum</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_cnt</span><span class="p">;</span> <span class="n">lnum</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_read_one_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot read lprops for LEB %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>

		<span class="n">ubifs_dump_lprop</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;(pid %d) finish dumping LEB properties</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ubifs_dump_lpt_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbg_lock</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;(pid %d) dumping LPT information</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">lpt_sz:        %lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_sz</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">pnode_sz:      %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">pnode_sz</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">nnode_sz:      %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nnode_sz</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">ltab_sz:       %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_sz</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">lsave_sz:      %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_sz</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">big_lpt:       %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">big_lpt</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">lpt_hght:      %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_hght</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">pnode_cnt:     %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">pnode_cnt</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">nnode_cnt:     %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nnode_cnt</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">dirty_pn_cnt:  %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_pn_cnt</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">dirty_nn_cnt:  %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_nn_cnt</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">lsave_cnt:     %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_cnt</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">space_bits:    %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">space_bits</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">lpt_lnum_bits: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lnum_bits</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">lpt_offs_bits: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_offs_bits</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">lpt_spc_bits:  %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_spc_bits</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">pcnt_bits:     %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">pcnt_bits</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">lnum_bits:     %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lnum_bits</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">LPT root is at %d:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_offs</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">LPT head is at %d:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_offs</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">LPT ltab is at %d:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_offs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">big_lpt</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">LPT lsave is at %d:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_offs</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lebs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">LPT LEB %d free %d dirty %d tgc %d &quot;</span>
		       <span class="s">&quot;cmt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">free</span><span class="p">,</span>
		       <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dirty</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tgc</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmt</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbg_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ubifs_dump_sleb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">sleb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_scan_node</span> <span class="o">*</span><span class="n">snod</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;(pid %d) start dumping scanned data from LEB %d:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">snod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Dumping node at LEB %d:%d len %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span>
		       <span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ubifs_dump_leb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">sleb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_scan_node</span> <span class="o">*</span><span class="n">snod</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dbg_is_tst_rcvry</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;(pid %d) start dumping LEB %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">__vmalloc</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">,</span> <span class="n">PAGE_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot allocate memory for dumping LEB %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sleb</span> <span class="o">=</span> <span class="n">ubifs_scan</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sleb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;scan error %d&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sleb</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;LEB %d has %d nodes ending at %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span>
	       <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes_cnt</span><span class="p">,</span> <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">endpt</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">snod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Dumping node at LEB %d:%d len %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span>
		       <span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;(pid %d) finish dumping LEB %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="n">ubifs_scan_destroy</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ubifs_dump_znode</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">key_buf</span><span class="p">[</span><span class="n">DBG_KEY_BUF_LEN</span><span class="p">];</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbg_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;znode %p, LEB %d:%d len %d parent %p iip %d level %d&quot;</span>
	       <span class="s">&quot; child_cnt %d flags %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span>
	       <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span><span class="p">,</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">,</span>
	       <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">,</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbg_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;zbranches:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">%d: znode %p LEB %d:%d len %d key &quot;</span>
					  <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span>
					  <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
					  <span class="n">dbg_snprintf_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span>
							   <span class="n">key_buf</span><span class="p">,</span>
							   <span class="n">DBG_KEY_BUF_LEN</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">%d: LNC %p LEB %d:%d len %d key &quot;</span>
					  <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span>
					  <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
					  <span class="n">dbg_snprintf_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span>
							   <span class="n">key_buf</span><span class="p">,</span>
							   <span class="n">DBG_KEY_BUF_LEN</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbg_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ubifs_dump_heap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_lpt_heap</span> <span class="o">*</span><span class="n">heap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;(pid %d) start dumping heap cat %d (%d elements)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">cat</span><span class="p">,</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lprops</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">%d. LEB %d hpos %d free %d dirty %d &quot;</span>
		       <span class="s">&quot;flags %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">hpos</span><span class="p">,</span>
		       <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">,</span> <span class="n">lprops</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;(pid %d) finish dumping heap</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ubifs_dump_pnode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_pnode</span> <span class="o">*</span><span class="n">pnode</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">ubifs_nnode</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;(pid %d) dumping pnode:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">address %zx parent %zx cnext %zx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">pnode</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">parent</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">cnext</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">flags %lu iip %d level %d num %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">iip</span><span class="p">,</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">,</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UBIFS_LPT_FANOUT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">lprops</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">%d: free %d dirty %d flags %d lnum %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">i</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ubifs_dump_tnc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;(pid %d) start dumping TNC tree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">znode</span> <span class="o">=</span> <span class="n">ubifs_tnc_levelorder_next</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">level</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;== Level %d ==</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">znode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">!=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">level</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;== Level %d ==</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ubifs_dump_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">ubifs_tnc_levelorder_next</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;(pid %d) finish dumping TNC tree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dump_znode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">,</span>
		      <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ubifs_dump_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_dump_index - dump the on-flash index.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function dumps whole UBIFS indexing B-tree, unlike &#39;ubifs_dump_tnc()&#39;</span>
<span class="cm"> * which dumps only in-memory znodes and does not read znodes which from flash.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubifs_dump_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dbg_walk_index</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">dump_znode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_save_space_info - save information about flash space.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function saves information about UBIFS free space, dirty space, etc, in</span>
<span class="cm"> * order to check it later.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dbg_save_space_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_debug_info</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">freeable_cnt</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">saved_lst</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lst</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_lp_stats</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">saved_bi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_budg_info</span><span class="p">));</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">saved_idx_gc_cnt</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">idx_gc_cnt</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We use a dirty hack here and zero out @c-&gt;freeable_cnt, because it</span>
<span class="cm">	 * affects the free space calculations, and UBIFS might not know about</span>
<span class="cm">	 * all freeable eraseblocks. Indeed, we know about freeable eraseblocks</span>
<span class="cm">	 * only when we read their lprops, and we do this only lazily, upon the</span>
<span class="cm">	 * need. So at any given point of time @c-&gt;freeable_cnt might be not</span>
<span class="cm">	 * exactly accurate.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Just one example about the issue we hit when we did not zero</span>
<span class="cm">	 * @c-&gt;freeable_cnt.</span>
<span class="cm">	 * 1. The file-system is mounted R/O, c-&gt;freeable_cnt is %0. We save the</span>
<span class="cm">	 *    amount of free space in @d-&gt;saved_free</span>
<span class="cm">	 * 2. We re-mount R/W, which makes UBIFS to read the &quot;lsave&quot;</span>
<span class="cm">	 *    information from flash, where we cache LEBs from various</span>
<span class="cm">	 *    categories (&#39;ubifs_remount_fs()&#39; -&gt; &#39;ubifs_lpt_init()&#39;</span>
<span class="cm">	 *    -&gt; &#39;lpt_init_wr()&#39; -&gt; &#39;read_lsave()&#39; -&gt; &#39;ubifs_lpt_lookup()&#39;</span>
<span class="cm">	 *    -&gt; &#39;ubifs_get_pnode()&#39; -&gt; &#39;update_cats()&#39;</span>
<span class="cm">	 *    -&gt; &#39;ubifs_add_to_cat()&#39;).</span>
<span class="cm">	 * 3. Lsave contains a freeable eraseblock, and @c-&gt;freeable_cnt</span>
<span class="cm">	 *    becomes %1.</span>
<span class="cm">	 * 4. We calculate the amount of free space when the re-mount is</span>
<span class="cm">	 *    finished in &#39;dbg_check_space_info()&#39; and it does not match</span>
<span class="cm">	 *    @d-&gt;saved_free.</span>
<span class="cm">	 */</span>
	<span class="n">freeable_cnt</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_cnt</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">saved_free</span> <span class="o">=</span> <span class="n">ubifs_get_free_space_nolock</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_cnt</span> <span class="o">=</span> <span class="n">freeable_cnt</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_check_space_info - check flash space information.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function compares current flash space information with the information</span>
<span class="cm"> * which was saved when the &#39;dbg_save_space_info()&#39; function was called.</span>
<span class="cm"> * Returns zero if the information has not changed, and %-EINVAL it it has</span>
<span class="cm"> * changed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbg_check_space_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_debug_info</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_lp_stats</span> <span class="n">lst</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">free</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">freeable_cnt</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>
	<span class="n">freeable_cnt</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_cnt</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">free</span> <span class="o">=</span> <span class="n">ubifs_get_free_space_nolock</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">freeable_cnt</span> <span class="o">=</span> <span class="n">freeable_cnt</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">space_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">!=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">saved_free</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;free space changed from %lld to %lld&quot;</span><span class="p">,</span>
			  <span class="n">d</span><span class="o">-&gt;</span><span class="n">saved_free</span><span class="p">,</span> <span class="n">free</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;saved lprops statistics dump&quot;</span><span class="p">);</span>
	<span class="n">ubifs_dump_lstats</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">saved_lst</span><span class="p">);</span>
	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;saved budgeting info dump&quot;</span><span class="p">);</span>
	<span class="n">ubifs_dump_budg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">saved_bi</span><span class="p">);</span>
	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;saved idx_gc_cnt %d&quot;</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">saved_idx_gc_cnt</span><span class="p">);</span>
	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;current lprops statistics dump&quot;</span><span class="p">);</span>
	<span class="n">ubifs_get_lp_stats</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lst</span><span class="p">);</span>
	<span class="n">ubifs_dump_lstats</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lst</span><span class="p">);</span>
	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;current budgeting info dump&quot;</span><span class="p">);</span>
	<span class="n">ubifs_dump_budg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_check_synced_i_size - check synchronized inode size.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @inode: inode to check</span>
<span class="cm"> *</span>
<span class="cm"> * If inode is clean, synchronized inode size has to be equivalent to current</span>
<span class="cm"> * inode size. This function has to be called only for locked inodes (@i_mutex</span>
<span class="cm"> * has to be locked). Returns %0 if synchronized inode size if correct, and</span>
<span class="cm"> * %-EINVAL if not.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbg_check_synced_i_size</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_chk_gen</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">!=</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">synced_i_size</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;ui_size is %lld, synced_i_size is %lld, but inode &quot;</span>
			  <span class="s">&quot;is clean&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_size</span><span class="p">,</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">synced_i_size</span><span class="p">);</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;i_ino %lu, i_mode %#x, i_size %lld&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
			  <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_lock</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * dbg_check_dir - check directory inode size and link count.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @dir: the directory to calculate size for</span>
<span class="cm"> * @size: the result is returned here</span>
<span class="cm"> *</span>
<span class="cm"> * This function makes sure that directory size and link count are correct.</span>
<span class="cm"> * Returns zero in case of success and a negative error code in case of</span>
<span class="cm"> * failure.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, it is good idea to make sure the @dir-&gt;i_mutex is locked before</span>
<span class="cm"> * calling this function.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbg_check_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nlink</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">dent</span><span class="p">,</span> <span class="o">*</span><span class="n">pdent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">nm</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span> <span class="p">};</span>
	<span class="n">loff_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">UBIFS_INO_NODE_SZ</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_chk_gen</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lowest_dent_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">dent</span> <span class="o">=</span> <span class="n">ubifs_tnc_next_ent</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dent</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dent</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">nm</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">dent</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="n">nm</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">nlen</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">CALC_DENT_SIZE</span><span class="p">(</span><span class="n">nm</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_ITYPE_DIR</span><span class="p">)</span>
			<span class="n">nlink</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pdent</span><span class="p">);</span>
		<span class="n">pdent</span> <span class="o">=</span> <span class="n">dent</span><span class="p">;</span>
		<span class="n">key_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pdent</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span> <span class="o">!=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;directory inode %lu has size %llu, &quot;</span>
			  <span class="s">&quot;but calculated size is %llu&quot;</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">dir</span><span class="p">),</span>
			  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">size</span><span class="p">);</span>
		<span class="n">ubifs_dump_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">!=</span> <span class="n">nlink</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;directory inode %lu has nlink %u, but calculated &quot;</span>
			  <span class="s">&quot;nlink is %u&quot;</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">,</span> <span class="n">nlink</span><span class="p">);</span>
		<span class="n">ubifs_dump_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_check_key_order - make sure that colliding keys are properly ordered.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @zbr1: first zbranch</span>
<span class="cm"> * @zbr2: following zbranch</span>
<span class="cm"> *</span>
<span class="cm"> * In UBIFS indexing B-tree colliding keys has to be sorted in binary order of</span>
<span class="cm"> * names of the direntries/xentries which are referred by the keys. This</span>
<span class="cm"> * function reads direntries/xentries referred by @zbr1 and @zbr2 and makes</span>
<span class="cm"> * sure the name of direntry/xentry referred by @zbr1 is less than</span>
<span class="cm"> * direntry/xentry referred by @zbr2. Returns zero if this is true, %1 if not,</span>
<span class="cm"> * and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_check_key_order</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr1</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">nlen1</span><span class="p">,</span> <span class="n">nlen2</span><span class="p">,</span> <span class="n">cmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">dent1</span><span class="p">,</span> <span class="o">*</span><span class="n">dent2</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">key_buf</span><span class="p">[</span><span class="n">DBG_KEY_BUF_LEN</span><span class="p">];</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr1</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr2</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">));</span>
	<span class="n">dent1</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">UBIFS_MAX_DENT_NODE_SZ</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dent1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">dent2</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">UBIFS_MAX_DENT_NODE_SZ</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dent2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_read_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr1</span><span class="p">,</span> <span class="n">dent1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_validate_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dent1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_read_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr2</span><span class="p">,</span> <span class="n">dent2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_validate_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dent2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="cm">/* Make sure node keys are the same as in zbranch */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">key_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dent1</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr1</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;1st entry at %d:%d has key %s&quot;</span><span class="p">,</span> <span class="n">zbr1</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span>
			  <span class="n">zbr1</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">dbg_snprintf_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">key_buf</span><span class="p">,</span>
						       <span class="n">DBG_KEY_BUF_LEN</span><span class="p">));</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;but it should have key %s according to tnc&quot;</span><span class="p">,</span>
			  <span class="n">dbg_snprintf_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr1</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">key_buf</span><span class="p">,</span>
					   <span class="n">DBG_KEY_BUF_LEN</span><span class="p">));</span>
		<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dent1</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">key_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dent2</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr2</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;2nd entry at %d:%d has key %s&quot;</span><span class="p">,</span> <span class="n">zbr1</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span>
			  <span class="n">zbr1</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">dbg_snprintf_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">key_buf</span><span class="p">,</span>
						       <span class="n">DBG_KEY_BUF_LEN</span><span class="p">));</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;but it should have key %s according to tnc&quot;</span><span class="p">,</span>
			  <span class="n">dbg_snprintf_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr2</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">key_buf</span><span class="p">,</span>
					   <span class="n">DBG_KEY_BUF_LEN</span><span class="p">));</span>
		<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dent2</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nlen1</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dent1</span><span class="o">-&gt;</span><span class="n">nlen</span><span class="p">);</span>
	<span class="n">nlen2</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dent2</span><span class="o">-&gt;</span><span class="n">nlen</span><span class="p">);</span>

	<span class="n">cmp</span> <span class="o">=</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">dent1</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dent2</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">nlen1</span><span class="p">,</span> <span class="n">nlen2</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nlen1</span> <span class="o">&lt;</span> <span class="n">nlen2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nlen1</span> <span class="o">==</span> <span class="n">nlen2</span><span class="p">)</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;2 xent/dent nodes with the same name&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad order of colliding key %s&quot;</span><span class="p">,</span>
			  <span class="n">dbg_snprintf_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">key_buf</span><span class="p">,</span> <span class="n">DBG_KEY_BUF_LEN</span><span class="p">));</span>

	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;first node at %d:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">zbr1</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr1</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
	<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dent1</span><span class="p">);</span>
	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;second node at %d:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">zbr2</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr2</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
	<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dent2</span><span class="p">);</span>

<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dent2</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dent1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_check_znode - check if znode is all right.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @zbr: zbranch which points to this znode</span>
<span class="cm"> *</span>
<span class="cm"> * This function makes sure that znode referred to by @zbr is all right.</span>
<span class="cm"> * Returns zero if it is, and %-EINVAL if it is not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dbg_check_znode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span> <span class="o">=</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">zp</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">cmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* Only dirty zbranch may have no on-flash nodes */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ubifs_zn_dirty</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ubifs_zn_dirty</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If znode is dirty, its parent has to be dirty as well. The</span>
<span class="cm">		 * order of the operation is important, so we have to have</span>
<span class="cm">		 * memory barriers.</span>
<span class="cm">		 */</span>
		<span class="n">smp_mb</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zp</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ubifs_zn_dirty</span><span class="p">(</span><span class="n">zp</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The dirty flag is atomic and is cleared outside the</span>
<span class="cm">			 * TNC mutex, so znode&#39;s dirty flag may now have</span>
<span class="cm">			 * been cleared. The child is always cleared before the</span>
<span class="cm">			 * parent, so we just need to check again.</span>
<span class="cm">			 */</span>
			<span class="n">smp_mb</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ubifs_zn_dirty</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">zp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">min</span><span class="p">,</span> <span class="o">*</span><span class="n">max</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">!=</span> <span class="n">zp</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Make sure the &#39;parent&#39; pointer in our znode is correct */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_search_zbranch</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This zbranch does not exist in the parent */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">&gt;=</span> <span class="n">zp</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">!=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This may happen only in case of collisions */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zp</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">key</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">zp</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span><span class="p">].</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Make sure that the first key in our znode is greater than or</span>
<span class="cm">		 * equal to the key in the pointing zbranch.</span>
<span class="cm">		 */</span>
		<span class="n">min</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
		<span class="n">cmp</span> <span class="o">=</span> <span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">zp</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">max</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">zp</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Make sure the last key in our znode is less or</span>
<span class="cm">			 * equivalent than the key in the zbranch which goes</span>
<span class="cm">			 * after our pointing zbranch.</span>
<span class="cm">			 */</span>
			<span class="n">cmp</span> <span class="o">=</span> <span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">key</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* This may only be root znode */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zbr</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure that next key is greater or equivalent then the previous</span>
<span class="cm">	 * one.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmp</span> <span class="o">=</span> <span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">key</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">key</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This can only be keys with colliding hash */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_hash_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">replaying</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Colliding keys should follow binary order of</span>
<span class="cm">			 * corresponding xentry/dentry names.</span>
<span class="cm">			 */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_key_order</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
						  <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">znode</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">lnum</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
		     <span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">lnum</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">lnum</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">lnum</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">offs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">19</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">znode</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">!=</span> <span class="n">znode</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;failed, error %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;dump of the znode&quot;</span><span class="p">);</span>
	<span class="n">ubifs_dump_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;dump of the parent znode&quot;</span><span class="p">);</span>
		<span class="n">ubifs_dump_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dump_stack</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_check_tnc - check TNC tree.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @extra: do extra checks that are possible at start commit</span>
<span class="cm"> *</span>
<span class="cm"> * This function traverses whole TNC tree and checks every znode. Returns zero</span>
<span class="cm"> * if everything is all right and %-EINVAL if something is wrong with TNC.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbg_check_tnc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">extra</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">clean_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dirty_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">last</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_chk_index</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">znode</span> <span class="o">=</span> <span class="n">ubifs_tnc_postorder_first</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
			<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span><span class="p">];</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">extra</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ubifs_zn_dirty</span><span class="p">(</span><span class="n">znode</span><span class="p">))</span>
				<span class="n">dirty_cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">clean_cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">prev</span> <span class="o">=</span> <span class="n">znode</span><span class="p">;</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">ubifs_tnc_postorder_next</span><span class="p">(</span><span class="n">znode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">znode</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the last key of this znode is equivalent to the first key</span>
<span class="cm">		 * of the next znode (collision), then check order of the keys.</span>
<span class="cm">		 */</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">child_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">replaying</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">last</span><span class="p">].</span><span class="n">key</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_key_order</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">last</span><span class="p">],</span>
						  <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;first znode&quot;</span><span class="p">);</span>
				<span class="n">ubifs_dump_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
				<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;second znode&quot;</span><span class="p">);</span>
				<span class="n">ubifs_dump_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">extra</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clean_cnt</span> <span class="o">!=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">clean_zn_cnt</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;incorrect clean_zn_cnt %ld, calculated %ld&quot;</span><span class="p">,</span>
				  <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">clean_zn_cnt</span><span class="p">),</span>
				  <span class="n">clean_cnt</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dirty_cnt</span> <span class="o">!=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_zn_cnt</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;incorrect dirty_zn_cnt %ld, calculated %ld&quot;</span><span class="p">,</span>
				  <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_zn_cnt</span><span class="p">),</span>
				  <span class="n">dirty_cnt</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_walk_index - walk the on-flash index.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @leaf_cb: called for each leaf node</span>
<span class="cm"> * @znode_cb: called for each indexing node</span>
<span class="cm"> * @priv: private data which is passed to callbacks</span>
<span class="cm"> *</span>
<span class="cm"> * This function walks the UBIFS index and calls the @leaf_cb for each leaf</span>
<span class="cm"> * node and @znode_cb for each indexing node. Returns zero in case of success</span>
<span class="cm"> * and a negative error code in case of failure.</span>
<span class="cm"> *</span>
<span class="cm"> * It would be better if this function removed every znode it pulled to into</span>
<span class="cm"> * the TNC, so that the behavior more closely matched the non-debugging</span>
<span class="cm"> * behavior.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbg_walk_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">dbg_leaf_callback</span> <span class="n">leaf_cb</span><span class="p">,</span>
		   <span class="n">dbg_znode_callback</span> <span class="n">znode_cb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">,</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="cm">/* If the root indexing node is not in TNC - pull it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span> <span class="o">=</span> <span class="n">ubifs_load_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="p">);</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are going to traverse the indexing tree in the postorder manner.</span>
<span class="cm">	 * Go down and find the leftmost indexing node where we are going to</span>
<span class="cm">	 * start from.</span>
<span class="cm">	 */</span>
	<span class="n">znode</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">child</span> <span class="o">=</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">child</span> <span class="o">=</span> <span class="n">ubifs_load_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">child</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">znode</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Iterate over all indexing nodes */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">znode_cb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">znode_cb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;znode checking function returned &quot;</span>
					  <span class="s">&quot;error %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
				<span class="n">ubifs_dump_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">leaf_cb</span> <span class="o">&amp;&amp;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">leaf_cb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;leaf checking function &quot;</span>
						  <span class="s">&quot;returned error %d, for leaf &quot;</span>
						  <span class="s">&quot;at LEB %d:%d&quot;</span><span class="p">,</span>
						  <span class="n">err</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">idx</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">znode</span> <span class="o">=</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Switch to the next index in the parent */</span>
			<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
			<span class="n">child</span> <span class="o">=</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">child</span> <span class="o">=</span> <span class="n">ubifs_load_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">child</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">znode</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="cm">/*</span>
<span class="cm">			 * This is the last child, switch to the parent and</span>
<span class="cm">			 * continue.</span>
<span class="cm">			 */</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Go to the lowest leftmost znode in the new sub-tree */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">child</span> <span class="o">=</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">child</span> <span class="o">=</span> <span class="n">ubifs_load_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">,</span> <span class="n">znode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">child</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">zbr</span><span class="o">-&gt;</span><span class="n">znode</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">znode</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_dump:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">iip</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">;</span>
	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;dump of znode at LEB %d:%d&quot;</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
	<span class="n">ubifs_dump_znode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * add_size - add znode size to partially calculated index size.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @znode: znode to add size for</span>
<span class="cm"> * @priv: partially calculated index size</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function for &#39;dbg_check_idx_size()&#39; which is called for</span>
<span class="cm"> * every indexing node and adds its size to the &#39;long long&#39; variable pointed to</span>
<span class="cm"> * by @priv.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">idx_size</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">add</span><span class="p">;</span>

	<span class="n">add</span> <span class="o">=</span> <span class="n">ubifs_idx_node_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">znode</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">);</span>
	<span class="n">add</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="o">*</span><span class="n">idx_size</span> <span class="o">+=</span> <span class="n">add</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_check_idx_size - check index size.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @idx_size: size to check</span>
<span class="cm"> *</span>
<span class="cm"> * This function walks the UBIFS index, calculates its size and checks that the</span>
<span class="cm"> * size is equivalent to @idx_size. Returns zero in case of success and a</span>
<span class="cm"> * negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbg_check_idx_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">idx_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">calc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_chk_index</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_walk_index</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">add_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">calc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;error %d while walking the index&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">calc</span> <span class="o">!=</span> <span class="n">idx_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;index size check failed: calculated size is %lld, &quot;</span>
			  <span class="s">&quot;should be %lld&quot;</span><span class="p">,</span> <span class="n">calc</span><span class="p">,</span> <span class="n">idx_size</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * struct fsck_inode - information about an inode used when checking the file-system.</span>
<span class="cm"> * @rb: link in the RB-tree of inodes</span>
<span class="cm"> * @inum: inode number</span>
<span class="cm"> * @mode: inode type, permissions, etc</span>
<span class="cm"> * @nlink: inode link count</span>
<span class="cm"> * @xattr_cnt: count of extended attributes</span>
<span class="cm"> * @references: how many directory/xattr entries refer this inode (calculated</span>
<span class="cm"> *              while walking the index)</span>
<span class="cm"> * @calc_cnt: for directory inode count of child directories</span>
<span class="cm"> * @size: inode size (read from on-flash inode)</span>
<span class="cm"> * @xattr_sz: summary size of all extended attributes (read from on-flash</span>
<span class="cm"> *            inode)</span>
<span class="cm"> * @calc_sz: for directories calculated directory size</span>
<span class="cm"> * @calc_xcnt: count of extended attributes</span>
<span class="cm"> * @calc_xsz: calculated summary size of all extended attributes</span>
<span class="cm"> * @xattr_nms: sum of lengths of all extended attribute names belonging to this</span>
<span class="cm"> *             inode (read from on-flash inode)</span>
<span class="cm"> * @calc_xnms: calculated sum of lengths of all extended attribute names</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fsck_inode</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rb</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">inum</span><span class="p">;</span>
	<span class="n">umode_t</span> <span class="n">mode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nlink</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xattr_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">references</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">calc_cnt</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xattr_sz</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">calc_sz</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">calc_xcnt</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">calc_xsz</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xattr_nms</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">calc_xnms</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct fsck_data - private FS checking information.</span>
<span class="cm"> * @inodes: RB-tree of all inodes (contains @struct fsck_inode objects)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fsck_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">inodes</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * add_inode - add inode information to RB-tree of inodes.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @fsckd: FS checking information</span>
<span class="cm"> * @ino: raw UBIFS inode to add</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function for &#39;check_leaf()&#39; which adds information about</span>
<span class="cm"> * inode @ino to the RB-tree of inodes. Returns inode information pointer in</span>
<span class="cm"> * case of success and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fsck_inode</span> <span class="o">*</span><span class="nf">add_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">fsck_data</span> <span class="o">*</span><span class="n">fsckd</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ubifs_ino_node</span> <span class="o">*</span><span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsck_inode</span> <span class="o">*</span><span class="n">fscki</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">inum</span> <span class="o">=</span> <span class="n">key_inum_flash</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fsckd</span><span class="o">-&gt;</span><span class="n">inodes</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">fscki</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsck_inode</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">&lt;</span> <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">&gt;</span> <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">fscki</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">highest_inum</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;too high inode number, max. is %lu&quot;</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">highest_inum</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">fscki</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsck_inode</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fscki</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">ilookup</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vfs_sb</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>

	<span class="n">fscki</span><span class="o">-&gt;</span><span class="n">inum</span> <span class="o">=</span> <span class="n">inum</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the inode is present in the VFS inode cache, use it instead of</span>
<span class="cm">	 * the on-flash inode which might be out-of-date. E.g., the size might</span>
<span class="cm">	 * be out-of-date. If we do not do this, the following may happen, for</span>
<span class="cm">	 * example:</span>
<span class="cm">	 *   1. A power cut happens</span>
<span class="cm">	 *   2. We mount the file-system R/O, the replay process fixes up the</span>
<span class="cm">	 *      inode size in the VFS cache, but on on-flash.</span>
<span class="cm">	 *   3. &#39;check_leaf()&#39; fails because it hits a data node beyond inode</span>
<span class="cm">	 *      size.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fscki</span><span class="o">-&gt;</span><span class="n">nlink</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="p">);</span>
		<span class="n">fscki</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
		<span class="n">fscki</span><span class="o">-&gt;</span><span class="n">xattr_cnt</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">xattr_cnt</span><span class="p">);</span>
		<span class="n">fscki</span><span class="o">-&gt;</span><span class="n">xattr_sz</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">xattr_size</span><span class="p">);</span>
		<span class="n">fscki</span><span class="o">-&gt;</span><span class="n">xattr_nms</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">xattr_names</span><span class="p">);</span>
		<span class="n">fscki</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">fscki</span><span class="o">-&gt;</span><span class="n">nlink</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">;</span>
		<span class="n">fscki</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
		<span class="n">fscki</span><span class="o">-&gt;</span><span class="n">xattr_cnt</span> <span class="o">=</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">xattr_cnt</span><span class="p">;</span>
		<span class="n">fscki</span><span class="o">-&gt;</span><span class="n">xattr_sz</span> <span class="o">=</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">xattr_size</span><span class="p">;</span>
		<span class="n">fscki</span><span class="o">-&gt;</span><span class="n">xattr_nms</span> <span class="o">=</span> <span class="n">ui</span><span class="o">-&gt;</span><span class="n">xattr_names</span><span class="p">;</span>
		<span class="n">fscki</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">;</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fscki</span><span class="o">-&gt;</span><span class="n">calc_sz</span> <span class="o">=</span> <span class="n">UBIFS_INO_NODE_SZ</span><span class="p">;</span>
		<span class="n">fscki</span><span class="o">-&gt;</span><span class="n">calc_cnt</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsckd</span><span class="o">-&gt;</span><span class="n">inodes</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">fscki</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * search_inode - search inode in the RB-tree of inodes.</span>
<span class="cm"> * @fsckd: FS checking information</span>
<span class="cm"> * @inum: inode number to search</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function for &#39;check_leaf()&#39; which searches inode @inum in</span>
<span class="cm"> * the RB-tree of inodes and returns an inode information pointer or %NULL if</span>
<span class="cm"> * the inode was not found.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fsck_inode</span> <span class="o">*</span><span class="nf">search_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsck_data</span> <span class="o">*</span><span class="n">fsckd</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">inum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsck_inode</span> <span class="o">*</span><span class="n">fscki</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">fsckd</span><span class="o">-&gt;</span><span class="n">inodes</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fscki</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsck_inode</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">&lt;</span> <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">&gt;</span> <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">fscki</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * read_add_inode - read inode node and add it to RB-tree of inodes.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @fsckd: FS checking information</span>
<span class="cm"> * @inum: inode number to read</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function for &#39;check_leaf()&#39; which finds inode node @inum in</span>
<span class="cm"> * the index, reads it, and adds it to the RB-tree of inodes. Returns inode</span>
<span class="cm"> * information pointer in case of success and a negative error code in case of</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fsck_inode</span> <span class="o">*</span><span class="nf">read_add_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">fsck_data</span> <span class="o">*</span><span class="n">fsckd</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">inum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_ino_node</span> <span class="o">*</span><span class="n">ino</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsck_inode</span> <span class="o">*</span><span class="n">fscki</span><span class="p">;</span>

	<span class="n">fscki</span> <span class="o">=</span> <span class="n">search_inode</span><span class="p">(</span><span class="n">fsckd</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fscki</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">fscki</span><span class="p">;</span>

	<span class="n">ino_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_lookup_level0</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;inode %lu not found in index&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inum</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;error %d while looking up inode %lu&quot;</span><span class="p">,</span>
			  <span class="n">err</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inum</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">UBIFS_INO_NODE_SZ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad node %lu node length %d&quot;</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ino</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ino</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_read_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot read inode node at LEB %d:%d, error %d&quot;</span><span class="p">,</span>
			  <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">fscki</span> <span class="o">=</span> <span class="n">add_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">fsckd</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fscki</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;error %ld while adding inode %lu node&quot;</span><span class="p">,</span>
			  <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">fscki</span><span class="p">),</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inum</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">fscki</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">fscki</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * check_leaf - check leaf node.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @zbr: zbranch of the leaf node to check</span>
<span class="cm"> * @priv: FS checking information</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function for &#39;dbg_check_filesystem()&#39; which is called for</span>
<span class="cm"> * every single leaf node while walking the indexing tree. It checks that the</span>
<span class="cm"> * leaf node referred from the indexing tree exists, has correct CRC, and does</span>
<span class="cm"> * some other basic validation. This function is also responsible for building</span>
<span class="cm"> * an RB-tree of inodes - it adds all inodes into the RB-tree. It also</span>
<span class="cm"> * calculates reference count, size, etc for each inode in order to later</span>
<span class="cm"> * compare them to the information stored inside the inodes and detect possible</span>
<span class="cm"> * inconsistencies. Returns zero in case of success and a negative error code</span>
<span class="cm"> * in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_leaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">,</span>
		      <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ino_t</span> <span class="n">inum</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="o">*</span><span class="n">ch</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">type</span> <span class="o">=</span> <span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fsck_inode</span> <span class="o">*</span><span class="n">fscki</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">UBIFS_CH_SZ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad leaf length %d (LEB %d:%d)&quot;</span><span class="p">,</span>
			  <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_read_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot read leaf node at LEB %d:%d, error %d&quot;</span><span class="p">,</span>
			  <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If this is an inode node, add it to RB-tree of inodes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_INO_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fscki</span> <span class="o">=</span> <span class="n">add_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">priv</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fscki</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">fscki</span><span class="p">);</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;error %d while adding inode node&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">UBIFS_DENT_KEY</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">!=</span> <span class="n">UBIFS_XENT_KEY</span> <span class="o">&amp;&amp;</span>
	    <span class="n">type</span> <span class="o">!=</span> <span class="n">UBIFS_DATA_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;unexpected node type %d at LEB %d:%d&quot;</span><span class="p">,</span>
			  <span class="n">type</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ch</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">sqnum</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_sqnum</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;too high sequence number, max. is %llu&quot;</span><span class="p">,</span>
			  <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_sqnum</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_DATA_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="kt">long</span> <span class="n">blk_offs</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ubifs_data_node</span> <span class="o">*</span><span class="n">dn</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Search the inode node this data node belongs to and insert</span>
<span class="cm">		 * it to the RB-tree of inodes.</span>
<span class="cm">		 */</span>
		<span class="n">inum</span> <span class="o">=</span> <span class="n">key_inum_flash</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
		<span class="n">fscki</span> <span class="o">=</span> <span class="n">read_add_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">priv</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fscki</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">fscki</span><span class="p">);</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;error %d while processing data node and &quot;</span>
				  <span class="s">&quot;trying to find inode node %lu&quot;</span><span class="p">,</span>
				  <span class="n">err</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inum</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Make sure the data node is within inode size */</span>
		<span class="n">blk_offs</span> <span class="o">=</span> <span class="n">key_block_flash</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
		<span class="n">blk_offs</span> <span class="o">&lt;&lt;=</span> <span class="n">UBIFS_BLOCK_SHIFT</span><span class="p">;</span>
		<span class="n">blk_offs</span> <span class="o">+=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blk_offs</span> <span class="o">&gt;</span> <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;data node at LEB %d:%d is not within inode &quot;</span>
				  <span class="s">&quot;size %lld&quot;</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span>
				  <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">nlen</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="o">*</span><span class="n">dent</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">fsck_inode</span> <span class="o">*</span><span class="n">fscki1</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_validate_entry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dent</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Search the inode node this entry refers to and the parent</span>
<span class="cm">		 * inode node and insert them to the RB-tree of inodes.</span>
<span class="cm">		 */</span>
		<span class="n">inum</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">);</span>
		<span class="n">fscki</span> <span class="o">=</span> <span class="n">read_add_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">priv</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fscki</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">fscki</span><span class="p">);</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;error %d while processing entry node and &quot;</span>
				  <span class="s">&quot;trying to find inode node %lu&quot;</span><span class="p">,</span>
				  <span class="n">err</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inum</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Count how many direntries or xentries refers this inode */</span>
		<span class="n">fscki</span><span class="o">-&gt;</span><span class="n">references</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">inum</span> <span class="o">=</span> <span class="n">key_inum_flash</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
		<span class="n">fscki1</span> <span class="o">=</span> <span class="n">read_add_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">priv</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fscki1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">fscki1</span><span class="p">);</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;error %d while processing entry node and &quot;</span>
				  <span class="s">&quot;trying to find parent inode node %lu&quot;</span><span class="p">,</span>
				  <span class="n">err</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inum</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">nlen</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">nlen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_XENT_KEY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fscki1</span><span class="o">-&gt;</span><span class="n">calc_xcnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">fscki1</span><span class="o">-&gt;</span><span class="n">calc_xsz</span> <span class="o">+=</span> <span class="n">CALC_DENT_SIZE</span><span class="p">(</span><span class="n">nlen</span><span class="p">);</span>
			<span class="n">fscki1</span><span class="o">-&gt;</span><span class="n">calc_xsz</span> <span class="o">+=</span> <span class="n">CALC_XATTR_BYTES</span><span class="p">(</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
			<span class="n">fscki1</span><span class="o">-&gt;</span><span class="n">calc_xnms</span> <span class="o">+=</span> <span class="n">nlen</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">fscki1</span><span class="o">-&gt;</span><span class="n">calc_sz</span> <span class="o">+=</span> <span class="n">CALC_DENT_SIZE</span><span class="p">(</span><span class="n">nlen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_ITYPE_DIR</span><span class="p">)</span>
				<span class="n">fscki1</span><span class="o">-&gt;</span><span class="n">calc_cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_dump:</span>
	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;dump of node at LEB %d:%d&quot;</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
	<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * free_inodes - free RB-tree of inodes.</span>
<span class="cm"> * @fsckd: FS checking information</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_inodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsck_data</span> <span class="o">*</span><span class="n">fsckd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">fsckd</span><span class="o">-&gt;</span><span class="n">inodes</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsck_inode</span> <span class="o">*</span><span class="n">fscki</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">)</span>
			<span class="n">this</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">)</span>
			<span class="n">this</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">fscki</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsck_inode</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
			<span class="n">this</span> <span class="o">=</span> <span class="n">rb_parent</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">)</span>
					<span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">fscki</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * check_inodes - checks all inodes.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @fsckd: FS checking information</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function for &#39;dbg_check_filesystem()&#39; which walks the</span>
<span class="cm"> * RB-tree of inodes after the index scan has been finished, and checks that</span>
<span class="cm"> * inode nlink, size, etc are correct. Returns zero if inodes are fine,</span>
<span class="cm"> * %-EINVAL if not, and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_inodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsck_data</span> <span class="o">*</span><span class="n">fsckd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_znode</span> <span class="o">*</span><span class="n">znode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zbr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_ino_node</span> <span class="o">*</span><span class="n">ino</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsck_inode</span> <span class="o">*</span><span class="n">fscki</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsckd</span><span class="o">-&gt;</span><span class="n">inodes</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fscki</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fsck_inode</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="n">this</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Directories have to have exactly one reference (they</span>
<span class="cm">			 * cannot have hardlinks), although root inode is an</span>
<span class="cm">			 * exception.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">inum</span> <span class="o">!=</span> <span class="n">UBIFS_ROOT_INO</span> <span class="o">&amp;&amp;</span>
			    <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">references</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;directory inode %lu has %d &quot;</span>
					  <span class="s">&quot;direntries which refer it, but &quot;</span>
					  <span class="s">&quot;should be 1&quot;</span><span class="p">,</span>
					  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">,</span>
					  <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">references</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">inum</span> <span class="o">==</span> <span class="n">UBIFS_ROOT_INO</span> <span class="o">&amp;&amp;</span>
			    <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">references</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;root inode %lu has non-zero (%d) &quot;</span>
					  <span class="s">&quot;direntries which refer it&quot;</span><span class="p">,</span>
					  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">,</span>
					  <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">references</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">calc_sz</span> <span class="o">!=</span> <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;directory inode %lu size is %lld, &quot;</span>
					  <span class="s">&quot;but calculated size is %lld&quot;</span><span class="p">,</span>
					  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">,</span>
					  <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">calc_sz</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">calc_cnt</span> <span class="o">!=</span> <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;directory inode %lu nlink is %d, &quot;</span>
					  <span class="s">&quot;but calculated nlink is %d&quot;</span><span class="p">,</span>
					  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">,</span>
					  <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="p">,</span> <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">calc_cnt</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">references</span> <span class="o">!=</span> <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;inode %lu nlink is %d, but &quot;</span>
					  <span class="s">&quot;calculated nlink is %d&quot;</span><span class="p">,</span>
					  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">,</span>
					  <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="p">,</span> <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">references</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">xattr_sz</span> <span class="o">!=</span> <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">calc_xsz</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;inode %lu has xattr size %u, but &quot;</span>
				  <span class="s">&quot;calculated size is %lld&quot;</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">,</span> <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">xattr_sz</span><span class="p">,</span>
				  <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">calc_xsz</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">xattr_cnt</span> <span class="o">!=</span> <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">calc_xcnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;inode %lu has %u xattrs, but &quot;</span>
				  <span class="s">&quot;calculated count is %lld&quot;</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">,</span>
				  <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">xattr_cnt</span><span class="p">,</span> <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">calc_xcnt</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">xattr_nms</span> <span class="o">!=</span> <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">calc_xnms</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;inode %lu has xattr names&#39; size %u, but &quot;</span>
				  <span class="s">&quot;calculated names&#39; size is %lld&quot;</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">,</span> <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">xattr_nms</span><span class="p">,</span>
				  <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">calc_xnms</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_dump:</span>
	<span class="cm">/* Read the bad inode and dump it */</span>
	<span class="n">ino_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">fscki</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_lookup_level0</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">znode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;inode %lu not found in index&quot;</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;error %d while looking up inode %lu&quot;</span><span class="p">,</span>
			  <span class="n">err</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">zbr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">znode</span><span class="o">-&gt;</span><span class="n">zbranch</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
	<span class="n">ino</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">zbr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ino</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_read_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zbr</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot read inode node at LEB %d:%d, error %d&quot;</span><span class="p">,</span>
			  <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;dump of the inode %lu sitting in LEB %d:%d&quot;</span><span class="p">,</span>
		  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fscki</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">zbr</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
	<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_check_filesystem - check the file-system.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks the file system, namely:</span>
<span class="cm"> * o makes sure that all leaf nodes exist and their CRCs are correct;</span>
<span class="cm"> * o makes sure inode nlink, size, xattr size/count are correct (for all</span>
<span class="cm"> *   inodes).</span>
<span class="cm"> *</span>
<span class="cm"> * The function reads whole indexing tree and all nodes, so it is pretty</span>
<span class="cm"> * heavy-weight. Returns zero if the file-system is consistent, %-EINVAL if</span>
<span class="cm"> * not, and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbg_check_filesystem</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsck_data</span> <span class="n">fsckd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_chk_fs</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fsckd</span><span class="p">.</span><span class="n">inodes</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_walk_index</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">check_leaf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsckd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">check_inodes</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsckd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">free_inodes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsckd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;file-system check failed with error %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
	<span class="n">free_inodes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsckd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_check_data_nodes_order - check that list of data nodes is sorted.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @head: the list of nodes (&#39;struct ubifs_scan_node&#39; objects)</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero if the list of data nodes is sorted correctly,</span>
<span class="cm"> * and %-EINVAL if not.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbg_check_data_nodes_order</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_scan_node</span> <span class="o">*</span><span class="n">sa</span><span class="p">,</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_chk_gen</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="n">head</span><span class="p">;</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ino_t</span> <span class="n">inuma</span><span class="p">,</span> <span class="n">inumb</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">blka</span><span class="p">,</span> <span class="n">blkb</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">sa</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_scan_node</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">sb</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_scan_node</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">UBIFS_DATA_NODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad node type %d&quot;</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
			<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">UBIFS_DATA_NODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad node type %d&quot;</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
			<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">inuma</span> <span class="o">=</span> <span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
		<span class="n">inumb</span> <span class="o">=</span> <span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">inuma</span> <span class="o">&lt;</span> <span class="n">inumb</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inuma</span> <span class="o">&gt;</span> <span class="n">inumb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;larger inum %lu goes before inum %lu&quot;</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inuma</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inumb</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error_dump</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">blka</span> <span class="o">=</span> <span class="n">key_block</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
		<span class="n">blkb</span> <span class="o">=</span> <span class="n">key_block</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">blka</span> <span class="o">&gt;</span> <span class="n">blkb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;larger block %u goes before %u&quot;</span><span class="p">,</span> <span class="n">blka</span><span class="p">,</span> <span class="n">blkb</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error_dump</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blka</span> <span class="o">==</span> <span class="n">blkb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;two data nodes for the same block&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error_dump</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_dump:</span>
	<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_check_nondata_nodes_order - check that list of data nodes is sorted.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @head: the list of nodes (&#39;struct ubifs_scan_node&#39; objects)</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns zero if the list of non-data nodes is sorted correctly,</span>
<span class="cm"> * and %-EINVAL if not.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbg_check_nondata_nodes_order</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_scan_node</span> <span class="o">*</span><span class="n">sa</span><span class="p">,</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_chk_gen</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="n">head</span><span class="p">;</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ino_t</span> <span class="n">inuma</span><span class="p">,</span> <span class="n">inumb</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">hasha</span><span class="p">,</span> <span class="n">hashb</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">sa</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_scan_node</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">sb</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_scan_node</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">UBIFS_INO_NODE</span> <span class="o">&amp;&amp;</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">UBIFS_DENT_NODE</span> <span class="o">&amp;&amp;</span>
		    <span class="n">sa</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">UBIFS_XENT_NODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad node type %d&quot;</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
			<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">UBIFS_INO_NODE</span> <span class="o">&amp;&amp;</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">UBIFS_DENT_NODE</span> <span class="o">&amp;&amp;</span>
		    <span class="n">sa</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">UBIFS_XENT_NODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;bad node type %d&quot;</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
			<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">UBIFS_INO_NODE</span> <span class="o">&amp;&amp;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_INO_NODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;non-inode node goes before inode node&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error_dump</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_INO_NODE</span> <span class="o">&amp;&amp;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">UBIFS_INO_NODE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_INO_NODE</span> <span class="o">&amp;&amp;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">UBIFS_INO_NODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Inode nodes are sorted in descending size order */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;smaller inode node goes first&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">error_dump</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * This is either a dentry or xentry, which should be sorted in</span>
<span class="cm">		 * ascending (parent ino, hash) order.</span>
<span class="cm">		 */</span>
		<span class="n">inuma</span> <span class="o">=</span> <span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
		<span class="n">inumb</span> <span class="o">=</span> <span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">inuma</span> <span class="o">&lt;</span> <span class="n">inumb</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inuma</span> <span class="o">&gt;</span> <span class="n">inumb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;larger inum %lu goes before inum %lu&quot;</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inuma</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inumb</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error_dump</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">hasha</span> <span class="o">=</span> <span class="n">key_block</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
		<span class="n">hashb</span> <span class="o">=</span> <span class="n">key_block</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hasha</span> <span class="o">&gt;</span> <span class="n">hashb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;larger hash %u goes before %u&quot;</span><span class="p">,</span>
				  <span class="n">hasha</span><span class="p">,</span> <span class="n">hashb</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error_dump</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_dump:</span>
	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;dumping first node&quot;</span><span class="p">);</span>
	<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;dumping second node&quot;</span><span class="p">);</span>
	<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">chance</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">out_of</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!!</span><span class="p">((</span><span class="n">random32</span><span class="p">()</span> <span class="o">%</span> <span class="n">out_of</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">power_cut_emulated</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_debug_info</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">dbg_is_tst_rcvry</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">pc_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* First call - decide delay to the power cut */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chance</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">chance</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">d</span><span class="o">-&gt;</span><span class="n">pc_delay</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="cm">/* Fail withing 1 minute */</span>
				<span class="n">delay</span> <span class="o">=</span> <span class="n">random32</span><span class="p">()</span> <span class="o">%</span> <span class="mi">60000</span><span class="p">;</span>
				<span class="n">d</span><span class="o">-&gt;</span><span class="n">pc_timeout</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
				<span class="n">d</span><span class="o">-&gt;</span><span class="n">pc_timeout</span> <span class="o">+=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">delay</span><span class="p">);</span>
				<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;failing after %lums&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">d</span><span class="o">-&gt;</span><span class="n">pc_delay</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="n">delay</span> <span class="o">=</span> <span class="n">random32</span><span class="p">()</span> <span class="o">%</span> <span class="mi">10000</span><span class="p">;</span>
				<span class="cm">/* Fail within 10000 operations */</span>
				<span class="n">d</span><span class="o">-&gt;</span><span class="n">pc_cnt_max</span> <span class="o">=</span> <span class="n">delay</span><span class="p">;</span>
				<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;failing after %lu calls&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">d</span><span class="o">-&gt;</span><span class="n">pc_cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Determine if failure delay has expired */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">pc_delay</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">pc_timeout</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">pc_delay</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">pc_cnt</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">pc_cnt_max</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">UBIFS_SB_LNUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="n">chance</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chance</span><span class="p">(</span><span class="mi">19</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;failing in super block LEB %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">UBIFS_MST_LNUM</span> <span class="o">||</span> <span class="n">lnum</span> <span class="o">==</span> <span class="n">UBIFS_MST_LNUM</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chance</span><span class="p">(</span><span class="mi">19</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;failing in master LEB %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">UBIFS_LOG_LNUM</span> <span class="o">&amp;&amp;</span> <span class="n">lnum</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">log_last</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="n">chance</span><span class="p">(</span><span class="mi">99</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chance</span><span class="p">(</span><span class="mi">399</span><span class="p">,</span> <span class="mi">400</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;failing in log LEB %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_first</span> <span class="o">&amp;&amp;</span> <span class="n">lnum</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_last</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="n">chance</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chance</span><span class="p">(</span><span class="mi">19</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;failing in LPT LEB %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_first</span> <span class="o">&amp;&amp;</span> <span class="n">lnum</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">orph_last</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="n">chance</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chance</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;failing in orphan LEB %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ihead_lnum</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chance</span><span class="p">(</span><span class="mi">99</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;failing in index head LEB %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span> <span class="o">&amp;&amp;</span> <span class="n">lnum</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">GCHD</span><span class="p">].</span><span class="n">wbuf</span><span class="p">.</span><span class="n">lnum</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chance</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;failing in GC head LEB %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">buds</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="o">!</span><span class="n">ubifs_search_bud</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chance</span><span class="p">(</span><span class="mi">19</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;failing in non-bud LEB %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">==</span> <span class="n">COMMIT_RUNNING_BACKGROUND</span> <span class="o">||</span>
		   <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">==</span> <span class="n">COMMIT_RUNNING_REQUIRED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chance</span><span class="p">(</span><span class="mi">999</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;failing in bud LEB %d commit running&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chance</span><span class="p">(</span><span class="mi">9999</span><span class="p">,</span> <span class="mi">10000</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;failing in bud LEB %d commit not running&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">d</span><span class="o">-&gt;</span><span class="n">pc_happened</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;========== Power cut emulated ==========&quot;</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cut_data</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ffs</span> <span class="o">=</span> <span class="n">chance</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">from</span> <span class="o">=</span> <span class="n">random32</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chance</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
		<span class="n">to</span> <span class="o">=</span> <span class="n">random32</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="n">from</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">to</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">from</span> <span class="o">&lt;</span> <span class="n">to</span><span class="p">)</span>
		<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;filled bytes %u-%u with %s&quot;</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			   <span class="n">ffs</span> <span class="o">?</span> <span class="s">&quot;0xFFs&quot;</span> <span class="o">:</span> <span class="s">&quot;random data&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ffs</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">from</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">to</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">from</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">to</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">random32</span><span class="p">()</span> <span class="o">%</span> <span class="mh">0x100</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dbg_leb_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		  <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">failing</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="o">-&gt;</span><span class="n">pc_happened</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="n">failing</span> <span class="o">=</span> <span class="n">power_cut_emulated</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">failing</span><span class="p">)</span>
		<span class="n">cut_data</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_leb_write</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ubi</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">failing</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dbg_leb_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="o">-&gt;</span><span class="n">pc_happened</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">power_cut_emulated</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_leb_change</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ubi</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">power_cut_emulated</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dbg_leb_unmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="o">-&gt;</span><span class="n">pc_happened</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">power_cut_emulated</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ubi</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">power_cut_emulated</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dbg_leb_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="o">-&gt;</span><span class="n">pc_happened</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">power_cut_emulated</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubi_leb_map</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ubi</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">power_cut_emulated</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Root directory for UBIFS stuff in debugfs. Contains sub-directories which</span>
<span class="cm"> * contain the stuff specific to particular file-system mounts.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dfs_rootdir</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dfs_file_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">nonseekable_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * provide_user_output - provide output to the user reading a debugfs file.</span>
<span class="cm"> * @val: boolean value for the answer</span>
<span class="cm"> * @u: the buffer to store the answer at</span>
<span class="cm"> * @count: size of the buffer</span>
<span class="cm"> * @ppos: position in the @u output buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This is a simple helper function which stores @val boolean value in the user</span>
<span class="cm"> * buffer when the user reads one of UBIFS debugfs files. Returns amount of</span>
<span class="cm"> * bytes written to @u in case of success and a negative error code in case of</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">provide_user_output</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">u</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
			       <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;1&#39;</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">dfs_file_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">u</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
			     <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dent</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_debug_info</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_chk_gen</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_gen</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_chk_index</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_index</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_chk_orph</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_orph</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_chk_lprops</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lprops</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_chk_fs</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_fs</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_tst_rcvry</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">tst_rcvry</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">provide_user_output</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * interpret_user_input - interpret user debugfs file input.</span>
<span class="cm"> * @u: user-provided buffer with the input</span>
<span class="cm"> * @count: buffer size</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function which interpret user input to a boolean UBIFS</span>
<span class="cm"> * debugfs file. Returns %0 or %1 in case of success and a negative error code</span>
<span class="cm"> * in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">interpret_user_input</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">u</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">buf_size</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="n">buf_size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">dfs_file_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">u</span><span class="p">,</span>
			      <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_debug_info</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dent</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * TODO: this is racy - the file-system might have already been</span>
<span class="cm">	 * unmounted and we&#39;d oops in this case. The plan is to fix it with</span>
<span class="cm">	 * help of &#39;iterate_supers_type()&#39; which we should have in v3.0: when</span>
<span class="cm">	 * a debugfs opened, we rember FS&#39;s UUID in file-&gt;private_data. Then</span>
<span class="cm">	 * whenever we access the FS via a debugfs file, we iterate all UBIFS</span>
<span class="cm">	 * superblocks and fine the one with the same UUID, and take the</span>
<span class="cm">	 * locking right.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The other way to go suggested by Al Viro is to create a separate</span>
<span class="cm">	 * &#39;ubifs-debug&#39; file-system instead.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_dump_lprops</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_dump_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_dump_budg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_dump_budg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_dump_tnc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
		<span class="n">ubifs_dump_tnc</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tnc_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">interpret_user_input</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_chk_gen</span><span class="p">)</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_gen</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_chk_index</span><span class="p">)</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_index</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_chk_orph</span><span class="p">)</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_orph</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_chk_lprops</span><span class="p">)</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_lprops</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_chk_fs</span><span class="p">)</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">chk_fs</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_tst_rcvry</span><span class="p">)</span>
		<span class="n">d</span><span class="o">-&gt;</span><span class="n">tst_rcvry</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">dfs_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">dfs_file_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">dfs_file_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">dfs_file_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_debugfs_init_fs - initialize debugfs for UBIFS instance.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates all debugfs files for this instance of UBIFS. Returns</span>
<span class="cm"> * zero in case of success and a negative error code in case of failure.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, the only reason we have not merged this function with the</span>
<span class="cm"> * &#39;ubifs_debugging_init()&#39; function is because it is better to initialize</span>
<span class="cm"> * debugfs interfaces at the very end of the mount process, and remove them at</span>
<span class="cm"> * the very beginning of the mount process.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbg_debugfs_init_fs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_debug_info</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_DEBUG_FS</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_dir_name</span><span class="p">,</span> <span class="n">UBIFS_DFS_DIR_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">UBIFS_DFS_DIR_NAME</span><span class="p">,</span>
		     <span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">ubi_num</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">vi</span><span class="p">.</span><span class="n">vol_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">UBIFS_DFS_DIR_LEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The array size is too small */</span>
		<span class="n">fname</span> <span class="o">=</span> <span class="n">UBIFS_DFS_DIR_NAME</span><span class="p">;</span>
		<span class="n">dent</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fname</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_dir_name</span><span class="p">;</span>
	<span class="n">dent</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">dfs_rootdir</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">dent</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_dir</span> <span class="o">=</span> <span class="n">dent</span><span class="p">;</span>

	<span class="n">fname</span> <span class="o">=</span> <span class="s">&quot;dump_lprops&quot;</span><span class="p">;</span>
	<span class="n">dent</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_dir</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dfs_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">dent</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_remove</span><span class="p">;</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_dump_lprops</span> <span class="o">=</span> <span class="n">dent</span><span class="p">;</span>

	<span class="n">fname</span> <span class="o">=</span> <span class="s">&quot;dump_budg&quot;</span><span class="p">;</span>
	<span class="n">dent</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_dir</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dfs_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">dent</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_remove</span><span class="p">;</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_dump_budg</span> <span class="o">=</span> <span class="n">dent</span><span class="p">;</span>

	<span class="n">fname</span> <span class="o">=</span> <span class="s">&quot;dump_tnc&quot;</span><span class="p">;</span>
	<span class="n">dent</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_dir</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dfs_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">dent</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_remove</span><span class="p">;</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_dump_tnc</span> <span class="o">=</span> <span class="n">dent</span><span class="p">;</span>

	<span class="n">fname</span> <span class="o">=</span> <span class="s">&quot;chk_general&quot;</span><span class="p">;</span>
	<span class="n">dent</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_dir</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">dfs_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">dent</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_remove</span><span class="p">;</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_chk_gen</span> <span class="o">=</span> <span class="n">dent</span><span class="p">;</span>

	<span class="n">fname</span> <span class="o">=</span> <span class="s">&quot;chk_index&quot;</span><span class="p">;</span>
	<span class="n">dent</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_dir</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">dfs_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">dent</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_remove</span><span class="p">;</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_chk_index</span> <span class="o">=</span> <span class="n">dent</span><span class="p">;</span>

	<span class="n">fname</span> <span class="o">=</span> <span class="s">&quot;chk_orphans&quot;</span><span class="p">;</span>
	<span class="n">dent</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_dir</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">dfs_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">dent</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_remove</span><span class="p">;</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_chk_orph</span> <span class="o">=</span> <span class="n">dent</span><span class="p">;</span>

	<span class="n">fname</span> <span class="o">=</span> <span class="s">&quot;chk_lprops&quot;</span><span class="p">;</span>
	<span class="n">dent</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_dir</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">dfs_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">dent</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_remove</span><span class="p">;</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_chk_lprops</span> <span class="o">=</span> <span class="n">dent</span><span class="p">;</span>

	<span class="n">fname</span> <span class="o">=</span> <span class="s">&quot;chk_fs&quot;</span><span class="p">;</span>
	<span class="n">dent</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_dir</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">dfs_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">dent</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_remove</span><span class="p">;</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_chk_fs</span> <span class="o">=</span> <span class="n">dent</span><span class="p">;</span>

	<span class="n">fname</span> <span class="o">=</span> <span class="s">&quot;tst_recovery&quot;</span><span class="p">;</span>
	<span class="n">dent</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_dir</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">dfs_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">dent</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_remove</span><span class="p">;</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_tst_rcvry</span> <span class="o">=</span> <span class="n">dent</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_remove:</span>
	<span class="n">debugfs_remove_recursive</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">dfs_dir</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dent</span> <span class="o">?</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dent</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot create </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> debugfs file or directory, error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">fname</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_debugfs_exit_fs - remove all debugfs files.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dbg_debugfs_exit_fs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_DEBUG_FS</span><span class="p">))</span>
		<span class="n">debugfs_remove_recursive</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="o">-&gt;</span><span class="n">dfs_dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ubifs_global_debug_info</span> <span class="n">ubifs_dbg</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dfs_chk_gen</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dfs_chk_index</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dfs_chk_orph</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dfs_chk_lprops</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dfs_chk_fs</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dfs_tst_rcvry</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">dfs_global_file_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">u</span><span class="p">,</span>
				    <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dent</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">dfs_chk_gen</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">ubifs_dbg</span><span class="p">.</span><span class="n">chk_gen</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">dfs_chk_index</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">ubifs_dbg</span><span class="p">.</span><span class="n">chk_index</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">dfs_chk_orph</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">ubifs_dbg</span><span class="p">.</span><span class="n">chk_orph</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">dfs_chk_lprops</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">ubifs_dbg</span><span class="p">.</span><span class="n">chk_lprops</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">dfs_chk_fs</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">ubifs_dbg</span><span class="p">.</span><span class="n">chk_fs</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">dfs_tst_rcvry</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">ubifs_dbg</span><span class="p">.</span><span class="n">tst_rcvry</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">provide_user_output</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">dfs_global_file_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">u</span><span class="p">,</span>
				     <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dent</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">interpret_user_input</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">dfs_chk_gen</span><span class="p">)</span>
		<span class="n">ubifs_dbg</span><span class="p">.</span><span class="n">chk_gen</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">dfs_chk_index</span><span class="p">)</span>
		<span class="n">ubifs_dbg</span><span class="p">.</span><span class="n">chk_index</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">dfs_chk_orph</span><span class="p">)</span>
		<span class="n">ubifs_dbg</span><span class="p">.</span><span class="n">chk_orph</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">dfs_chk_lprops</span><span class="p">)</span>
		<span class="n">ubifs_dbg</span><span class="p">.</span><span class="n">chk_lprops</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">dfs_chk_fs</span><span class="p">)</span>
		<span class="n">ubifs_dbg</span><span class="p">.</span><span class="n">chk_fs</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dent</span> <span class="o">==</span> <span class="n">dfs_tst_rcvry</span><span class="p">)</span>
		<span class="n">ubifs_dbg</span><span class="p">.</span><span class="n">tst_rcvry</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">dfs_global_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">dfs_global_file_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">dfs_global_file_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_debugfs_init - initialize debugfs file-system.</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS uses debugfs file-system to expose various debugging knobs to</span>
<span class="cm"> * user-space. This function creates &quot;ubifs&quot; directory in the debugfs</span>
<span class="cm"> * file-system. Returns zero in case of success and a negative error code in</span>
<span class="cm"> * case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbg_debugfs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_DEBUG_FS</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fname</span> <span class="o">=</span> <span class="s">&quot;ubifs&quot;</span><span class="p">;</span>
	<span class="n">dent</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">dent</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">dfs_rootdir</span> <span class="o">=</span> <span class="n">dent</span><span class="p">;</span>

	<span class="n">fname</span> <span class="o">=</span> <span class="s">&quot;chk_general&quot;</span><span class="p">;</span>
	<span class="n">dent</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">dfs_rootdir</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">dfs_global_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">dent</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_remove</span><span class="p">;</span>
	<span class="n">dfs_chk_gen</span> <span class="o">=</span> <span class="n">dent</span><span class="p">;</span>

	<span class="n">fname</span> <span class="o">=</span> <span class="s">&quot;chk_index&quot;</span><span class="p">;</span>
	<span class="n">dent</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">dfs_rootdir</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">dfs_global_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">dent</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_remove</span><span class="p">;</span>
	<span class="n">dfs_chk_index</span> <span class="o">=</span> <span class="n">dent</span><span class="p">;</span>

	<span class="n">fname</span> <span class="o">=</span> <span class="s">&quot;chk_orphans&quot;</span><span class="p">;</span>
	<span class="n">dent</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">dfs_rootdir</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">dfs_global_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">dent</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_remove</span><span class="p">;</span>
	<span class="n">dfs_chk_orph</span> <span class="o">=</span> <span class="n">dent</span><span class="p">;</span>

	<span class="n">fname</span> <span class="o">=</span> <span class="s">&quot;chk_lprops&quot;</span><span class="p">;</span>
	<span class="n">dent</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">dfs_rootdir</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">dfs_global_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">dent</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_remove</span><span class="p">;</span>
	<span class="n">dfs_chk_lprops</span> <span class="o">=</span> <span class="n">dent</span><span class="p">;</span>

	<span class="n">fname</span> <span class="o">=</span> <span class="s">&quot;chk_fs&quot;</span><span class="p">;</span>
	<span class="n">dent</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">dfs_rootdir</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">dfs_global_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">dent</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_remove</span><span class="p">;</span>
	<span class="n">dfs_chk_fs</span> <span class="o">=</span> <span class="n">dent</span><span class="p">;</span>

	<span class="n">fname</span> <span class="o">=</span> <span class="s">&quot;tst_recovery&quot;</span><span class="p">;</span>
	<span class="n">dent</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">dfs_rootdir</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">dfs_global_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">dent</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_remove</span><span class="p">;</span>
	<span class="n">dfs_tst_rcvry</span> <span class="o">=</span> <span class="n">dent</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_remove:</span>
	<span class="n">debugfs_remove_recursive</span><span class="p">(</span><span class="n">dfs_rootdir</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dent</span> <span class="o">?</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dent</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;cannot create </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> debugfs file or directory, error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">fname</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_debugfs_exit - remove the &quot;ubifs&quot; directory from debugfs file-system.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dbg_debugfs_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_DEBUG_FS</span><span class="p">))</span>
		<span class="n">debugfs_remove_recursive</span><span class="p">(</span><span class="n">dfs_rootdir</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_debugging_init - initialize UBIFS debugging.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function initializes debugging-related data for the file system.</span>
<span class="cm"> * Returns zero in case of success and a negative error code in case of</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_debugging_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">dbg</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_debug_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_debugging_exit - free debugging data.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubifs_debugging_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
