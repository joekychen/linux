<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ubifs › recovery.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>recovery.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is part of UBIFS.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Nokia Corporation</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="cm"> * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Adrian Hunter</span>
<span class="cm"> *          Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file implements functions needed to recover from unclean un-mounts.</span>
<span class="cm"> * When UBIFS is mounted, it checks a flag on the master node to determine if</span>
<span class="cm"> * an un-mount was completed successfully. If not, the process of mounting</span>
<span class="cm"> * incorporates additional checking and fixing of on-flash data structures.</span>
<span class="cm"> * UBIFS always cleans away all remnants of an unclean un-mount, so that</span>
<span class="cm"> * errors do not accumulate. However UBIFS defers recovery if it is mounted</span>
<span class="cm"> * read-only, and the flash is not modified in that case.</span>
<span class="cm"> *</span>
<span class="cm"> * The general UBIFS approach to the recovery is that it recovers from</span>
<span class="cm"> * corruptions which could be caused by power cuts, but it refuses to recover</span>
<span class="cm"> * from corruption caused by other reasons. And UBIFS tries to distinguish</span>
<span class="cm"> * between these 2 reasons of corruptions and silently recover in the former</span>
<span class="cm"> * case and loudly complain in the latter case.</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS writes only to erased LEBs, so it writes only to the flash space</span>
<span class="cm"> * containing only 0xFFs. UBIFS also always writes strictly from the beginning</span>
<span class="cm"> * of the LEB to the end. And UBIFS assumes that the underlying flash media</span>
<span class="cm"> * writes in @c-&gt;max_write_size bytes at a time.</span>
<span class="cm"> *</span>
<span class="cm"> * Hence, if UBIFS finds a corrupted node at offset X, it expects only the min.</span>
<span class="cm"> * I/O unit corresponding to offset X to contain corrupted data, all the</span>
<span class="cm"> * following min. I/O units have to contain empty space (all 0xFFs). If this is</span>
<span class="cm"> * not true, the corruption cannot be the result of a power cut, and UBIFS</span>
<span class="cm"> * refuses to mount.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &quot;ubifs.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * is_empty - determine whether a buffer is empty (contains all 0xff).</span>
<span class="cm"> * @buf: buffer to clean</span>
<span class="cm"> * @len: length of buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %1 if the buffer is empty (contains all 0xff) otherwise</span>
<span class="cm"> * %0 is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_empty</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">!=</span> <span class="mh">0xff</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * first_non_ff - find offset of the first non-0xff byte.</span>
<span class="cm"> * @buf: buffer to search in</span>
<span class="cm"> * @len: length of buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns offset of the first non-0xff byte in @buf or %-1 if</span>
<span class="cm"> * the buffer contains only 0xff bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">first_non_ff</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">!=</span> <span class="mh">0xff</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_master_node - get the last valid master node allowing for corruption.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB number</span>
<span class="cm"> * @pbuf: buffer containing the LEB read, is returned here</span>
<span class="cm"> * @mst: master node, if found, is returned here</span>
<span class="cm"> * @cor: corruption, if found, is returned here</span>
<span class="cm"> *</span>
<span class="cm"> * This function allocates a buffer, reads the LEB into it, and finds and</span>
<span class="cm"> * returns the last valid master node allowing for one area of corruption.</span>
<span class="cm"> * The corrupt area, if there is one, must be consistent with the assumption</span>
<span class="cm"> * that it is the result of an unclean unmount while the master node was being</span>
<span class="cm"> * written. Under those circumstances, it is valid to use the previously written</span>
<span class="cm"> * master node.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_master_node</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">pbuf</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">ubifs_mst_node</span> <span class="o">**</span><span class="n">mst</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">cor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node_alsz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">sbuf</span><span class="p">,</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">sbuf</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbuf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">sbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EBADMSG</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="cm">/* Find the first position that is definitely not a node */</span>
	<span class="n">offs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">sbuf</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">offs</span> <span class="o">+</span> <span class="n">UBIFS_MST_NODE_SZ</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="o">*</span><span class="n">ch</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">)</span> <span class="o">!=</span> <span class="n">UBIFS_NODE_MAGIC</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">offs</span> <span class="o">+=</span> <span class="n">sz</span><span class="p">;</span>
		<span class="n">buf</span>  <span class="o">+=</span> <span class="n">sz</span><span class="p">;</span>
		<span class="n">len</span>  <span class="o">-=</span> <span class="n">sz</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* See if there was a valid master node before that */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offs</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">offs</span> <span class="o">-=</span> <span class="n">sz</span><span class="p">;</span>
		<span class="n">buf</span>  <span class="o">-=</span> <span class="n">sz</span><span class="p">;</span>
		<span class="n">len</span>  <span class="o">+=</span> <span class="n">sz</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ubifs_scan_a_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">SCANNED_A_NODE</span> <span class="o">&amp;&amp;</span> <span class="n">offs</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Could have been corruption so check one place back */</span>
			<span class="n">offs</span> <span class="o">-=</span> <span class="n">sz</span><span class="p">;</span>
			<span class="n">buf</span>  <span class="o">-=</span> <span class="n">sz</span><span class="p">;</span>
			<span class="n">len</span>  <span class="o">+=</span> <span class="n">sz</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ubifs_scan_a_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">SCANNED_A_NODE</span><span class="p">)</span>
				<span class="cm">/*</span>
<span class="cm">				 * We accept only one area of corruption because</span>
<span class="cm">				 * we are assuming that it was caused while</span>
<span class="cm">				 * trying to write a master node.</span>
<span class="cm">				 */</span>
				<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">SCANNED_A_NODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="o">*</span><span class="n">ch</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">node_type</span> <span class="o">!=</span> <span class="n">UBIFS_MST_NODE</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
			<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;found a master node at %d:%d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
			<span class="o">*</span><span class="n">mst</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
			<span class="n">offs</span> <span class="o">+=</span> <span class="n">sz</span><span class="p">;</span>
			<span class="n">buf</span>  <span class="o">+=</span> <span class="n">sz</span><span class="p">;</span>
			<span class="n">len</span>  <span class="o">-=</span> <span class="n">sz</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Check for corruption */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offs</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_empty</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">sz</span><span class="p">)))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">cor</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
			<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;found corruption at %d:%d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">offs</span> <span class="o">+=</span> <span class="n">sz</span><span class="p">;</span>
		<span class="n">buf</span>  <span class="o">+=</span> <span class="n">sz</span><span class="p">;</span>
		<span class="n">len</span>  <span class="o">-=</span> <span class="n">sz</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Check remaining empty space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offs</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_empty</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="o">*</span><span class="n">pbuf</span> <span class="o">=</span> <span class="n">sbuf</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_err:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="nl">out_free:</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">sbuf</span><span class="p">);</span>
	<span class="o">*</span><span class="n">mst</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="o">*</span><span class="n">cor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * write_rcvrd_mst_node - write recovered master node.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @mst: master node</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_rcvrd_mst_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ubifs_mst_node</span> <span class="o">*</span><span class="n">mst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lnum</span> <span class="o">=</span> <span class="n">UBIFS_MST_LNUM</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node_alsz</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">save_flags</span><span class="p">;</span>

	<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;recovery&quot;</span><span class="p">);</span>

	<span class="n">save_flags</span> <span class="o">=</span> <span class="n">mst</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UBIFS_MST_RCVRY</span><span class="p">);</span>

	<span class="n">ubifs_prepare_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">mst</span><span class="p">,</span> <span class="n">UBIFS_MST_NODE_SZ</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_change</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">mst</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_change</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mst</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">mst</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">save_flags</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_recover_master_node - recover the master node.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function recovers the master node from corruption that may occur due to</span>
<span class="cm"> * an unclean unmount.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_recover_master_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">buf2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">cor1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">cor2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_mst_node</span> <span class="o">*</span><span class="n">mst1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">mst2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">mst</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node_alsz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">offs1</span><span class="p">,</span> <span class="n">offs2</span><span class="p">;</span>

	<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;recovery&quot;</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">get_master_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">UBIFS_MST_LNUM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mst1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cor1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">get_master_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">UBIFS_MST_LNUM</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mst2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cor2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mst1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offs1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">mst1</span> <span class="o">-</span> <span class="n">buf1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mst1</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UBIFS_MST_RCVRY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">offs1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cor1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * mst1 was written by recovery at offset 0 with no</span>
<span class="cm">			 * corruption.</span>
<span class="cm">			 */</span>
			<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;recovery recovery&quot;</span><span class="p">);</span>
			<span class="n">mst</span> <span class="o">=</span> <span class="n">mst1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mst2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">offs2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">mst2</span> <span class="o">-</span> <span class="n">buf2</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">offs1</span> <span class="o">==</span> <span class="n">offs2</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Same offset, so must be the same */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">mst1</span> <span class="o">+</span> <span class="n">UBIFS_CH_SZ</span><span class="p">,</span>
					   <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">mst2</span> <span class="o">+</span> <span class="n">UBIFS_CH_SZ</span><span class="p">,</span>
					   <span class="n">UBIFS_MST_NODE_SZ</span> <span class="o">-</span> <span class="n">UBIFS_CH_SZ</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
				<span class="n">mst</span> <span class="o">=</span> <span class="n">mst1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">offs2</span> <span class="o">+</span> <span class="n">sz</span> <span class="o">==</span> <span class="n">offs1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* 1st LEB was written, 2nd was not */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cor1</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
				<span class="n">mst</span> <span class="o">=</span> <span class="n">mst1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">offs1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
				   <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">offs2</span> <span class="o">-</span> <span class="n">sz</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* 1st LEB was unmapped and written, 2nd not */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cor1</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
				<span class="n">mst</span> <span class="o">=</span> <span class="n">mst1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * 2nd LEB was unmapped and about to be written, so</span>
<span class="cm">			 * there must be only one master node in the first LEB</span>
<span class="cm">			 * and no corruption.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">offs1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">cor1</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
			<span class="n">mst</span> <span class="o">=</span> <span class="n">mst1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mst2</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * 1st LEB was unmapped and about to be written, so there must</span>
<span class="cm">		 * be no room left in 2nd LEB.</span>
<span class="cm">		 */</span>
		<span class="n">offs2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">mst2</span> <span class="o">-</span> <span class="n">buf2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offs2</span> <span class="o">+</span> <span class="n">sz</span> <span class="o">+</span> <span class="n">sz</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
		<span class="n">mst</span> <span class="o">=</span> <span class="n">mst2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ubifs_msg</span><span class="p">(</span><span class="s">&quot;recovered master node from LEB %d&quot;</span><span class="p">,</span>
		  <span class="p">(</span><span class="n">mst</span> <span class="o">==</span> <span class="n">mst1</span> <span class="o">?</span> <span class="n">UBIFS_MST_LNUM</span> <span class="o">:</span> <span class="n">UBIFS_MST_LNUM</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="p">,</span> <span class="n">mst</span><span class="p">,</span> <span class="n">UBIFS_MST_NODE_SZ</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read-only mode. Keep a copy for switching to rw mode */</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">rcvrd_mst_node</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rcvrd_mst_node</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rcvrd_mst_node</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="p">,</span> <span class="n">UBIFS_MST_NODE_SZ</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We had to recover the master node, which means there was an</span>
<span class="cm">		 * unclean reboot. However, it is possible that the master node</span>
<span class="cm">		 * is clean at this point, i.e., %UBIFS_MST_DIRTY is not set.</span>
<span class="cm">		 * E.g., consider the following chain of events:</span>
<span class="cm">		 *</span>
<span class="cm">		 * 1. UBIFS was cleanly unmounted, so the master node is clean</span>
<span class="cm">		 * 2. UBIFS is being mounted R/W and starts changing the master</span>
<span class="cm">		 *    node in the first (%UBIFS_MST_LNUM). A power cut happens,</span>
<span class="cm">		 *    so this LEB ends up with some amount of garbage at the</span>
<span class="cm">		 *    end.</span>
<span class="cm">		 * 3. UBIFS is being mounted R/O. We reach this place and</span>
<span class="cm">		 *    recover the master node from the second LEB</span>
<span class="cm">		 *    (%UBIFS_MST_LNUM + 1). But we cannot update the media</span>
<span class="cm">		 *    because we are being mounted R/O. We have to defer the</span>
<span class="cm">		 *    operation.</span>
<span class="cm">		 * 4. However, this master node (@c-&gt;mst_node) is marked as</span>
<span class="cm">		 *    clean (since the step 1). And if we just return, the</span>
<span class="cm">		 *    mount code will be confused and won&#39;t recover the master</span>
<span class="cm">		 *    node when it is re-mounter R/W later.</span>
<span class="cm">		 *</span>
<span class="cm">		 *    Thus, to force the recovery by marking the master node as</span>
<span class="cm">		 *    dirty.</span>
<span class="cm">		 */</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UBIFS_MST_DIRTY</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Write the recovered master node */</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">max_sqnum</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">mst</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">sqnum</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">write_rcvrd_mst_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">buf2</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">buf1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_err:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="nl">out_free:</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;failed to recover master node&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mst1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;dumping first master node&quot;</span><span class="p">);</span>
		<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">mst1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mst2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;dumping second master node&quot;</span><span class="p">);</span>
		<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">mst2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">buf2</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">buf1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_write_rcvrd_mst_node - write the recovered master node.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function writes the master node that was recovered during mounting in</span>
<span class="cm"> * read-only mode and must now be written because we are remounting rw.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_write_rcvrd_mst_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rcvrd_mst_node</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">rcvrd_mst_node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UBIFS_MST_DIRTY</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UBIFS_MST_DIRTY</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">write_rcvrd_mst_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">rcvrd_mst_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rcvrd_mst_node</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">rcvrd_mst_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * is_last_write - determine if an offset was in the last write to a LEB.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @buf: buffer to check</span>
<span class="cm"> * @offs: offset to check</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %1 if @offs was in the last write to the LEB whose data</span>
<span class="cm"> * is in @buf, otherwise %0 is returned. The determination is made by checking</span>
<span class="cm"> * for subsequent empty space starting from the next @c-&gt;max_write_size</span>
<span class="cm"> * boundary.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_last_write</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">empty_offs</span><span class="p">,</span> <span class="n">check_len</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Round up to the next @c-&gt;max_write_size boundary i.e. @offs is in</span>
<span class="cm">	 * the last wbuf written. After that should be empty space.</span>
<span class="cm">	 */</span>
	<span class="n">empty_offs</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">offs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">);</span>
	<span class="n">check_len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">empty_offs</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">empty_offs</span> <span class="o">-</span> <span class="n">offs</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">is_empty</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">check_len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clean_buf - clean the data from an LEB sitting in a buffer.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @buf: buffer to clean</span>
<span class="cm"> * @lnum: LEB number to clean</span>
<span class="cm"> * @offs: offset from which to clean</span>
<span class="cm"> * @len: length of buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This function pads up to the next min_io_size boundary (if there is one) and</span>
<span class="cm"> * sets empty space to all 0xff. @buf, @offs and @len are updated to the next</span>
<span class="cm"> * @c-&gt;min_io_size boundary.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">clean_buf</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="o">*</span><span class="n">offs</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">empty_offs</span><span class="p">,</span> <span class="n">pad_len</span><span class="p">;</span>

	<span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;cleaning corruption at %d:%d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="o">*</span><span class="n">offs</span><span class="p">);</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">offs</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">));</span>
	<span class="n">empty_offs</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="o">*</span><span class="n">offs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="n">pad_len</span> <span class="o">=</span> <span class="n">empty_offs</span> <span class="o">-</span> <span class="o">*</span><span class="n">offs</span><span class="p">;</span>
	<span class="n">ubifs_pad</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">pad_len</span><span class="p">);</span>
	<span class="o">*</span><span class="n">offs</span> <span class="o">+=</span> <span class="n">pad_len</span><span class="p">;</span>
	<span class="o">*</span><span class="n">buf</span> <span class="o">+=</span> <span class="n">pad_len</span><span class="p">;</span>
	<span class="o">*</span><span class="n">len</span> <span class="o">-=</span> <span class="n">pad_len</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">empty_offs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * no_more_nodes - determine if there are no more nodes in a buffer.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @buf: buffer to check</span>
<span class="cm"> * @len: length of buffer</span>
<span class="cm"> * @lnum: LEB number of the LEB from which @buf was read</span>
<span class="cm"> * @offs: offset from which @buf was read</span>
<span class="cm"> *</span>
<span class="cm"> * This function ensures that the corrupted node at @offs is the last thing</span>
<span class="cm"> * written to a LEB. This function returns %1 if more data is not found and</span>
<span class="cm"> * %0 if more data is found.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">no_more_nodes</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="o">*</span><span class="n">ch</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">skip</span><span class="p">,</span> <span class="n">dlen</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Check for empty space after the corrupt node&#39;s common header */</span>
	<span class="n">skip</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">offs</span> <span class="o">+</span> <span class="n">UBIFS_CH_SZ</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">)</span> <span class="o">-</span> <span class="n">offs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_empty</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">skip</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">skip</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The area after the common header size is not empty, so the common</span>
<span class="cm">	 * header must be intact. Check it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ubifs_check_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EUCLEAN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;unexpected bad common header at %d:%d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Now we know the corrupt node&#39;s length we can skip over it */</span>
	<span class="n">skip</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">offs</span> <span class="o">+</span> <span class="n">dlen</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">)</span> <span class="o">-</span> <span class="n">offs</span><span class="p">;</span>
	<span class="cm">/* After which there should be empty space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_empty</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">skip</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">skip</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;unexpected data at %d:%d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span> <span class="o">+</span> <span class="n">skip</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fix_unclean_leb - fix an unclean LEB.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @sleb: scanned LEB information</span>
<span class="cm"> * @start: offset where scan started</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fix_unclean_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">sleb</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">lnum</span> <span class="o">=</span> <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">endpt</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>

	<span class="cm">/* Get the end offset of the last node we are keeping */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_scan_node</span> <span class="o">*</span><span class="n">snod</span><span class="p">;</span>

		<span class="n">snod</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ubifs_scan_node</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">endpt</span> <span class="o">=</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">+</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">remounting_rw</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Add to recovery list */</span>
		<span class="k">struct</span> <span class="n">ubifs_unclean_leb</span> <span class="o">*</span><span class="n">ucleb</span><span class="p">;</span>

		<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;need to fix LEB %d start %d endpt %d&quot;</span><span class="p">,</span>
			  <span class="n">lnum</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">endpt</span><span class="p">);</span>
		<span class="n">ucleb</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_unclean_leb</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ucleb</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">ucleb</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
		<span class="n">ucleb</span><span class="o">-&gt;</span><span class="n">endpt</span> <span class="o">=</span> <span class="n">endpt</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ucleb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">unclean_leb_list</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Write the fixed LEB back to flash */</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;fixing LEB %d start %d endpt %d&quot;</span><span class="p">,</span>
			  <span class="n">lnum</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">endpt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">endpt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">endpt</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						     <span class="n">start</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Pad to min_io_size */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">endpt</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">pad_len</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">endpt</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">pad_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="n">pad_len</span><span class="p">;</span>

					<span class="n">ubifs_pad</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">pad_len</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_change</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * drop_last_group - drop the last group of nodes.</span>
<span class="cm"> * @sleb: scanned LEB information</span>
<span class="cm"> * @offs: offset of dropped nodes is returned here</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function for &#39;ubifs_recover_leb()&#39; which drops the last</span>
<span class="cm"> * group of nodes of the scanned LEB.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">drop_last_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">sleb</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_scan_node</span> <span class="o">*</span><span class="n">snod</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="o">*</span><span class="n">ch</span><span class="p">;</span>

		<span class="n">snod</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_scan_node</span><span class="p">,</span>
				  <span class="n">list</span><span class="p">);</span>
		<span class="n">ch</span> <span class="o">=</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">group_type</span> <span class="o">!=</span> <span class="n">UBIFS_IN_NODE_GROUP</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;dropping grouped node at %d:%d&quot;</span><span class="p">,</span>
			  <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
		<span class="o">*</span><span class="n">offs</span> <span class="o">=</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">snod</span><span class="p">);</span>
		<span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes_cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * drop_last_node - drop the last node.</span>
<span class="cm"> * @sleb: scanned LEB information</span>
<span class="cm"> * @offs: offset of dropped nodes is returned here</span>
<span class="cm"> * @grouped: non-zero if whole group of nodes have to be dropped</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function for &#39;ubifs_recover_leb()&#39; which drops the last</span>
<span class="cm"> * node of the scanned LEB.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">drop_last_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">sleb</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_scan_node</span> <span class="o">*</span><span class="n">snod</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">snod</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_scan_node</span><span class="p">,</span>
				  <span class="n">list</span><span class="p">);</span>

		<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;dropping last node at %d:%d&quot;</span><span class="p">,</span> <span class="n">sleb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
		<span class="o">*</span><span class="n">offs</span> <span class="o">=</span> <span class="n">snod</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">snod</span><span class="p">);</span>
		<span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes_cnt</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_recover_leb - scan and recover a LEB.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB number</span>
<span class="cm"> * @offs: offset</span>
<span class="cm"> * @sbuf: LEB-sized buffer to use</span>
<span class="cm"> * @jhead: journal head number this LEB belongs to (%-1 if the LEB does not</span>
<span class="cm"> *         belong to any journal head)</span>
<span class="cm"> *</span>
<span class="cm"> * This function does a scan of a LEB, but caters for errors that might have</span>
<span class="cm"> * been caused by the unclean unmount from which we are attempting to recover.</span>
<span class="cm"> * Returns %0 in case of success, %-EUCLEAN if an unrecoverable corruption is</span>
<span class="cm"> * found, and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="nf">ubifs_recover_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">jhead</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">offs</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="n">offs</span><span class="p">,</span> <span class="n">min_io_unit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">grouped</span> <span class="o">=</span> <span class="n">jhead</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">jhead</span><span class="p">].</span><span class="n">grouped</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">sleb</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">sbuf</span> <span class="o">+</span> <span class="n">offs</span><span class="p">;</span>

	<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;%d:%d, jhead %d, grouped %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">jhead</span><span class="p">,</span> <span class="n">grouped</span><span class="p">);</span>

	<span class="n">sleb</span> <span class="o">=</span> <span class="n">ubifs_start_scan</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">sbuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sleb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sleb</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_scan</span><span class="p">(</span><span class="s">&quot;look at LEB %d:%d (%d bytes left)&quot;</span><span class="p">,</span>
			 <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * Scan quietly until there is an error from which we cannot</span>
<span class="cm">		 * recover</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ubifs_scan_a_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">SCANNED_A_NODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* A valid node, and not a padding node */</span>
			<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="o">*</span><span class="n">ch</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">node_len</span><span class="p">;</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_add_snod</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sleb</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="n">node_len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>
			<span class="n">offs</span> <span class="o">+=</span> <span class="n">node_len</span><span class="p">;</span>
			<span class="n">buf</span> <span class="o">+=</span> <span class="n">node_len</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">-=</span> <span class="n">node_len</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Padding bytes or a valid padding node */</span>
			<span class="n">offs</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="n">buf</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">-=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">SCANNED_EMPTY_SPACE</span> <span class="o">||</span>
			   <span class="n">ret</span> <span class="o">==</span> <span class="n">SCANNED_GARBAGE</span>     <span class="o">||</span>
			   <span class="n">ret</span> <span class="o">==</span> <span class="n">SCANNED_A_BAD_PAD_NODE</span> <span class="o">||</span>
			   <span class="n">ret</span> <span class="o">==</span> <span class="n">SCANNED_A_CORRUPT_NODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;found corruption (%d) at %d:%d&quot;</span><span class="p">,</span>
				  <span class="n">ret</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;unexpected return value %d&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">SCANNED_GARBAGE</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">==</span> <span class="n">SCANNED_A_BAD_PAD_NODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_last_write</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">offs</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">corrupted_rescan</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">SCANNED_A_CORRUPT_NODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">no_more_nodes</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">corrupted_rescan</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_empty</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_last_write</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">offs</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">corruption</span> <span class="o">=</span> <span class="n">first_non_ff</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * See header comment for this file for more</span>
<span class="cm">			 * explanations about the reasons we have this check.</span>
<span class="cm">			 */</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;corrupt empty space LEB %d:%d, corruption &quot;</span>
				  <span class="s">&quot;starts at %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">corruption</span><span class="p">);</span>
			<span class="cm">/* Make sure we dump interesting non-0xFF data */</span>
			<span class="n">offs</span> <span class="o">+=</span> <span class="n">corruption</span><span class="p">;</span>
			<span class="n">buf</span> <span class="o">+=</span> <span class="n">corruption</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">corrupted</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">min_io_unit</span> <span class="o">=</span> <span class="n">round_down</span><span class="p">(</span><span class="n">offs</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">grouped</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * If nodes are grouped, always drop the incomplete group at</span>
<span class="cm">		 * the end.</span>
<span class="cm">		 */</span>
		<span class="n">drop_last_group</span><span class="p">(</span><span class="n">sleb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">jhead</span> <span class="o">==</span> <span class="n">GCHD</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If this LEB belongs to the GC head then while we are in the</span>
<span class="cm">		 * middle of the same min. I/O unit keep dropping nodes. So</span>
<span class="cm">		 * basically, what we want is to make sure that the last min.</span>
<span class="cm">		 * I/O unit where we saw the corruption is dropped completely</span>
<span class="cm">		 * with all the uncorrupted nodes which may possibly sit there.</span>
<span class="cm">		 *</span>
<span class="cm">		 * In other words, let&#39;s name the min. I/O unit where the</span>
<span class="cm">		 * corruption starts B, and the previous min. I/O unit A. The</span>
<span class="cm">		 * below code tries to deal with a situation when half of B</span>
<span class="cm">		 * contains valid nodes or the end of a valid node, and the</span>
<span class="cm">		 * second half of B contains corrupted data or garbage. This</span>
<span class="cm">		 * means that UBIFS had been writing to B just before the power</span>
<span class="cm">		 * cut happened. I do not know how realistic is this scenario</span>
<span class="cm">		 * that half of the min. I/O unit had been written successfully</span>
<span class="cm">		 * and the other half not, but this is possible in our &#39;failure</span>
<span class="cm">		 * mode emulation&#39; infrastructure at least.</span>
<span class="cm">		 *</span>
<span class="cm">		 * So what is the problem, why we need to drop those nodes? Why</span>
<span class="cm">		 * can&#39;t we just clean-up the second half of B by putting a</span>
<span class="cm">		 * padding node there? We can, and this works fine with one</span>
<span class="cm">		 * exception which was reproduced with power cut emulation</span>
<span class="cm">		 * testing and happens extremely rarely.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Imagine the file-system is full, we run GC which starts</span>
<span class="cm">		 * moving valid nodes from LEB X to LEB Y (obviously, LEB Y is</span>
<span class="cm">		 * the current GC head LEB). The @c-&gt;gc_lnum is -1, which means</span>
<span class="cm">		 * that GC will retain LEB X and will try to continue. Imagine</span>
<span class="cm">		 * that LEB X is currently the dirtiest LEB, and the amount of</span>
<span class="cm">		 * used space in LEB Y is exactly the same as amount of free</span>
<span class="cm">		 * space in LEB X.</span>
<span class="cm">		 *</span>
<span class="cm">		 * And a power cut happens when nodes are moved from LEB X to</span>
<span class="cm">		 * LEB Y. We are here trying to recover LEB Y which is the GC</span>
<span class="cm">		 * head LEB. We find the min. I/O unit B as described above.</span>
<span class="cm">		 * Then we clean-up LEB Y by padding min. I/O unit. And later</span>
<span class="cm">		 * &#39;ubifs_rcvry_gc_commit()&#39; function fails, because it cannot</span>
<span class="cm">		 * find a dirty LEB which could be GC&#39;d into LEB Y! Even LEB X</span>
<span class="cm">		 * does not match because the amount of valid nodes there does</span>
<span class="cm">		 * not fit the free space in LEB Y any more! And this is</span>
<span class="cm">		 * because of the padding node which we added to LEB Y. The</span>
<span class="cm">		 * user-visible effect of this which I once observed and</span>
<span class="cm">		 * analysed is that we cannot mount the file-system with</span>
<span class="cm">		 * -ENOSPC error.</span>
<span class="cm">		 *</span>
<span class="cm">		 * So obviously, to make sure that situation does not happen we</span>
<span class="cm">		 * should free min. I/O unit B in LEB Y completely and the last</span>
<span class="cm">		 * used min. I/O unit in LEB Y should be A. This is basically</span>
<span class="cm">		 * what the below code tries to do.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">offs</span> <span class="o">&gt;</span> <span class="n">min_io_unit</span><span class="p">)</span>
			<span class="n">drop_last_node</span><span class="p">(</span><span class="n">sleb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">sbuf</span> <span class="o">+</span> <span class="n">offs</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">offs</span><span class="p">;</span>

	<span class="n">clean_buf</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">ubifs_end_scan</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sleb</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">fix_unclean_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sleb</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sleb</span><span class="p">;</span>

<span class="nl">corrupted_rescan:</span>
	<span class="cm">/* Re-scan the corrupted data with verbose messages */</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;corruptio %d&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="n">ubifs_scan_a_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="nl">corrupted:</span>
	<span class="n">ubifs_scanned_corruption</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EUCLEAN</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;LEB %d scanning failed&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="n">ubifs_scan_destroy</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_cs_sqnum - get commit start sequence number.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB number of commit start node</span>
<span class="cm"> * @offs: offset of commit start node</span>
<span class="cm"> * @cs_sqnum: commit start sequence number is returned here</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_cs_sqnum</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">cs_sqnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_cs_node</span> <span class="o">*</span><span class="n">cs_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;at %d:%d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
	<span class="n">cs_node</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">UBIFS_CS_NODE_SZ</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cs_node</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">offs</span> <span class="o">&lt;</span> <span class="n">UBIFS_CS_NODE_SZ</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">cs_node</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span>
			     <span class="n">UBIFS_CS_NODE_SZ</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EBADMSG</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ubifs_scan_a_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">cs_node</span><span class="p">,</span> <span class="n">UBIFS_CS_NODE_SZ</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">SCANNED_A_NODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;Not a valid node&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cs_node</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">node_type</span> <span class="o">!=</span> <span class="n">UBIFS_CS_NODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;Node a CS node, type is %d&quot;</span><span class="p">,</span> <span class="n">cs_node</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">node_type</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">cs_node</span><span class="o">-&gt;</span><span class="n">cmt_no</span><span class="p">)</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_no</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;CS node cmt_no %llu != current cmt_no %llu&quot;</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">cs_node</span><span class="o">-&gt;</span><span class="n">cmt_no</span><span class="p">),</span>
			  <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_no</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">cs_sqnum</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">cs_node</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">sqnum</span><span class="p">);</span>
	<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;commit start sqnum %llu&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">cs_sqnum</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cs_node</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_err:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="nl">out_free:</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;failed to get CS sqnum&quot;</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cs_node</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_recover_log_leb - scan and recover a log LEB.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB number</span>
<span class="cm"> * @offs: offset</span>
<span class="cm"> * @sbuf: LEB-sized buffer to use</span>
<span class="cm"> *</span>
<span class="cm"> * This function does a scan of a LEB, but caters for errors that might have</span>
<span class="cm"> * been caused by unclean reboots from which we are attempting to recover</span>
<span class="cm"> * (assume that only the last log LEB can be corrupted by an unclean reboot).</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="nf">ubifs_recover_log_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_scan_leb</span> <span class="o">*</span><span class="n">sleb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">next_lnum</span><span class="p">;</span>

	<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;LEB %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
	<span class="n">next_lnum</span> <span class="o">=</span> <span class="n">lnum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next_lnum</span> <span class="o">&gt;=</span> <span class="n">UBIFS_LOG_LNUM</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">log_lebs</span><span class="p">)</span>
		<span class="n">next_lnum</span> <span class="o">=</span> <span class="n">UBIFS_LOG_LNUM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next_lnum</span> <span class="o">!=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltail_lnum</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We can only recover at the end of the log, so check that the</span>
<span class="cm">		 * next log LEB is empty or out of date.</span>
<span class="cm">		 */</span>
		<span class="n">sleb</span> <span class="o">=</span> <span class="n">ubifs_scan</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">next_lnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sleb</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">sleb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes_cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ubifs_scan_node</span> <span class="o">*</span><span class="n">snod</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">cs_sqnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_sqnum</span><span class="p">;</span>

			<span class="n">snod</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">sleb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">ubifs_scan_node</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cs_sqnum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

				<span class="n">err</span> <span class="o">=</span> <span class="n">get_cs_sqnum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cs_sqnum</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ubifs_scan_destroy</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>
					<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">snod</span><span class="o">-&gt;</span><span class="n">sqnum</span> <span class="o">&gt;</span> <span class="n">cs_sqnum</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;unrecoverable log corruption &quot;</span>
					  <span class="s">&quot;in LEB %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
				<span class="n">ubifs_scan_destroy</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EUCLEAN</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">ubifs_scan_destroy</span><span class="p">(</span><span class="n">sleb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ubifs_recover_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">sbuf</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * recover_head - recover a head.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @lnum: LEB number of head to recover</span>
<span class="cm"> * @offs: offset of head to recover</span>
<span class="cm"> * @sbuf: LEB-sized buffer to use</span>
<span class="cm"> *</span>
<span class="cm"> * This function ensures that there is no data on the flash at a head location.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">recover_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offs</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max_write_size</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offs</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="n">offs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Read at the head location and check it is empty flash */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">sbuf</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="o">!</span><span class="n">is_empty</span><span class="p">(</span><span class="n">sbuf</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;cleaning head at %d:%d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">sbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ubifs_leb_change</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">sbuf</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_recover_inl_heads - recover index and LPT heads.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @sbuf: LEB-sized buffer to use</span>
<span class="cm"> *</span>
<span class="cm"> * This function ensures that there is no data on the flash at the index and</span>
<span class="cm"> * LPT head locations.</span>
<span class="cm"> *</span>
<span class="cm"> * This deals with the recovery of a half-completed journal commit. UBIFS is</span>
<span class="cm"> * careful never to overwrite the last version of the index or the LPT. Because</span>
<span class="cm"> * the index and LPT are wandering trees, data from a half-completed commit will</span>
<span class="cm"> * not be referenced anywhere in UBIFS. The data will be either in LEBs that are</span>
<span class="cm"> * assumed to be empty and will be unmapped anyway before use, or in the index</span>
<span class="cm"> * and LPT heads.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_recover_inl_heads</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">remounting_rw</span><span class="p">);</span>

	<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;checking index head at %d:%d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ihead_lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ihead_offs</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">recover_head</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ihead_lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ihead_offs</span><span class="p">,</span> <span class="n">sbuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;checking LPT head at %d:%d&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_offs</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">recover_head</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_offs</span><span class="p">,</span> <span class="n">sbuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * clean_an_unclean_leb - read and write a LEB to remove corruption.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @ucleb: unclean LEB information</span>
<span class="cm"> * @sbuf: LEB-sized buffer to use</span>
<span class="cm"> *</span>
<span class="cm"> * This function reads a LEB up to a point pre-determined by the mount recovery,</span>
<span class="cm"> * checks the nodes, and writes the result back to the flash, thereby cleaning</span>
<span class="cm"> * off any following corruption, or non-fatal ECC errors.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">clean_an_unclean_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ubifs_unclean_leb</span> <span class="o">*</span><span class="n">ucleb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">lnum</span> <span class="o">=</span> <span class="n">ucleb</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">ucleb</span><span class="o">-&gt;</span><span class="n">endpt</span><span class="p">,</span> <span class="n">quiet</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">sbuf</span><span class="p">;</span>

	<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;LEB %d len %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Nothing to read, just unmap it */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EBADMSG</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="cm">/* Scan quietly until there is an error */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ubifs_scan_a_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">quiet</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">SCANNED_A_NODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* A valid node, and not a padding node */</span>
			<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="o">*</span><span class="n">ch</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">node_len</span><span class="p">;</span>

			<span class="n">node_len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ch</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>
			<span class="n">offs</span> <span class="o">+=</span> <span class="n">node_len</span><span class="p">;</span>
			<span class="n">buf</span> <span class="o">+=</span> <span class="n">node_len</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">-=</span> <span class="n">node_len</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Padding bytes or a valid padding node */</span>
			<span class="n">offs</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="n">buf</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">-=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">SCANNED_EMPTY_SPACE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;unexpected empty space at %d:%d&quot;</span><span class="p">,</span>
				  <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EUCLEAN</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">quiet</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Redo the last scan but noisily */</span>
			<span class="n">quiet</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ubifs_scanned_corruption</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EUCLEAN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Pad to min_io_size */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">ucleb</span><span class="o">-&gt;</span><span class="n">endpt</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">ucleb</span><span class="o">-&gt;</span><span class="n">endpt</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">pad_len</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">ucleb</span><span class="o">-&gt;</span><span class="n">endpt</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pad_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">buf</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sbuf</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="n">pad_len</span><span class="p">;</span>
			<span class="n">ubifs_pad</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">pad_len</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Write back the LEB atomically */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_change</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">sbuf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;cleaned LEB %d&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_clean_lebs - clean LEBs recovered during read-only mount.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @sbuf: LEB-sized buffer to use</span>
<span class="cm"> *</span>
<span class="cm"> * This function cleans a LEB identified during recovery that needs to be</span>
<span class="cm"> * written but was not because UBIFS was mounted read-only. This happens when</span>
<span class="cm"> * remounting to read-write mode.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_clean_lebs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;recovery&quot;</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">unclean_leb_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_unclean_leb</span> <span class="o">*</span><span class="n">ucleb</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">ucleb</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">unclean_leb_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">ubifs_unclean_leb</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">clean_an_unclean_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ucleb</span><span class="p">,</span> <span class="n">sbuf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ucleb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ucleb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * grab_empty_leb - grab an empty LEB to use as GC LEB and run commit.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function for &#39;ubifs_rcvry_gc_commit()&#39; which grabs an empty</span>
<span class="cm"> * LEB to be used as GC LEB (@c-&gt;gc_lnum), and then runs the commit. Returns</span>
<span class="cm"> * zero in case of success and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">grab_empty_leb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note, it is very important to first search for an empty LEB and then</span>
<span class="cm">	 * run the commit, not vice-versa. The reason is that there might be</span>
<span class="cm">	 * only one empty LEB at the moment, the one which has been the</span>
<span class="cm">	 * @c-&gt;gc_lnum just before the power cut happened. During the regular</span>
<span class="cm">	 * UBIFS operation (not now) @c-&gt;gc_lnum is marked as &quot;taken&quot;, so no</span>
<span class="cm">	 * one but GC can grab it. But at this moment this single empty LEB is</span>
<span class="cm">	 * not marked as taken, so if we run commit - what happens? Right, the</span>
<span class="cm">	 * commit will grab it and write the index there. Remember that the</span>
<span class="cm">	 * index always expands as long as there is free space, and it only</span>
<span class="cm">	 * starts consolidating when we run out of space.</span>
<span class="cm">	 *</span>
<span class="cm">	 * IOW, if we run commit now, we might not be able to find a free LEB</span>
<span class="cm">	 * after this.</span>
<span class="cm">	 */</span>
	<span class="n">lnum</span> <span class="o">=</span> <span class="n">ubifs_find_free_leb_for_idx</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lnum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;could not find an empty LEB&quot;</span><span class="p">);</span>
		<span class="n">ubifs_dump_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="n">ubifs_dump_budg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Reset the index flag */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_change_one_lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">LPROPS_NC</span><span class="p">,</span> <span class="n">LPROPS_NC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				  <span class="n">LPROPS_INDEX</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_lnum</span> <span class="o">=</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;found empty LEB %d, run commit&quot;</span><span class="p">,</span> <span class="n">lnum</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ubifs_run_commit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_rcvry_gc_commit - recover the GC LEB number and run the commit.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * Out-of-place garbage collection requires always one empty LEB with which to</span>
<span class="cm"> * start garbage collection. The LEB number is recorded in c-&gt;gc_lnum and is</span>
<span class="cm"> * written to the master node on unmounting. In the case of an unclean unmount</span>
<span class="cm"> * the value of gc_lnum recorded in the master node is out of date and cannot</span>
<span class="cm"> * be used. Instead, recovery must allocate an empty LEB for this purpose.</span>
<span class="cm"> * However, there may not be enough empty space, in which case it must be</span>
<span class="cm"> * possible to GC the dirtiest LEB into the GC head LEB.</span>
<span class="cm"> *</span>
<span class="cm"> * This function also runs the commit which causes the TNC updates from</span>
<span class="cm"> * size-recovery and orphans to be written to the flash. That is important to</span>
<span class="cm"> * ensure correct replay order for subsequent mounts.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_rcvry_gc_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_wbuf</span> <span class="o">*</span><span class="n">wbuf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">GCHD</span><span class="p">].</span><span class="n">wbuf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_lprops</span> <span class="n">lp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;GC head LEB %d, offs %d&quot;</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_lnum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">lnum</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">grab_empty_leb</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_find_dirty_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lp</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;could not find a dirty LEB&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">grab_empty_leb</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lp</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LPROPS_INDEX</span><span class="p">));</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">lp</span><span class="p">.</span><span class="n">free</span> <span class="o">+</span> <span class="n">lp</span><span class="p">.</span><span class="n">dirty</span> <span class="o">&gt;=</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We run the commit before garbage collection otherwise subsequent</span>
<span class="cm">	 * mounts will see the GC and orphan deletion in a different order.</span>
<span class="cm">	 */</span>
	<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;committing&quot;</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_run_commit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;GC&#39;ing LEB %d&quot;</span><span class="p">,</span> <span class="n">lp</span><span class="p">.</span><span class="n">lnum</span><span class="p">);</span>
	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">,</span> <span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">jhead</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_garbage_collect_leb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err2</span> <span class="o">=</span> <span class="n">ubifs_wbuf_sync_nolock</span><span class="p">(</span><span class="n">wbuf</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err2</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">err2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wbuf</span><span class="o">-&gt;</span><span class="n">io_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;GC failed, error %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">LEB_RETAINED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">LEB_RETAINED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_unmap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">gc_lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;allocated LEB %d for GC&quot;</span><span class="p">,</span> <span class="n">lp</span><span class="p">.</span><span class="n">lnum</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * struct size_entry - inode size information for recovery.</span>
<span class="cm"> * @rb: link in the RB-tree of sizes</span>
<span class="cm"> * @inum: inode number</span>
<span class="cm"> * @i_size: size on inode</span>
<span class="cm"> * @d_size: maximum size based on data nodes</span>
<span class="cm"> * @exists: indicates whether the inode exists</span>
<span class="cm"> * @inode: inode if pinned in memory awaiting rw mode to fix it</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">size_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rb</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">inum</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">i_size</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">d_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">exists</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * add_ino - add an entry to the size tree.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @inum: inode number</span>
<span class="cm"> * @i_size: size on inode</span>
<span class="cm"> * @d_size: maximum size based on data nodes</span>
<span class="cm"> * @exists: indicates whether the inode exists</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_ino</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">inum</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">i_size</span><span class="p">,</span>
		   <span class="n">loff_t</span> <span class="n">d_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exists</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">size_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">size_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">e</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">size_entry</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">&lt;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">e</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">size_entry</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">e</span><span class="o">-&gt;</span><span class="n">inum</span> <span class="o">=</span> <span class="n">inum</span><span class="p">;</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">i_size</span><span class="p">;</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">d_size</span> <span class="o">=</span> <span class="n">d_size</span><span class="p">;</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">exists</span> <span class="o">=</span> <span class="n">exists</span><span class="p">;</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">size_tree</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_ino - find an entry on the size tree.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @inum: inode number</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">size_entry</span> <span class="o">*</span><span class="nf">find_ino</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">inum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">size_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">size_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">size_entry</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">&lt;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inum</span> <span class="o">&gt;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">e</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * remove_ino - remove an entry from the size tree.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @inum: inode number</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_ino</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">inum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">size_entry</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">find_ino</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">size_tree</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_destroy_size_tree - free resources related to the size tree.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubifs_destroy_size_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">size_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">size_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">this</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">this</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">e</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="k">struct</span> <span class="n">size_entry</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">this</span> <span class="o">=</span> <span class="n">rb_parent</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">)</span>
				<span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">size_tree</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_recover_size_accum - accumulate inode sizes for recovery.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @key: node key</span>
<span class="cm"> * @deletion: node is for a deletion</span>
<span class="cm"> * @new_size: inode size</span>
<span class="cm"> *</span>
<span class="cm"> * This function has two purposes:</span>
<span class="cm"> *     1) to ensure there are no data nodes that fall outside the inode size</span>
<span class="cm"> *     2) to ensure there are no data nodes for inodes that do not exist</span>
<span class="cm"> * To accomplish those purposes, a rb-tree is constructed containing an entry</span>
<span class="cm"> * for each inode number in the journal that has not been deleted, and recording</span>
<span class="cm"> * the size from the inode node, the maximum size of any data node (also altered</span>
<span class="cm"> * by truncations) and a flag indicating a inode number for which no inode node</span>
<span class="cm"> * was present in the journal.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that there is still the possibility that there are data nodes that have</span>
<span class="cm"> * been committed that are beyond the inode size, however the only way to find</span>
<span class="cm"> * them would be to scan the entire index. Alternatively, some provision could</span>
<span class="cm"> * be made to record the size of inodes at the start of commit, which would seem</span>
<span class="cm"> * very cumbersome for a scenario that is quite unlikely and the only negative</span>
<span class="cm"> * consequence of which is wasted space.</span>
<span class="cm"> *</span>
<span class="cm"> * This functions returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_recover_size_accum</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">union</span> <span class="n">ubifs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">deletion</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">new_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ino_t</span> <span class="n">inum</span> <span class="o">=</span> <span class="n">key_inum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">size_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">key_type</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UBIFS_INO_KEY</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">deletion</span><span class="p">)</span>
			<span class="n">remove_ino</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">e</span> <span class="o">=</span> <span class="n">find_ino</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">e</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">new_size</span><span class="p">;</span>
				<span class="n">e</span><span class="o">-&gt;</span><span class="n">exists</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">add_ino</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inum</span><span class="p">,</span> <span class="n">new_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_DATA_KEY</span>:
		<span class="n">e</span> <span class="o">=</span> <span class="n">find_ino</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">&gt;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">d_size</span><span class="p">)</span>
				<span class="n">e</span><span class="o">-&gt;</span><span class="n">d_size</span> <span class="o">=</span> <span class="n">new_size</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">add_ino</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">new_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UBIFS_TRUN_KEY</span>:
		<span class="n">e</span> <span class="o">=</span> <span class="n">find_ino</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span>
			<span class="n">e</span><span class="o">-&gt;</span><span class="n">d_size</span> <span class="o">=</span> <span class="n">new_size</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * fix_size_in_place - fix inode size in place on flash.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @e: inode size information for recovery</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fix_size_in_place</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">size_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_ino_node</span> <span class="o">*</span><span class="n">ino</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sbuf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">i_size</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">crc</span><span class="p">;</span>

	<span class="cm">/* Locate the inode node LEB number and offset */</span>
	<span class="n">ino_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_locate</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the size recorded on the inode node is greater than the size that</span>
<span class="cm">	 * was calculated from nodes in the journal then don&#39;t change the inode.</span>
<span class="cm">	 */</span>
	<span class="n">i_size</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">&gt;=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">d_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Read the LEB */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/* Change the size field and recalculate the CRC */</span>
	<span class="n">ino</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sbuf</span> <span class="o">+</span> <span class="n">offs</span><span class="p">;</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">d_size</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="n">UBIFS_CRC32_INIT</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ino</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">ino</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">crc</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">crc</span><span class="p">);</span>
	<span class="cm">/* Work out where data in the LEB ends and free space begins */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sbuf</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">leb_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">min_io_size</span><span class="p">);</span>
	<span class="cm">/* Atomically write the fixed LEB back again */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_leb_change</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sbuf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;inode %lu at %d:%d size %lld -&gt; %lld&quot;</span><span class="p">,</span>
		  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">i_size</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">d_size</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">ubifs_warn</span><span class="p">(</span><span class="s">&quot;inode %lu failed to fix size %lld -&gt; %lld error %d&quot;</span><span class="p">,</span>
		   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">d_size</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_recover_size - recover inode size.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function attempts to fix inode size discrepancies identified by the</span>
<span class="cm"> * &#39;ubifs_recover_size_accum()&#39; function.</span>
<span class="cm"> *</span>
<span class="cm"> * This functions returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_recover_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">size_tree</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">size_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">e</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="k">struct</span> <span class="n">size_entry</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">exists</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">key</span><span class="p">;</span>

			<span class="n">ino_key_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_lookup</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sbuf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Remove data nodes that have no inode */</span>
				<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;removing ino %lu&quot;</span><span class="p">,</span>
					  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_remove_ino</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">ubifs_ino_node</span> <span class="o">*</span><span class="n">ino</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sbuf</span><span class="p">;</span>

				<span class="n">e</span><span class="o">-&gt;</span><span class="n">exists</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">e</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">exists</span> <span class="o">&amp;&amp;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&lt;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">d_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Fix the inode size and pin it in memory */</span>
				<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
				<span class="k">struct</span> <span class="n">ubifs_inode</span> <span class="o">*</span><span class="n">ui</span><span class="p">;</span>

				<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">);</span>

				<span class="n">inode</span> <span class="o">=</span> <span class="n">ubifs_iget</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">vfs_sb</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
					<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

				<span class="n">ui</span> <span class="o">=</span> <span class="n">ubifs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&lt;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">d_size</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">dbg_rcvry</span><span class="p">(</span><span class="s">&quot;ino %lu size %lld -&gt; %lld&quot;</span><span class="p">,</span>
						  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">,</span>
						  <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">d_size</span><span class="p">);</span>
					<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">d_size</span><span class="p">;</span>
					<span class="n">ui</span><span class="o">-&gt;</span><span class="n">ui_size</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">d_size</span><span class="p">;</span>
					<span class="n">ui</span><span class="o">-&gt;</span><span class="n">synced_i_size</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">d_size</span><span class="p">;</span>
					<span class="n">e</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>
					<span class="n">this</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Fix the size in place */</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">fix_size_in_place</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span>
					<span class="n">iput</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">this</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">size_tree</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
