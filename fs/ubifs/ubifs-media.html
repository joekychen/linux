<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ubifs › ubifs-media.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ubifs-media.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is part of UBIFS.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Nokia Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="cm"> * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> *          Adrian Hunter</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file describes UBIFS on-flash format and contains definitions of all the</span>
<span class="cm"> * relevant data structures and constants.</span>
<span class="cm"> *</span>
<span class="cm"> * All UBIFS on-flash objects are stored in the form of nodes. All nodes start</span>
<span class="cm"> * with the UBIFS node magic number and have the same common header. Nodes</span>
<span class="cm"> * always sit at 8-byte aligned positions on the media and node header sizes are</span>
<span class="cm"> * also 8-byte aligned (except for the indexing node and the padding node).</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __UBIFS_MEDIA_H__</span>
<span class="cp">#define __UBIFS_MEDIA_H__</span>

<span class="cm">/* UBIFS node magic number (must not have the padding byte first or last) */</span>
<span class="cp">#define UBIFS_NODE_MAGIC  0x06101831</span>

<span class="cm">/*</span>
<span class="cm"> * UBIFS on-flash format version. This version is increased when the on-flash</span>
<span class="cm"> * format is changing. If this happens, UBIFS is will support older versions as</span>
<span class="cm"> * well. But older UBIFS code will not support newer formats. Format changes</span>
<span class="cm"> * will be rare and only when absolutely necessary, e.g. to fix a bug or to add</span>
<span class="cm"> * a new feature.</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS went into mainline kernel with format version 4. The older formats</span>
<span class="cm"> * were development formats.</span>
<span class="cm"> */</span>
<span class="cp">#define UBIFS_FORMAT_VERSION 4</span>

<span class="cm">/*</span>
<span class="cm"> * Read-only compatibility version. If the UBIFS format is changed, older UBIFS</span>
<span class="cm"> * implementations will not be able to mount newer formats in read-write mode.</span>
<span class="cm"> * However, depending on the change, it may be possible to mount newer formats</span>
<span class="cm"> * in R/O mode. This is indicated by the R/O compatibility version which is</span>
<span class="cm"> * stored in the super-block.</span>
<span class="cm"> *</span>
<span class="cm"> * This is needed to support boot-loaders which only need R/O mounting. With</span>
<span class="cm"> * this flag it is possible to do UBIFS format changes without a need to update</span>
<span class="cm"> * boot-loaders.</span>
<span class="cm"> */</span>
<span class="cp">#define UBIFS_RO_COMPAT_VERSION 0</span>

<span class="cm">/* Minimum logical eraseblock size in bytes */</span>
<span class="cp">#define UBIFS_MIN_LEB_SZ (15*1024)</span>

<span class="cm">/* Initial CRC32 value used when calculating CRC checksums */</span>
<span class="cp">#define UBIFS_CRC32_INIT 0xFFFFFFFFU</span>

<span class="cm">/*</span>
<span class="cm"> * UBIFS does not try to compress data if its length is less than the below</span>
<span class="cm"> * constant.</span>
<span class="cm"> */</span>
<span class="cp">#define UBIFS_MIN_COMPR_LEN 128</span>

<span class="cm">/*</span>
<span class="cm"> * If compressed data length is less than %UBIFS_MIN_COMPRESS_DIFF bytes</span>
<span class="cm"> * shorter than uncompressed data length, UBIFS prefers to leave this data</span>
<span class="cm"> * node uncompress, because it&#39;ll be read faster.</span>
<span class="cm"> */</span>
<span class="cp">#define UBIFS_MIN_COMPRESS_DIFF 64</span>

<span class="cm">/* Root inode number */</span>
<span class="cp">#define UBIFS_ROOT_INO 1</span>

<span class="cm">/* Lowest inode number used for regular inodes (not UBIFS-only internal ones) */</span>
<span class="cp">#define UBIFS_FIRST_INO 64</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum file name and extended attribute length (must be a multiple of 8,</span>
<span class="cm"> * minus 1).</span>
<span class="cm"> */</span>
<span class="cp">#define UBIFS_MAX_NLEN 255</span>

<span class="cm">/* Maximum number of data journal heads */</span>
<span class="cp">#define UBIFS_MAX_JHEADS 1</span>

<span class="cm">/*</span>
<span class="cm"> * Size of UBIFS data block. Note, UBIFS is not a block oriented file-system,</span>
<span class="cm"> * which means that it does not treat the underlying media as consisting of</span>
<span class="cm"> * blocks like in case of hard drives. Do not be confused. UBIFS block is just</span>
<span class="cm"> * the maximum amount of data which one data node can have or which can be</span>
<span class="cm"> * attached to an inode node.</span>
<span class="cm"> */</span>
<span class="cp">#define UBIFS_BLOCK_SIZE  4096</span>
<span class="cp">#define UBIFS_BLOCK_SHIFT 12</span>

<span class="cm">/* UBIFS padding byte pattern (must not be first or last byte of node magic) */</span>
<span class="cp">#define UBIFS_PADDING_BYTE 0xCE</span>

<span class="cm">/* Maximum possible key length */</span>
<span class="cp">#define UBIFS_MAX_KEY_LEN 16</span>

<span class="cm">/* Key length (&quot;simple&quot; format) */</span>
<span class="cp">#define UBIFS_SK_LEN 8</span>

<span class="cm">/* Minimum index tree fanout */</span>
<span class="cp">#define UBIFS_MIN_FANOUT 3</span>

<span class="cm">/* Maximum number of levels in UBIFS indexing B-tree */</span>
<span class="cp">#define UBIFS_MAX_LEVELS 512</span>

<span class="cm">/* Maximum amount of data attached to an inode in bytes */</span>
<span class="cp">#define UBIFS_MAX_INO_DATA UBIFS_BLOCK_SIZE</span>

<span class="cm">/* LEB Properties Tree fanout (must be power of 2) and fanout shift */</span>
<span class="cp">#define UBIFS_LPT_FANOUT 4</span>
<span class="cp">#define UBIFS_LPT_FANOUT_SHIFT 2</span>

<span class="cm">/* LEB Properties Tree bit field sizes */</span>
<span class="cp">#define UBIFS_LPT_CRC_BITS 16</span>
<span class="cp">#define UBIFS_LPT_CRC_BYTES 2</span>
<span class="cp">#define UBIFS_LPT_TYPE_BITS 4</span>

<span class="cm">/* The key is always at the same position in all keyed nodes */</span>
<span class="cp">#define UBIFS_KEY_OFFSET offsetof(struct ubifs_ino_node, key)</span>

<span class="cm">/* Garbage collector journal head number */</span>
<span class="cp">#define UBIFS_GC_HEAD   0</span>
<span class="cm">/* Base journal head number */</span>
<span class="cp">#define UBIFS_BASE_HEAD 1</span>
<span class="cm">/* Data journal head number */</span>
<span class="cp">#define UBIFS_DATA_HEAD 2</span>

<span class="cm">/*</span>
<span class="cm"> * LEB Properties Tree node types.</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS_LPT_PNODE: LPT leaf node (contains LEB properties)</span>
<span class="cm"> * UBIFS_LPT_NNODE: LPT internal node</span>
<span class="cm"> * UBIFS_LPT_LTAB: LPT&#39;s own lprops table</span>
<span class="cm"> * UBIFS_LPT_LSAVE: LPT&#39;s save table (big model only)</span>
<span class="cm"> * UBIFS_LPT_NODE_CNT: count of LPT node types</span>
<span class="cm"> * UBIFS_LPT_NOT_A_NODE: all ones (15 for 4 bits) is never a valid node type</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">UBIFS_LPT_PNODE</span><span class="p">,</span>
	<span class="n">UBIFS_LPT_NNODE</span><span class="p">,</span>
	<span class="n">UBIFS_LPT_LTAB</span><span class="p">,</span>
	<span class="n">UBIFS_LPT_LSAVE</span><span class="p">,</span>
	<span class="n">UBIFS_LPT_NODE_CNT</span><span class="p">,</span>
	<span class="n">UBIFS_LPT_NOT_A_NODE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UBIFS_LPT_TYPE_BITS</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * UBIFS inode types.</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS_ITYPE_REG: regular file</span>
<span class="cm"> * UBIFS_ITYPE_DIR: directory</span>
<span class="cm"> * UBIFS_ITYPE_LNK: soft link</span>
<span class="cm"> * UBIFS_ITYPE_BLK: block device node</span>
<span class="cm"> * UBIFS_ITYPE_CHR: character device node</span>
<span class="cm"> * UBIFS_ITYPE_FIFO: fifo</span>
<span class="cm"> * UBIFS_ITYPE_SOCK: socket</span>
<span class="cm"> * UBIFS_ITYPES_CNT: count of supported file types</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">UBIFS_ITYPE_REG</span><span class="p">,</span>
	<span class="n">UBIFS_ITYPE_DIR</span><span class="p">,</span>
	<span class="n">UBIFS_ITYPE_LNK</span><span class="p">,</span>
	<span class="n">UBIFS_ITYPE_BLK</span><span class="p">,</span>
	<span class="n">UBIFS_ITYPE_CHR</span><span class="p">,</span>
	<span class="n">UBIFS_ITYPE_FIFO</span><span class="p">,</span>
	<span class="n">UBIFS_ITYPE_SOCK</span><span class="p">,</span>
	<span class="n">UBIFS_ITYPES_CNT</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Supported key hash functions.</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS_KEY_HASH_R5: R5 hash</span>
<span class="cm"> * UBIFS_KEY_HASH_TEST: test hash which just returns first 4 bytes of the name</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">UBIFS_KEY_HASH_R5</span><span class="p">,</span>
	<span class="n">UBIFS_KEY_HASH_TEST</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Supported key formats.</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS_SIMPLE_KEY_FMT: simple key format</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">UBIFS_SIMPLE_KEY_FMT</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The simple key format uses 29 bits for storing UBIFS block number and hash</span>
<span class="cm"> * value.</span>
<span class="cm"> */</span>
<span class="cp">#define UBIFS_S_KEY_BLOCK_BITS 29</span>
<span class="cp">#define UBIFS_S_KEY_BLOCK_MASK 0x1FFFFFFF</span>
<span class="cp">#define UBIFS_S_KEY_HASH_BITS  UBIFS_S_KEY_BLOCK_BITS</span>
<span class="cp">#define UBIFS_S_KEY_HASH_MASK  UBIFS_S_KEY_BLOCK_MASK</span>

<span class="cm">/*</span>
<span class="cm"> * Key types.</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS_INO_KEY: inode node key</span>
<span class="cm"> * UBIFS_DATA_KEY: data node key</span>
<span class="cm"> * UBIFS_DENT_KEY: directory entry node key</span>
<span class="cm"> * UBIFS_XENT_KEY: extended attribute entry key</span>
<span class="cm"> * UBIFS_KEY_TYPES_CNT: number of supported key types</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">UBIFS_INO_KEY</span><span class="p">,</span>
	<span class="n">UBIFS_DATA_KEY</span><span class="p">,</span>
	<span class="n">UBIFS_DENT_KEY</span><span class="p">,</span>
	<span class="n">UBIFS_XENT_KEY</span><span class="p">,</span>
	<span class="n">UBIFS_KEY_TYPES_CNT</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Count of LEBs reserved for the superblock area */</span>
<span class="cp">#define UBIFS_SB_LEBS 1</span>
<span class="cm">/* Count of LEBs reserved for the master area */</span>
<span class="cp">#define UBIFS_MST_LEBS 2</span>

<span class="cm">/* First LEB of the superblock area */</span>
<span class="cp">#define UBIFS_SB_LNUM 0</span>
<span class="cm">/* First LEB of the master area */</span>
<span class="cp">#define UBIFS_MST_LNUM (UBIFS_SB_LNUM + UBIFS_SB_LEBS)</span>
<span class="cm">/* First LEB of the log area */</span>
<span class="cp">#define UBIFS_LOG_LNUM (UBIFS_MST_LNUM + UBIFS_MST_LEBS)</span>

<span class="cm">/*</span>
<span class="cm"> * The below constants define the absolute minimum values for various UBIFS</span>
<span class="cm"> * media areas. Many of them actually depend of flash geometry and the FS</span>
<span class="cm"> * configuration (number of journal heads, orphan LEBs, etc). This means that</span>
<span class="cm"> * the smallest volume size which can be used for UBIFS cannot be pre-defined</span>
<span class="cm"> * by these constants. The file-system that meets the below limitation will not</span>
<span class="cm"> * necessarily mount. UBIFS does run-time calculations and validates the FS</span>
<span class="cm"> * size.</span>
<span class="cm"> */</span>

<span class="cm">/* Minimum number of logical eraseblocks in the log */</span>
<span class="cp">#define UBIFS_MIN_LOG_LEBS 2</span>
<span class="cm">/* Minimum number of bud logical eraseblocks (one for each head) */</span>
<span class="cp">#define UBIFS_MIN_BUD_LEBS 3</span>
<span class="cm">/* Minimum number of journal logical eraseblocks */</span>
<span class="cp">#define UBIFS_MIN_JNL_LEBS (UBIFS_MIN_LOG_LEBS + UBIFS_MIN_BUD_LEBS)</span>
<span class="cm">/* Minimum number of LPT area logical eraseblocks */</span>
<span class="cp">#define UBIFS_MIN_LPT_LEBS 2</span>
<span class="cm">/* Minimum number of orphan area logical eraseblocks */</span>
<span class="cp">#define UBIFS_MIN_ORPH_LEBS 1</span>
<span class="cm">/*</span>
<span class="cm"> * Minimum number of main area logical eraseblocks (buds, 3 for the index, 1</span>
<span class="cm"> * for GC, 1 for deletions, and at least 1 for committed data).</span>
<span class="cm"> */</span>
<span class="cp">#define UBIFS_MIN_MAIN_LEBS (UBIFS_MIN_BUD_LEBS + 6)</span>

<span class="cm">/* Minimum number of logical eraseblocks */</span>
<span class="cp">#define UBIFS_MIN_LEB_CNT (UBIFS_SB_LEBS + UBIFS_MST_LEBS + \</span>
<span class="cp">			   UBIFS_MIN_LOG_LEBS + UBIFS_MIN_LPT_LEBS + \</span>
<span class="cp">			   UBIFS_MIN_ORPH_LEBS + UBIFS_MIN_MAIN_LEBS)</span>

<span class="cm">/* Node sizes (N.B. these are guaranteed to be multiples of 8) */</span>
<span class="cp">#define UBIFS_CH_SZ        sizeof(struct ubifs_ch)</span>
<span class="cp">#define UBIFS_INO_NODE_SZ  sizeof(struct ubifs_ino_node)</span>
<span class="cp">#define UBIFS_DATA_NODE_SZ sizeof(struct ubifs_data_node)</span>
<span class="cp">#define UBIFS_DENT_NODE_SZ sizeof(struct ubifs_dent_node)</span>
<span class="cp">#define UBIFS_TRUN_NODE_SZ sizeof(struct ubifs_trun_node)</span>
<span class="cp">#define UBIFS_PAD_NODE_SZ  sizeof(struct ubifs_pad_node)</span>
<span class="cp">#define UBIFS_SB_NODE_SZ   sizeof(struct ubifs_sb_node)</span>
<span class="cp">#define UBIFS_MST_NODE_SZ  sizeof(struct ubifs_mst_node)</span>
<span class="cp">#define UBIFS_REF_NODE_SZ  sizeof(struct ubifs_ref_node)</span>
<span class="cp">#define UBIFS_IDX_NODE_SZ  sizeof(struct ubifs_idx_node)</span>
<span class="cp">#define UBIFS_CS_NODE_SZ   sizeof(struct ubifs_cs_node)</span>
<span class="cp">#define UBIFS_ORPH_NODE_SZ sizeof(struct ubifs_orph_node)</span>
<span class="cm">/* Extended attribute entry nodes are identical to directory entry nodes */</span>
<span class="cp">#define UBIFS_XENT_NODE_SZ UBIFS_DENT_NODE_SZ</span>
<span class="cm">/* Only this does not have to be multiple of 8 bytes */</span>
<span class="cp">#define UBIFS_BRANCH_SZ    sizeof(struct ubifs_branch)</span>

<span class="cm">/* Maximum node sizes (N.B. these are guaranteed to be multiples of 8) */</span>
<span class="cp">#define UBIFS_MAX_DATA_NODE_SZ  (UBIFS_DATA_NODE_SZ + UBIFS_BLOCK_SIZE)</span>
<span class="cp">#define UBIFS_MAX_INO_NODE_SZ   (UBIFS_INO_NODE_SZ + UBIFS_MAX_INO_DATA)</span>
<span class="cp">#define UBIFS_MAX_DENT_NODE_SZ  (UBIFS_DENT_NODE_SZ + UBIFS_MAX_NLEN + 1)</span>
<span class="cp">#define UBIFS_MAX_XENT_NODE_SZ  UBIFS_MAX_DENT_NODE_SZ</span>

<span class="cm">/* The largest UBIFS node */</span>
<span class="cp">#define UBIFS_MAX_NODE_SZ UBIFS_MAX_INO_NODE_SZ</span>

<span class="cm">/*</span>
<span class="cm"> * On-flash inode flags.</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS_COMPR_FL: use compression for this inode</span>
<span class="cm"> * UBIFS_SYNC_FL:  I/O on this inode has to be synchronous</span>
<span class="cm"> * UBIFS_IMMUTABLE_FL: inode is immutable</span>
<span class="cm"> * UBIFS_APPEND_FL: writes to the inode may only append data</span>
<span class="cm"> * UBIFS_DIRSYNC_FL: I/O on this directory inode has to be synchronous</span>
<span class="cm"> * UBIFS_XATTR_FL: this inode is the inode for an extended attribute value</span>
<span class="cm"> *</span>
<span class="cm"> * Note, these are on-flash flags which correspond to ioctl flags</span>
<span class="cm"> * (@FS_COMPR_FL, etc). They have the same values now, but generally, do not</span>
<span class="cm"> * have to be the same.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">UBIFS_COMPR_FL</span>     <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
	<span class="n">UBIFS_SYNC_FL</span>      <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="n">UBIFS_IMMUTABLE_FL</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
	<span class="n">UBIFS_APPEND_FL</span>    <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>
	<span class="n">UBIFS_DIRSYNC_FL</span>   <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="n">UBIFS_XATTR_FL</span>     <span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Inode flag bits used by UBIFS */</span>
<span class="cp">#define UBIFS_FL_MASK 0x0000001F</span>

<span class="cm">/*</span>
<span class="cm"> * UBIFS compression algorithms.</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS_COMPR_NONE: no compression</span>
<span class="cm"> * UBIFS_COMPR_LZO: LZO compression</span>
<span class="cm"> * UBIFS_COMPR_ZLIB: ZLIB compression</span>
<span class="cm"> * UBIFS_COMPR_TYPES_CNT: count of supported compression types</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">UBIFS_COMPR_NONE</span><span class="p">,</span>
	<span class="n">UBIFS_COMPR_LZO</span><span class="p">,</span>
	<span class="n">UBIFS_COMPR_ZLIB</span><span class="p">,</span>
	<span class="n">UBIFS_COMPR_TYPES_CNT</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * UBIFS node types.</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS_INO_NODE: inode node</span>
<span class="cm"> * UBIFS_DATA_NODE: data node</span>
<span class="cm"> * UBIFS_DENT_NODE: directory entry node</span>
<span class="cm"> * UBIFS_XENT_NODE: extended attribute node</span>
<span class="cm"> * UBIFS_TRUN_NODE: truncation node</span>
<span class="cm"> * UBIFS_PAD_NODE: padding node</span>
<span class="cm"> * UBIFS_SB_NODE: superblock node</span>
<span class="cm"> * UBIFS_MST_NODE: master node</span>
<span class="cm"> * UBIFS_REF_NODE: LEB reference node</span>
<span class="cm"> * UBIFS_IDX_NODE: index node</span>
<span class="cm"> * UBIFS_CS_NODE: commit start node</span>
<span class="cm"> * UBIFS_ORPH_NODE: orphan node</span>
<span class="cm"> * UBIFS_NODE_TYPES_CNT: count of supported node types</span>
<span class="cm"> *</span>
<span class="cm"> * Note, we index arrays by these numbers, so keep them low and contiguous.</span>
<span class="cm"> * Node type constants for inodes, direntries and so on have to be the same as</span>
<span class="cm"> * corresponding key type constants.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">UBIFS_INO_NODE</span><span class="p">,</span>
	<span class="n">UBIFS_DATA_NODE</span><span class="p">,</span>
	<span class="n">UBIFS_DENT_NODE</span><span class="p">,</span>
	<span class="n">UBIFS_XENT_NODE</span><span class="p">,</span>
	<span class="n">UBIFS_TRUN_NODE</span><span class="p">,</span>
	<span class="n">UBIFS_PAD_NODE</span><span class="p">,</span>
	<span class="n">UBIFS_SB_NODE</span><span class="p">,</span>
	<span class="n">UBIFS_MST_NODE</span><span class="p">,</span>
	<span class="n">UBIFS_REF_NODE</span><span class="p">,</span>
	<span class="n">UBIFS_IDX_NODE</span><span class="p">,</span>
	<span class="n">UBIFS_CS_NODE</span><span class="p">,</span>
	<span class="n">UBIFS_ORPH_NODE</span><span class="p">,</span>
	<span class="n">UBIFS_NODE_TYPES_CNT</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Master node flags.</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS_MST_DIRTY: rebooted uncleanly - master node is dirty</span>
<span class="cm"> * UBIFS_MST_NO_ORPHS: no orphan inodes present</span>
<span class="cm"> * UBIFS_MST_RCVRY: written by recovery</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">UBIFS_MST_DIRTY</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">UBIFS_MST_NO_ORPHS</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">UBIFS_MST_RCVRY</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Node group type (used by recovery to recover whole group or none).</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS_NO_NODE_GROUP: this node is not part of a group</span>
<span class="cm"> * UBIFS_IN_NODE_GROUP: this node is a part of a group</span>
<span class="cm"> * UBIFS_LAST_OF_NODE_GROUP: this node is the last in a group</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">UBIFS_NO_NODE_GROUP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">UBIFS_IN_NODE_GROUP</span><span class="p">,</span>
	<span class="n">UBIFS_LAST_OF_NODE_GROUP</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Superblock flags.</span>
<span class="cm"> *</span>
<span class="cm"> * UBIFS_FLG_BIGLPT: if &quot;big&quot; LPT model is used if set</span>
<span class="cm"> * UBIFS_FLG_SPACE_FIXUP: first-mount &quot;fixup&quot; of free space within LEBs needed</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">UBIFS_FLG_BIGLPT</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="n">UBIFS_FLG_SPACE_FIXUP</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_ch - common header node.</span>
<span class="cm"> * @magic: UBIFS node magic number (%UBIFS_NODE_MAGIC)</span>
<span class="cm"> * @crc: CRC-32 checksum of the node header</span>
<span class="cm"> * @sqnum: sequence number</span>
<span class="cm"> * @len: full node length</span>
<span class="cm"> * @node_type: node type</span>
<span class="cm"> * @group_type: node group type</span>
<span class="cm"> * @padding: reserved for future, zeroes</span>
<span class="cm"> *</span>
<span class="cm"> * Every UBIFS node starts with this common part. If the node has a key, the</span>
<span class="cm"> * key always goes next.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">magic</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">crc</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">sqnum</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">node_type</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">group_type</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">padding</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * union ubifs_dev_desc - device node descriptor.</span>
<span class="cm"> * @new: new type device descriptor</span>
<span class="cm"> * @huge: huge type device descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * This data structure describes major/minor numbers of a device node. In an</span>
<span class="cm"> * inode is a device node then its data contains an object of this type. UBIFS</span>
<span class="cm"> * uses standard Linux &quot;new&quot; and &quot;huge&quot; device node encodings.</span>
<span class="cm"> */</span>
<span class="k">union</span> <span class="n">ubifs_dev_desc</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">new</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">huge</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_ino_node - inode node.</span>
<span class="cm"> * @ch: common header</span>
<span class="cm"> * @key: node key</span>
<span class="cm"> * @creat_sqnum: sequence number at time of creation</span>
<span class="cm"> * @size: inode size in bytes (amount of uncompressed data)</span>
<span class="cm"> * @atime_sec: access time seconds</span>
<span class="cm"> * @ctime_sec: creation time seconds</span>
<span class="cm"> * @mtime_sec: modification time seconds</span>
<span class="cm"> * @atime_nsec: access time nanoseconds</span>
<span class="cm"> * @ctime_nsec: creation time nanoseconds</span>
<span class="cm"> * @mtime_nsec: modification time nanoseconds</span>
<span class="cm"> * @nlink: number of hard links</span>
<span class="cm"> * @uid: owner ID</span>
<span class="cm"> * @gid: group ID</span>
<span class="cm"> * @mode: access flags</span>
<span class="cm"> * @flags: per-inode flags (%UBIFS_COMPR_FL, %UBIFS_SYNC_FL, etc)</span>
<span class="cm"> * @data_len: inode data length</span>
<span class="cm"> * @xattr_cnt: count of extended attributes this inode has</span>
<span class="cm"> * @xattr_size: summarized size of all extended attributes in bytes</span>
<span class="cm"> * @padding1: reserved for future, zeroes</span>
<span class="cm"> * @xattr_names: sum of lengths of all extended attribute names belonging to</span>
<span class="cm"> *               this inode</span>
<span class="cm"> * @compr_type: compression type used for this inode</span>
<span class="cm"> * @padding2: reserved for future, zeroes</span>
<span class="cm"> * @data: data attached to the inode</span>
<span class="cm"> *</span>
<span class="cm"> * Note, even though inode compression type is defined by @compr_type, some</span>
<span class="cm"> * nodes of this inode may be compressed with different compressor - this</span>
<span class="cm"> * happens if compression type is changed while the inode already has data</span>
<span class="cm"> * nodes. But @compr_type will be use for further writes to the inode.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, do not forget to amend &#39;zero_ino_node_unused()&#39; function when changing</span>
<span class="cm"> * the padding fields.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_ino_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="n">ch</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">key</span><span class="p">[</span><span class="n">UBIFS_MAX_KEY_LEN</span><span class="p">];</span>
	<span class="n">__le64</span> <span class="n">creat_sqnum</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">atime_sec</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">ctime_sec</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">mtime_sec</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">atime_nsec</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ctime_nsec</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">mtime_nsec</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">nlink</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">uid</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">gid</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">data_len</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">xattr_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">xattr_size</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">padding1</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="cm">/* Watch &#39;zero_ino_node_unused()&#39; if changing! */</span>
	<span class="n">__le32</span> <span class="n">xattr_names</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">compr_type</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">padding2</span><span class="p">[</span><span class="mi">26</span><span class="p">];</span> <span class="cm">/* Watch &#39;zero_ino_node_unused()&#39; if changing! */</span>
	<span class="n">__u8</span> <span class="n">data</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_dent_node - directory entry node.</span>
<span class="cm"> * @ch: common header</span>
<span class="cm"> * @key: node key</span>
<span class="cm"> * @inum: target inode number</span>
<span class="cm"> * @padding1: reserved for future, zeroes</span>
<span class="cm"> * @type: type of the target inode (%UBIFS_ITYPE_REG, %UBIFS_ITYPE_DIR, etc)</span>
<span class="cm"> * @nlen: name length</span>
<span class="cm"> * @padding2: reserved for future, zeroes</span>
<span class="cm"> * @name: zero-terminated name</span>
<span class="cm"> *</span>
<span class="cm"> * Note, do not forget to amend &#39;zero_dent_node_unused()&#39; function when</span>
<span class="cm"> * changing the padding fields.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_dent_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="n">ch</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">key</span><span class="p">[</span><span class="n">UBIFS_MAX_KEY_LEN</span><span class="p">];</span>
	<span class="n">__le64</span> <span class="n">inum</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">padding1</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">nlen</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">padding2</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="cm">/* Watch &#39;zero_dent_node_unused()&#39; if changing! */</span>
	<span class="n">__u8</span> <span class="n">name</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_data_node - data node.</span>
<span class="cm"> * @ch: common header</span>
<span class="cm"> * @key: node key</span>
<span class="cm"> * @size: uncompressed data size in bytes</span>
<span class="cm"> * @compr_type: compression type (%UBIFS_COMPR_NONE, %UBIFS_COMPR_LZO, etc)</span>
<span class="cm"> * @padding: reserved for future, zeroes</span>
<span class="cm"> * @data: data</span>
<span class="cm"> *</span>
<span class="cm"> * Note, do not forget to amend &#39;zero_data_node_unused()&#39; function when</span>
<span class="cm"> * changing the padding fields.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_data_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="n">ch</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">key</span><span class="p">[</span><span class="n">UBIFS_MAX_KEY_LEN</span><span class="p">];</span>
	<span class="n">__le32</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">compr_type</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">padding</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="cm">/* Watch &#39;zero_data_node_unused()&#39; if changing! */</span>
	<span class="n">__u8</span> <span class="n">data</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_trun_node - truncation node.</span>
<span class="cm"> * @ch: common header</span>
<span class="cm"> * @inum: truncated inode number</span>
<span class="cm"> * @padding: reserved for future, zeroes</span>
<span class="cm"> * @old_size: size before truncation</span>
<span class="cm"> * @new_size: size after truncation</span>
<span class="cm"> *</span>
<span class="cm"> * This node exists only in the journal and never goes to the main area. Note,</span>
<span class="cm"> * do not forget to amend &#39;zero_trun_node_unused()&#39; function when changing the</span>
<span class="cm"> * padding fields.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_trun_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="n">ch</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">inum</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">padding</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span> <span class="cm">/* Watch &#39;zero_trun_node_unused()&#39; if changing! */</span>
	<span class="n">__le64</span> <span class="n">old_size</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">new_size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_pad_node - padding node.</span>
<span class="cm"> * @ch: common header</span>
<span class="cm"> * @pad_len: how many bytes after this node are unused (because padded)</span>
<span class="cm"> * @padding: reserved for future, zeroes</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_pad_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="n">ch</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">pad_len</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_sb_node - superblock node.</span>
<span class="cm"> * @ch: common header</span>
<span class="cm"> * @padding: reserved for future, zeroes</span>
<span class="cm"> * @key_hash: type of hash function used in keys</span>
<span class="cm"> * @key_fmt: format of the key</span>
<span class="cm"> * @flags: file-system flags (%UBIFS_FLG_BIGLPT, etc)</span>
<span class="cm"> * @min_io_size: minimal input/output unit size</span>
<span class="cm"> * @leb_size: logical eraseblock size in bytes</span>
<span class="cm"> * @leb_cnt: count of LEBs used by file-system</span>
<span class="cm"> * @max_leb_cnt: maximum count of LEBs used by file-system</span>
<span class="cm"> * @max_bud_bytes: maximum amount of data stored in buds</span>
<span class="cm"> * @log_lebs: log size in logical eraseblocks</span>
<span class="cm"> * @lpt_lebs: number of LEBs used for lprops table</span>
<span class="cm"> * @orph_lebs: number of LEBs used for recording orphans</span>
<span class="cm"> * @jhead_cnt: count of journal heads</span>
<span class="cm"> * @fanout: tree fanout (max. number of links per indexing node)</span>
<span class="cm"> * @lsave_cnt: number of LEB numbers in LPT&#39;s save table</span>
<span class="cm"> * @fmt_version: UBIFS on-flash format version</span>
<span class="cm"> * @default_compr: default compression algorithm (%UBIFS_COMPR_LZO, etc)</span>
<span class="cm"> * @padding1: reserved for future, zeroes</span>
<span class="cm"> * @rp_uid: reserve pool UID</span>
<span class="cm"> * @rp_gid: reserve pool GID</span>
<span class="cm"> * @rp_size: size of the reserved pool in bytes</span>
<span class="cm"> * @padding2: reserved for future, zeroes</span>
<span class="cm"> * @time_gran: time granularity in nanoseconds</span>
<span class="cm"> * @uuid: UUID generated when the file system image was created</span>
<span class="cm"> * @ro_compat_version: UBIFS R/O compatibility version</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_sb_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="n">ch</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">padding</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">__u8</span> <span class="n">key_hash</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">key_fmt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">min_io_size</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">leb_size</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">leb_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">max_leb_cnt</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">max_bud_bytes</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">log_lebs</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">lpt_lebs</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">orph_lebs</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">jhead_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">fanout</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">lsave_cnt</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">fmt_version</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">default_compr</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">padding1</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">__le32</span> <span class="n">rp_uid</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">rp_gid</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">rp_size</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">time_gran</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="n">__le32</span> <span class="n">ro_compat_version</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">padding2</span><span class="p">[</span><span class="mi">3968</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_mst_node - master node.</span>
<span class="cm"> * @ch: common header</span>
<span class="cm"> * @highest_inum: highest inode number in the committed index</span>
<span class="cm"> * @cmt_no: commit number</span>
<span class="cm"> * @flags: various flags (%UBIFS_MST_DIRTY, etc)</span>
<span class="cm"> * @log_lnum: start of the log</span>
<span class="cm"> * @root_lnum: LEB number of the root indexing node</span>
<span class="cm"> * @root_offs: offset within @root_lnum</span>
<span class="cm"> * @root_len: root indexing node length</span>
<span class="cm"> * @gc_lnum: LEB reserved for garbage collection (%-1 value means the LEB was</span>
<span class="cm"> * not reserved and should be reserved on mount)</span>
<span class="cm"> * @ihead_lnum: LEB number of index head</span>
<span class="cm"> * @ihead_offs: offset of index head</span>
<span class="cm"> * @index_size: size of index on flash</span>
<span class="cm"> * @total_free: total free space in bytes</span>
<span class="cm"> * @total_dirty: total dirty space in bytes</span>
<span class="cm"> * @total_used: total used space in bytes (includes only data LEBs)</span>
<span class="cm"> * @total_dead: total dead space in bytes (includes only data LEBs)</span>
<span class="cm"> * @total_dark: total dark space in bytes (includes only data LEBs)</span>
<span class="cm"> * @lpt_lnum: LEB number of LPT root nnode</span>
<span class="cm"> * @lpt_offs: offset of LPT root nnode</span>
<span class="cm"> * @nhead_lnum: LEB number of LPT head</span>
<span class="cm"> * @nhead_offs: offset of LPT head</span>
<span class="cm"> * @ltab_lnum: LEB number of LPT&#39;s own lprops table</span>
<span class="cm"> * @ltab_offs: offset of LPT&#39;s own lprops table</span>
<span class="cm"> * @lsave_lnum: LEB number of LPT&#39;s save table (big model only)</span>
<span class="cm"> * @lsave_offs: offset of LPT&#39;s save table (big model only)</span>
<span class="cm"> * @lscan_lnum: LEB number of last LPT scan</span>
<span class="cm"> * @empty_lebs: number of empty logical eraseblocks</span>
<span class="cm"> * @idx_lebs: number of indexing logical eraseblocks</span>
<span class="cm"> * @leb_cnt: count of LEBs used by file-system</span>
<span class="cm"> * @padding: reserved for future, zeroes</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_mst_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="n">ch</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">highest_inum</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">cmt_no</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">log_lnum</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">root_lnum</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">root_offs</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">root_len</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">gc_lnum</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ihead_lnum</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ihead_offs</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">index_size</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">total_free</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">total_dirty</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">total_used</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">total_dead</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">total_dark</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">lpt_lnum</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">lpt_offs</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">nhead_lnum</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">nhead_offs</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ltab_lnum</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ltab_offs</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">lsave_lnum</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">lsave_offs</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">lscan_lnum</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">empty_lebs</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">idx_lebs</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">leb_cnt</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">padding</span><span class="p">[</span><span class="mi">344</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_ref_node - logical eraseblock reference node.</span>
<span class="cm"> * @ch: common header</span>
<span class="cm"> * @lnum: the referred logical eraseblock number</span>
<span class="cm"> * @offs: start offset in the referred LEB</span>
<span class="cm"> * @jhead: journal head number</span>
<span class="cm"> * @padding: reserved for future, zeroes</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_ref_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="n">ch</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">offs</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">jhead</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">padding</span><span class="p">[</span><span class="mi">28</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_branch - key/reference/length branch</span>
<span class="cm"> * @lnum: LEB number of the target node</span>
<span class="cm"> * @offs: offset within @lnum</span>
<span class="cm"> * @len: target node length</span>
<span class="cm"> * @key: key</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_branch</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">lnum</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">offs</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">key</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_idx_node - indexing node.</span>
<span class="cm"> * @ch: common header</span>
<span class="cm"> * @child_cnt: number of child index nodes</span>
<span class="cm"> * @level: tree level</span>
<span class="cm"> * @branches: LEB number / offset / length / key branches</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_idx_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="n">ch</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">child_cnt</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">level</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">branches</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_cs_node - commit start node.</span>
<span class="cm"> * @ch: common header</span>
<span class="cm"> * @cmt_no: commit number</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_cs_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="n">ch</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">cmt_no</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct ubifs_orph_node - orphan node.</span>
<span class="cm"> * @ch: common header</span>
<span class="cm"> * @cmt_no: commit number (also top bit is set on the last node of the commit)</span>
<span class="cm"> * @inos: inode numbers of orphans</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ubifs_orph_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_ch</span> <span class="n">ch</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">cmt_no</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">inos</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* __UBIFS_MEDIA_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
