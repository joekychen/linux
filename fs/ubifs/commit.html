<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ubifs › commit.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>commit.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file is part of UBIFS.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2006-2008 Nokia Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License version 2 as published by</span>
<span class="cm"> * the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along with</span>
<span class="cm"> * this program; if not, write to the Free Software Foundation, Inc., 51</span>
<span class="cm"> * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Adrian Hunter</span>
<span class="cm"> *          Artem Bityutskiy (Битюцкий Артём)</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This file implements functions that manage the running of the commit process.</span>
<span class="cm"> * Each affected module has its own functions to accomplish their part in the</span>
<span class="cm"> * commit and those functions are called here.</span>
<span class="cm"> *</span>
<span class="cm"> * The commit is the process whereby all updates to the index and LEB properties</span>
<span class="cm"> * are written out together and the journal becomes empty. This keeps the</span>
<span class="cm"> * file system consistent - at all times the state can be recreated by reading</span>
<span class="cm"> * the index and LEB properties and then replaying the journal.</span>
<span class="cm"> *</span>
<span class="cm"> * The commit is split into two parts named &quot;commit start&quot; and &quot;commit end&quot;.</span>
<span class="cm"> * During commit start, the commit process has exclusive access to the journal</span>
<span class="cm"> * by holding the commit semaphore down for writing. As few I/O operations as</span>
<span class="cm"> * possible are performed during commit start, instead the nodes that are to be</span>
<span class="cm"> * written are merely identified. During commit end, the commit semaphore is no</span>
<span class="cm"> * longer held and the journal is again in operation, allowing users to continue</span>
<span class="cm"> * to use the file system while the bulk of the commit I/O is performed. The</span>
<span class="cm"> * purpose of this two-step approach is to prevent the commit from causing any</span>
<span class="cm"> * latency blips. Note that in any case, the commit does not prevent lookups</span>
<span class="cm"> * (as permitted by the TNC mutex), or access to VFS data structures e.g. page</span>
<span class="cm"> * cache.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &quot;ubifs.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * nothing_to_commit - check if there is nothing to commit.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper function which checks if there is anything to commit. It is</span>
<span class="cm"> * used as an optimization to avoid starting the commit if it is not really</span>
<span class="cm"> * necessary. Indeed, the commit operation always assumes flash I/O (e.g.,</span>
<span class="cm"> * writing the commit start node to the log), and it is better to avoid doing</span>
<span class="cm"> * this unnecessarily. E.g., &#39;ubifs_sync_fs()&#39; runs the commit, but if there is</span>
<span class="cm"> * nothing to commit, it is more optimal to avoid any flash I/O.</span>
<span class="cm"> *</span>
<span class="cm"> * This function has to be called with @c-&gt;commit_sem locked for writing -</span>
<span class="cm"> * this function does not take LPT/TNC locks because the @c-&gt;commit_sem</span>
<span class="cm"> * guarantees that we have exclusive access to the TNC and LPT data structures.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %1 if there is nothing to commit and %0 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nothing_to_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * During mounting or remounting from R/O mode to R/W mode we may</span>
<span class="cm">	 * commit for various recovery-related reasons.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mounting</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">remounting_rw</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the root TNC node is dirty, we definitely have something to</span>
<span class="cm">	 * commit.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span> <span class="o">&amp;&amp;</span> <span class="n">ubifs_zn_dirty</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">zroot</span><span class="p">.</span><span class="n">znode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Even though the TNC is clean, the LPT tree may have dirty nodes. For</span>
<span class="cm">	 * example, this may happen if the budgeting subsystem invoked GC to</span>
<span class="cm">	 * make some free space, and the GC found an LEB with only dirty and</span>
<span class="cm">	 * free space. In this case GC would just change the lprops of this</span>
<span class="cm">	 * LEB (by turning all space into free space) and unmap it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">nroot</span> <span class="o">&amp;&amp;</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">DIRTY_CNODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">nroot</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_zn_cnt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_pn_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_nn_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * do_commit - commit the journal.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function implements UBIFS commit. It has to be called with commit lock</span>
<span class="cm"> * locked. Returns zero in case of success and a negative error code in case of</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">new_ltail_lnum</span><span class="p">,</span> <span class="n">old_ltail_lnum</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="n">zroot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_lp_stats</span> <span class="n">lst</span><span class="p">;</span>

	<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;start&quot;</span><span class="p">);</span>
	<span class="n">ubifs_assert</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_media</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_mount</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ro_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_up</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nothing_to_commit</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">commit_sem</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_cancel</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Sync all write buffers (necessary for recovery) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">jhead_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_wbuf_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">jheads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">wbuf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_up</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_no</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_gc_start_commit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_up</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_lprops</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_up</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_log_start_commit</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_ltail_lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_up</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_start_commit</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zroot</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_up</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_lpt_start_commit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_up</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_orphan_start_commit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_up</span><span class="p">;</span>

	<span class="n">ubifs_get_lp_stats</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lst</span><span class="p">);</span>

	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">commit_sem</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_tnc_end_commit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_lpt_end_commit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_orphan_end_commit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">old_ltail_lnum</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">ltail_lnum</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_log_end_commit</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">new_ltail_lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_check_old_index</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zroot</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_mutex</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">cmt_no</span>      <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_no</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">log_lnum</span>    <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">new_ltail_lnum</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">root_lnum</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">zroot</span><span class="p">.</span><span class="n">lnum</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">root_offs</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">zroot</span><span class="p">.</span><span class="n">offs</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">root_len</span>    <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">zroot</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">ihead_lnum</span>  <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ihead_lnum</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">ihead_offs</span>  <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ihead_offs</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">index_size</span>  <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bi</span><span class="p">.</span><span class="n">old_idx_sz</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">lpt_lnum</span>    <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_lnum</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">lpt_offs</span>    <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lpt_offs</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">nhead_lnum</span>  <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_lnum</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">nhead_offs</span>  <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">nhead_offs</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">ltab_lnum</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_lnum</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">ltab_offs</span>   <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ltab_offs</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">lsave_lnum</span>  <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_lnum</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">lsave_offs</span>  <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lsave_offs</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">lscan_lnum</span>  <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lscan_lnum</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">empty_lebs</span>  <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lst</span><span class="p">.</span><span class="n">empty_lebs</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">idx_lebs</span>    <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lst</span><span class="p">.</span><span class="n">idx_lebs</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">total_free</span>  <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">lst</span><span class="p">.</span><span class="n">total_free</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">total_dirty</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">lst</span><span class="p">.</span><span class="n">total_dirty</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">total_used</span>  <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">lst</span><span class="p">.</span><span class="n">total_used</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">total_dead</span>  <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">lst</span><span class="p">.</span><span class="n">total_dead</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">total_dark</span>  <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">lst</span><span class="p">.</span><span class="n">total_dark</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">no_orphs</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UBIFS_MST_NO_ORPHS</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_node</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UBIFS_MST_NO_ORPHS</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_write_master</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mst_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_log_post_commit</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">old_ltail_lnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_gc_end_commit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_lpt_post_commit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">out_cancel:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">=</span> <span class="n">COMMIT_RESTING</span><span class="p">;</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_wq</span><span class="p">);</span>
	<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;commit end&quot;</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_up:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">commit_sem</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;commit failed, error %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">=</span> <span class="n">COMMIT_BROKEN</span><span class="p">;</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_wq</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>
	<span class="n">ubifs_ro_mode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * run_bg_commit - run background commit if it is needed.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function runs background commit if it is needed. Returns zero in case</span>
<span class="cm"> * of success and a negative error code in case of failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">run_bg_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Run background commit only if background commit was requested or if</span>
<span class="cm">	 * commit is required.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">!=</span> <span class="n">COMMIT_BACKGROUND</span> <span class="o">&amp;&amp;</span>
	    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">!=</span> <span class="n">COMMIT_REQUIRED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">commit_sem</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">==</span> <span class="n">COMMIT_REQUIRED</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">=</span> <span class="n">COMMIT_RUNNING_REQUIRED</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">==</span> <span class="n">COMMIT_BACKGROUND</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">=</span> <span class="n">COMMIT_RUNNING_BACKGROUND</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">goto</span> <span class="n">out_cmt_unlock</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">do_commit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

<span class="nl">out_cmt_unlock:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">commit_sem</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_bg_thread - UBIFS background thread function.</span>
<span class="cm"> * @info: points to the file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function implements various file-system background activities:</span>
<span class="cm"> * o when a write-buffer timer expires it synchronizes the appropriate</span>
<span class="cm"> *   write-buffer;</span>
<span class="cm"> * o when the journal is about to be full, it starts in-advance commit.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, other stuff like background garbage collection may be added here in</span>
<span class="cm"> * future.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_bg_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>

	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;background thread </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> started, PID %d&quot;</span><span class="p">,</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt_name</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">set_freezable</span><span class="p">();</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kthread_should_stop</span><span class="p">())</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">try_to_freeze</span><span class="p">())</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="cm">/* Check if there is something to do */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">need_bgt</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Nothing prevents us from going sleep now and</span>
<span class="cm">			 * be never woken up and block the task which</span>
<span class="cm">			 * could wait in &#39;kthread_stop()&#39; forever.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">kthread_should_stop</span><span class="p">())</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>

		<span class="n">c</span><span class="o">-&gt;</span><span class="n">need_bgt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_bg_wbufs_sync</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">ubifs_ro_mode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

		<span class="n">run_bg_commit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">dbg_msg</span><span class="p">(</span><span class="s">&quot;background thread </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> stops&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">bgt_name</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_commit_required - set commit state to &quot;required&quot;.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called if a commit is required but cannot be done from the</span>
<span class="cm"> * calling function, so it is just flagged instead.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubifs_commit_required</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">COMMIT_RESTING</span>:
	<span class="k">case</span> <span class="n">COMMIT_BACKGROUND</span>:
		<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;old: %s, new: %s&quot;</span><span class="p">,</span> <span class="n">dbg_cstate</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span><span class="p">),</span>
			<span class="n">dbg_cstate</span><span class="p">(</span><span class="n">COMMIT_REQUIRED</span><span class="p">));</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">=</span> <span class="n">COMMIT_REQUIRED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMMIT_RUNNING_BACKGROUND</span>:
		<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;old: %s, new: %s&quot;</span><span class="p">,</span> <span class="n">dbg_cstate</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span><span class="p">),</span>
			<span class="n">dbg_cstate</span><span class="p">(</span><span class="n">COMMIT_RUNNING_REQUIRED</span><span class="p">));</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">=</span> <span class="n">COMMIT_RUNNING_REQUIRED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMMIT_REQUIRED</span>:
	<span class="k">case</span> <span class="n">COMMIT_RUNNING_REQUIRED</span>:
	<span class="k">case</span> <span class="n">COMMIT_BROKEN</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_request_bg_commit - notify the background thread to do a commit.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called if the journal is full enough to make a commit</span>
<span class="cm"> * worthwhile, so background thread is kicked to start it.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ubifs_request_bg_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">==</span> <span class="n">COMMIT_RESTING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;old: %s, new: %s&quot;</span><span class="p">,</span> <span class="n">dbg_cstate</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span><span class="p">),</span>
			<span class="n">dbg_cstate</span><span class="p">(</span><span class="n">COMMIT_BACKGROUND</span><span class="p">));</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">=</span> <span class="n">COMMIT_BACKGROUND</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>
		<span class="n">ubifs_wake_up_bgt</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wait_for_commit - wait for commit.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function sleeps until the commit operation is no longer running.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">wait_for_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;pid %d goes sleep&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The following sleeps if the condition is false, and will be woken</span>
<span class="cm">	 * when the commit ends. It is possible, although very unlikely, that we</span>
<span class="cm">	 * will wake up and see the subsequent commit running, rather than the</span>
<span class="cm">	 * one we were waiting for, and go back to sleep.  However, we will be</span>
<span class="cm">	 * woken again, so there is no danger of sleeping forever.</span>
<span class="cm">	 */</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_wq</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">!=</span> <span class="n">COMMIT_RUNNING_BACKGROUND</span> <span class="o">&amp;&amp;</span>
			      <span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">!=</span> <span class="n">COMMIT_RUNNING_REQUIRED</span><span class="p">);</span>
	<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;commit finished, pid %d woke up&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_run_commit - run or wait for commit.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function runs commit and returns zero in case of success and a negative</span>
<span class="cm"> * error code in case of failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_run_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">==</span> <span class="n">COMMIT_BROKEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">==</span> <span class="n">COMMIT_RUNNING_BACKGROUND</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * We set the commit state to &#39;running required&#39; to indicate</span>
<span class="cm">		 * that we want it to complete as quickly as possible.</span>
<span class="cm">		 */</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">=</span> <span class="n">COMMIT_RUNNING_REQUIRED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">==</span> <span class="n">COMMIT_RUNNING_REQUIRED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">wait_for_commit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>

	<span class="cm">/* Ok, the commit is indeed needed */</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">commit_sem</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Since we unlocked &#39;c-&gt;cs_lock&#39;, the state may have changed, so</span>
<span class="cm">	 * re-check it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">==</span> <span class="n">COMMIT_BROKEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_cmt_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">==</span> <span class="n">COMMIT_RUNNING_BACKGROUND</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">=</span> <span class="n">COMMIT_RUNNING_REQUIRED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">==</span> <span class="n">COMMIT_RUNNING_REQUIRED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">commit_sem</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">wait_for_commit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">=</span> <span class="n">COMMIT_RUNNING_REQUIRED</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">do_commit</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_cmt_unlock:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">commit_sem</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ubifs_gc_should_commit - determine if it is time for GC to run commit.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by garbage collection to determine if commit should</span>
<span class="cm"> * be run. If commit state is @COMMIT_BACKGROUND, which means that the journal</span>
<span class="cm"> * is full enough to start commit, this function returns true. It is not</span>
<span class="cm"> * absolutely necessary to commit yet, but it feels like this should be better</span>
<span class="cm"> * then to keep doing GC. This function returns %1 if GC has to initiate commit</span>
<span class="cm"> * and %0 if not.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ubifs_gc_should_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">==</span> <span class="n">COMMIT_BACKGROUND</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;commit required now&quot;</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">=</span> <span class="n">COMMIT_REQUIRED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dbg_cmt</span><span class="p">(</span><span class="s">&quot;commit not requested&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cmt_state</span> <span class="o">==</span> <span class="n">COMMIT_REQUIRED</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">cs_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Everything below is related to debugging.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct idx_node - hold index nodes during index tree traversal.</span>
<span class="cm"> * @list: list</span>
<span class="cm"> * @iip: index in parent (slot number of this indexing node in the parent</span>
<span class="cm"> *       indexing node)</span>
<span class="cm"> * @upper_key: all keys in this indexing node have to be less or equivalent to</span>
<span class="cm"> *             this key</span>
<span class="cm"> * @idx: index node (8-byte aligned because all node structures must be 8-byte</span>
<span class="cm"> *       aligned)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">idx_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iip</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">upper_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_idx_node</span> <span class="n">idx</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_old_index_check_init - get information for the next old index check.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @zroot: root of the index</span>
<span class="cm"> *</span>
<span class="cm"> * This function records information about the index that will be needed for the</span>
<span class="cm"> * next old index check i.e. &#39;dbg_check_old_index()&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbg_old_index_check_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zroot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ubifs_idx_node</span> <span class="o">*</span><span class="n">idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_debug_info</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="p">;</span>

	<span class="n">d</span><span class="o">-&gt;</span><span class="n">old_zroot</span> <span class="o">=</span> <span class="o">*</span><span class="n">zroot</span><span class="p">;</span>
	<span class="n">lnum</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">old_zroot</span><span class="p">.</span><span class="n">lnum</span><span class="p">;</span>
	<span class="n">offs</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">old_zroot</span><span class="p">.</span><span class="n">offs</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">old_zroot</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">max_idx_node_sz</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idx</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_read_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">UBIFS_IDX_NODE</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">d</span><span class="o">-&gt;</span><span class="n">old_zroot_level</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">idx</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">old_zroot_sqnum</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">idx</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">sqnum</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dbg_check_old_index - check the old copy of the index.</span>
<span class="cm"> * @c: UBIFS file-system description object</span>
<span class="cm"> * @zroot: root of the new index</span>
<span class="cm"> *</span>
<span class="cm"> * In order to be able to recover from an unclean unmount, a complete copy of</span>
<span class="cm"> * the index must exist on flash. This is the &quot;old&quot; index. The commit process</span>
<span class="cm"> * must write the &quot;new&quot; index to flash without overwriting or destroying any</span>
<span class="cm"> * part of the old index. This function is run at commit end in order to check</span>
<span class="cm"> * that the old index does indeed exist completely intact.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns %0 on success and a negative error code on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dbg_check_old_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">ubifs_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ubifs_zbranch</span> <span class="o">*</span><span class="n">zroot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">last_level</span><span class="p">),</span> <span class="n">child_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubifs_debug_info</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dbg</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">ubifs_key</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">lower_key</span><span class="p">),</span> <span class="n">upper_key</span><span class="p">,</span> <span class="n">l_key</span><span class="p">,</span> <span class="n">u_key</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">last_sqnum</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ubifs_idx_node</span> <span class="o">*</span><span class="n">idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">idx_node</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">sz</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbg_is_chk_index</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>

	<span class="n">sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">idx_node</span><span class="p">)</span> <span class="o">+</span> <span class="n">ubifs_idx_node_sz</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span><span class="p">)</span> <span class="o">-</span>
	     <span class="n">UBIFS_IDX_NODE_SZ</span><span class="p">;</span>

	<span class="cm">/* Start at the old zroot */</span>
	<span class="n">lnum</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">old_zroot</span><span class="p">.</span><span class="n">lnum</span><span class="p">;</span>
	<span class="n">offs</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">old_zroot</span><span class="p">.</span><span class="n">offs</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">old_zroot</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
	<span class="n">iip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Traverse the index tree preorder depth-first i.e. do a node and then</span>
<span class="cm">	 * its subtrees from left to right.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ubifs_branch</span> <span class="o">*</span><span class="n">br</span><span class="p">;</span>

		<span class="cm">/* Get the next index node */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span><span class="o">-&gt;</span><span class="n">iip</span> <span class="o">=</span> <span class="n">iip</span><span class="p">;</span>
		<span class="cm">/* Keep the index nodes on our path in a linked list */</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>
		<span class="cm">/* Read the index node */</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ubifs_read_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">UBIFS_IDX_NODE</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">lnum</span><span class="p">,</span> <span class="n">offs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="cm">/* Validate index node */</span>
		<span class="n">child_cnt</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">idx</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">child_cnt</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">child_cnt</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">fanout</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* Check root level and sqnum */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">idx</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span> <span class="o">!=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">old_zroot_level</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">idx</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">sqnum</span><span class="p">)</span> <span class="o">!=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">old_zroot_sqnum</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Set last values as though root had a parent */</span>
			<span class="n">last_level</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">idx</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">last_sqnum</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">idx</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">sqnum</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">key_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ubifs_idx_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">lower_key</span><span class="p">);</span>
			<span class="n">highest_ino_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">upper_key</span><span class="p">,</span> <span class="n">INUM_WATERMARK</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">key_copy</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">upper_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">upper_key</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">idx</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span> <span class="o">!=</span> <span class="n">last_level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * The index is always written bottom up hence a child&#39;s sqnum</span>
<span class="cm">		 * is always less than the parents.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">idx</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">sqnum</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">last_sqnum</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Check key range */</span>
		<span class="n">key_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ubifs_idx_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">l_key</span><span class="p">);</span>
		<span class="n">br</span> <span class="o">=</span> <span class="n">ubifs_idx_branch</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">child_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">key_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u_key</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lower_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l_key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">upper_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u_key</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">keys_cmp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">upper_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u_key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_hash_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u_key</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_dump</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="cm">/* Go to next index node */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">idx</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* At the bottom, so go up until can go right */</span>
			<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Drop the bottom of the list */</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
				<span class="cm">/* No more list means we are done */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="cm">/* Look at the new bottom */</span>
				<span class="n">i</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">idx_node</span><span class="p">,</span>
					       <span class="n">list</span><span class="p">);</span>
				<span class="n">idx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">;</span>
				<span class="cm">/* Can we go right */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">iip</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">idx</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">iip</span> <span class="o">=</span> <span class="n">iip</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="cm">/* Nope, so go up again */</span>
					<span class="n">iip</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">iip</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="cm">/* Go down left */</span>
			<span class="n">iip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We have the parent in &#39;idx&#39; and now we set up for reading the</span>
<span class="cm">		 * child pointed to by slot &#39;iip&#39;.</span>
<span class="cm">		 */</span>
		<span class="n">last_level</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">idx</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
		<span class="n">last_sqnum</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">idx</span><span class="o">-&gt;</span><span class="n">ch</span><span class="p">.</span><span class="n">sqnum</span><span class="p">);</span>
		<span class="n">br</span> <span class="o">=</span> <span class="n">ubifs_idx_branch</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">iip</span><span class="p">);</span>
		<span class="n">lnum</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">lnum</span><span class="p">);</span>
		<span class="n">offs</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">offs</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">key_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lower_key</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iip</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">idx</span><span class="o">-&gt;</span><span class="n">child_cnt</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">br</span> <span class="o">=</span> <span class="n">ubifs_idx_branch</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">iip</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">key_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">upper_key</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">key_copy</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">upper_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">upper_key</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dbg_old_index_check_init</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">zroot</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_dump:</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;dumping index node (iip=%d)&quot;</span><span class="p">,</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">iip</span><span class="p">);</span>
	<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">idx_node</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;dumping parent index node&quot;</span><span class="p">);</span>
		<span class="n">ubifs_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out_free:</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">idx_node</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ubifs_err</span><span class="p">(</span><span class="s">&quot;failed, error %d&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
