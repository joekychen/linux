<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ocfs2 › stackglue.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>stackglue.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* -*- mode: c; c-basic-offset: 8; -*-</span>
<span class="cm"> * vim: noexpandtab sw=8 ts=8 sts=0:</span>
<span class="cm"> *</span>
<span class="cm"> * stackglue.h</span>
<span class="cm"> *</span>
<span class="cm"> * Glue to the underlying cluster stack.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007 Oracle.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public</span>
<span class="cm"> * License as published by the Free Software Foundation, version 2.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> */</span>


<span class="cp">#ifndef STACKGLUE_H</span>
<span class="cp">#define STACKGLUE_H</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/dlmconstants.h&gt;</span>

<span class="cp">#include &quot;dlm/dlmapi.h&quot;</span>
<span class="cp">#include &lt;linux/dlm.h&gt;</span>

<span class="cm">/* Needed for plock-related prototypes */</span>
<span class="k">struct</span> <span class="n">file</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">file_lock</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * dlmconstants.h does not have a LOCAL flag.  We hope to remove it</span>
<span class="cm"> * some day, but right now we need it.  Let&#39;s fake it.  This value is larger</span>
<span class="cm"> * than any flag in dlmconstants.h.</span>
<span class="cm"> */</span>
<span class="cp">#define DLM_LKF_LOCAL		0x00100000</span>

<span class="cm">/*</span>
<span class="cm"> * This shadows DLM_LOCKSPACE_LEN in fs/dlm/dlm_internal.h.  That probably</span>
<span class="cm"> * wants to be in a public header.</span>
<span class="cm"> */</span>
<span class="cp">#define GROUP_NAME_MAX		64</span>


<span class="cm">/*</span>
<span class="cm"> * ocfs2_protocol_version changes when ocfs2 does something different in</span>
<span class="cm"> * its inter-node behavior.  See dlmglue.c for more information.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_protocol_version</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">pv_major</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pv_minor</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The dlm_lockstatus struct includes lvb space, but the dlm_lksb struct only</span>
<span class="cm"> * has a pointer to separately allocated lvb space.  This struct exists only to</span>
<span class="cm"> * include in the lksb union to make space for a combined dlm_lksb and lvb.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fsdlm_lksb_plus_lvb</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lksb</span> <span class="n">lksb</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">lvb</span><span class="p">[</span><span class="n">DLM_LVB_LEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * A union of all lock status structures.  We define it here so that the</span>
<span class="cm"> * size of the union is known.  Lock status structures are embedded in</span>
<span class="cm"> * ocfs2 inodes.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_cluster_connection</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ocfs2_dlm_lksb</span> <span class="p">{</span>
	 <span class="k">union</span> <span class="p">{</span>
		 <span class="k">struct</span> <span class="n">dlm_lockstatus</span> <span class="n">lksb_o2dlm</span><span class="p">;</span>
		 <span class="k">struct</span> <span class="n">dlm_lksb</span> <span class="n">lksb_fsdlm</span><span class="p">;</span>
		 <span class="k">struct</span> <span class="n">fsdlm_lksb_plus_lvb</span> <span class="n">padding</span><span class="p">;</span>
	 <span class="p">};</span>
	 <span class="k">struct</span> <span class="n">ocfs2_cluster_connection</span> <span class="o">*</span><span class="n">lksb_conn</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The ocfs2_locking_protocol defines the handlers called on ocfs2&#39;s behalf.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_locking_protocol</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ocfs2_protocol_version</span> <span class="n">lp_max_version</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lp_lock_ast</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ocfs2_dlm_lksb</span> <span class="o">*</span><span class="n">lksb</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lp_blocking_ast</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ocfs2_dlm_lksb</span> <span class="o">*</span><span class="n">lksb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lp_unlock_ast</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ocfs2_dlm_lksb</span> <span class="o">*</span><span class="n">lksb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">);</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * A cluster connection.  Mostly opaque to ocfs2, the connection holds</span>
<span class="cm"> * state for the underlying stack.  ocfs2 does use cc_version to determine</span>
<span class="cm"> * locking compatibility.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_cluster_connection</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">cc_name</span><span class="p">[</span><span class="n">GROUP_NAME_MAX</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">cc_namelen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_protocol_version</span> <span class="n">cc_version</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_locking_protocol</span> <span class="o">*</span><span class="n">cc_proto</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cc_recovery_handler</span><span class="p">)(</span><span class="kt">int</span> <span class="n">node_num</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">recovery_data</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cc_recovery_data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cc_lockspace</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">cc_private</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Each cluster stack implements the stack operations structure.  Not used</span>
<span class="cm"> * in the ocfs2 code, the stackglue code translates generic cluster calls</span>
<span class="cm"> * into stack operations.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_stack_operations</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The fs code calls ocfs2_cluster_connect() to attach a new</span>
<span class="cm">	 * filesystem to the cluster stack.  The -&gt;connect() op is passed</span>
<span class="cm">	 * an ocfs2_cluster_connection with the name and recovery field</span>
<span class="cm">	 * filled in.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The stack must set up any notification mechanisms and create</span>
<span class="cm">	 * the filesystem lockspace in the DLM.  The lockspace should be</span>
<span class="cm">	 * stored on cc_lockspace.  Any other information can be stored on</span>
<span class="cm">	 * cc_private.</span>
<span class="cm">	 *</span>
<span class="cm">	 * -&gt;connect() must not return until it is guaranteed that</span>
<span class="cm">	 *</span>
<span class="cm">	 *  - Node down notifications for the filesystem will be received</span>
<span class="cm">	 *    and passed to conn-&gt;cc_recovery_handler().</span>
<span class="cm">	 *  - Locking requests for the filesystem will be processed.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">connect</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ocfs2_cluster_connection</span> <span class="o">*</span><span class="n">conn</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The fs code calls ocfs2_cluster_disconnect() when a filesystem</span>
<span class="cm">	 * no longer needs cluster services.  All DLM locks have been</span>
<span class="cm">	 * dropped, and recovery notification is being ignored by the</span>
<span class="cm">	 * fs code.  The stack must disengage from the DLM and discontinue</span>
<span class="cm">	 * recovery notification.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Once -&gt;disconnect() has returned, the connection structure will</span>
<span class="cm">	 * be freed.  Thus, a stack must not return from -&gt;disconnect()</span>
<span class="cm">	 * until it will no longer reference the conn pointer.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Once this call returns, the stack glue will be dropping this</span>
<span class="cm">	 * connection&#39;s reference on the module.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">disconnect</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ocfs2_cluster_connection</span> <span class="o">*</span><span class="n">conn</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * -&gt;this_node() returns the cluster&#39;s unique identifier for the</span>
<span class="cm">	 * local node.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">this_node</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Call the underlying dlm lock function.  The -&gt;dlm_lock()</span>
<span class="cm">	 * callback should convert the flags and mode as appropriate.</span>
<span class="cm">	 *</span>
<span class="cm">	 * ast and bast functions are not part of the call because the</span>
<span class="cm">	 * stack will likely want to wrap ast and bast calls before passing</span>
<span class="cm">	 * them to stack-&gt;sp_proto.  There is no astarg.  The lksb will</span>
<span class="cm">	 * be passed back to the ast and bast functions.  The caller can</span>
<span class="cm">	 * use this to find their object.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dlm_lock</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ocfs2_cluster_connection</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">ocfs2_dlm_lksb</span> <span class="o">*</span><span class="n">lksb</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">flags</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Call the underlying dlm unlock function.  The -&gt;dlm_unlock()</span>
<span class="cm">	 * function should convert the flags as appropriate.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The unlock ast is not passed, as the stack will want to wrap</span>
<span class="cm">	 * it before calling stack-&gt;sp_proto-&gt;lp_unlock_ast().  There is</span>
<span class="cm">	 * no astarg.  The lksb will be passed back to the unlock ast</span>
<span class="cm">	 * function.  The caller can use this to find their object.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dlm_unlock</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ocfs2_cluster_connection</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ocfs2_dlm_lksb</span> <span class="o">*</span><span class="n">lksb</span><span class="p">,</span>
			  <span class="n">u32</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Return the status of the current lock status block.  The fs</span>
<span class="cm">	 * code should never dereference the union.  The -&gt;lock_status()</span>
<span class="cm">	 * callback pulls out the stack-specific lksb, converts the status</span>
<span class="cm">	 * to a proper errno, and returns it.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lock_status</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ocfs2_dlm_lksb</span> <span class="o">*</span><span class="n">lksb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Return non-zero if the LVB is valid.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lvb_valid</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ocfs2_dlm_lksb</span> <span class="o">*</span><span class="n">lksb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Pull the lvb pointer off of the stack-specific lksb.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">lock_lvb</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ocfs2_dlm_lksb</span> <span class="o">*</span><span class="n">lksb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Cluster-aware posix locks</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is NULL for stacks which do not support posix locks.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">plock</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ocfs2_cluster_connection</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span>
		     <span class="n">u64</span> <span class="n">ino</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is an optoinal debugging hook.  If provided, the</span>
<span class="cm">	 * stack can dump debugging information about this lock.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dump_lksb</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ocfs2_dlm_lksb</span> <span class="o">*</span><span class="n">lksb</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Each stack plugin must describe itself by registering a</span>
<span class="cm"> * ocfs2_stack_plugin structure.  This is only seen by stackglue and the</span>
<span class="cm"> * stack driver.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_stack_plugin</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sp_name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_stack_operations</span> <span class="o">*</span><span class="n">sp_ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">sp_owner</span><span class="p">;</span>

	<span class="cm">/* These are managed by the stackglue code. */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">sp_list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sp_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_protocol_version</span> <span class="n">sp_max_proto</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/* Used by the filesystem */</span>
<span class="kt">int</span> <span class="n">ocfs2_cluster_connect</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">stack_name</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">grouplen</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ocfs2_locking_protocol</span> <span class="o">*</span><span class="n">lproto</span><span class="p">,</span>
			  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">recovery_handler</span><span class="p">)(</span><span class="kt">int</span> <span class="n">node_num</span><span class="p">,</span>
						   <span class="kt">void</span> <span class="o">*</span><span class="n">recovery_data</span><span class="p">),</span>
			  <span class="kt">void</span> <span class="o">*</span><span class="n">recovery_data</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ocfs2_cluster_connection</span> <span class="o">**</span><span class="n">conn</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * Used by callers that don&#39;t store their stack name.  They must ensure</span>
<span class="cm"> * all nodes have the same stack.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ocfs2_cluster_connect_agnostic</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">grouplen</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">ocfs2_locking_protocol</span> <span class="o">*</span><span class="n">lproto</span><span class="p">,</span>
				   <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">recovery_handler</span><span class="p">)(</span><span class="kt">int</span> <span class="n">node_num</span><span class="p">,</span>
							    <span class="kt">void</span> <span class="o">*</span><span class="n">recovery_data</span><span class="p">),</span>
				   <span class="kt">void</span> <span class="o">*</span><span class="n">recovery_data</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">ocfs2_cluster_connection</span> <span class="o">**</span><span class="n">conn</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ocfs2_cluster_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_cluster_connection</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">hangup_pending</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ocfs2_cluster_hangup</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span> <span class="kt">int</span> <span class="n">grouplen</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ocfs2_cluster_this_node</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ocfs2_lock_res</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ocfs2_dlm_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_cluster_connection</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">ocfs2_dlm_lksb</span> <span class="o">*</span><span class="n">lksb</span><span class="p">,</span>
		   <span class="n">u32</span> <span class="n">flags</span><span class="p">,</span>
		   <span class="kt">void</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ocfs2_dlm_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_cluster_connection</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">ocfs2_dlm_lksb</span> <span class="o">*</span><span class="n">lksb</span><span class="p">,</span>
		     <span class="n">u32</span> <span class="n">flags</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ocfs2_dlm_lock_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dlm_lksb</span> <span class="o">*</span><span class="n">lksb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ocfs2_dlm_lvb_valid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dlm_lksb</span> <span class="o">*</span><span class="n">lksb</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">ocfs2_dlm_lvb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dlm_lksb</span> <span class="o">*</span><span class="n">lksb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ocfs2_dlm_dump_lksb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dlm_lksb</span> <span class="o">*</span><span class="n">lksb</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ocfs2_stack_supports_plocks</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ocfs2_plock</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_cluster_connection</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ino</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ocfs2_stack_glue_set_max_proto_version</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_protocol_version</span> <span class="o">*</span><span class="n">max_proto</span><span class="p">);</span>


<span class="cm">/* Used by stack plugins */</span>
<span class="kt">int</span> <span class="n">ocfs2_stack_glue_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_stack_plugin</span> <span class="o">*</span><span class="n">plugin</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ocfs2_stack_glue_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_stack_plugin</span> <span class="o">*</span><span class="n">plugin</span><span class="p">);</span>

<span class="cp">#endif  </span><span class="cm">/* STACKGLUE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
