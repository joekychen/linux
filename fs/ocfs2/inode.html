<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ocfs2 › inode.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>inode.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* -*- mode: c; c-basic-offset: 8; -*-</span>
<span class="cm"> * vim: noexpandtab sw=8 ts=8 sts=0:</span>
<span class="cm"> *</span>
<span class="cm"> * inode.h</span>
<span class="cm"> *</span>
<span class="cm"> * Function prototypes</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2002, 2004 Oracle.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public</span>
<span class="cm"> * License as published by the Free Software Foundation; either</span>
<span class="cm"> * version 2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public</span>
<span class="cm"> * License along with this program; if not, write to the</span>
<span class="cm"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 021110-1307, USA.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef OCFS2_INODE_H</span>
<span class="cp">#define OCFS2_INODE_H</span>

<span class="cp">#include &quot;extent_map.h&quot;</span>

<span class="cm">/* OCFS2 Inode Private Data */</span>
<span class="k">struct</span> <span class="n">ocfs2_inode_info</span>
<span class="p">{</span>
	<span class="n">u64</span>			<span class="n">ip_blkno</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ocfs2_lock_res</span>		<span class="n">ip_rw_lockres</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_lock_res</span>		<span class="n">ip_inode_lockres</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_lock_res</span>		<span class="n">ip_open_lockres</span><span class="p">;</span>

	<span class="cm">/* protects allocation changes on this inode. */</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span>		<span class="n">ip_alloc_sem</span><span class="p">;</span>

	<span class="cm">/* protects extended attribute changes on this inode */</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span>		<span class="n">ip_xattr_sem</span><span class="p">;</span>

	<span class="cm">/* Number of outstanding AIO&#39;s which are not page aligned */</span>
	<span class="n">atomic_t</span>			<span class="n">ip_unaligned_aio</span><span class="p">;</span>

	<span class="cm">/* These fields are protected by ip_lock */</span>
	<span class="n">spinlock_t</span>			<span class="n">ip_lock</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">ip_open_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">ip_io_markers</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">ip_clusters</span><span class="p">;</span>

	<span class="n">u16</span>				<span class="n">ip_dyn_features</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>			<span class="n">ip_io_mutex</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">ip_flags</span><span class="p">;</span> <span class="cm">/* see below */</span>
	<span class="n">u32</span>				<span class="n">ip_attr</span><span class="p">;</span> <span class="cm">/* inode attributes */</span>

	<span class="cm">/* protected by recovery_lock. */</span>
	<span class="k">struct</span> <span class="n">inode</span>			<span class="o">*</span><span class="n">ip_next_orphan</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ocfs2_caching_info</span>	<span class="n">ip_metadata_cache</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_extent_map</span>		<span class="n">ip_extent_map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>			<span class="n">vfs_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jbd2_inode</span>		<span class="n">ip_jinode</span><span class="p">;</span>

	<span class="n">u32</span>				<span class="n">ip_dir_start_lookup</span><span class="p">;</span>

	<span class="cm">/* Only valid if the inode is the dir. */</span>
	<span class="n">u32</span>				<span class="n">ip_last_used_slot</span><span class="p">;</span>
	<span class="n">u64</span>				<span class="n">ip_last_used_group</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">ip_dir_lock_gen</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ocfs2_alloc_reservation</span>	<span class="n">ip_la_data_resv</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Flags for the ip_flags field</span>
<span class="cm"> */</span>
<span class="cm">/* System file inodes  */</span>
<span class="cp">#define OCFS2_INODE_SYSTEM_FILE		0x00000001</span>
<span class="cp">#define OCFS2_INODE_JOURNAL		0x00000002</span>
<span class="cp">#define OCFS2_INODE_BITMAP		0x00000004</span>
<span class="cm">/* This inode has been wiped from disk */</span>
<span class="cp">#define OCFS2_INODE_DELETED		0x00000008</span>
<span class="cm">/* Another node is deleting, so our delete is a nop */</span>
<span class="cp">#define OCFS2_INODE_SKIP_DELETE		0x00000010</span>
<span class="cm">/* Has the inode been orphaned on another node?</span>
<span class="cm"> *</span>
<span class="cm"> * This hints to ocfs2_drop_inode that it should clear i_nlink before</span>
<span class="cm"> * continuing.</span>
<span class="cm"> *</span>
<span class="cm"> * We *only* set this on unlink vote from another node. If the inode</span>
<span class="cm"> * was locally orphaned, then we&#39;re sure of the state and don&#39;t need</span>
<span class="cm"> * to twiddle i_nlink later - it&#39;s either zero or not depending on</span>
<span class="cm"> * whether our unlink succeeded. Otherwise we got this from a node</span>
<span class="cm"> * whose intention was to orphan the inode, however he may have</span>
<span class="cm"> * crashed, failed etc, so we let ocfs2_drop_inode zero the value and</span>
<span class="cm"> * rely on ocfs2_delete_inode to sort things out under the proper</span>
<span class="cm"> * cluster locks.</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_INODE_MAYBE_ORPHANED	0x00000020</span>
<span class="cm">/* Does someone have the file open O_DIRECT */</span>
<span class="cp">#define OCFS2_INODE_OPEN_DIRECT		0x00000040</span>
<span class="cm">/* Tell the inode wipe code it&#39;s not in orphan dir */</span>
<span class="cp">#define OCFS2_INODE_SKIP_ORPHAN_DIR     0x00000080</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ocfs2_inode_info</span> <span class="o">*</span><span class="nf">OCFS2_I</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ocfs2_inode_info</span><span class="p">,</span> <span class="n">vfs_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define INODE_JOURNAL(i) (OCFS2_I(i)-&gt;ip_flags &amp; OCFS2_INODE_JOURNAL)</span>
<span class="cp">#define SET_INODE_JOURNAL(i) (OCFS2_I(i)-&gt;ip_flags |= OCFS2_INODE_JOURNAL)</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">ocfs2_inode_cache</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">ocfs2_aops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ocfs2_caching_operations</span> <span class="n">ocfs2_inode_caching_ops</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ocfs2_caching_info</span> <span class="o">*</span><span class="nf">INODE_CACHE</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">OCFS2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ip_metadata_cache</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ocfs2_evict_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ocfs2_drop_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="cm">/* Flags for ocfs2_iget() */</span>
<span class="cp">#define OCFS2_FI_FLAG_SYSFILE		0x1</span>
<span class="cp">#define OCFS2_FI_FLAG_ORPHAN_RECOVERY	0x2</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ocfs2_ilookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">feoff</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ocfs2_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">feoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">sysfile_type</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ocfs2_inode_init_private</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ocfs2_inode_revalidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ocfs2_populate_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ocfs2_dinode</span> <span class="o">*</span><span class="n">fe</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">create_ino</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ocfs2_read_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ocfs2_read_inode2</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="n">ocfs2_rw_direct</span><span class="p">(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offp</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ocfs2_sync_blockdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ocfs2_refresh_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ocfs2_dinode</span> <span class="o">*</span><span class="n">fe</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ocfs2_mark_inode_dirty</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ocfs2_aio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ocfs2_aio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">ocfs2_bread</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">block</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reada</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ocfs2_set_inode_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ocfs2_get_inode_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_inode_info</span> <span class="o">*</span><span class="n">oi</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">blkcnt_t</span> <span class="nf">ocfs2_inode_sector_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">c_to_s_bits</span> <span class="o">=</span> <span class="n">OCFS2_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_clustersize_bits</span> <span class="o">-</span> <span class="mi">9</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">blkcnt_t</span><span class="p">)(</span><span class="n">OCFS2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ip_clusters</span> <span class="o">&lt;&lt;</span> <span class="n">c_to_s_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Validate that a bh contains a valid inode */</span>
<span class="kt">int</span> <span class="n">ocfs2_validate_inode_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * Read an inode block into *bh.  If *bh is NULL, a bh will be allocated.</span>
<span class="cm"> * This is a cached read.  The inode will be validated with</span>
<span class="cm"> * ocfs2_validate_inode_block().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ocfs2_read_inode_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">bh</span><span class="p">);</span>
<span class="cm">/* The same, but can be passed OCFS2_BH_* flags */</span>
<span class="kt">int</span> <span class="n">ocfs2_read_inode_block_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">bh</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ocfs2_inode_info</span> <span class="o">*</span><span class="nf">cache_info_to_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_caching_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ocfs2_inode_info</span><span class="p">,</span> <span class="n">ip_metadata_cache</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* OCFS2_INODE_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
