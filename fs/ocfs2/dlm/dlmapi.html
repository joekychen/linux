<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ocfs2 › dlm › dlmapi.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>dlmapi.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* -*- mode: c; c-basic-offset: 8; -*-</span>
<span class="cm"> * vim: noexpandtab sw=8 ts=8 sts=0:</span>
<span class="cm"> *</span>
<span class="cm"> * dlmapi.h</span>
<span class="cm"> *</span>
<span class="cm"> * externally exported dlm interfaces</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004 Oracle.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public</span>
<span class="cm"> * License as published by the Free Software Foundation; either</span>
<span class="cm"> * version 2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public</span>
<span class="cm"> * License along with this program; if not, write to the</span>
<span class="cm"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 021110-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef DLMAPI_H</span>
<span class="cp">#define DLMAPI_H</span>

<span class="k">struct</span> <span class="n">dlm_lock</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">dlm_ctxt</span><span class="p">;</span>

<span class="cm">/* NOTE: changes made to this enum should be reflected in dlmdebug.c */</span>
<span class="k">enum</span> <span class="n">dlm_status</span> <span class="p">{</span>
	<span class="n">DLM_NORMAL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>           <span class="cm">/*  0: request in progress */</span>
	<span class="n">DLM_GRANTED</span><span class="p">,</span>              <span class="cm">/*  1: request granted */</span>
	<span class="n">DLM_DENIED</span><span class="p">,</span>               <span class="cm">/*  2: request denied */</span>
	<span class="n">DLM_DENIED_NOLOCKS</span><span class="p">,</span>       <span class="cm">/*  3: request denied, out of system resources */</span>
	<span class="n">DLM_WORKING</span><span class="p">,</span>              <span class="cm">/*  4: async request in progress */</span>
	<span class="n">DLM_BLOCKED</span><span class="p">,</span>              <span class="cm">/*  5: lock request blocked */</span>
	<span class="n">DLM_BLOCKED_ORPHAN</span><span class="p">,</span>       <span class="cm">/*  6: lock request blocked by a orphan lock*/</span>
	<span class="n">DLM_DENIED_GRACE_PERIOD</span><span class="p">,</span>  <span class="cm">/*  7: topological change in progress */</span>
	<span class="n">DLM_SYSERR</span><span class="p">,</span>               <span class="cm">/*  8: system error */</span>
	<span class="n">DLM_NOSUPPORT</span><span class="p">,</span>            <span class="cm">/*  9: unsupported */</span>
	<span class="n">DLM_CANCELGRANT</span><span class="p">,</span>          <span class="cm">/* 10: can&#39;t cancel convert: already granted */</span>
	<span class="n">DLM_IVLOCKID</span><span class="p">,</span>             <span class="cm">/* 11: bad lockid */</span>
	<span class="n">DLM_SYNC</span><span class="p">,</span>                 <span class="cm">/* 12: synchronous request granted */</span>
	<span class="n">DLM_BADTYPE</span><span class="p">,</span>              <span class="cm">/* 13: bad resource type */</span>
	<span class="n">DLM_BADRESOURCE</span><span class="p">,</span>          <span class="cm">/* 14: bad resource handle */</span>
	<span class="n">DLM_MAXHANDLES</span><span class="p">,</span>           <span class="cm">/* 15: no more resource handles */</span>
	<span class="n">DLM_NOCLINFO</span><span class="p">,</span>             <span class="cm">/* 16: can&#39;t contact cluster manager */</span>
	<span class="n">DLM_NOLOCKMGR</span><span class="p">,</span>            <span class="cm">/* 17: can&#39;t contact lock manager */</span>
	<span class="n">DLM_NOPURGED</span><span class="p">,</span>             <span class="cm">/* 18: can&#39;t contact purge daemon */</span>
	<span class="n">DLM_BADARGS</span><span class="p">,</span>              <span class="cm">/* 19: bad api args */</span>
	<span class="n">DLM_VOID</span><span class="p">,</span>                 <span class="cm">/* 20: no status */</span>
	<span class="n">DLM_NOTQUEUED</span><span class="p">,</span>            <span class="cm">/* 21: NOQUEUE was specified and request failed */</span>
	<span class="n">DLM_IVBUFLEN</span><span class="p">,</span>             <span class="cm">/* 22: invalid resource name length */</span>
	<span class="n">DLM_CVTUNGRANT</span><span class="p">,</span>           <span class="cm">/* 23: attempted to convert ungranted lock */</span>
	<span class="n">DLM_BADPARAM</span><span class="p">,</span>             <span class="cm">/* 24: invalid lock mode specified */</span>
	<span class="n">DLM_VALNOTVALID</span><span class="p">,</span>          <span class="cm">/* 25: value block has been invalidated */</span>
	<span class="n">DLM_REJECTED</span><span class="p">,</span>             <span class="cm">/* 26: request rejected, unrecognized client */</span>
	<span class="n">DLM_ABORT</span><span class="p">,</span>                <span class="cm">/* 27: blocked lock request cancelled */</span>
	<span class="n">DLM_CANCEL</span><span class="p">,</span>               <span class="cm">/* 28: conversion request cancelled */</span>
	<span class="n">DLM_IVRESHANDLE</span><span class="p">,</span>          <span class="cm">/* 29: invalid resource handle */</span>
	<span class="n">DLM_DEADLOCK</span><span class="p">,</span>             <span class="cm">/* 30: deadlock recovery refused this request */</span>
	<span class="n">DLM_DENIED_NOASTS</span><span class="p">,</span>        <span class="cm">/* 31: failed to allocate AST */</span>
	<span class="n">DLM_FORWARD</span><span class="p">,</span>              <span class="cm">/* 32: request must wait for primary&#39;s response */</span>
	<span class="n">DLM_TIMEOUT</span><span class="p">,</span>              <span class="cm">/* 33: timeout value for lock has expired */</span>
	<span class="n">DLM_IVGROUPID</span><span class="p">,</span>            <span class="cm">/* 34: invalid group specification */</span>
	<span class="n">DLM_VERS_CONFLICT</span><span class="p">,</span>        <span class="cm">/* 35: version conflicts prevent request handling */</span>
	<span class="n">DLM_BAD_DEVICE_PATH</span><span class="p">,</span>      <span class="cm">/* 36: Locks device does not exist or path wrong */</span>
	<span class="n">DLM_NO_DEVICE_PERMISSION</span><span class="p">,</span> <span class="cm">/* 37: Client has insufficient pers for device */</span>
	<span class="n">DLM_NO_CONTROL_DEVICE</span><span class="p">,</span>    <span class="cm">/* 38: Cannot set options on opened device */</span>

	<span class="n">DLM_RECOVERING</span><span class="p">,</span>           <span class="cm">/* 39: extension, allows caller to fail a lock</span>
<span class="cm">				     request if it is being recovered */</span>
	<span class="n">DLM_MIGRATING</span><span class="p">,</span>            <span class="cm">/* 40: extension, allows caller to fail a lock</span>
<span class="cm">				     request if it is being migrated */</span>
	<span class="n">DLM_MAXSTATS</span><span class="p">,</span>             <span class="cm">/* 41: upper limit for return code validation */</span>
<span class="p">};</span>

<span class="cm">/* for pretty-printing dlm_status error messages */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dlm_errmsg</span><span class="p">(</span><span class="k">enum</span> <span class="n">dlm_status</span> <span class="n">err</span><span class="p">);</span>
<span class="cm">/* for pretty-printing dlm_status error names */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dlm_errname</span><span class="p">(</span><span class="k">enum</span> <span class="n">dlm_status</span> <span class="n">err</span><span class="p">);</span>

<span class="cm">/* Eventually the DLM will use standard errno values, but in the</span>
<span class="cm"> * meantime this lets us track dlm errors as they bubble up. When we</span>
<span class="cm"> * bring its error reporting into line with the rest of the stack,</span>
<span class="cm"> * these can just be replaced with calls to mlog_errno. */</span>
<span class="cp">#define dlm_error(st) do {						\</span>
<span class="cp">	if ((st) != DLM_RECOVERING &amp;&amp;					\</span>
<span class="cp">	    (st) != DLM_MIGRATING &amp;&amp;					\</span>
<span class="cp">	    (st) != DLM_FORWARD)					\</span>
<span class="cp">		mlog(ML_ERROR, &quot;dlm status = %s\n&quot;, dlm_errname((st)));	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define DLM_LKSB_UNUSED1           0x01</span>
<span class="cp">#define DLM_LKSB_PUT_LVB           0x02</span>
<span class="cp">#define DLM_LKSB_GET_LVB           0x04</span>
<span class="cp">#define DLM_LKSB_UNUSED2           0x08</span>
<span class="cp">#define DLM_LKSB_UNUSED3           0x10</span>
<span class="cp">#define DLM_LKSB_UNUSED4           0x20</span>
<span class="cp">#define DLM_LKSB_UNUSED5           0x40</span>
<span class="cp">#define DLM_LKSB_UNUSED6           0x80</span>

<span class="cp">#define DLM_LVB_LEN  64</span>

<span class="cm">/* Callers are only allowed access to the lvb and status members of</span>
<span class="cm"> * this struct. */</span>
<span class="k">struct</span> <span class="n">dlm_lockstatus</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">dlm_status</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lockid</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">lvb</span><span class="p">[</span><span class="n">DLM_LVB_LEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* Valid lock modes. */</span>
<span class="cp">#define LKM_IVMODE      (-1)            </span><span class="cm">/* invalid mode */</span><span class="cp"></span>
<span class="cp">#define LKM_NLMODE      0               </span><span class="cm">/* null lock */</span><span class="cp"></span>
<span class="cp">#define LKM_CRMODE      1               </span><span class="cm">/* concurrent read    unsupported */</span><span class="cp"></span>
<span class="cp">#define LKM_CWMODE      2               </span><span class="cm">/* concurrent write   unsupported */</span><span class="cp"></span>
<span class="cp">#define LKM_PRMODE      3               </span><span class="cm">/* protected read */</span><span class="cp"></span>
<span class="cp">#define LKM_PWMODE      4               </span><span class="cm">/* protected write    unsupported */</span><span class="cp"></span>
<span class="cp">#define LKM_EXMODE      5               </span><span class="cm">/* exclusive */</span><span class="cp"></span>
<span class="cp">#define LKM_MAXMODE     5</span>
<span class="cp">#define LKM_MODEMASK    0xff</span>

<span class="cm">/* Flags passed to dlmlock and dlmunlock:</span>
<span class="cm"> * reserved: flags used by the &quot;real&quot; dlm</span>
<span class="cm"> * only a few are supported by this dlm</span>
<span class="cm"> * (U) = unsupported by ocfs2 dlm */</span>
<span class="cp">#define LKM_ORPHAN       0x00000010  </span><span class="cm">/* this lock is orphanable (U) */</span><span class="cp"></span>
<span class="cp">#define LKM_PARENTABLE   0x00000020  </span><span class="cm">/* this lock was orphaned (U) */</span><span class="cp"></span>
<span class="cp">#define LKM_BLOCK        0x00000040  </span><span class="cm">/* blocking lock request (U) */</span><span class="cp"></span>
<span class="cp">#define LKM_LOCAL        0x00000080  </span><span class="cm">/* local lock request */</span><span class="cp"></span>
<span class="cp">#define LKM_VALBLK       0x00000100  </span><span class="cm">/* lock value block request */</span><span class="cp"></span>
<span class="cp">#define LKM_NOQUEUE      0x00000200  </span><span class="cm">/* non blocking request */</span><span class="cp"></span>
<span class="cp">#define LKM_CONVERT      0x00000400  </span><span class="cm">/* conversion request */</span><span class="cp"></span>
<span class="cp">#define LKM_NODLCKWT     0x00000800  </span><span class="cm">/* this lock wont deadlock (U) */</span><span class="cp"></span>
<span class="cp">#define LKM_UNLOCK       0x00001000  </span><span class="cm">/* deallocate this lock */</span><span class="cp"></span>
<span class="cp">#define LKM_CANCEL       0x00002000  </span><span class="cm">/* cancel conversion request */</span><span class="cp"></span>
<span class="cp">#define LKM_DEQALL       0x00004000  </span><span class="cm">/* remove all locks held by proc (U) */</span><span class="cp"></span>
<span class="cp">#define LKM_INVVALBLK    0x00008000  </span><span class="cm">/* invalidate lock value block */</span><span class="cp"></span>
<span class="cp">#define LKM_SYNCSTS      0x00010000  </span><span class="cm">/* return synchronous status if poss (U) */</span><span class="cp"></span>
<span class="cp">#define LKM_TIMEOUT      0x00020000  </span><span class="cm">/* lock request contains timeout (U) */</span><span class="cp"></span>
<span class="cp">#define LKM_SNGLDLCK     0x00040000  </span><span class="cm">/* request can self-deadlock (U) */</span><span class="cp"></span>
<span class="cp">#define LKM_FINDLOCAL    0x00080000  </span><span class="cm">/* find local lock request (U) */</span><span class="cp"></span>
<span class="cp">#define LKM_PROC_OWNED   0x00100000  </span><span class="cm">/* owned by process, not group (U) */</span><span class="cp"></span>
<span class="cp">#define LKM_XID          0x00200000  </span><span class="cm">/* use transaction id for deadlock (U) */</span><span class="cp"></span>
<span class="cp">#define LKM_XID_CONFLICT 0x00400000  </span><span class="cm">/* do not allow lock inheritance (U) */</span><span class="cp"></span>
<span class="cp">#define LKM_FORCE        0x00800000  </span><span class="cm">/* force unlock flag */</span><span class="cp"></span>
<span class="cp">#define LKM_REVVALBLK    0x01000000  </span><span class="cm">/* temporary solution: re-validate</span>
<span class="cm">					lock value block (U) */</span><span class="cp"></span>
<span class="cm">/* unused */</span>
<span class="cp">#define LKM_UNUSED1      0x00000001  </span><span class="cm">/* unused */</span><span class="cp"></span>
<span class="cp">#define LKM_UNUSED2      0x00000002  </span><span class="cm">/* unused */</span><span class="cp"></span>
<span class="cp">#define LKM_UNUSED3      0x00000004  </span><span class="cm">/* unused */</span><span class="cp"></span>
<span class="cp">#define LKM_UNUSED4      0x00000008  </span><span class="cm">/* unused */</span><span class="cp"></span>
<span class="cp">#define LKM_UNUSED5      0x02000000  </span><span class="cm">/* unused */</span><span class="cp"></span>
<span class="cp">#define LKM_UNUSED6      0x04000000  </span><span class="cm">/* unused */</span><span class="cp"></span>
<span class="cp">#define LKM_UNUSED7      0x08000000  </span><span class="cm">/* unused */</span><span class="cp"></span>

<span class="cm">/* ocfs2 extensions: internal only</span>
<span class="cm"> * should never be used by caller */</span>
<span class="cp">#define LKM_MIGRATION    0x10000000  </span><span class="cm">/* extension: lockres is to be migrated</span>
<span class="cm">					to another node */</span><span class="cp"></span>
<span class="cp">#define LKM_PUT_LVB      0x20000000  </span><span class="cm">/* extension: lvb is being passed</span>
<span class="cm">					should be applied to lockres */</span><span class="cp"></span>
<span class="cp">#define LKM_GET_LVB      0x40000000  </span><span class="cm">/* extension: lvb should be copied</span>
<span class="cm">					from lockres when lock is granted */</span><span class="cp"></span>
<span class="cp">#define LKM_RECOVERY     0x80000000  </span><span class="cm">/* extension: flag for recovery lock</span>
<span class="cm">					used to avoid recovery rwsem */</span><span class="cp"></span>


<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">dlm_astlockfunc_t</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">dlm_bastlockfunc_t</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">dlm_astunlockfunc_t</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dlm_status</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">dlm_status</span> <span class="n">dlmlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">dlm_lockstatus</span> <span class="o">*</span><span class="n">lksb</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">namelen</span><span class="p">,</span>
			<span class="n">dlm_astlockfunc_t</span> <span class="o">*</span><span class="n">ast</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			<span class="n">dlm_bastlockfunc_t</span> <span class="o">*</span><span class="n">bast</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">dlm_status</span> <span class="n">dlmunlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">dlm_lockstatus</span> <span class="o">*</span><span class="n">lksb</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
			  <span class="n">dlm_astunlockfunc_t</span> <span class="o">*</span><span class="n">unlockast</span><span class="p">,</span>
			  <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">dlm_protocol_version</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">pv_major</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pv_minor</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span> <span class="n">dlm_register_domain</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">domain</span><span class="p">,</span> <span class="n">u32</span> <span class="n">key</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">dlm_protocol_version</span> <span class="o">*</span><span class="n">fs_proto</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">dlm_unregister_domain</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">dlm_print_one_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lockid</span><span class="p">);</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">dlm_eviction_func</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">dlm_eviction_cb</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>        <span class="n">ec_item</span><span class="p">;</span>
	<span class="n">dlm_eviction_func</span>       <span class="o">*</span><span class="n">ec_func</span><span class="p">;</span>
	<span class="kt">void</span>                    <span class="o">*</span><span class="n">ec_data</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">dlm_setup_eviction_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_eviction_cb</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span>
			   <span class="n">dlm_eviction_func</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_register_eviction_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">dlm_eviction_cb</span> <span class="o">*</span><span class="n">cb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_unregister_eviction_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_eviction_cb</span> <span class="o">*</span><span class="n">cb</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* DLMAPI_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
