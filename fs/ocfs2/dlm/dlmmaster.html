<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ocfs2 › dlm › dlmmaster.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>dlmmaster.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* -*- mode: c; c-basic-offset: 8; -*-</span>
<span class="cm"> * vim: noexpandtab sw=8 ts=8 sts=0:</span>
<span class="cm"> *</span>
<span class="cm"> * dlmmod.c</span>
<span class="cm"> *</span>
<span class="cm"> * standalone DLM module</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004 Oracle.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public</span>
<span class="cm"> * License as published by the Free Software Foundation; either</span>
<span class="cm"> * version 2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public</span>
<span class="cm"> * License along with this program; if not, write to the</span>
<span class="cm"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 021110-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>


<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/sysctl.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/inet.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>


<span class="cp">#include &quot;cluster/heartbeat.h&quot;</span>
<span class="cp">#include &quot;cluster/nodemanager.h&quot;</span>
<span class="cp">#include &quot;cluster/tcp.h&quot;</span>

<span class="cp">#include &quot;dlmapi.h&quot;</span>
<span class="cp">#include &quot;dlmcommon.h&quot;</span>
<span class="cp">#include &quot;dlmdomain.h&quot;</span>
<span class="cp">#include &quot;dlmdebug.h&quot;</span>

<span class="cp">#define MLOG_MASK_PREFIX (ML_DLM|ML_DLM_MASTER)</span>
<span class="cp">#include &quot;cluster/masklog.h&quot;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">dlm_mle_node_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">o2nm_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dlm_mle_node_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">o2nm_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">idx</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">dlm_assert_master_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_work_item</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dlm_do_assert_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">nodemap</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dlm_deref_lockres_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_work_item</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dlm_mle_equal</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlm</span> <span class="o">!=</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">dlm</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">namelen</span> <span class="o">!=</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">mnamelen</span> <span class="o">||</span>
	    <span class="n">memcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">mname</span><span class="p">,</span> <span class="n">namelen</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">dlm_lockres_cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">dlm_lockname_cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">dlm_mle_cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">dlm_mle_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dlm_init_mle</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">dlm_mle_type</span> <span class="n">type</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dlm_put_mle</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__dlm_put_mle</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dlm_find_mle</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">**</span><span class="n">mle</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">dlm_do_master_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">dlm_wait_for_lock_mastery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="o">*</span><span class="n">blocked</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dlm_restart_lock_mastery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">blocked</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dlm_add_migration_mle</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">**</span><span class="n">oldmle</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">,</span>
				 <span class="n">u8</span> <span class="n">new_master</span><span class="p">,</span> <span class="n">u8</span> <span class="n">master</span><span class="p">);</span>

<span class="k">static</span> <span class="n">u8</span> <span class="n">dlm_pick_migration_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dlm_remove_nonlocal_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dlm_mark_lockres_migrating</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
				       <span class="n">u8</span> <span class="n">target</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dlm_pre_master_reco_lockres</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>


<span class="kt">int</span> <span class="nf">dlm_is_host_down</span><span class="p">(</span><span class="kt">int</span> <span class="n">errno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">errno</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EBADF</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">ECONNREFUSED</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">ENOTCONN</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">ECONNRESET</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">EPIPE</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">EHOSTDOWN</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">ETIMEDOUT</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">ECONNABORTED</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">ENETDOWN</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">ENETUNREACH</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">ENETRESET</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">ESHUTDOWN</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">EINVAL</span>:   <span class="cm">/* if returned from our tcp code,</span>
<span class="cm">				   this means there is no socket */</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * MASTER LIST FUNCTIONS</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * regarding master list entries and heartbeat callbacks:</span>
<span class="cm"> *</span>
<span class="cm"> * in order to avoid sleeping and allocation that occurs in</span>
<span class="cm"> * heartbeat, master list entries are simply attached to the</span>
<span class="cm"> * dlm&#39;s established heartbeat callbacks.  the mle is attached</span>
<span class="cm"> * when it is created, and since the dlm-&gt;spinlock is held at</span>
<span class="cm"> * that time, any heartbeat event will be properly discovered</span>
<span class="cm"> * by the mle.  the mle needs to be detached from the</span>
<span class="cm"> * dlm-&gt;mle_hb_events list as soon as heartbeat events are no</span>
<span class="cm"> * longer useful to the mle, and before the mle is freed.</span>
<span class="cm"> *</span>
<span class="cm"> * as a general rule, heartbeat events are no longer needed by</span>
<span class="cm"> * the mle once an &quot;answer&quot; regarding the lock master has been</span>
<span class="cm"> * received.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__dlm_mle_attach_hb_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">hb_events</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">mle_hb_events</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__dlm_mle_detach_hb_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">hb_events</span><span class="p">))</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">hb_events</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dlm_mle_detach_hb_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">__dlm_mle_detach_hb_events</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_get_mle_inuse</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">;</span>
	<span class="n">dlm</span> <span class="o">=</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">dlm</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
	<span class="n">mle</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="o">++</span><span class="p">;</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">mle_refs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_put_mle_inuse</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">;</span>
	<span class="n">dlm</span> <span class="o">=</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">dlm</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
	<span class="n">mle</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="o">--</span><span class="p">;</span>
	<span class="n">__dlm_put_mle</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/* remove from list and free */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__dlm_put_mle</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">;</span>
	<span class="n">dlm</span> <span class="o">=</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">dlm</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">mle_refs</span><span class="p">.</span><span class="n">refcount</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* this may or may not crash, but who cares.</span>
<span class="cm">		 * it&#39;s a BUG. */</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;bad mle: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
		<span class="n">dlm_print_one_mle</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">mle_refs</span><span class="p">,</span> <span class="n">dlm_mle_release</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* must not have any spinlocks coming in */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_put_mle</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">;</span>
	<span class="n">dlm</span> <span class="o">=</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">dlm</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
	<span class="n">__dlm_put_mle</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dlm_get_mle</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">mle_refs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_init_mle</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">dlm_mle_type</span> <span class="n">type</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">mle</span><span class="o">-&gt;</span><span class="n">dlm</span> <span class="o">=</span> <span class="n">dlm</span><span class="p">;</span>
	<span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">INIT_HLIST_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">master_hash_node</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">hb_events</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">maybe_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">maybe_map</span><span class="p">));</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">woken</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">mle_refs</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">response_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">response_map</span><span class="p">));</span>
	<span class="n">mle</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">=</span> <span class="n">O2NM_MAX_NODES</span><span class="p">;</span>
	<span class="n">mle</span><span class="o">-&gt;</span><span class="n">new_master</span> <span class="o">=</span> <span class="n">O2NM_MAX_NODES</span><span class="p">;</span>
	<span class="n">mle</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">DLM_MLE_BLOCK</span> <span class="o">&amp;&amp;</span>
	       <span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">DLM_MLE_MASTER</span> <span class="o">&amp;&amp;</span>
	       <span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">DLM_MLE_MIGRATION</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">DLM_MLE_MASTER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">);</span>
		<span class="n">mle</span><span class="o">-&gt;</span><span class="n">mleres</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">mname</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
		<span class="n">mle</span><span class="o">-&gt;</span><span class="n">mnamelen</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
		<span class="n">mle</span><span class="o">-&gt;</span><span class="n">mnamehash</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">hash</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">);</span>
		<span class="n">mle</span><span class="o">-&gt;</span><span class="n">mleres</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">mname</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>
		<span class="n">mle</span><span class="o">-&gt;</span><span class="n">mnamelen</span> <span class="o">=</span> <span class="n">namelen</span><span class="p">;</span>
		<span class="n">mle</span><span class="o">-&gt;</span><span class="n">mnamehash</span> <span class="o">=</span> <span class="n">dlm_lockid_hash</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">mle_tot_count</span><span class="p">[</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">]);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">mle_cur_count</span><span class="p">[</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">]);</span>

	<span class="cm">/* copy off the node_map and register hb callbacks on our copy */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">node_map</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">domain_map</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">node_map</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">vote_map</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">domain_map</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">vote_map</span><span class="p">));</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">vote_map</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">node_map</span><span class="p">);</span>

	<span class="cm">/* attach the mle to the domain node up/down events */</span>
	<span class="n">__dlm_mle_attach_hb_events</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__dlm_unlink_mle</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hlist_unhashed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">master_hash_node</span><span class="p">))</span>
		<span class="n">hlist_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">master_hash_node</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__dlm_insert_mle</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">bucket</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>

	<span class="n">bucket</span> <span class="o">=</span> <span class="n">dlm_master_hash</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">mnamehash</span><span class="p">);</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">master_hash_node</span><span class="p">,</span> <span class="n">bucket</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* returns 1 if found, 0 if not */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_find_mle</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">**</span><span class="n">mle</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">tmpmle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">bucket</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">dlm_lockid_hash</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>
	<span class="n">bucket</span> <span class="o">=</span> <span class="n">dlm_master_hash</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
	<span class="n">hlist_for_each</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">bucket</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmpmle</span> <span class="o">=</span> <span class="n">hlist_entry</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_master_list_entry</span><span class="p">,</span>
				     <span class="n">master_hash_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_mle_equal</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">tmpmle</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">dlm_get_mle</span><span class="p">(</span><span class="n">tmpmle</span><span class="p">);</span>
		<span class="o">*</span><span class="n">mle</span> <span class="o">=</span> <span class="n">tmpmle</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_hb_event_notify_attached</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node_up</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">mle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">mle_hb_events</span><span class="p">,</span> <span class="n">hb_events</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node_up</span><span class="p">)</span>
			<span class="n">dlm_mle_node_up</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dlm_mle_node_down</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_mle_node_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">o2nm_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">node_map</span><span class="p">))</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node %u already removed from nodemap!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">node_map</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_mle_node_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">o2nm_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">node_map</span><span class="p">))</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node %u already in node map!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">node_map</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">dlm_init_mle_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dlm_mle_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;o2dlm_mle&quot;</span><span class="p">,</span>
					  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_master_list_entry</span><span class="p">),</span>
					  <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span>
					  <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlm_mle_cache</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_destroy_mle_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlm_mle_cache</span><span class="p">)</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">dlm_mle_cache</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_mle_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">;</span>

	<span class="n">mle</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_master_list_entry</span><span class="p">,</span> <span class="n">mle_refs</span><span class="p">);</span>
	<span class="n">dlm</span> <span class="o">=</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">dlm</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Releasing mle for %.*s, type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">mnamelen</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">mname</span><span class="p">,</span>
	     <span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>

	<span class="cm">/* remove from list if not already */</span>
	<span class="n">__dlm_unlink_mle</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>

	<span class="cm">/* detach the mle from the domain node up/down events */</span>
	<span class="n">__dlm_mle_detach_hb_events</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>

	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">mle_cur_count</span><span class="p">[</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">]);</span>

	<span class="cm">/* NOTE: kfree under spinlock here.</span>
<span class="cm">	 * if this is bad, we can move this to a freelist. */</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">dlm_mle_cache</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * LOCK RESOURCE FUNCTIONS</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">dlm_init_master_caches</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dlm_lockres_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;o2dlm_lockres&quot;</span><span class="p">,</span>
					      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span><span class="p">),</span>
					      <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_lockres_cache</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="n">dlm_lockname_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;o2dlm_lockname&quot;</span><span class="p">,</span>
					       <span class="n">DLM_LOCKID_NAME_MAX</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					       <span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_lockname_cache</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">bail:</span>
	<span class="n">dlm_destroy_master_caches</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_destroy_master_caches</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlm_lockname_cache</span><span class="p">)</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">dlm_lockname_cache</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dlm_lockres_cache</span><span class="p">)</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">dlm_lockres_cache</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_lockres_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lock_resource</span><span class="p">,</span> <span class="n">refs</span><span class="p">);</span>
	<span class="n">dlm</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">dlm</span><span class="p">;</span>

	<span class="cm">/* This should not happen -- all lockres&#39; have a name</span>
<span class="cm">	 * associated with them at init time. */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;destroying lockres %.*s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
	     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">track_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">tracking</span><span class="p">))</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">tracking</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;Resource %.*s not on the Tracking list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="n">dlm_print_one_lock_resource</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">track_lock</span><span class="p">);</span>

	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">res_cur_count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hlist_unhashed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">hash_node</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">granted</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">converting</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">recovering</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">purge</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span>
		     <span class="s">&quot;Going to BUG for resource %.*s.&quot;</span>
		     <span class="s">&quot;  We&#39;re on a list! [%c%c%c%c%c%c%c]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
		     <span class="o">!</span><span class="n">hlist_unhashed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">hash_node</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;H&#39;</span> <span class="o">:</span> <span class="sc">&#39; &#39;</span><span class="p">,</span>
		     <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">granted</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;G&#39;</span> <span class="o">:</span> <span class="sc">&#39; &#39;</span><span class="p">,</span>
		     <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">converting</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;C&#39;</span> <span class="o">:</span> <span class="sc">&#39; &#39;</span><span class="p">,</span>
		     <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;B&#39;</span> <span class="o">:</span> <span class="sc">&#39; &#39;</span><span class="p">,</span>
		     <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;D&#39;</span> <span class="o">:</span> <span class="sc">&#39; &#39;</span><span class="p">,</span>
		     <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">recovering</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;R&#39;</span> <span class="o">:</span> <span class="sc">&#39; &#39;</span><span class="p">,</span>
		     <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">purge</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;P&#39;</span> <span class="o">:</span> <span class="sc">&#39; &#39;</span><span class="p">);</span>

		<span class="n">dlm_print_one_lock_resource</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* By the time we&#39;re ready to blow this guy away, we shouldn&#39;t</span>
<span class="cm">	 * be on any lists. */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">hlist_unhashed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">hash_node</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">granted</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">converting</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">recovering</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">purge</span><span class="p">));</span>

	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">dlm_lockname_cache</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">dlm_lockres_cache</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_lockres_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">,</span> <span class="n">dlm_lockres_release</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_init_lockres</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">qname</span><span class="p">;</span>

	<span class="cm">/* If we memset here, we lose our reference to the kmalloc&#39;d</span>
<span class="cm">	 * res-&gt;lockname.name, so be sure to init every field</span>
<span class="cm">	 * correctly! */</span>

	<span class="n">qname</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">qname</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>

	<span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">namelen</span><span class="p">;</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="n">dlm_lockid_hash</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>

	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">INIT_HLIST_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">hash_node</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">granted</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">converting</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">recovering</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">purge</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">tracking</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">asts_reserved</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">migration_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">inflight_locks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">res</span><span class="o">-&gt;</span><span class="n">dlm</span> <span class="o">=</span> <span class="n">dlm</span><span class="p">;</span>

	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">);</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">res_tot_count</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">res_cur_count</span><span class="p">);</span>

	<span class="cm">/* just for consistency */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">dlm_set_lockres_owner</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">DLM_LOCK_RES_OWNER_UNKNOWN</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DLM_LOCK_RES_IN_PROGRESS</span><span class="p">;</span>

	<span class="n">res</span><span class="o">-&gt;</span><span class="n">last_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">tracking</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">tracking_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">lvb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DLM_LVB_LEN</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">refmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">refmap</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="nf">dlm_new_lockres</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">dlm_lockres_cache</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">dlm_lockname_cache</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">dlm_init_lockres</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&amp;&amp;</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">dlm_lockname_cache</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">dlm_lockres_cache</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_lockres_set_refmap_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;res %.*s, set node %u, %ps()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
	     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">bit</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">refmap</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_lockres_clear_refmap_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;res %.*s, clr node %u, %ps()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
	     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">bit</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">refmap</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">dlm_lockres_grab_inflight_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">res</span><span class="o">-&gt;</span><span class="n">inflight_locks</span><span class="o">++</span><span class="p">;</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: res %.*s, inflight++: now %u, %ps()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
	     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">inflight_locks</span><span class="p">,</span>
	     <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_lockres_drop_inflight_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">inflight_locks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">res</span><span class="o">-&gt;</span><span class="n">inflight_locks</span><span class="o">--</span><span class="p">;</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: res %.*s, inflight--: now %u, %ps()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
	     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">inflight_locks</span><span class="p">,</span>
	     <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * lookup a lock resource by name.</span>
<span class="cm"> * may already exist in the hashtable.</span>
<span class="cm"> * lockid is null terminated</span>
<span class="cm"> *</span>
<span class="cm"> * if not, allocate enough for the lockres and for</span>
<span class="cm"> * the temporary structure used in doing the mastering.</span>
<span class="cm"> *</span>
<span class="cm"> * also, do a lookup in the dlm-&gt;master_list to see</span>
<span class="cm"> * if another node has begun mastering the same lock.</span>
<span class="cm"> * if so, there should be a block entry in there</span>
<span class="cm"> * for this name, and we should *not* attempt to master</span>
<span class="cm"> * the lock here.   need to wait around for that node</span>
<span class="cm"> * to assert_master (or die).</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span> <span class="nf">dlm_get_lock_resource</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
					  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lockid</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">namelen</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">tmpres</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">res</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">alloc_mle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">blocked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">nodenum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_node_iter</span> <span class="n">iter</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bit</span><span class="p">,</span> <span class="n">wait_on_recovery</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">lockid</span><span class="p">);</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">dlm_lockid_hash</span><span class="p">(</span><span class="n">lockid</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;get lockres %s (len %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lockid</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>

<span class="nl">lookup:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">tmpres</span> <span class="o">=</span> <span class="n">__dlm_lookup_lockres_full</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">lockid</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmpres</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmpres</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="cm">/* Wait on the thread that is mastering the resource */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmpres</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">==</span> <span class="n">DLM_LOCK_RES_OWNER_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__dlm_wait_on_lockres</span><span class="p">(</span><span class="n">tmpres</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tmpres</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">==</span> <span class="n">DLM_LOCK_RES_OWNER_UNKNOWN</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmpres</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">dlm_lockres_put</span><span class="p">(</span><span class="n">tmpres</span><span class="p">);</span>
			<span class="n">tmpres</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">lookup</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Wait on the resource purge to complete before continuing */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmpres</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_DROPPING_REF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tmpres</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">==</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">);</span>
			<span class="n">__dlm_wait_on_lockres_flags</span><span class="p">(</span><span class="n">tmpres</span><span class="p">,</span>
						    <span class="n">DLM_LOCK_RES_DROPPING_REF</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmpres</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">dlm_lockres_put</span><span class="p">(</span><span class="n">tmpres</span><span class="p">);</span>
			<span class="n">tmpres</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">lookup</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Grab inflight ref to pin the resource */</span>
		<span class="n">dlm_lockres_grab_inflight_ref</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">tmpres</span><span class="p">);</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmpres</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
			<span class="n">dlm_lockres_put</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">tmpres</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;allocating a new resource</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* nothing found and we need to allocate one. */</span>
		<span class="n">alloc_mle</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">dlm_mle_cache</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_mle</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">dlm_new_lockres</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">lockid</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">lookup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;no lockres found, allocated our own: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LKM_LOCAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* caller knows it&#39;s safe to assume it&#39;s not mastered elsewhere</span>
<span class="cm">		 * DONE!  return right away */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="n">dlm_change_lockres_owner</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">);</span>
		<span class="n">__dlm_insert_lockres</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
		<span class="n">dlm_lockres_grab_inflight_ref</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="cm">/* lockres still marked IN_PROGRESS */</span>
		<span class="k">goto</span> <span class="n">wake_waiters</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check master list to see if another node has started mastering it */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>

	<span class="cm">/* if we found a block, wait for lock to be mastered by another node */</span>
	<span class="n">blocked</span> <span class="o">=</span> <span class="n">dlm_find_mle</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mle</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">lockid</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blocked</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">mig</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">DLM_MLE_MASTER</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;master entry for nonexistent lock!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">mig</span> <span class="o">=</span> <span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">DLM_MLE_MIGRATION</span><span class="p">);</span>
		<span class="cm">/* if there is a migration in progress, let the migration</span>
<span class="cm">		 * finish before continuing.  we can wait for the absence</span>
<span class="cm">		 * of the MIGRATION mle: either the migrate finished or</span>
<span class="cm">		 * one of the nodes died and the mle was cleaned up.</span>
<span class="cm">		 * if there is a BLOCK here, but it already has a master</span>
<span class="cm">		 * set, we are too late.  the master does not have a ref</span>
<span class="cm">		 * for us in the refmap.  detach the mle and drop it.</span>
<span class="cm">		 * either way, go back to the top and start over. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mig</span> <span class="o">||</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">!=</span> <span class="n">O2NM_MAX_NODES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mig</span> <span class="o">&amp;&amp;</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">==</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">);</span>
			<span class="cm">/* we arrived too late.  the master does not</span>
<span class="cm">			 * have a ref for us. retry. */</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: late on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">lockid</span><span class="p">,</span>
			     <span class="n">mig</span> <span class="o">?</span>  <span class="s">&quot;MIGRATION&quot;</span> <span class="o">:</span> <span class="s">&quot;BLOCK&quot;</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

			<span class="cm">/* master is known, detach */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mig</span><span class="p">)</span>
				<span class="n">dlm_mle_detach_hb_events</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
			<span class="n">dlm_put_mle</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
			<span class="n">mle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="cm">/* this is lame, but we can&#39;t wait on either</span>
<span class="cm">			 * the mle or lockres waitqueue here */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mig</span><span class="p">)</span>
				<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">lookup</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* go ahead and try to master lock on this node */</span>
		<span class="n">mle</span> <span class="o">=</span> <span class="n">alloc_mle</span><span class="p">;</span>
		<span class="cm">/* make sure this does not get freed below */</span>
		<span class="n">alloc_mle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">dlm_init_mle</span><span class="p">(</span><span class="n">mle</span><span class="p">,</span> <span class="n">DLM_MLE_MASTER</span><span class="p">,</span> <span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">maybe_map</span><span class="p">);</span>
		<span class="n">__dlm_insert_mle</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>

		<span class="cm">/* still holding the dlm spinlock, check the recovery map</span>
<span class="cm">		 * to see if there are any nodes that still need to be</span>
<span class="cm">		 * considered.  these will not appear in the mle nodemap</span>
<span class="cm">		 * but they might own this lockres.  wait on them. */</span>
		<span class="n">bit</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">recovery_map</span><span class="p">,</span> <span class="n">O2NM_MAX_NODES</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&lt;</span> <span class="n">O2NM_MAX_NODES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: res %.*s, At least one node (%d) &quot;</span>
			     <span class="s">&quot;to recover before lock mastery can begin</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">lockid</span><span class="p">,</span> <span class="n">bit</span><span class="p">);</span>
			<span class="n">wait_on_recovery</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* at this point there is either a DLM_MLE_BLOCK or a</span>
<span class="cm">	 * DLM_MLE_MASTER on the master list, so it&#39;s safe to add the</span>
<span class="cm">	 * lockres to the hashtable.  anyone who finds the lock will</span>
<span class="cm">	 * still have to wait on the IN_PROGRESS. */</span>

	<span class="cm">/* finally add the lockres to its hash bucket */</span>
	<span class="n">__dlm_insert_lockres</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>

	<span class="cm">/* Grab inflight ref to pin the resource */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">dlm_lockres_grab_inflight_ref</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="cm">/* get an extra ref on the mle in case this is a BLOCK</span>
<span class="cm">	 * if so, the creator of the BLOCK may try to put the last</span>
<span class="cm">	 * ref at this time in the assert master handler, so we</span>
<span class="cm">	 * need an extra one to keep from a bad ptr deref. */</span>
	<span class="n">dlm_get_mle_inuse</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

<span class="nl">redo_request:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">wait_on_recovery</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* any cluster changes that occurred after dropping the</span>
<span class="cm">		 * dlm spinlock would be detectable be a change on the mle,</span>
<span class="cm">		 * so we only need to clear out the recovery map once. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlm_is_recovery_lock</span><span class="p">(</span><span class="n">lockid</span><span class="p">,</span> <span class="n">namelen</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: Recovery map is not empty, but must &quot;</span>
			     <span class="s">&quot;master $RECOVERY lock now</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_pre_master_reco_lockres</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">))</span>
				<span class="n">wait_on_recovery</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: waiting 500ms for heartbeat state &quot;</span>
				    <span class="s">&quot;change</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="n">msleep</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dlm_kick_recovery_thread</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
		<span class="n">dlm_wait_for_recovery</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="n">bit</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">recovery_map</span><span class="p">,</span> <span class="n">O2NM_MAX_NODES</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&lt;</span> <span class="n">O2NM_MAX_NODES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: res %.*s, At least one node (%d) &quot;</span>
			     <span class="s">&quot;to recover before lock mastery can begin</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">lockid</span><span class="p">,</span> <span class="n">bit</span><span class="p">);</span>
			<span class="n">wait_on_recovery</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">wait_on_recovery</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wait_on_recovery</span><span class="p">)</span>
			<span class="n">dlm_wait_for_node_recovery</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">bit</span><span class="p">,</span> <span class="mi">10000</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* must wait for lock to be mastered elsewhere */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blocked</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">wait</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">dlm_node_iter_init</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">vote_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">nodenum</span> <span class="o">=</span> <span class="n">dlm_node_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_do_master_request</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">mle</span><span class="p">,</span> <span class="n">nodenum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">mlog_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">!=</span> <span class="n">O2NM_MAX_NODES</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* found a master ! */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">&lt;=</span> <span class="n">nodenum</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* if our master request has not reached the master</span>
<span class="cm">			 * yet, keep going until it does.  this is how the</span>
<span class="cm">			 * master will know that asserts are needed back to</span>
<span class="cm">			 * the lower nodes. */</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: res %.*s, Requests only up to %u but &quot;</span>
			     <span class="s">&quot;master is %u, keep going</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span>
			     <span class="n">lockid</span><span class="p">,</span> <span class="n">nodenum</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">wait:</span>
	<span class="cm">/* keep going until the response map includes all nodes */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_wait_for_lock_mastery</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">mle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blocked</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wait_on_recovery</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: res %.*s, Node map changed, redo the master &quot;</span>
		     <span class="s">&quot;request now, blocked=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
		     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">blocked</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">tries</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s: res %.*s, Spinning on &quot;</span>
			     <span class="s">&quot;dlm_wait_for_lock_mastery, blocked = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
			     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">blocked</span><span class="p">);</span>
			<span class="n">dlm_print_one_lock_resource</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
			<span class="n">dlm_print_one_mle</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
			<span class="n">tries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">redo_request</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: res %.*s, Mastered by %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
	     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="cm">/* make sure we never continue without this */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">==</span> <span class="n">O2NM_MAX_NODES</span><span class="p">);</span>

	<span class="cm">/* master is known, detach if not already detached */</span>
	<span class="n">dlm_mle_detach_hb_events</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
	<span class="n">dlm_put_mle</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
	<span class="cm">/* put the extra ref */</span>
	<span class="n">dlm_put_mle_inuse</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>

<span class="nl">wake_waiters:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_LOCK_RES_IN_PROGRESS</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>

<span class="nl">leave:</span>
	<span class="cm">/* need to free the unused mle */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_mle</span><span class="p">)</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">dlm_mle_cache</span><span class="p">,</span> <span class="n">alloc_mle</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#define DLM_MASTERY_TIMEOUT_MS   5000</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_wait_for_lock_mastery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="o">*</span><span class="n">blocked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">m</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">bit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">map_changed</span><span class="p">,</span> <span class="n">voting_done</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">assert</span><span class="p">,</span> <span class="n">sleep</span><span class="p">;</span>

<span class="nl">recheck:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">assert</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* check if another node has already become the owner */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">DLM_LOCK_RES_OWNER_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: owner is suddenly %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="cm">/* this will cause the master to re-assert across</span>
<span class="cm">		 * the whole cluster, freeing up mles */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_do_master_request</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">mle</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* give recovery a chance to run */</span>
				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;link to %u went down?: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
				<span class="n">msleep</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">recheck</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">m</span> <span class="o">=</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">;</span>
	<span class="n">map_changed</span> <span class="o">=</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">vote_map</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">node_map</span><span class="p">,</span>
			      <span class="k">sizeof</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">vote_map</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">voting_done</span> <span class="o">=</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">vote_map</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">response_map</span><span class="p">,</span>
			     <span class="k">sizeof</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">vote_map</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* restart if we hit any errors */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map_changed</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: %.*s: node map changed, restarting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_restart_lock_mastery</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">mle</span><span class="p">,</span> <span class="o">*</span><span class="n">blocked</span><span class="p">);</span>
		<span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">DLM_MLE_BLOCK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">blocked</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!*</span><span class="n">blocked</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: status change: old=%d new=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			     <span class="o">*</span><span class="n">blocked</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
			<span class="o">*</span><span class="n">blocked</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: restart lock mastery succeeded, &quot;</span>
		     <span class="s">&quot;rechecking now</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
		     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">recheck</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">voting_done</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;map not changed and voting not done &quot;</span>
			     <span class="s">&quot;for %s:%.*s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
			     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">O2NM_MAX_NODES</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* another node has done an assert!</span>
<span class="cm">		 * all done! */</span>
		<span class="n">sleep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sleep</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* have all nodes responded? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">voting_done</span> <span class="o">&amp;&amp;</span> <span class="o">!*</span><span class="n">blocked</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bit</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">maybe_map</span><span class="p">,</span> <span class="n">O2NM_MAX_NODES</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span> <span class="o">&lt;=</span> <span class="n">bit</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* my node number is lowest.</span>
<span class="cm">			 	 * now tell other nodes that I am</span>
<span class="cm">				 * mastering this. */</span>
				<span class="n">mle</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">;</span>
				<span class="cm">/* ref was grabbed in get_lock_resource</span>
<span class="cm">				 * will be dropped in dlmlock_master */</span>
				<span class="n">assert</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">sleep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* if voting is done, but we have not received</span>
<span class="cm">			 * an assert master yet, we must sleep */</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="cm">/* sleep if we haven&#39;t finished voting yet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sleep</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeo</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">DLM_MASTERY_TIMEOUT_MS</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		if (atomic_read(&amp;mle-&gt;mle_refs.refcount) &lt; 2)</span>
<span class="cm">			mlog(ML_ERROR, &quot;mle (%p) refs=%d, name=%.*s\n&quot;, mle,</span>
<span class="cm">			atomic_read(&amp;mle-&gt;mle_refs.refcount),</span>
<span class="cm">			res-&gt;lockname.len, res-&gt;lockname.name);</span>
<span class="cm">		*/</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">woken</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">wait_event_timeout</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span>
					 <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">woken</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span>
					 <span class="n">timeo</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">==</span> <span class="n">O2NM_MAX_NODES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: waiting again</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">recheck</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;done waiting, master is %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="cm">/* done */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">assert</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">;</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;about to master %.*s here, this=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_do_assert_master</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">vote_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This is a failure in the network path,</span>
<span class="cm">			 * not in the response to the assert_master</span>
<span class="cm">			 * (any nonzero response is a BUG on this node).</span>
<span class="cm">			 * Most likely a socket just got disconnected</span>
<span class="cm">			 * due to node death. */</span>
			<span class="n">mlog_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* no longer need to restart lock mastery.</span>
<span class="cm">		 * all living nodes have been contacted. */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* set the lockres owner */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="cm">/* mastery reference obtained either during</span>
<span class="cm">	 * assert_master_handler or in get_lock_resource */</span>
	<span class="n">dlm_change_lockres_owner</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

<span class="nl">leave:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dlm_bitmap_diff_iter</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">curnode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">orig_bm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">cur_bm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">diff_bm</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">O2NM_MAX_NODES</span><span class="p">)];</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">dlm_node_state_change</span>
<span class="p">{</span>
	<span class="n">NODE_DOWN</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="n">NODE_NO_CHANGE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">NODE_UP</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_bitmap_diff_iter_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_bitmap_diff_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">orig_bm</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">cur_bm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">curnode</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">orig_bm</span> <span class="o">=</span> <span class="n">orig_bm</span><span class="p">;</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur_bm</span> <span class="o">=</span> <span class="n">cur_bm</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">O2NM_MAX_NODES</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       		<span class="n">p1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">orig_bm</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	       	<span class="n">p2</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">cur_bm</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">diff_bm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">p2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">p2</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">p1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_bitmap_diff_iter_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_bitmap_diff_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span>
				     <span class="k">enum</span> <span class="n">dlm_node_state_change</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">curnode</span> <span class="o">&gt;=</span> <span class="n">O2NM_MAX_NODES</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">bit</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">diff_bm</span><span class="p">,</span> <span class="n">O2NM_MAX_NODES</span><span class="p">,</span>
			    <span class="n">iter</span><span class="o">-&gt;</span><span class="n">curnode</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&gt;=</span> <span class="n">O2NM_MAX_NODES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">curnode</span> <span class="o">=</span> <span class="n">O2NM_MAX_NODES</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if it was there in the original then this node died */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">orig_bm</span><span class="p">))</span>
		<span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">NODE_DOWN</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">NODE_UP</span><span class="p">;</span>

	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">curnode</span> <span class="o">=</span> <span class="n">bit</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">bit</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_restart_lock_mastery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">blocked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_bitmap_diff_iter</span> <span class="n">bdi</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">dlm_node_state_change</span> <span class="n">sc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;something happened such that the &quot;</span>
	     <span class="s">&quot;master process may need to be restarted!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">dlm_bitmap_diff_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">vote_map</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">node_map</span><span class="p">);</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">dlm_bitmap_diff_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">node</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sc</span> <span class="o">==</span> <span class="n">NODE_UP</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* a node came up.  clear any old vote from</span>
<span class="cm">			 * the response map and set it in the vote map</span>
<span class="cm">			 * then restart the mastery. */</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_NOTICE</span><span class="p">,</span> <span class="s">&quot;node %d up while restarting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

			<span class="cm">/* redo the master request, but only for the new node */</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;sending request to new node</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">response_map</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">vote_map</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;node down! %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">blocked</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">lowest</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">maybe_map</span><span class="p">,</span>
						       <span class="n">O2NM_MAX_NODES</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

				<span class="cm">/* act like it was never there */</span>
				<span class="n">clear_bit</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">maybe_map</span><span class="p">);</span>

			       	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">lowest</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;expected master %u died&quot;</span>
					    <span class="s">&quot; while this node was blocked &quot;</span>
					    <span class="s">&quot;waiting on it!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
					<span class="n">lowest</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">maybe_map</span><span class="p">,</span>
						       	<span class="n">O2NM_MAX_NODES</span><span class="p">,</span>
						       	<span class="n">lowest</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">lowest</span> <span class="o">&lt;</span> <span class="n">O2NM_MAX_NODES</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s:still &quot;</span>
						     <span class="s">&quot;blocked. waiting on %u &quot;</span>
						     <span class="s">&quot;now</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
						     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
						     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
						     <span class="n">lowest</span><span class="p">);</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="cm">/* mle is an MLE_BLOCK, but</span>
<span class="cm">						 * there is now nothing left to</span>
<span class="cm">						 * block on.  we need to return</span>
<span class="cm">						 * all the way back out and try</span>
<span class="cm">						 * again with an MLE_MASTER.</span>
<span class="cm">						 * dlm_do_local_recovery_cleanup</span>
<span class="cm">						 * has already run, so the mle</span>
<span class="cm">						 * refcount is ok */</span>
						<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: no &quot;</span>
						     <span class="s">&quot;longer blocking. try to &quot;</span>
						     <span class="s">&quot;master this here</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
						     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
						     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
						<span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">DLM_MLE_MASTER</span><span class="p">;</span>
						<span class="n">mle</span><span class="o">-&gt;</span><span class="n">mleres</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="cm">/* now blank out everything, as if we had never</span>
<span class="cm">			 * contacted anyone */</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">maybe_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">maybe_map</span><span class="p">));</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">response_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">response_map</span><span class="p">));</span>
			<span class="cm">/* reset the vote_map to the current node_map */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">vote_map</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">node_map</span><span class="p">,</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">node_map</span><span class="p">));</span>
			<span class="cm">/* put myself into the maybe map */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">DLM_MLE_BLOCK</span><span class="p">)</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">maybe_map</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">dlm_bitmap_diff_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * DLM_MASTER_REQUEST_MSG</span>
<span class="cm"> *</span>
<span class="cm"> * returns: 0 on success,</span>
<span class="cm"> *          -errno on a network error</span>
<span class="cm"> *</span>
<span class="cm"> * on error, the caller should assume the target node is &quot;dead&quot;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_do_master_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span> <span class="o">=</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">dlm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_master_request</span> <span class="n">request</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">response</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">resend</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">request</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">request</span><span class="p">));</span>
	<span class="n">request</span><span class="p">.</span><span class="n">node_idx</span> <span class="o">=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">DLM_MLE_MIGRATION</span><span class="p">);</span>

	<span class="n">request</span><span class="p">.</span><span class="n">namelen</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">mnamelen</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">request</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">mname</span><span class="p">,</span> <span class="n">request</span><span class="p">.</span><span class="n">namelen</span><span class="p">);</span>

<span class="nl">again:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">o2net_send_message</span><span class="p">(</span><span class="n">DLM_MASTER_REQUEST_MSG</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">request</span><span class="p">,</span>
				 <span class="k">sizeof</span><span class="p">(</span><span class="n">request</span><span class="p">),</span> <span class="n">to</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>  <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* should never happen */</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;TCP stack not ready!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;bad args passed to o2net!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;out of memory while trying to send &quot;</span>
			     <span class="s">&quot;network message!  retrying</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="cm">/* this is totally crude */</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_is_host_down</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* not a network error. bad. */</span>
			<span class="n">mlog_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;unhandled error!&quot;</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="cm">/* all other errors should be network errors,</span>
<span class="cm">		 * and likely indicate node death */</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;link to %d went down!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">resend</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">response</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">DLM_MASTER_RESP_YES</span>:
			<span class="n">set_bit</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">response_map</span><span class="p">);</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node %u is the master, response=YES</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: master node %u now knows I have a &quot;</span>
			     <span class="s">&quot;reference</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
			     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
			<span class="n">mle</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">=</span> <span class="n">to</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DLM_MASTER_RESP_NO</span>:
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node %u not master, response=NO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">response_map</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DLM_MASTER_RESP_MAYBE</span>:
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node %u not master, response=MAYBE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">response_map</span><span class="p">);</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">maybe_map</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DLM_MASTER_RESP_ERROR</span>:
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node %u hit an error, resending</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
			<span class="n">resend</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">response</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;bad response! %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">resend</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* this is also totally crude */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * locks that can be taken here:</span>
<span class="cm"> * dlm-&gt;spinlock</span>
<span class="cm"> * res-&gt;spinlock</span>
<span class="cm"> * mle-&gt;spinlock</span>
<span class="cm"> * dlm-&gt;master_list</span>
<span class="cm"> *</span>
<span class="cm"> * if possible, TRIM THIS DOWN!!!</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dlm_master_request_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">response</span> <span class="o">=</span> <span class="n">DLM_MASTER_RESP_MAYBE</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_master_request</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dlm_master_request</span> <span class="o">*</span><span class="p">)</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tmpmle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">hash</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">set_maybe</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dispatch_assert</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_grab</span><span class="p">(</span><span class="n">dlm</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">DLM_MASTER_RESP_NO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_domain_fully_joined</span><span class="p">(</span><span class="n">dlm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">response</span> <span class="o">=</span> <span class="n">DLM_MASTER_RESP_NO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">send_response</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">name</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">namelen</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">;</span>
	<span class="n">hash</span> <span class="o">=</span> <span class="n">dlm_lockid_hash</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">namelen</span> <span class="o">&gt;</span> <span class="n">DLM_LOCKID_NAME_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">response</span> <span class="o">=</span> <span class="n">DLM_IVBUFLEN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">send_response</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">way_up_top:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">__dlm_lookup_lockres</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

		<span class="cm">/* take care of the easy cases up front */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DLM_LOCK_RES_RECOVERING</span><span class="o">|</span>
				  <span class="n">DLM_LOCK_RES_MIGRATING</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;returning DLM_MASTER_RESP_ERROR since res is &quot;</span>
			     <span class="s">&quot;being recovered/migrated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">response</span> <span class="o">=</span> <span class="n">DLM_MASTER_RESP_ERROR</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mle</span><span class="p">)</span>
				<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">dlm_mle_cache</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">send_response</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">==</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dlm_lockres_set_refmap_bit</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">response</span> <span class="o">=</span> <span class="n">DLM_MASTER_RESP_YES</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mle</span><span class="p">)</span>
				<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">dlm_mle_cache</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>

			<span class="cm">/* this node is the owner.</span>
<span class="cm">			 * there is some extra work that needs to</span>
<span class="cm">			 * happen now.  the requesting node has</span>
<span class="cm">			 * caused all nodes up to this one to</span>
<span class="cm">			 * create mles.  this node now needs to</span>
<span class="cm">			 * go back and clean those up. */</span>
			<span class="n">dispatch_assert</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">send_response</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">DLM_LOCK_RES_OWNER_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>mlog(0, "node %u is the master\n", res->owner);</p></td><td class="code"><div class="highlight"><pre>			<span class="n">response</span> <span class="o">=</span> <span class="n">DLM_MASTER_RESP_NO</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mle</span><span class="p">)</span>
				<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">dlm_mle_cache</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">send_response</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* ok, there is no owner.  either this node is</span>
<span class="cm">		 * being blocked, or it is actively trying to</span>
<span class="cm">		 * master this lock. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_IN_PROGRESS</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;lock with no owner should be &quot;</span>
			     <span class="s">&quot;in-progress!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>mlog(0, "lockres is in progress...\n");</p></td><td class="code"><div class="highlight"><pre>		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
		<span class="n">found</span> <span class="o">=</span> <span class="n">dlm_find_mle</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmpmle</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;no mle found for this lock!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">set_maybe</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmpmle</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmpmle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">DLM_MLE_BLOCK</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>mlog(0, "this node is waiting for "
"lockres to be mastered\n");</p></td><td class="code"><div class="highlight"><pre>			<span class="n">response</span> <span class="o">=</span> <span class="n">DLM_MASTER_RESP_NO</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tmpmle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">DLM_MLE_MIGRATION</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node %u is master, but trying to migrate to &quot;</span>
			     <span class="s">&quot;node %u.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tmpmle</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">,</span> <span class="n">tmpmle</span><span class="o">-&gt;</span><span class="n">new_master</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmpmle</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">==</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;no owner on lockres, but this &quot;</span>
				     <span class="s">&quot;node is trying to migrate it to %u?!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">tmpmle</span><span class="o">-&gt;</span><span class="n">new_master</span><span class="p">);</span>
				<span class="n">BUG</span><span class="p">();</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* the real master can respond on its own */</span>
				<span class="n">response</span> <span class="o">=</span> <span class="n">DLM_MASTER_RESP_NO</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tmpmle</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">!=</span> <span class="n">DLM_LOCK_RES_OWNER_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_maybe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmpmle</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">==</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">response</span> <span class="o">=</span> <span class="n">DLM_MASTER_RESP_YES</span><span class="p">;</span>
				<span class="cm">/* this node will be the owner.</span>
<span class="cm">				 * go back and clean the mles on any</span>
<span class="cm">				 * other nodes */</span>
				<span class="n">dispatch_assert</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">dlm_lockres_set_refmap_bit</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span>
							   <span class="n">request</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">response</span> <span class="o">=</span> <span class="n">DLM_MASTER_RESP_NO</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>mlog(0, "this node is attempting to "
"master lockres\n");</p></td><td class="code"><div class="highlight"><pre>			<span class="n">response</span> <span class="o">=</span> <span class="n">DLM_MASTER_RESP_MAYBE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">set_maybe</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">tmpmle</span><span class="o">-&gt;</span><span class="n">maybe_map</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmpmle</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

		<span class="cm">/* keep the mle attached to heartbeat events */</span>
		<span class="n">dlm_put_mle</span><span class="p">(</span><span class="n">tmpmle</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mle</span><span class="p">)</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">dlm_mle_cache</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">send_response</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * lockres doesn&#39;t exist on this node</span>
<span class="cm">	 * if there is an MLE_BLOCK, return NO</span>
<span class="cm">	 * if there is an MLE_MASTER, return MAYBE</span>
<span class="cm">	 * otherwise, add an MLE_BLOCK, return NO</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
	<span class="n">found</span> <span class="o">=</span> <span class="n">dlm_find_mle</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmpmle</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* this lockid has never been seen on this node yet */</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>mlog(0, "no mle found\n");</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mle</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

			<span class="n">mle</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">dlm_mle_cache</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mle</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">response</span> <span class="o">=</span> <span class="n">DLM_MASTER_RESP_ERROR</span><span class="p">;</span>
				<span class="n">mlog_errno</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">send_response</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">way_up_top</span><span class="p">;</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>mlog(0, "this is second time thru, already allocated, "
"add the block.\n");</p></td><td class="code"><div class="highlight"><pre>		<span class="n">dlm_init_mle</span><span class="p">(</span><span class="n">mle</span><span class="p">,</span> <span class="n">DLM_MLE_BLOCK</span><span class="p">,</span> <span class="n">dlm</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">maybe_map</span><span class="p">);</span>
		<span class="n">__dlm_insert_mle</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
		<span class="n">response</span> <span class="o">=</span> <span class="n">DLM_MASTER_RESP_NO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>mlog(0, "mle was found\n");</p></td><td class="code"><div class="highlight"><pre>		<span class="n">set_maybe</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmpmle</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmpmle</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">==</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;no lockres, but an mle with this node as master!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmpmle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">DLM_MLE_BLOCK</span><span class="p">)</span>
			<span class="n">response</span> <span class="o">=</span> <span class="n">DLM_MASTER_RESP_NO</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tmpmle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">DLM_MLE_MIGRATION</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;migration mle was found (%u-&gt;%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">tmpmle</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">,</span> <span class="n">tmpmle</span><span class="o">-&gt;</span><span class="n">new_master</span><span class="p">);</span>
			<span class="cm">/* real master can respond on its own */</span>
			<span class="n">response</span> <span class="o">=</span> <span class="n">DLM_MASTER_RESP_NO</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">response</span> <span class="o">=</span> <span class="n">DLM_MASTER_RESP_MAYBE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">set_maybe</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">tmpmle</span><span class="o">-&gt;</span><span class="n">maybe_map</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmpmle</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* keep the mle attached to heartbeat events */</span>
		<span class="n">dlm_put_mle</span><span class="p">(</span><span class="n">tmpmle</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">send_response:</span>
	<span class="cm">/*</span>
<span class="cm">	 * __dlm_lookup_lockres() grabbed a reference to this lockres.</span>
<span class="cm">	 * The reference is released by dlm_assert_master_worker() under</span>
<span class="cm">	 * the call to dlm_dispatch_assert_master().  If</span>
<span class="cm">	 * dlm_assert_master_worker() isn&#39;t called, we drop it here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dispatch_assert</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">response</span> <span class="o">!=</span> <span class="n">DLM_MASTER_RESP_YES</span><span class="p">)</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;invalid response %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;bad lockres while trying to assert!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%u is the owner of %.*s, cleaning everyone else</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_dispatch_assert_master</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span>
						 <span class="n">DLM_ASSERT_MASTER_MLE_CLEANUP</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;failed to dispatch assert master work</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">response</span> <span class="o">=</span> <span class="n">DLM_MASTER_RESP_ERROR</span><span class="p">;</span>
			<span class="n">dlm_lockres_put</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
			<span class="n">dlm_lockres_put</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dlm_put</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">response</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * DLM_ASSERT_MASTER_MSG</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * NOTE: this can be used for debugging</span>
<span class="cm"> * can periodically run all locks owned by this node</span>
<span class="cm"> * and re-assert across the cluster...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_do_assert_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">nodemap</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_assert_master</span> <span class="n">assert</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">to</span><span class="p">,</span> <span class="n">tmpret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_node_iter</span> <span class="n">iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reassert</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lockname</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">namelen</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">namelen</span> <span class="o">&gt;</span> <span class="n">O2NM_MAX_NAME_LEN</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">DLM_LOCK_RES_SETREF_INPROG</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

<span class="nl">again:</span>
	<span class="n">reassert</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* note that if this nodemap is empty, it returns 0 */</span>
	<span class="n">dlm_node_iter_init</span><span class="p">(</span><span class="n">nodemap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">to</span> <span class="o">=</span> <span class="n">dlm_node_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;sending assert master to %d (%.*s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span>
		     <span class="n">namelen</span><span class="p">,</span> <span class="n">lockname</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">assert</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">assert</span><span class="p">));</span>
		<span class="n">assert</span><span class="p">.</span><span class="n">node_idx</span> <span class="o">=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">;</span>
		<span class="n">assert</span><span class="p">.</span><span class="n">namelen</span> <span class="o">=</span> <span class="n">namelen</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">assert</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">lockname</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>
		<span class="n">assert</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

		<span class="n">tmpret</span> <span class="o">=</span> <span class="n">o2net_send_message</span><span class="p">(</span><span class="n">DLM_ASSERT_MASTER_MSG</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">assert</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">assert</span><span class="p">),</span> <span class="n">to</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmpret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;Error %d when sending message %u (key &quot;</span>
			     <span class="s">&quot;0x%x) to node %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tmpret</span><span class="p">,</span>
			     <span class="n">DLM_ASSERT_MASTER_MSG</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_is_host_down</span><span class="p">(</span><span class="n">tmpret</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;unhandled error=%d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tmpret</span><span class="p">);</span>
				<span class="n">BUG</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="cm">/* a node died.  finish out the rest of the nodes. */</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;link to %d went down!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
			<span class="cm">/* any nonzero status return will do */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">tmpret</span><span class="p">;</span>
			<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* ok, something horribly messed.  kill thyself. */</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span><span class="s">&quot;during assert master of %.*s to %u, &quot;</span>
			     <span class="s">&quot;got %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">lockname</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dlm_find_mle</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mle</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">lockname</span><span class="p">,</span>
					 <span class="n">namelen</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dlm_print_one_mle</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
				<span class="n">__dlm_put_mle</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&amp;</span> <span class="n">DLM_ASSERT_RESPONSE_REASSERT</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">r</span> <span class="o">&amp;</span> <span class="n">DLM_ASSERT_RESPONSE_MASTERY_REF</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%.*s: very strange, &quot;</span>
				     <span class="s">&quot;master MLE but no lockres on %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">namelen</span><span class="p">,</span> <span class="n">lockname</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&amp;</span> <span class="n">DLM_ASSERT_RESPONSE_REASSERT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%.*s: node %u create mles on other &quot;</span>
			     <span class="s">&quot;nodes and requests a re-assert</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">namelen</span><span class="p">,</span> <span class="n">lockname</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
			<span class="n">reassert</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&amp;</span> <span class="n">DLM_ASSERT_RESPONSE_MASTERY_REF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%.*s: node %u has a reference to this &quot;</span>
			     <span class="s">&quot;lockres, set the bit in the refmap</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">namelen</span><span class="p">,</span> <span class="n">lockname</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">dlm_lockres_set_refmap_bit</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reassert</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_LOCK_RES_SETREF_INPROG</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * locks that can be taken here:</span>
<span class="cm"> * dlm-&gt;spinlock</span>
<span class="cm"> * res-&gt;spinlock</span>
<span class="cm"> * mle-&gt;spinlock</span>
<span class="cm"> * dlm-&gt;master_list</span>
<span class="cm"> *</span>
<span class="cm"> * if possible, TRIM THIS DOWN!!!</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dlm_assert_master_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_assert_master</span> <span class="o">*</span><span class="n">assert</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dlm_assert_master</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">hash</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">master_request</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">have_lockres_ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_grab</span><span class="p">(</span><span class="n">dlm</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">name</span> <span class="o">=</span> <span class="n">assert</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">namelen</span> <span class="o">=</span> <span class="n">assert</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">;</span>
	<span class="n">hash</span> <span class="o">=</span> <span class="n">dlm_lockid_hash</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">assert</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">namelen</span> <span class="o">&gt;</span> <span class="n">DLM_LOCKID_NAME_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;Invalid name length!&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span><span class="p">)</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;assert_master with flags: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* find the MLE */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_find_mle</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mle</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* not an error, could be master just re-asserting */</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;just got an assert_master from %u, but no &quot;</span>
		     <span class="s">&quot;MLE for it! (%.*s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span>
		     <span class="n">namelen</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">bit</span> <span class="o">=</span> <span class="n">find_next_bit</span> <span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">maybe_map</span><span class="p">,</span> <span class="n">O2NM_MAX_NODES</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&gt;=</span> <span class="n">O2NM_MAX_NODES</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* not necessarily an error, though less likely.</span>
<span class="cm">			 * could be master just re-asserting. */</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;no bits set in the maybe_map, but %u &quot;</span>
			     <span class="s">&quot;is asserting! (%.*s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span>
			     <span class="n">namelen</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">!=</span> <span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_ASSERT_MASTER_MLE_CLEANUP</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;master %u was found, %u should &quot;</span>
				     <span class="s">&quot;back off</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">bit</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* with the fix for bug 569, a higher node</span>
<span class="cm">				 * number winning the mastery will respond</span>
<span class="cm">				 * YES to mastery requests, but this node</span>
<span class="cm">				 * had no way of knowing.  let it pass. */</span>
				<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%u is the lowest node, &quot;</span>
				     <span class="s">&quot;%u is asserting. (%.*s)  %u must &quot;</span>
				     <span class="s">&quot;have begun after %u won.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bit</span><span class="p">,</span>
				     <span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bit</span><span class="p">,</span>
				     <span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">DLM_MLE_MIGRATION</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_ASSERT_MASTER_MLE_CLEANUP</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: got cleanup assert&quot;</span>
				     <span class="s">&quot; from %u for migration</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
				     <span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_ASSERT_MASTER_FINISH_MIGRATION</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: got unrelated assert&quot;</span>
				     <span class="s">&quot; from %u for migration, ignoring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
				     <span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">);</span>
				<span class="n">__dlm_put_mle</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>

	<span class="cm">/* ok everything checks out with the MLE</span>
<span class="cm">	 * now check to see if there is a lockres */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">__dlm_lookup_lockres</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_RECOVERING</span><span class="p">)</span>  <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%u asserting but %.*s is &quot;</span>
			     <span class="s">&quot;RECOVERING!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">kill</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mle</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">DLM_LOCK_RES_OWNER_UNKNOWN</span> <span class="o">&amp;&amp;</span>
			    <span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;DIE! Mastery assert from %u, &quot;</span>
				     <span class="s">&quot;but current owner is %u! (%.*s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span>
				     <span class="n">name</span><span class="p">);</span>
				<span class="n">__dlm_print_one_lock_resource</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
				<span class="n">BUG</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">DLM_MLE_MIGRATION</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">DLM_LOCK_RES_OWNER_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* owner is just re-asserting */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">==</span> <span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;owner %u re-asserting on &quot;</span>
					     <span class="s">&quot;lock %.*s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span>
					     <span class="n">namelen</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">ok</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;got assert_master from &quot;</span>
				     <span class="s">&quot;node %u, but %u is the owner! &quot;</span>
				     <span class="s">&quot;(%.*s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span>
				     <span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">kill</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_IN_PROGRESS</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;got assert from %u, but lock &quot;</span>
				     <span class="s">&quot;with no owner should be &quot;</span>
				     <span class="s">&quot;in-progress! (%.*s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span>
				     <span class="n">namelen</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">kill</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="cm">/* mle-&gt;type == DLM_MLE_MIGRATION */</span> <span class="p">{</span>
			<span class="cm">/* should only be getting an assert from new master */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span> <span class="o">!=</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">new_master</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;got assert from %u, but &quot;</span>
				     <span class="s">&quot;new master is %u, and old master &quot;</span>
				     <span class="s">&quot;was %u (%.*s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">new_master</span><span class="p">,</span>
				     <span class="n">mle</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">kill</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="p">}</span>
<span class="nl">ok:</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>mlog(0, "woo!  got an assert<em>master from node %u!\n",
         assert->node</em>idx);</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">mle</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">extra_ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">rr</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">DLM_MLE_BLOCK</span> <span class="o">||</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">DLM_MLE_MIGRATION</span><span class="p">)</span>
			<span class="n">extra_ref</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* MASTER mle: if any bits set in the response map</span>
<span class="cm">			 * then the calling node needs to re-assert to clear</span>
<span class="cm">			 * up nodes that this node contacted */</span>
			<span class="k">while</span> <span class="p">((</span><span class="n">nn</span> <span class="o">=</span> <span class="n">find_next_bit</span> <span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">response_map</span><span class="p">,</span> <span class="n">O2NM_MAX_NODES</span><span class="p">,</span>
						    <span class="n">nn</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">O2NM_MAX_NODES</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">nn</span> <span class="o">!=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span> <span class="o">&amp;&amp;</span> <span class="n">nn</span> <span class="o">!=</span> <span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">)</span>
					<span class="n">master_request</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">mle</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">=</span> <span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">;</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">woken</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">wake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">DLM_MLE_MIGRATION</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;finishing off migration of lockres %.*s, &quot;</span>
			     		<span class="s">&quot;from %u to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       		<span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			       		<span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">new_master</span><span class="p">);</span>
				<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_LOCK_RES_MIGRATING</span><span class="p">;</span>
				<span class="n">wake</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">dlm_change_lockres_owner</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">new_master</span><span class="p">);</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_DIRTY</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">dlm_change_lockres_owner</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">have_lockres_ref</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wake</span><span class="p">)</span>
				<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* master is known, detach if not already detached.</span>
<span class="cm">		 * ensures that only one assert_master call will happen</span>
<span class="cm">		 * on this mle. */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>

		<span class="n">rr</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">mle_refs</span><span class="p">.</span><span class="n">refcount</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">extra_ref</span> <span class="o">&amp;&amp;</span> <span class="n">rr</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">extra_ref</span> <span class="o">&amp;&amp;</span> <span class="n">rr</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">extra_ref</span> <span class="o">&amp;&amp;</span> <span class="n">rr</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">extra_ref</span> <span class="o">&amp;&amp;</span> <span class="n">rr</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: got assert master from %u &quot;</span>
			     <span class="s">&quot;that will mess up this node, refs=%d, extra=%d, &quot;</span>
			     <span class="s">&quot;inuse=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
			     <span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">rr</span><span class="p">,</span> <span class="n">extra_ref</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">);</span>
			<span class="n">dlm_print_one_mle</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">__dlm_unlink_mle</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
		<span class="n">__dlm_mle_detach_hb_events</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
		<span class="n">__dlm_put_mle</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">extra_ref</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* the assert master message now balances the extra</span>
<span class="cm">		 	 * ref given by the master / migration request message.</span>
<span class="cm">		 	 * if this is the last put, it will be removed</span>
<span class="cm">		 	 * from the list. */</span>
			<span class="n">__dlm_put_mle</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;assert_master from %u, but current &quot;</span>
			     <span class="s">&quot;owner is %u (%.*s), no mle</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span>
			     <span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">DLM_LOCK_RES_SETREF_INPROG</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="o">*</span><span class="n">ret_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dlm_put</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">master_request</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;need to tell master to reassert</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* positive. negative would shoot down the node. */</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">DLM_ASSERT_RESPONSE_REASSERT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">have_lockres_ref</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;strange, got assert from %u, MASTER &quot;</span>
			     <span class="s">&quot;mle present here for %s:%.*s, but no lockres!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">have_lockres_ref</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* let the master know we have a reference to the lockres */</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">DLM_ASSERT_RESPONSE_MASTERY_REF</span><span class="p">;</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: got assert from %u, need a ref</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">assert</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">kill:</span>
	<span class="cm">/* kill the caller! */</span>
	<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;Bad message received from another node.  Dumping state &quot;</span>
	     <span class="s">&quot;and killing the other node now!  This node is OK and can continue.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">__dlm_print_one_lock_resource</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="o">*</span><span class="n">ret_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">res</span><span class="p">;</span>
	<span class="n">dlm_put</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_assert_master_post_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ret_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="p">)</span><span class="n">ret_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_LOCK_RES_SETREF_INPROG</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
		<span class="n">dlm_lockres_put</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dlm_dispatch_assert_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">ignore_higher</span><span class="p">,</span> <span class="n">u8</span> <span class="n">request_from</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_work_item</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="n">item</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">item</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>


	<span class="cm">/* queue up work for dlm_assert_master_worker */</span>
	<span class="n">dlm_grab</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>  <span class="cm">/* get an extra ref for the work item */</span>
	<span class="n">dlm_init_work_item</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">dlm_assert_master_worker</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">am</span><span class="p">.</span><span class="n">lockres</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span> <span class="cm">/* already have a ref */</span>
	<span class="cm">/* can optionally ignore node numbers higher than this node */</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">am</span><span class="p">.</span><span class="n">ignore_higher</span> <span class="o">=</span> <span class="n">ignore_higher</span><span class="p">;</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">am</span><span class="p">.</span><span class="n">request_from</span> <span class="o">=</span> <span class="n">request_from</span><span class="p">;</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">am</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ignore_higher</span><span class="p">)</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;IGNORE HIGHER: %.*s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
		     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>

	<span class="n">queue_work</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_worker</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dispatched_work</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_assert_master_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_work_item</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nodemap</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">O2NM_MAX_NODES</span><span class="p">)];</span>
	<span class="kt">int</span> <span class="n">ignore_higher</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bit</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">request_from</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">dlm</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">dlm</span><span class="p">;</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">am</span><span class="p">.</span><span class="n">lockres</span><span class="p">;</span>
	<span class="n">ignore_higher</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">am</span><span class="p">.</span><span class="n">ignore_higher</span><span class="p">;</span>
	<span class="n">request_from</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">am</span><span class="p">.</span><span class="n">request_from</span><span class="p">;</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">am</span><span class="p">.</span><span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">nodemap</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">domain_map</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nodemap</span><span class="p">));</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span> <span class="n">nodemap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ignore_higher</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if is this just to clear up mles for nodes below</span>
<span class="cm">		 * this node, do not send the message to the original</span>
<span class="cm">		 * caller or any node number higher than this */</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">request_from</span><span class="p">,</span> <span class="n">nodemap</span><span class="p">);</span>
		<span class="n">bit</span> <span class="o">=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bit</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">nodemap</span><span class="p">,</span> <span class="n">O2NM_MAX_NODES</span><span class="p">,</span>
					    <span class="n">bit</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
		       	<span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&gt;=</span> <span class="n">O2NM_MAX_NODES</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="n">nodemap</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re migrating this lock to someone else, we are no</span>
<span class="cm">	 * longer allowed to assert out own mastery.  OTOH, we need to</span>
<span class="cm">	 * prevent migration from starting while we&#39;re still asserting</span>
<span class="cm">	 * our dominance.  The reserved ast delays migration.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_MIGRATING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Someone asked us to assert mastery, but we&#39;re &quot;</span>
		     <span class="s">&quot;in the middle of migration.  Skipping assert, &quot;</span>
		     <span class="s">&quot;the new master will handle that.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">put</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">__dlm_lockres_reserve_ast</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="cm">/* this call now finishes out the nodemap</span>
<span class="cm">	 * even if one or more nodes die */</span>
	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;worker about to master %.*s here, this=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_do_assert_master</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">nodemap</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* no need to restart, we are done */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_is_host_down</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
			<span class="n">mlog_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Ok, we&#39;ve asserted ourselves.  Let&#39;s let migration start. */</span>
	<span class="n">dlm_lockres_release_ast</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>

<span class="nl">put:</span>
	<span class="n">dlm_lockres_put</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;finished with dlm_assert_master_worker</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* SPECIAL CASE for the $RECOVERY lock used by the recovery thread.</span>
<span class="cm"> * We cannot wait for node recovery to complete to begin mastering this</span>
<span class="cm"> * lockres because this lockres is used to kick off recovery! ;-)</span>
<span class="cm"> * So, do a pre-check on all living nodes to see if any of those nodes</span>
<span class="cm"> * think that $RECOVERY is currently mastered by a dead node.  If so,</span>
<span class="cm"> * we wait a short time to allow that node to get notified by its own</span>
<span class="cm"> * heartbeat stack, then check again.  All $RECOVERY lock resources</span>
<span class="cm"> * mastered by dead nodes are purged when the hearbeat callback is</span>
<span class="cm"> * fired, so we can know for sure that it is safe to continue once</span>
<span class="cm"> * the node returns a live node or no node.  */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_pre_master_reco_lockres</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_node_iter</span> <span class="n">iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nodenum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">master</span> <span class="o">=</span> <span class="n">DLM_LOCK_RES_OWNER_UNKNOWN</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">dlm_node_iter_init</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">domain_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">nodenum</span> <span class="o">=</span> <span class="n">dlm_node_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* do not send to self */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nodenum</span> <span class="o">==</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_do_master_requery</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">nodenum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">master</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_is_host_down</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
				<span class="n">BUG</span><span class="p">();</span>
			<span class="cm">/* host is down, so answer for that node would be</span>
<span class="cm">			 * DLM_LOCK_RES_OWNER_UNKNOWN.  continue. */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">master</span> <span class="o">!=</span> <span class="n">DLM_LOCK_RES_OWNER_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* check to see if this master is in the recovery map */</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">recovery_map</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_NOTICE</span><span class="p">,</span> <span class="s">&quot;%s: node %u has not seen &quot;</span>
				     <span class="s">&quot;node %u go down yet, and thinks the &quot;</span>
				     <span class="s">&quot;dead node is mastering the recovery &quot;</span>
				     <span class="s">&quot;lock.  must wait.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				     <span class="n">nodenum</span><span class="p">,</span> <span class="n">master</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: reco lock master is %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			     <span class="n">master</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * DLM_DEREF_LOCKRES_MSG</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">dlm_drop_lockres_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_deref_lockres</span> <span class="n">deref</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lockname</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">;</span>

	<span class="n">lockname</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
	<span class="n">namelen</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">namelen</span> <span class="o">&gt;</span> <span class="n">O2NM_MAX_NAME_LEN</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deref</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">deref</span><span class="p">));</span>
	<span class="n">deref</span><span class="p">.</span><span class="n">node_idx</span> <span class="o">=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">;</span>
	<span class="n">deref</span><span class="p">.</span><span class="n">namelen</span> <span class="o">=</span> <span class="n">namelen</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">deref</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">lockname</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">o2net_send_message</span><span class="p">(</span><span class="n">DLM_DEREF_LOCKRES_MSG</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">deref</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">deref</span><span class="p">),</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s: res %.*s, error %d send DEREF to node %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">lockname</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* BAD.  other node says I did not have a ref. */</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s: res %.*s, DEREF to node %u got %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">lockname</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
		<span class="n">dlm_print_one_lock_resource</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dlm_deref_lockres_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_deref_lockres</span> <span class="o">*</span><span class="n">deref</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dlm_deref_lockres</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_work_item</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cleared</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dispatch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_grab</span><span class="p">(</span><span class="n">dlm</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">name</span> <span class="o">=</span> <span class="n">deref</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">namelen</span> <span class="o">=</span> <span class="n">deref</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">;</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">deref</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">namelen</span> <span class="o">&gt;</span> <span class="n">DLM_LOCKID_NAME_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;Invalid name length!&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">deref</span><span class="o">-&gt;</span><span class="n">node_idx</span> <span class="o">&gt;=</span> <span class="n">O2NM_MAX_NODES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;Invalid node number: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">dlm_lockid_hash</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">__dlm_lookup_lockres_full</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: bad lockres name</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_SETREF_INPROG</span><span class="p">)</span>
		<span class="n">dispatch</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_DROPPING_REF</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">refmap</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dlm_lockres_clear_refmap_bit</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
			<span class="n">cleared</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dispatch</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cleared</span><span class="p">)</span>
			<span class="n">dlm_lockres_calc_usage</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: node %u trying to drop ref &quot;</span>
		     	<span class="s">&quot;but it is already dropped!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		     	<span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
			<span class="n">dlm_print_one_lock_resource</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">item</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">item</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">mlog_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dlm_init_work_item</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">dlm_deref_lockres_worker</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">dl</span><span class="p">.</span><span class="n">deref_res</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">dl</span><span class="p">.</span><span class="n">deref_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>

	<span class="n">queue_work</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_worker</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dispatched_work</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="n">dlm_lockres_put</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
	<span class="n">dlm_put</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_deref_lockres_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_work_item</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">node</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cleared</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dlm</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">dlm</span><span class="p">;</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">dl</span><span class="p">.</span><span class="n">deref_res</span><span class="p">;</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">dl</span><span class="p">.</span><span class="n">deref_node</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_DROPPING_REF</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">refmap</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__dlm_wait_on_lockres_flags</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">DLM_LOCK_RES_SETREF_INPROG</span><span class="p">);</span>
		<span class="n">dlm_lockres_clear_refmap_bit</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">cleared</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cleared</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s node %u ref dropped in dispatch</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">dlm_lockres_calc_usage</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: node %u trying to drop ref &quot;</span>
		     <span class="s">&quot;but it is already dropped!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">dlm_print_one_lock_resource</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dlm_lockres_put</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A migrateable resource is one that is :</span>
<span class="cm"> * 1. locally mastered, and,</span>
<span class="cm"> * 2. zero local locks, and,</span>
<span class="cm"> * 3. one or more non-local locks, or, one or more references</span>
<span class="cm"> * Returns 1 if yes, 0 if not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_is_lockres_migrateable</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">dlm_lockres_list</span> <span class="n">idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nonlocal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">node_ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">cookie</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="n">DLM_GRANTED_LIST</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">DLM_BLOCKED_LIST</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">queue</span> <span class="o">=</span> <span class="n">dlm_list_idx_to_ptr</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">node</span> <span class="o">!=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">nonlocal</span><span class="o">++</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">cookie</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">cookie</span><span class="p">);</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: Not migrateable res %.*s, lock %u:%llu on &quot;</span>
			     <span class="s">&quot;%s list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
			     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			     <span class="n">dlm_get_lock_cookie_node</span><span class="p">(</span><span class="n">cookie</span><span class="p">),</span>
			     <span class="n">dlm_get_lock_cookie_seq</span><span class="p">(</span><span class="n">cookie</span><span class="p">),</span>
			     <span class="n">dlm_list_in_text</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nonlocal</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node_ref</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">refmap</span><span class="p">,</span> <span class="n">O2NM_MAX_NODES</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node_ref</span> <span class="o">&gt;=</span> <span class="n">O2NM_MAX_NODES</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: res %.*s, Migrateable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
	     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * DLM_MIGRATE_LOCKRES</span>
<span class="cm"> */</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_migrate_lockres</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="n">u8</span> <span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">oldmle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
 	<span class="k">struct</span> <span class="n">dlm_migratable_lockres</span> <span class="o">*</span><span class="n">mres</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mle_added</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_grab</span><span class="p">(</span><span class="n">dlm</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">O2NM_MAX_NODES</span><span class="p">);</span>

	<span class="n">name</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
	<span class="n">namelen</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: Migrating %.*s to node %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
	     <span class="n">target</span><span class="p">);</span>

	<span class="cm">/* preallocate up front. if this fails, abort */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">mres</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dlm_migratable_lockres</span> <span class="o">*</span><span class="p">)</span> <span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mres</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mle</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">dlm_mle_cache</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mle</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * clear any existing master requests and</span>
<span class="cm">	 * add the migration mle to the list</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_add_migration_mle</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">mle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmle</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
				    <span class="n">namelen</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;another process is already migrating it</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mle_added</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * set the MIGRATING flag and flush asts</span>
<span class="cm">	 * if we fail after this we need to re-dirty the lockres</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlm_mark_lockres_migrating</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;tried to migrate %.*s to %u, but &quot;</span>
		     <span class="s">&quot;the target went down.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
		     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_LOCK_RES_MIGRATING</span><span class="p">;</span>
		<span class="n">wake</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">fail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oldmle</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* master is known, detach if not already detached */</span>
		<span class="n">dlm_mle_detach_hb_events</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">oldmle</span><span class="p">);</span>
		<span class="n">dlm_put_mle</span><span class="p">(</span><span class="n">oldmle</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mle_added</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dlm_mle_detach_hb_events</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
			<span class="n">dlm_put_mle</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mle</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">dlm_mle_cache</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
			<span class="n">mle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * at this point, we have a migration target, an mle</span>
<span class="cm">	 * in the master list, and the MIGRATING flag set on</span>
<span class="cm">	 * the lockres</span>
<span class="cm">	 */</span>

	<span class="cm">/* now that remote nodes are spinning on the MIGRATING flag,</span>
<span class="cm">	 * ensure that all assert_master work is flushed. */</span>
	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_worker</span><span class="p">);</span>

	<span class="cm">/* get an extra reference on the mle.</span>
<span class="cm">	 * otherwise the assert_master from the new</span>
<span class="cm">	 * master will destroy this.</span>
<span class="cm">	 * also, make sure that all callers of dlm_get_mle</span>
<span class="cm">	 * take both dlm-&gt;spinlock and dlm-&gt;master_lock */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
	<span class="n">dlm_get_mle_inuse</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="cm">/* notify new node and send all lock state */</span>
	<span class="cm">/* call send_one_lockres with migration flag.</span>
<span class="cm">	 * this serves as notice to the target node that a</span>
<span class="cm">	 * migration is starting. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_send_one_lockres</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">mres</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>
				   <span class="n">DLM_MRES_MIGRATION</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;migration to node %u failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">target</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="cm">/* migration failed, detach and clean up mle */</span>
		<span class="n">dlm_mle_detach_hb_events</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
		<span class="n">dlm_put_mle</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
		<span class="n">dlm_put_mle_inuse</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_LOCK_RES_MIGRATING</span><span class="p">;</span>
		<span class="n">wake</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlm_is_host_down</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
			<span class="n">dlm_wait_for_node_death</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>
						<span class="n">DLM_NODE_DEATH_WAIT_MAX</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* at this point, the target sends a message to all nodes,</span>
<span class="cm">	 * (using dlm_do_migrate_request).  this node is skipped since</span>
<span class="cm">	 * we had to put an mle in the list to begin the process.  this</span>
<span class="cm">	 * node now waits for target to do an assert master.  this node</span>
<span class="cm">	 * will be the last one notified, ensuring that the migration</span>
<span class="cm">	 * is complete everywhere.  if the target dies while this is</span>
<span class="cm">	 * going on, some nodes could potentially see the target as the</span>
<span class="cm">	 * master, so it is important that my recovery finds the migration</span>
<span class="cm">	 * mle and sets the master to UNKNOWN. */</span>


	<span class="cm">/* wait for new node to assert master */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_event_interruptible_timeout</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span>
					<span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">woken</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span>
					<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">5000</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		       	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">woken</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span>
			    <span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: timed out during migration</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
			<span class="cm">/* avoid hang during shutdown when migrating lockres</span>
<span class="cm">			 * to a node which also goes down */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dlm_is_node_dead</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: expected migration &quot;</span>
				     <span class="s">&quot;target %u is no longer up, restarting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
				     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="cm">/* migration failed, detach and clean up mle */</span>
				<span class="n">dlm_mle_detach_hb_events</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
				<span class="n">dlm_put_mle</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
				<span class="n">dlm_put_mle_inuse</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
				<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_LOCK_RES_MIGRATING</span><span class="p">;</span>
				<span class="n">wake</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: caught signal during migration</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* all done, set the owner, clear the flag */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">dlm_set_lockres_owner</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_LOCK_RES_MIGRATING</span><span class="p">;</span>
	<span class="n">dlm_remove_nonlocal_locks</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>

	<span class="cm">/* master is known, detach if not already detached */</span>
	<span class="n">dlm_mle_detach_hb_events</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
	<span class="n">dlm_put_mle_inuse</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dlm_lockres_calc_usage</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>

<span class="nl">leave:</span>
	<span class="cm">/* re-dirty the lockres if we failed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dlm_kick_thread</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>

	<span class="cm">/* wake up waiters if the MIGRATING flag got set</span>
<span class="cm">	 * but migration failed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wake</span><span class="p">)</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mres</span><span class="p">)</span>
		<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mres</span><span class="p">);</span>

	<span class="n">dlm_put</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: Migrating %.*s to %u, returns %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span>
	     <span class="n">name</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define DLM_MIGRATION_RETRY_MS  100</span>

<span class="cm">/*</span>
<span class="cm"> * Should be called only after beginning the domain leave process.</span>
<span class="cm"> * There should not be any remaining locks on nonlocal lock resources,</span>
<span class="cm"> * and there should be no local locks left on locally mastered resources.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with the dlm spinlock held, may drop it to do migration, but</span>
<span class="cm"> * will re-acquire before exit.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 1 if dlm-&gt;spinlock was dropped/retaken, 0 if never dropped</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dlm_empty_lockres</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lock_dropped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">target</span> <span class="o">=</span> <span class="n">O2NM_MAX_NODES</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlm_is_lockres_migrateable</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">))</span>
		<span class="n">target</span> <span class="o">=</span> <span class="n">dlm_pick_migration_target</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">O2NM_MAX_NODES</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>

	<span class="cm">/* Wheee! Migrate lockres here! Will sleep so drop spinlock. */</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">lock_dropped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_migrate_lockres</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: res %.*s, Migrate to node %u failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
		     <span class="n">target</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
<span class="nl">leave:</span>
	<span class="k">return</span> <span class="n">lock_dropped</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dlm_lock_basts_flushed</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">ast_lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">bast_list</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">bast_pending</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">ast_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_migration_can_proceed</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
				     <span class="n">u8</span> <span class="n">mig_target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">can_proceed</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">can_proceed</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_MIGRATING</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="cm">/* target has died, so make the caller break out of the</span>
<span class="cm">	 * wait_event, but caller must recheck the domain_map */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">mig_target</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">domain_map</span><span class="p">))</span>
		<span class="n">can_proceed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">can_proceed</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_lockres_is_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_DIRTY</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_mark_lockres_migrating</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
				       <span class="n">u8</span> <span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;dlm_mark_lockres_migrating: %.*s, from %u to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span>
	       <span class="n">target</span><span class="p">);</span>
	<span class="cm">/* need to set MIGRATING flag on lockres.  this is done by</span>
<span class="cm">	 * ensuring that all asts have been flushed for this lockres. */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">migration_pending</span><span class="p">);</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">migration_pending</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* strategy is to reserve an extra ast then release</span>
<span class="cm">	 * it below, letting the release do all of the work */</span>
	<span class="n">__dlm_lockres_reserve_ast</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="cm">/* now flush all the pending asts */</span>
	<span class="n">dlm_kick_thread</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
	<span class="cm">/* before waiting on DIRTY, block processes which may</span>
<span class="cm">	 * try to dirty the lockres before MIGRATING is set */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_BLOCK_DIRTY</span><span class="p">);</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">DLM_LOCK_RES_BLOCK_DIRTY</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="cm">/* now wait on any pending asts and the DIRTY state */</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">ast_wq</span><span class="p">,</span> <span class="o">!</span><span class="n">dlm_lockres_is_dirty</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">));</span>
	<span class="n">dlm_lockres_release_ast</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;about to wait on migration_wq, dirty=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_DIRTY</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span><span class="p">);</span>
	<span class="cm">/* if the extra ref we just put was the final one, this</span>
<span class="cm">	 * will pass thru immediately.  otherwise, we need to wait</span>
<span class="cm">	 * for the last ast to finish. */</span>
<span class="nl">again:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_event_interruptible_timeout</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">migration_wq</span><span class="p">,</span>
		   <span class="n">dlm_migration_can_proceed</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">target</span><span class="p">),</span>
		   <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;woken again: migrating? %s, dead? %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_MIGRATING</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span><span class="o">:</span><span class="s">&quot;no&quot;</span><span class="p">,</span>
		       <span class="n">test_bit</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">domain_map</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;no&quot;</span><span class="o">:</span><span class="s">&quot;yes&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;all is well: migrating? %s, dead? %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_MIGRATING</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span><span class="o">:</span><span class="s">&quot;no&quot;</span><span class="p">,</span>
		       <span class="n">test_bit</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">domain_map</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;no&quot;</span><span class="o">:</span><span class="s">&quot;yes&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_migration_can_proceed</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;trying again...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* did the target go down or die? */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">domain_map</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;aha. migration target %u just went down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">target</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EHOSTDOWN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * if target is down, we need to clear DLM_LOCK_RES_BLOCK_DIRTY for</span>
<span class="cm">	 * another try; otherwise, we are sure the MIGRATING state is there,</span>
<span class="cm">	 * drop the unneded state which blocked threads trying to DIRTY</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_BLOCK_DIRTY</span><span class="p">));</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_LOCK_RES_BLOCK_DIRTY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_MIGRATING</span><span class="p">));</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * at this point:</span>
<span class="cm">	 *</span>
<span class="cm">	 *   o the DLM_LOCK_RES_MIGRATING flag is set if target not down</span>
<span class="cm">	 *   o there are no pending asts on this lockres</span>
<span class="cm">	 *   o all processes trying to reserve an ast on this</span>
<span class="cm">	 *     lockres must wait for the MIGRATING flag to clear</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* last step in the migration process.</span>
<span class="cm"> * original master calls this to free all of the dlm_lock</span>
<span class="cm"> * structures that used to be for other nodes. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_remove_nonlocal_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">granted</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">bit</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">==</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">node</span> <span class="o">!=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;putting lock for node %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">node</span><span class="p">);</span>
				<span class="cm">/* be extra careful */</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ast_list</span><span class="p">));</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">bast_list</span><span class="p">));</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ast_pending</span><span class="p">);</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">bast_pending</span><span class="p">);</span>
				<span class="n">dlm_lockres_clear_refmap_bit</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span>
							     <span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">node</span><span class="p">);</span>
				<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
				<span class="n">dlm_lock_put</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
				<span class="cm">/* In a normal unlock, we would have added a</span>
<span class="cm">				 * DLM_UNLOCK_FREE_LOCK action. Force it. */</span>
				<span class="n">dlm_lock_put</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">queue</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bit</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">refmap</span><span class="p">,</span> <span class="n">O2NM_MAX_NODES</span><span class="p">,</span> <span class="n">bit</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&gt;=</span> <span class="n">O2NM_MAX_NODES</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* do not clear the local node reference, if there is a</span>
<span class="cm">		 * process holding this, let it drop the ref itself */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">!=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: node %u had a ref to this &quot;</span>
			     <span class="s">&quot;migrating lockres, clearing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">bit</span><span class="p">);</span>
			<span class="n">dlm_lockres_clear_refmap_bit</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">bit</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">bit</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Pick a node to migrate the lock resource to. This function selects a</span>
<span class="cm"> * potential target based first on the locks and then on refmap. It skips</span>
<span class="cm"> * nodes that are in the process of exiting the domain.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="nf">dlm_pick_migration_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">dlm_lockres_list</span> <span class="n">idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">granted</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">noderef</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">nodenum</span> <span class="o">=</span> <span class="n">O2NM_MAX_NODES</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="cm">/* Go through all the locks */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="n">DLM_GRANTED_LIST</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">DLM_BLOCKED_LIST</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">queue</span> <span class="o">=</span> <span class="n">dlm_list_idx_to_ptr</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">node</span> <span class="o">==</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">exit_domain_map</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">nodenum</span> <span class="o">=</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">node</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Go thru the refmap */</span>
	<span class="n">noderef</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">noderef</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">refmap</span><span class="p">,</span> <span class="n">O2NM_MAX_NODES</span><span class="p">,</span>
					<span class="n">noderef</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">noderef</span> <span class="o">&gt;=</span> <span class="n">O2NM_MAX_NODES</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">noderef</span> <span class="o">==</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">noderef</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">exit_domain_map</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">nodenum</span> <span class="o">=</span> <span class="n">noderef</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">bail:</span>
	<span class="k">return</span> <span class="n">nodenum</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* this is called by the new master once all lockres</span>
<span class="cm"> * data has been received */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_do_migrate_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
				  <span class="n">u8</span> <span class="n">master</span><span class="p">,</span> <span class="n">u8</span> <span class="n">new_master</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">dlm_node_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_migrate_request</span> <span class="n">migrate</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">skip</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nodenum</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">migrate</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">migrate</span><span class="p">));</span>
	<span class="n">migrate</span><span class="p">.</span><span class="n">namelen</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">migrate</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">migrate</span><span class="p">.</span><span class="n">namelen</span><span class="p">);</span>
	<span class="n">migrate</span><span class="p">.</span><span class="n">new_master</span> <span class="o">=</span> <span class="n">new_master</span><span class="p">;</span>
	<span class="n">migrate</span><span class="p">.</span><span class="n">master</span> <span class="o">=</span> <span class="n">master</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* send message to all nodes, except the master and myself */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">nodenum</span> <span class="o">=</span> <span class="n">dlm_node_iter_next</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nodenum</span> <span class="o">==</span> <span class="n">master</span> <span class="o">||</span>
		    <span class="n">nodenum</span> <span class="o">==</span> <span class="n">new_master</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* We could race exit domain. If exited, skip. */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="n">skip</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">nodenum</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">domain_map</span><span class="p">));</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">nodenum</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">node_map</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">o2net_send_message</span><span class="p">(</span><span class="n">DLM_MIGRATE_REQUEST_MSG</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">migrate</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">migrate</span><span class="p">),</span> <span class="n">nodenum</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s: res %.*s, Error %d send &quot;</span>
			     <span class="s">&quot;MIGRATE_REQUEST to node %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			     <span class="n">migrate</span><span class="p">.</span><span class="n">namelen</span><span class="p">,</span> <span class="n">migrate</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">nodenum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_is_host_down</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;unhandled error=%d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
				<span class="n">BUG</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">nodenum</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">node_map</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;migrate request (node %u) returned %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">nodenum</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">DLM_MIGRATE_RESPONSE_MASTERY_REF</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* during the migration request we short-circuited</span>
<span class="cm">			 * the mastery of the lockres.  make sure we have</span>
<span class="cm">			 * a mastery ref for nodenum */</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: need ref for node %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			     <span class="n">nodenum</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">dlm_lockres_set_refmap_bit</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">nodenum</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mlog_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;returning ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* if there is an existing mle for this lockres, we now know who the master is.</span>
<span class="cm"> * (the one who sent us *this* message) we can clear it up right away.</span>
<span class="cm"> * since the process that put the mle on the list still has a reference to it,</span>
<span class="cm"> * we can unhash it now, set the master and wake the process.  as a result,</span>
<span class="cm"> * we will have no mle in the list to start with.  now we can add an mle for</span>
<span class="cm"> * the migration and this should be the only one found for those scanning the</span>
<span class="cm"> * list.  */</span>
<span class="kt">int</span> <span class="nf">dlm_migrate_request_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_migrate_request</span> <span class="o">*</span><span class="n">migrate</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dlm_migrate_request</span> <span class="o">*</span><span class="p">)</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">oldmle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">hash</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_grab</span><span class="p">(</span><span class="n">dlm</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">name</span> <span class="o">=</span> <span class="n">migrate</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">namelen</span> <span class="o">=</span> <span class="n">migrate</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">;</span>
	<span class="n">hash</span> <span class="o">=</span> <span class="n">dlm_lockid_hash</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>

	<span class="cm">/* preallocate.. if this fails, abort */</span>
	<span class="n">mle</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">dlm_mle_cache</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mle</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check for pre-existing lock */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">__dlm_lookup_lockres</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_RECOVERING</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* if all is working ok, this can only mean that we got</span>
<span class="cm">		 	* a migrate request from a node that we now see as</span>
<span class="cm">		 	* dead.  what can we do here?  drop it to the floor? */</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;Got a migrate request, but the &quot;</span>
			     <span class="s">&quot;lockres is marked as recovering!&quot;</span><span class="p">);</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">dlm_mle_cache</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span> <span class="cm">/* need a better solution */</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">DLM_LOCK_RES_MIGRATING</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
	<span class="cm">/* ignore status.  only nonzero status would BUG. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_add_migration_mle</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">mle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmle</span><span class="p">,</span>
				    <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span>
				    <span class="n">migrate</span><span class="o">-&gt;</span><span class="n">new_master</span><span class="p">,</span>
				    <span class="n">migrate</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
<span class="nl">unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oldmle</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* master is known, detach if not already detached */</span>
		<span class="n">dlm_mle_detach_hb_events</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">oldmle</span><span class="p">);</span>
		<span class="n">dlm_put_mle</span><span class="p">(</span><span class="n">oldmle</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="n">dlm_lockres_put</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
<span class="nl">leave:</span>
	<span class="n">dlm_put</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* must be holding dlm-&gt;spinlock and dlm-&gt;master_lock</span>
<span class="cm"> * when adding a migration mle, we can clear any other mles</span>
<span class="cm"> * in the master list because we know with certainty that</span>
<span class="cm"> * the master is &quot;master&quot;.  so we remove any old mle from</span>
<span class="cm"> * the list after setting it&#39;s master field, and then add</span>
<span class="cm"> * the new migration mle.  this way we can hold with the rule</span>
<span class="cm"> * of having only one mle for a given lock name at all times. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_add_migration_mle</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">**</span><span class="n">oldmle</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">,</span>
				 <span class="n">u8</span> <span class="n">new_master</span><span class="p">,</span> <span class="n">u8</span> <span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">found</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="o">*</span><span class="n">oldmle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>

	<span class="cm">/* caller is responsible for any ref taken here on oldmle */</span>
	<span class="n">found</span> <span class="o">=</span> <span class="n">dlm_find_mle</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">oldmle</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">oldmle</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">DLM_MLE_MIGRATION</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">master</span> <span class="o">==</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* ah another process raced me to it */</span>
				<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;tried to migrate %.*s, but some &quot;</span>
				     <span class="s">&quot;process beat me to it</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">namelen</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* bad.  2 NODES are trying to migrate! */</span>
				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;migration error  mle: &quot;</span>
				     <span class="s">&quot;master=%u new_master=%u // request: &quot;</span>
				     <span class="s">&quot;master=%u new_master=%u // &quot;</span>
				     <span class="s">&quot;lockres=%.*s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">new_master</span><span class="p">,</span>
				     <span class="n">master</span><span class="p">,</span> <span class="n">new_master</span><span class="p">,</span>
				     <span class="n">namelen</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
				<span class="n">BUG</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* this is essentially what assert_master does */</span>
			<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">=</span> <span class="n">master</span><span class="p">;</span>
			<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">woken</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
			<span class="cm">/* remove it so that only one mle will be found */</span>
			<span class="n">__dlm_unlink_mle</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
			<span class="n">__dlm_mle_detach_hb_events</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">DLM_MIGRATE_RESPONSE_MASTERY_REF</span><span class="p">;</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: master=%u, newmaster=%u, &quot;</span>
			    <span class="s">&quot;telling master to get ref for cleared out mle &quot;</span>
			    <span class="s">&quot;during migration</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
			    <span class="n">master</span><span class="p">,</span> <span class="n">new_master</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* now add a migration mle to the tail of the list */</span>
	<span class="n">dlm_init_mle</span><span class="p">(</span><span class="n">mle</span><span class="p">,</span> <span class="n">DLM_MLE_MIGRATION</span><span class="p">,</span> <span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>
	<span class="n">mle</span><span class="o">-&gt;</span><span class="n">new_master</span> <span class="o">=</span> <span class="n">new_master</span><span class="p">;</span>
	<span class="cm">/* the new master will be sending an assert master for this.</span>
<span class="cm">	 * at that point we will get the refmap reference */</span>
	<span class="n">mle</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">=</span> <span class="n">master</span><span class="p">;</span>
	<span class="cm">/* do this for consistency with other mle types */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">new_master</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">maybe_map</span><span class="p">);</span>
	<span class="n">__dlm_insert_mle</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sets the owner of the lockres, associated to the mle, to UNKNOWN</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="nf">dlm_reset_mleres_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>

	<span class="cm">/* Find the lockres associated to the mle and set its owner to UNK */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">__dlm_lookup_lockres</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">mname</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">mnamelen</span><span class="p">,</span>
				   <span class="n">mle</span><span class="o">-&gt;</span><span class="n">mnamehash</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>

		<span class="cm">/* move lockres onto recovery list */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="n">dlm_set_lockres_owner</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">DLM_LOCK_RES_OWNER_UNKNOWN</span><span class="p">);</span>
		<span class="n">dlm_move_lockres_to_recovery_list</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="n">dlm_lockres_put</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>

		<span class="cm">/* about to get rid of mle, detach from heartbeat */</span>
		<span class="n">__dlm_mle_detach_hb_events</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>

		<span class="cm">/* dump the mle */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
		<span class="n">__dlm_put_mle</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_clean_migration_mle</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__dlm_mle_detach_hb_events</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">__dlm_unlink_mle</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">woken</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_clean_block_mle</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dead_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bit</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">DLM_MLE_BLOCK</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">bit</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">maybe_map</span><span class="p">,</span> <span class="n">O2NM_MAX_NODES</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">!=</span> <span class="n">dead_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;mle found, but dead node %u would not have been &quot;</span>
		     <span class="s">&quot;master</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Must drop the refcount by one since the assert_master will</span>
<span class="cm">		 * never arrive. This may result in the mle being unlinked and</span>
<span class="cm">		 * freed, but there may still be a process waiting in the</span>
<span class="cm">		 * dlmlock path which is fine. */</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node %u was expected master</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">woken</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>

		<span class="cm">/* Do not need events any longer, so detach from heartbeat */</span>
		<span class="n">__dlm_mle_detach_hb_events</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
		<span class="n">__dlm_put_mle</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_clean_master_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dead_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">bucket</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;dlm=%s, dead node=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>
<span class="nl">top:</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="cm">/* clean the master list */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DLM_HASH_BUCKETS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bucket</span> <span class="o">=</span> <span class="n">dlm_master_hash</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">hlist_for_each</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">bucket</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mle</span> <span class="o">=</span> <span class="n">hlist_entry</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_master_list_entry</span><span class="p">,</span>
					  <span class="n">master_hash_node</span><span class="p">);</span>

			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">DLM_MLE_BLOCK</span> <span class="o">&amp;&amp;</span>
			       <span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">DLM_MLE_MASTER</span> <span class="o">&amp;&amp;</span>
			       <span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">DLM_MLE_MIGRATION</span><span class="p">);</span>

			<span class="cm">/* MASTER mles are initiated locally. The waiting</span>
<span class="cm">			 * process will notice the node map change shortly.</span>
<span class="cm">			 * Let that happen as normal. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">DLM_MLE_MASTER</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* BLOCK mles are initiated by other nodes. Need to</span>
<span class="cm">			 * clean up if the dead node would have been the</span>
<span class="cm">			 * master. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">DLM_MLE_BLOCK</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dlm_clean_block_mle</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Everything else is a MIGRATION mle */</span>

			<span class="cm">/* The rule for MIGRATION mles is that the master</span>
<span class="cm">			 * becomes UNKNOWN if *either* the original or the new</span>
<span class="cm">			 * master dies. All UNKNOWN lockres&#39; are sent to</span>
<span class="cm">			 * whichever node becomes the recovery master. The new</span>
<span class="cm">			 * master is responsible for determining if there is</span>
<span class="cm">			 * still a master for this lockres, or if he needs to</span>
<span class="cm">			 * take over mastery. Either way, this node should</span>
<span class="cm">			 * expect another message to resolve this. */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">!=</span> <span class="n">dead_node</span> <span class="o">&amp;&amp;</span>
			    <span class="n">mle</span><span class="o">-&gt;</span><span class="n">new_master</span> <span class="o">!=</span> <span class="n">dead_node</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* If we have reached this point, this mle needs to be</span>
<span class="cm">			 * removed from the list and freed. */</span>
			<span class="n">dlm_clean_migration_mle</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>

			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: node %u died during migration from &quot;</span>
			     <span class="s">&quot;%u to %u!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">,</span> <span class="n">mle</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">,</span>
			     <span class="n">mle</span><span class="o">-&gt;</span><span class="n">new_master</span><span class="p">);</span>

			<span class="cm">/* If we find a lockres associated with the mle, we&#39;ve</span>
<span class="cm">			 * hit this rare case that messes up our lock ordering.</span>
<span class="cm">			 * If so, we need to drop the master lock so that we can</span>
<span class="cm">			 * take the lockres lock, meaning that we will have to</span>
<span class="cm">			 * restart from the head of list. */</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">dlm_reset_mleres_owner</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
				<span class="cm">/* restart */</span>
				<span class="k">goto</span> <span class="n">top</span><span class="p">;</span>

			<span class="cm">/* This may be the last reference */</span>
			<span class="n">__dlm_put_mle</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dlm_finish_migration</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
			 <span class="n">u8</span> <span class="n">old_master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_node_iter</span> <span class="n">iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">dlm_node_iter_init</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">domain_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">old_master</span><span class="p">,</span> <span class="n">iter</span><span class="p">.</span><span class="n">node_map</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span> <span class="n">iter</span><span class="p">.</span><span class="n">node_map</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="cm">/* ownership of the lockres is changing.  account for the</span>
<span class="cm">	 * mastery reference here since old_master will briefly have</span>
<span class="cm">	 * a reference after the migration completes */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">dlm_lockres_set_refmap_bit</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">old_master</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;now time to do a migrate request to other nodes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_do_migrate_request</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">old_master</span><span class="p">,</span>
				     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;doing assert master of %.*s to all except the original node</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="cm">/* this call now finishes out the nodemap</span>
<span class="cm">	 * even if one or more nodes die */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_do_assert_master</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">iter</span><span class="p">.</span><span class="n">node_map</span><span class="p">,</span>
				   <span class="n">DLM_ASSERT_MASTER_FINISH_MIGRATION</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* no longer need to retry.  all living nodes contacted. */</span>
		<span class="n">mlog_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">node_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">node_map</span><span class="p">));</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">old_master</span><span class="p">,</span> <span class="n">iter</span><span class="p">.</span><span class="n">node_map</span><span class="p">);</span>
	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;doing assert master of %.*s back to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">old_master</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_do_assert_master</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">iter</span><span class="p">.</span><span class="n">node_map</span><span class="p">,</span>
				   <span class="n">DLM_ASSERT_MASTER_FINISH_MIGRATION</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;assert master to original master failed &quot;</span>
		     <span class="s">&quot;with %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="cm">/* the only nonzero status here would be because of</span>
<span class="cm">		 * a dead original node.  we&#39;re done. */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* all done, set the owner, clear the flag */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">dlm_set_lockres_owner</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">);</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_LOCK_RES_MIGRATING</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="cm">/* re-dirty it on the new master */</span>
	<span class="n">dlm_kick_thread</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
<span class="nl">leave:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * LOCKRES AST REFCOUNT</span>
<span class="cm"> * this is integral to migration</span>
<span class="cm"> */</span>

<span class="cm">/* for future intent to call an ast, reserve one ahead of time.</span>
<span class="cm"> * this should be called only after waiting on the lockres</span>
<span class="cm"> * with dlm_wait_on_lockres, and while still holding the</span>
<span class="cm"> * spinlock after the call. */</span>
<span class="kt">void</span> <span class="nf">__dlm_lockres_reserve_ast</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_MIGRATING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__dlm_print_one_lock_resource</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_MIGRATING</span><span class="p">);</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">asts_reserved</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * used to drop the reserved ast, either because it went unused,</span>
<span class="cm"> * or because the ast/bast was actually called.</span>
<span class="cm"> *</span>
<span class="cm"> * also, if there is a pending migration on this lockres,</span>
<span class="cm"> * and this was the last pending ast on the lockres,</span>
<span class="cm"> * atomically set the MIGRATING flag before we drop the lock.</span>
<span class="cm"> * this is how we ensure that migration can proceed with no</span>
<span class="cm"> * asts in progress.  note that it is ok if the state of the</span>
<span class="cm"> * queues is such that a lock should be granted in the future</span>
<span class="cm"> * or that a bast should be fired, because the new master will</span>
<span class="cm"> * shuffle the lists on this lockres as soon as it is migrated.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dlm_lockres_release_ast</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">asts_reserved</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">migration_pending</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_MIGRATING</span><span class="p">);</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">migration_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">DLM_LOCK_RES_MIGRATING</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">migration_wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_force_free_mles</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">bucket</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We notified all other nodes that we are exiting the domain and</span>
<span class="cm">	 * marked the dlm state to DLM_CTXT_LEAVING. If any mles are still</span>
<span class="cm">	 * around we force free them and wake any processes that are waiting</span>
<span class="cm">	 * on the mles</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_state</span> <span class="o">!=</span> <span class="n">DLM_CTXT_LEAVING</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">find_next_bit</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">domain_map</span><span class="p">,</span> <span class="n">O2NM_MAX_NODES</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">O2NM_MAX_NODES</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DLM_HASH_BUCKETS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bucket</span> <span class="o">=</span> <span class="n">dlm_master_hash</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">hlist_for_each_safe</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">bucket</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mle</span> <span class="o">=</span> <span class="n">hlist_entry</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_master_list_entry</span><span class="p">,</span>
					  <span class="n">master_hash_node</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">DLM_MLE_BLOCK</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;bad mle: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
				<span class="n">dlm_print_one_mle</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">woken</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mle</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>

			<span class="n">__dlm_unlink_mle</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
			<span class="n">__dlm_mle_detach_hb_events</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mle</span><span class="p">);</span>
			<span class="n">__dlm_put_mle</span><span class="p">(</span><span class="n">mle</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
