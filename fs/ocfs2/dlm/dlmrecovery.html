<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ocfs2 › dlm › dlmrecovery.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>dlmrecovery.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* -*- mode: c; c-basic-offset: 8; -*-</span>
<span class="cm"> * vim: noexpandtab sw=8 ts=8 sts=0:</span>
<span class="cm"> *</span>
<span class="cm"> * dlmrecovery.c</span>
<span class="cm"> *</span>
<span class="cm"> * recovery stuff</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004 Oracle.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public</span>
<span class="cm"> * License as published by the Free Software Foundation; either</span>
<span class="cm"> * version 2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public</span>
<span class="cm"> * License along with this program; if not, write to the</span>
<span class="cm"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 021110-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>


<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/sysctl.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/inet.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>


<span class="cp">#include &quot;cluster/heartbeat.h&quot;</span>
<span class="cp">#include &quot;cluster/nodemanager.h&quot;</span>
<span class="cp">#include &quot;cluster/tcp.h&quot;</span>

<span class="cp">#include &quot;dlmapi.h&quot;</span>
<span class="cp">#include &quot;dlmcommon.h&quot;</span>
<span class="cp">#include &quot;dlmdomain.h&quot;</span>

<span class="cp">#define MLOG_MASK_PREFIX (ML_DLM|ML_DLM_RECOVERY)</span>
<span class="cp">#include &quot;cluster/masklog.h&quot;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">dlm_do_local_recovery_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dead_node</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">dlm_recovery_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_complete_recovery_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_launch_recovery_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_kick_recovery_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dlm_do_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">dlm_pick_recovery_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dlm_remaster_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dead_node</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dlm_init_recovery_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dead_node</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dlm_request_all_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				 <span class="n">u8</span> <span class="n">request_from</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dead_node</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dlm_destroy_recovery_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dead_node</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">dlm_num_locks_in_lockres</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dlm_init_migratable_lockres</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_migratable_lockres</span> <span class="o">*</span><span class="n">mres</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lockname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">total_locks</span><span class="p">,</span> <span class="n">u64</span> <span class="n">cookie</span><span class="p">,</span>
					<span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="n">u8</span> <span class="n">master</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dlm_send_mig_lockres_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dlm_migratable_lockres</span> <span class="o">*</span><span class="n">mres</span><span class="p">,</span>
				    <span class="n">u8</span> <span class="n">send_to</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">total_locks</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dlm_process_recovery_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dlm_migratable_lockres</span> <span class="o">*</span><span class="n">mres</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dlm_send_finalize_reco_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dlm_send_all_done_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				 <span class="n">u8</span> <span class="n">dead_node</span><span class="p">,</span> <span class="n">u8</span> <span class="n">send_to</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dlm_send_begin_reco_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dead_node</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dlm_move_reco_locks_to_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dead_node</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dlm_finish_local_lockres_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
					      <span class="n">u8</span> <span class="n">dead_node</span><span class="p">,</span> <span class="n">u8</span> <span class="n">new_master</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dlm_reco_ast</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">astdata</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dlm_reco_bast</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">astdata</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blocked_type</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dlm_reco_unlock_ast</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">astdata</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dlm_status</span> <span class="n">st</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dlm_request_all_locks_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_work_item</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span>
					 <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dlm_mig_lockres_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_work_item</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dlm_lockres_master_requery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
				      <span class="n">u8</span> <span class="o">*</span><span class="n">real_master</span><span class="p">);</span>

<span class="k">static</span> <span class="n">u64</span> <span class="n">dlm_get_next_mig_cookie</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">dlm_reco_state_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">dlm_mig_cookie_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u64</span> <span class="n">dlm_mig_cookie</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">dlm_get_next_mig_cookie</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">c</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm_mig_cookie_lock</span><span class="p">);</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">dlm_mig_cookie</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlm_mig_cookie</span> <span class="o">==</span> <span class="p">(</span><span class="o">~</span><span class="mi">0ULL</span><span class="p">))</span>
		<span class="n">dlm_mig_cookie</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">dlm_mig_cookie</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm_mig_cookie_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dlm_set_reco_dead_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
					  <span class="n">u8</span> <span class="n">dead_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span> <span class="o">!=</span> <span class="n">dead_node</span><span class="p">)</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: changing dead_node from %u to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>
	<span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span> <span class="o">=</span> <span class="n">dead_node</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dlm_set_reco_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				       <span class="n">u8</span> <span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: changing new_master from %u to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span><span class="p">,</span> <span class="n">master</span><span class="p">);</span>
	<span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span> <span class="o">=</span> <span class="n">master</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__dlm_reset_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">recovery_map</span><span class="p">);</span>
	<span class="n">dlm_set_reco_dead_node</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">O2NM_INVALID_NODE_NUM</span><span class="p">);</span>
	<span class="n">dlm_set_reco_master</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">O2NM_INVALID_NODE_NUM</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dlm_reset_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">__dlm_reset_recovery</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Worker function used during recovery. */</span>
<span class="kt">void</span> <span class="nf">dlm_dispatch_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_ctxt</span><span class="p">,</span> <span class="n">dispatched_work</span><span class="p">);</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">tmp_list</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dlm_work_item</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="n">dlm_workfunc_t</span> <span class="o">*</span><span class="n">workfunc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tot</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tot</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: work thread has %d work items</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">tot</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">workfunc</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">;</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

		<span class="cm">/* already have ref on dlm to avoid having</span>
<span class="cm">		 * it disappear.  just double-check. */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">dlm</span> <span class="o">!=</span> <span class="n">dlm</span><span class="p">);</span>

		<span class="cm">/* this is allowed to sleep and</span>
<span class="cm">		 * call network stuff */</span>
		<span class="n">workfunc</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>

		<span class="n">dlm_put</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * RECOVERY THREAD</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">dlm_kick_recovery_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* wake the recovery thread</span>
<span class="cm">	 * this will wake the reco thread in one of three places</span>
<span class="cm">	 * 1) sleeping with no recovery happening</span>
<span class="cm">	 * 2) sleeping with recovery mastered elsewhere</span>
<span class="cm">	 * 3) recovery mastered here, waiting on reco data */</span>

	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_reco_thread_wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Launch the recovery thread */</span>
<span class="kt">int</span> <span class="nf">dlm_launch_recovery_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;starting dlm recovery thread...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_reco_thread_task</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">dlm_recovery_thread</span><span class="p">,</span> <span class="n">dlm</span><span class="p">,</span>
						<span class="s">&quot;dlm_reco_thread&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_reco_thread_task</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mlog_errno</span><span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_reco_thread_task</span><span class="p">));</span>
		<span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_reco_thread_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_complete_recovery_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_reco_thread_task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;waiting for dlm recovery thread to exit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_reco_thread_task</span><span class="p">);</span>
		<span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_reco_thread_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>



<span class="cm">/*</span>
<span class="cm"> * this is lame, but here&#39;s how recovery works...</span>
<span class="cm"> * 1) all recovery threads cluster wide will work on recovering</span>
<span class="cm"> *    ONE node at a time</span>
<span class="cm"> * 2) negotiate who will take over all the locks for the dead node.</span>
<span class="cm"> *    thats right... ALL the locks.</span>
<span class="cm"> * 3) once a new master is chosen, everyone scans all locks</span>
<span class="cm"> *    and moves aside those mastered by the dead guy</span>
<span class="cm"> * 4) each of these locks should be locked until recovery is done</span>
<span class="cm"> * 5) the new master collects up all of secondary lock queue info</span>
<span class="cm"> *    one lock at a time, forcing each node to communicate back</span>
<span class="cm"> *    before continuing</span>
<span class="cm"> * 6) each secondary lock queue responds with the full known lock info</span>
<span class="cm"> * 7) once the new master has run all its locks, it sends a ALLDONE!</span>
<span class="cm"> *    message to everyone</span>
<span class="cm"> * 8) upon receiving this message, the secondary queue node unlocks</span>
<span class="cm"> *    and responds to the ALLDONE</span>
<span class="cm"> * 9) once the new master gets responses from everyone, he unlocks</span>
<span class="cm"> *    everything and recovery for this dead node is done</span>
<span class="cm"> *10) go back to 2) while there are still dead nodes</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_print_reco_node_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_reco_node_data</span> <span class="o">*</span><span class="n">ndata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>

	<span class="n">mlog</span><span class="p">(</span><span class="n">ML_NOTICE</span><span class="p">,</span> <span class="s">&quot;%s(%d): recovery info, state=%s, dead=%u, master=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_reco_thread_task</span><span class="p">),</span>
	     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_RECO_STATE_ACTIVE</span> <span class="o">?</span> <span class="s">&quot;ACTIVE&quot;</span> <span class="o">:</span> <span class="s">&quot;inactive&quot;</span><span class="p">,</span>
	     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ndata</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">node_data</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">st</span> <span class="o">=</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ndata</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_INIT</span>:
				<span class="n">st</span> <span class="o">=</span> <span class="s">&quot;init&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_REQUESTING</span>:
				<span class="n">st</span> <span class="o">=</span> <span class="s">&quot;requesting&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_DEAD</span>:
				<span class="n">st</span> <span class="o">=</span> <span class="s">&quot;dead&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_RECEIVING</span>:
				<span class="n">st</span> <span class="o">=</span> <span class="s">&quot;receiving&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_REQUESTED</span>:
				<span class="n">st</span> <span class="o">=</span> <span class="s">&quot;requested&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_DONE</span>:
				<span class="n">st</span> <span class="o">=</span> <span class="s">&quot;done&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_FINALIZE_SENT</span>:
				<span class="n">st</span> <span class="o">=</span> <span class="s">&quot;finalize-sent&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">st</span> <span class="o">=</span> <span class="s">&quot;bad&quot;</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_NOTICE</span><span class="p">,</span> <span class="s">&quot;%s: reco state, node %u, state=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ndata</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span> <span class="n">st</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">resources</span><span class="p">,</span> <span class="n">recovering</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_NOTICE</span><span class="p">,</span> <span class="s">&quot;%s: lockres %.*s on recovering list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define DLM_RECO_THREAD_TIMEOUT_MS (5 * 1000)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_recovery_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">DLM_RECO_THREAD_TIMEOUT_MS</span><span class="p">);</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;dlm thread running for %s...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlm_domain_fully_joined</span><span class="p">(</span><span class="n">dlm</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">dlm_do_recovery</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* do not sleep, recheck immediately. */</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">mlog_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">wait_event_interruptible_timeout</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_reco_thread_wq</span><span class="p">,</span>
						 <span class="n">kthread_should_stop</span><span class="p">(),</span>
						 <span class="n">timeout</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;quitting DLM recovery thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* returns true when the recovery master has contacted us */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_reco_master_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ready</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">ready</span> <span class="o">=</span> <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span> <span class="o">!=</span> <span class="n">O2NM_INVALID_NODE_NUM</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ready</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* returns true if node is no longer in the domain</span>
<span class="cm"> * could be dead or just not joined */</span>
<span class="kt">int</span> <span class="nf">dlm_is_node_dead</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dead</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">dead</span> <span class="o">=</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">domain_map</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dead</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* returns true if node is no longer in the domain</span>
<span class="cm"> * could be dead or just not joined */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_is_node_recovered</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">recovered</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">recovered</span> <span class="o">=</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">recovery_map</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">recovered</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">dlm_wait_for_node_death</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlm_is_node_dead</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;o2dlm: Waiting on the death of node %u in &quot;</span>
	       <span class="s">&quot;domain %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
		<span class="n">wait_event_timeout</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_reco_thread_wq</span><span class="p">,</span>
				   <span class="n">dlm_is_node_dead</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">node</span><span class="p">),</span>
				   <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">timeout</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_reco_thread_wq</span><span class="p">,</span>
			   <span class="n">dlm_is_node_dead</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">node</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_wait_for_node_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlm_is_node_recovered</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;o2dlm: Waiting on the recovery of node %u in &quot;</span>
	       <span class="s">&quot;domain %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
		<span class="n">wait_event_timeout</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_reco_thread_wq</span><span class="p">,</span>
				   <span class="n">dlm_is_node_recovered</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">node</span><span class="p">),</span>
				   <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">timeout</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_reco_thread_wq</span><span class="p">,</span>
			   <span class="n">dlm_is_node_recovered</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">node</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* callers of the top-level api calls (dlmlock/dlmunlock) should</span>
<span class="cm"> * block on the dlm-&gt;reco.event when recovery is in progress.</span>
<span class="cm"> * the dlm recovery thread will set this state when it begins</span>
<span class="cm"> * recovering a dead node (as the new master or not) and clear</span>
<span class="cm"> * the state and wake as soon as all affected lock resources have</span>
<span class="cm"> * been marked with the RECOVERY flag */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_in_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">in_recovery</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">in_recovery</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_RECO_STATE_ACTIVE</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">in_recovery</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">dlm_wait_for_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlm_in_recovery</span><span class="p">(</span><span class="n">dlm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: reco thread %d in recovery: &quot;</span>
		     <span class="s">&quot;state=%d, master=%u, dead=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_reco_thread_task</span><span class="p">),</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">state</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">event</span><span class="p">,</span> <span class="o">!</span><span class="n">dlm_in_recovery</span><span class="p">(</span><span class="n">dlm</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_begin_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_RECO_STATE_ACTIVE</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;o2dlm: Begin recovery on domain %s for node %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">);</span>
	<span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">state</span> <span class="o">|=</span> <span class="n">DLM_RECO_STATE_ACTIVE</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_end_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_RECO_STATE_ACTIVE</span><span class="p">));</span>
	<span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_RECO_STATE_ACTIVE</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;o2dlm: End recovery on domain %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_print_recovery_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;o2dlm: Node %u (%s) is the Recovery Master for the &quot;</span>
	       <span class="s">&quot;dead node %u in domain %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span> <span class="o">==</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span> <span class="o">?</span> <span class="s">&quot;me&quot;</span> <span class="o">:</span> <span class="s">&quot;he&quot;</span><span class="p">),</span>
	       <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_do_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="cm">/* check to see if the new master has died */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span> <span class="o">!=</span> <span class="n">O2NM_INVALID_NODE_NUM</span> <span class="o">&amp;&amp;</span>
	    <span class="n">test_bit</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">recovery_map</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;new master %u died while recovering %u!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">);</span>
		<span class="cm">/* unset the new_master, leave dead_node */</span>
		<span class="n">dlm_set_reco_master</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">O2NM_INVALID_NODE_NUM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* select a target to recover */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span> <span class="o">==</span> <span class="n">O2NM_INVALID_NODE_NUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">bit</span><span class="p">;</span>

		<span class="n">bit</span> <span class="o">=</span> <span class="n">find_next_bit</span> <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">recovery_map</span><span class="p">,</span> <span class="n">O2NM_MAX_NODES</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&gt;=</span> <span class="n">O2NM_MAX_NODES</span> <span class="o">||</span> <span class="n">bit</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dlm_set_reco_dead_node</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">O2NM_INVALID_NODE_NUM</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dlm_set_reco_dead_node</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">bit</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">recovery_map</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* BUG? */</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;dead_node %u no longer in recovery map!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">);</span>
		<span class="n">dlm_set_reco_dead_node</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">O2NM_INVALID_NODE_NUM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span> <span class="o">==</span> <span class="n">O2NM_INVALID_NODE_NUM</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>mlog(0, "nothing to recover!  sleeping now!\n");</p></td><td class="code"><div class="highlight"><pre>		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="cm">/* return to main thread loop and sleep. */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(%d):recovery thread found node %u in the recovery map!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_reco_thread_task</span><span class="p">),</span>
	     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="cm">/* take write barrier */</span>
	<span class="cm">/* (stops the list reshuffling thread, proxy ast handling) */</span>
	<span class="n">dlm_begin_recovery</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span> <span class="o">==</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">master_here</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span> <span class="o">==</span> <span class="n">O2NM_INVALID_NODE_NUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* choose a new master, returns 0 if this node</span>
<span class="cm">		 * is the master, -EEXIST if it&#39;s another node.</span>
<span class="cm">		 * this does not return until a new master is chosen</span>
<span class="cm">		 * or recovery completes entirely. */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_pick_recovery_master</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* already notified everyone.  go. */</span>
			<span class="k">goto</span> <span class="n">master_here</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;another node will master this recovery session.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dlm_print_recovery_master</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>

	<span class="cm">/* it is safe to start everything back up here</span>
<span class="cm">	 * because all of the dead node&#39;s lock resources</span>
<span class="cm">	 * have been marked as in-recovery */</span>
	<span class="n">dlm_end_recovery</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>

	<span class="cm">/* sleep out in main dlm_recovery_thread loop. */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">master_here:</span>
	<span class="n">dlm_print_recovery_master</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">dlm_remaster_locks</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* we should never hit this anymore */</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s: Error %d remastering locks for node %u, &quot;</span>
		     <span class="s">&quot;retrying.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">);</span>
		<span class="cm">/* yield a bit to allow any final network messages</span>
<span class="cm">		 * to get handled on remaining nodes */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* success!  see if any other nodes need recovery */</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;DONE mastering recovery of %s:%u here(this=%u)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">);</span>
		<span class="n">dlm_reset_recovery</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dlm_end_recovery</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>

	<span class="cm">/* continue and look for another dead node */</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_remaster_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dead_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_reco_node_data</span> <span class="o">*</span><span class="n">ndata</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">all_nodes_done</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">destroy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pass</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* we have become recovery master.  there is no escaping</span>
<span class="cm">		 * this, so just keep trying until we get it. */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">dlm_init_recovery_area</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s: failed to alloc recovery area, &quot;</span>
			     <span class="s">&quot;retrying</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* safe to access the node data list without a lock, since this</span>
<span class="cm">	 * process is the only one to change the list */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ndata</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">node_data</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ndata</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">DLM_RECO_NODE_DATA_INIT</span><span class="p">);</span>
		<span class="n">ndata</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DLM_RECO_NODE_DATA_REQUESTING</span><span class="p">;</span>

		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: Requesting lock info from node %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		     <span class="n">ndata</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ndata</span><span class="o">-&gt;</span><span class="n">node_num</span> <span class="o">==</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ndata</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DLM_RECO_NODE_DATA_DONE</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">dlm_request_all_locks</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">ndata</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span>
						       <span class="n">dead_node</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mlog_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dlm_is_host_down</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* node died, ignore it for recovery */</span>
					<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">ndata</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DLM_RECO_NODE_DATA_DEAD</span><span class="p">;</span>
					<span class="cm">/* wait for the domain map to catch up</span>
<span class="cm">					 * with the network state. */</span>
					<span class="n">wait_event_timeout</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_reco_thread_wq</span><span class="p">,</span>
							   <span class="n">dlm_is_node_dead</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span>
								<span class="n">ndata</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">),</span>
							   <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>
					<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;waited 1 sec for %u, &quot;</span>
					     <span class="s">&quot;dead? %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ndata</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span>
					     <span class="n">dlm_is_node_dead</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">ndata</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span> <span class="o">?</span>
					     <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* -ENOMEM on the other node */</span>
					<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: node %u returned &quot;</span>
					     <span class="s">&quot;%d during recovery, retrying &quot;</span>
					     <span class="s">&quot;after a short wait</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ndata</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span>
					     <span class="n">status</span><span class="p">);</span>
					<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm_reco_state_lock</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ndata</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_INIT</span>:
			<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_FINALIZE_SENT</span>:
			<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_REQUESTED</span>:
				<span class="n">BUG</span><span class="p">();</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_DEAD</span>:
				<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node %u died after requesting &quot;</span>
				     <span class="s">&quot;recovery info for node %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">ndata</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>
				<span class="cm">/* fine.  don&#39;t need this node&#39;s info.</span>
<span class="cm">				 * continue without it. */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_REQUESTING</span>:
				<span class="n">ndata</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DLM_RECO_NODE_DATA_REQUESTED</span><span class="p">;</span>
				<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;now receiving recovery data from &quot;</span>
				     <span class="s">&quot;node %u for dead node %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">ndata</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_RECEIVING</span>:
				<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;already receiving recovery data from &quot;</span>
				     <span class="s">&quot;node %u for dead node %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">ndata</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_DONE</span>:
				<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;already DONE receiving recovery data &quot;</span>
				     <span class="s">&quot;from node %u for dead node %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">ndata</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm_reco_state_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: Done requesting all lock info</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* nodes should be sending reco data now</span>
<span class="cm">	 * just need to wait */</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* check all the nodes now to see if we are</span>
<span class="cm">		 * done, or if anyone died */</span>
		<span class="n">all_nodes_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm_reco_state_lock</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ndata</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">node_data</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;checking recovery state of node %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">ndata</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">);</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">ndata</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_INIT</span>:
				<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_REQUESTING</span>:
					<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;bad ndata state for &quot;</span>
					     <span class="s">&quot;node %u: state=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">ndata</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span> <span class="n">ndata</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
					<span class="n">BUG</span><span class="p">();</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_DEAD</span>:
					<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node %u died after &quot;</span>
					     <span class="s">&quot;requesting recovery info for &quot;</span>
					     <span class="s">&quot;node %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ndata</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span>
					     <span class="n">dead_node</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_RECEIVING</span>:
				<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_REQUESTED</span>:
					<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: node %u still in state %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ndata</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span>
					     <span class="n">ndata</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">==</span><span class="n">DLM_RECO_NODE_DATA_RECEIVING</span> <span class="o">?</span>
					     <span class="s">&quot;receiving&quot;</span> <span class="o">:</span> <span class="s">&quot;requested&quot;</span><span class="p">);</span>
					<span class="n">all_nodes_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_DONE</span>:
					<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: node %u state is done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ndata</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_FINALIZE_SENT</span>:
					<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: node %u state is finalize</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ndata</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm_reco_state_lock</span><span class="p">);</span>

		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;pass #%d, all_nodes_done?: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">++</span><span class="n">pass</span><span class="p">,</span>
		     <span class="n">all_nodes_done</span><span class="o">?</span><span class="s">&quot;yes&quot;</span><span class="o">:</span><span class="s">&quot;no&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">all_nodes_done</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

			<span class="cm">/* all nodes are now in DLM_RECO_NODE_DATA_DONE state</span>
<span class="cm">	 		 * just send a finalize message to everyone and</span>
<span class="cm">	 		 * clean up */</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;all nodes are done! send finalize</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_send_finalize_reco_message</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">mlog_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">dlm_finish_local_lockres_recovery</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">,</span>
							  <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;should be done with recovery!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;finishing recovery of %s at %lu, &quot;</span>
			     <span class="s">&quot;dead=%u, this=%u, new=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			     <span class="n">jiffies</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">,</span>
			     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span><span class="p">);</span>
			<span class="n">destroy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* rescan everything marked dirty along the way */</span>
			<span class="n">dlm_kick_thread</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* wait to be signalled, with periodic timeout</span>
<span class="cm">		 * to check for node death */</span>
		<span class="n">wait_event_interruptible_timeout</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_reco_thread_wq</span><span class="p">,</span>
					 <span class="n">kthread_should_stop</span><span class="p">(),</span>
					 <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">DLM_RECO_THREAD_TIMEOUT_MS</span><span class="p">));</span>

	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">destroy</span><span class="p">)</span>
		<span class="n">dlm_destroy_recovery_area</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_init_recovery_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dead_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">num</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_reco_node_data</span> <span class="o">*</span><span class="n">ndata</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">node_map</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">domain_map</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">domain_map</span><span class="p">));</span>
	<span class="cm">/* nodes can only be removed (by dying) after dropping</span>
<span class="cm">	 * this lock, and death will be trapped later, so this should do */</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">num</span> <span class="o">=</span> <span class="n">find_next_bit</span> <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">node_map</span><span class="p">,</span> <span class="n">O2NM_MAX_NODES</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;=</span> <span class="n">O2NM_MAX_NODES</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="n">dead_node</span><span class="p">);</span>

		<span class="n">ndata</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ndata</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndata</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dlm_destroy_recovery_area</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ndata</span><span class="o">-&gt;</span><span class="n">node_num</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
		<span class="n">ndata</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DLM_RECO_NODE_DATA_INIT</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm_reco_state_lock</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndata</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">node_data</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm_reco_state_lock</span><span class="p">);</span>
		<span class="n">num</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_destroy_recovery_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dead_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_reco_node_data</span> <span class="o">*</span><span class="n">ndata</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">tmplist</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm_reco_state_lock</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">node_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmplist</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm_reco_state_lock</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ndata</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmplist</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndata</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ndata</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_request_all_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">request_from</span><span class="p">,</span>
				 <span class="n">u8</span> <span class="n">dead_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lock_request</span> <span class="n">lr</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">dlm_status</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>


	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;dlm_request_all_locks: dead node is %u, sending request &quot;</span>
		  <span class="s">&quot;to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">,</span> <span class="n">request_from</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lr</span><span class="p">));</span>
	<span class="n">lr</span><span class="p">.</span><span class="n">node_idx</span> <span class="o">=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">;</span>
	<span class="n">lr</span><span class="p">.</span><span class="n">dead_node</span> <span class="o">=</span> <span class="n">dead_node</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>send message</p></td><td class="code"><div class="highlight"><pre>	<span class="n">ret</span> <span class="o">=</span> <span class="n">DLM_NOLOCKMGR</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">o2net_send_message</span><span class="p">(</span><span class="n">DLM_LOCK_REQUEST_MSG</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">lr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lr</span><span class="p">),</span> <span class="n">request_from</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* negative status is handled by caller */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s: Error %d send LOCK_REQUEST to node %u &quot;</span>
		     <span class="s">&quot;to recover dead node %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span>
		     <span class="n">request_from</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>return from here, then
sleep until all received or error</p></td><td class="code"><div class="highlight"><pre>	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dlm_request_all_locks_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock_request</span> <span class="o">*</span><span class="n">lr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_request</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_work_item</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_grab</span><span class="p">(</span><span class="n">dlm</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lr</span><span class="o">-&gt;</span><span class="n">dead_node</span> <span class="o">!=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s: node %u sent dead_node=%u, but local &quot;</span>
		     <span class="s">&quot;dead_node is %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">lr</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span>
		     <span class="n">lr</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">);</span>
		<span class="n">dlm_print_reco_node_status</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
		<span class="cm">/* this is a hack */</span>
		<span class="n">dlm_put</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">lr</span><span class="o">-&gt;</span><span class="n">dead_node</span> <span class="o">!=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">);</span>

	<span class="n">item</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">item</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dlm_put</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* this will get freed by dlm_request_all_locks_worker */</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
		<span class="n">dlm_put</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* queue up work for dlm_request_all_locks_worker */</span>
	<span class="n">dlm_grab</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>  <span class="cm">/* get an extra ref for the work item */</span>
	<span class="n">dlm_init_work_item</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">dlm_request_all_locks_worker</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ral</span><span class="p">.</span><span class="n">reco_master</span> <span class="o">=</span> <span class="n">lr</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">;</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ral</span><span class="p">.</span><span class="n">dead_node</span> <span class="o">=</span> <span class="n">lr</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_worker</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dispatched_work</span><span class="p">);</span>

	<span class="n">dlm_put</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_request_all_locks_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_work_item</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_migratable_lockres</span> <span class="o">*</span><span class="n">mres</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">resources</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dead_node</span><span class="p">,</span> <span class="n">reco_master</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">skip_all_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dlm</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">dlm</span><span class="p">;</span>
	<span class="n">dead_node</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ral</span><span class="p">.</span><span class="n">dead_node</span><span class="p">;</span>
	<span class="n">reco_master</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ral</span><span class="p">.</span><span class="n">reco_master</span><span class="p">;</span>
	<span class="n">mres</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dlm_migratable_lockres</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: recovery worker started, dead=%u, master=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">,</span> <span class="n">reco_master</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dead_node</span> <span class="o">!=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span> <span class="o">||</span>
	    <span class="n">reco_master</span> <span class="o">!=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* worker could have been created before the recovery master</span>
<span class="cm">		 * died.  if so, do not continue, but do not error. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span> <span class="o">==</span> <span class="n">O2NM_INVALID_NODE_NUM</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_NOTICE</span><span class="p">,</span> <span class="s">&quot;%s: will not send recovery state, &quot;</span>
			     <span class="s">&quot;recovery master %u died, thread=(dead=%u,mas=%u)&quot;</span>
			     <span class="s">&quot; current=(dead=%u,mas=%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			     <span class="n">reco_master</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">,</span> <span class="n">reco_master</span><span class="p">,</span>
			     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_NOTICE</span><span class="p">,</span> <span class="s">&quot;%s: reco state invalid: reco(dead=%u, &quot;</span>
			     <span class="s">&quot;master=%u), request(dead=%u, master=%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">,</span>
			     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">,</span> <span class="n">reco_master</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* lock resources should have already been moved to the</span>
<span class="cm"> 	 * dlm-&gt;reco.resources list.  now move items from that list</span>
<span class="cm"> 	 * to a temp list if the dead owner matches.  note that the</span>
<span class="cm">	 * whole cluster recovers only one node at a time, so we</span>
<span class="cm">	 * can safely move UNKNOWN lock resources for each recovery</span>
<span class="cm">	 * session. */</span>
	<span class="n">dlm_move_reco_locks_to_list</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">resources</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>

	<span class="cm">/* now we can begin blasting lockreses without the dlm lock */</span>

	<span class="cm">/* any errors returned will be due to the new_master dying,</span>
<span class="cm">	 * the dlm_reco_thread should detect this */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">resources</span><span class="p">,</span> <span class="n">recovering</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_send_one_lockres</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">mres</span><span class="p">,</span> <span class="n">reco_master</span><span class="p">,</span>
				   	<span class="n">DLM_MRES_RECOVERY</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s: node %u went down while sending &quot;</span>
			     <span class="s">&quot;recovery state for dead node %u, ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			     <span class="n">reco_master</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="n">skip_all_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* move the resources back to the list */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resources</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">resources</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skip_all_done</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_send_all_done_msg</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">,</span> <span class="n">reco_master</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s: node %u went down while sending &quot;</span>
			     <span class="s">&quot;recovery all-done for dead node %u, ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">reco_master</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">leave:</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_send_all_done_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dead_node</span><span class="p">,</span> <span class="n">u8</span> <span class="n">send_to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">tmpret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_reco_data_done</span> <span class="n">done_msg</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done_msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">done_msg</span><span class="p">));</span>
	<span class="n">done_msg</span><span class="p">.</span><span class="n">node_idx</span> <span class="o">=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">;</span>
	<span class="n">done_msg</span><span class="p">.</span><span class="n">dead_node</span> <span class="o">=</span> <span class="n">dead_node</span><span class="p">;</span>
	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;sending DATA DONE message to %u, &quot;</span>
	     <span class="s">&quot;my node=%u, dead node=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">send_to</span><span class="p">,</span> <span class="n">done_msg</span><span class="p">.</span><span class="n">node_idx</span><span class="p">,</span>
	     <span class="n">done_msg</span><span class="p">.</span><span class="n">dead_node</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">o2net_send_message</span><span class="p">(</span><span class="n">DLM_RECO_DATA_DONE_MSG</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">done_msg</span><span class="p">,</span>
				 <span class="k">sizeof</span><span class="p">(</span><span class="n">done_msg</span><span class="p">),</span> <span class="n">send_to</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmpret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s: Error %d send RECO_DATA_DONE to node %u &quot;</span>
		     <span class="s">&quot;to recover dead node %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">send_to</span><span class="p">,</span>
		     <span class="n">dead_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_is_host_down</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">tmpret</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">dlm_reco_data_done_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_reco_data_done</span> <span class="o">*</span><span class="n">done</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dlm_reco_data_done</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_reco_node_data</span> <span class="o">*</span><span class="n">ndata</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_grab</span><span class="p">(</span><span class="n">dlm</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;got DATA DONE: dead_node=%u, reco.dead_node=%u, &quot;</span>
	     <span class="s">&quot;node_idx=%u, this node=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">done</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">,</span>
	     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">done</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">);</span>

	<span class="n">mlog_bug_on_msg</span><span class="p">((</span><span class="n">done</span><span class="o">-&gt;</span><span class="n">dead_node</span> <span class="o">!=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">),</span>
			<span class="s">&quot;Got DATA DONE: dead_node=%u, reco.dead_node=%u, &quot;</span>
			<span class="s">&quot;node_idx=%u, this node=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">done</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">,</span>
			<span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">done</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm_reco_state_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ndata</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">node_data</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ndata</span><span class="o">-&gt;</span><span class="n">node_num</span> <span class="o">!=</span> <span class="n">done</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">ndata</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* should have moved beyond INIT but not to FINALIZE yet */</span>
			<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_INIT</span>:
			<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_DEAD</span>:
			<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_FINALIZE_SENT</span>:
				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;bad ndata state for node %u:&quot;</span>
				     <span class="s">&quot; state=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ndata</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span>
				     <span class="n">ndata</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
				<span class="n">BUG</span><span class="p">();</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* these states are possible at this point, anywhere along</span>
<span class="cm">			 * the line of recovery */</span>
			<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_DONE</span>:
			<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_RECEIVING</span>:
			<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_REQUESTED</span>:
			<span class="k">case</span> <span class="n">DLM_RECO_NODE_DATA_REQUESTING</span>:
				<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node %u is DONE sending &quot;</span>
					  <span class="s">&quot;recovery data!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">ndata</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">);</span>

				<span class="n">ndata</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">DLM_RECO_NODE_DATA_DONE</span><span class="p">;</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm_reco_state_lock</span><span class="p">);</span>

	<span class="cm">/* wake the recovery thread, some node is done */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">dlm_kick_recovery_thread</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;failed to find recovery node data for node &quot;</span>
		     <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">done</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">);</span>
	<span class="n">dlm_put</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;leaving reco data done handler, ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_move_reco_locks_to_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
				       	<span class="n">u8</span> <span class="n">dead_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">resources</span><span class="p">,</span> <span class="n">recovering</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* always prune any $RECOVERY entries for dead nodes,</span>
<span class="cm">		 * otherwise hangs can occur during later recovery */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlm_is_recovery_lock</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
					 <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">granted</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">node</span> <span class="o">==</span> <span class="n">dead_node</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;AHA! there was &quot;</span>
					     <span class="s">&quot;a $RECOVERY lock for dead &quot;</span>
					     <span class="s">&quot;node %u (%s)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">dead_node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
					<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
					<span class="n">dlm_lock_put</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">==</span> <span class="n">dead_node</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;found lockres owned by dead node while &quot;</span>
				  <span class="s">&quot;doing recovery for node %u. sending it.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">dead_node</span><span class="p">);</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">recovering</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">==</span> <span class="n">DLM_LOCK_RES_OWNER_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;found UNKNOWN owner while doing recovery &quot;</span>
				  <span class="s">&quot;for node %u. sending it.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">recovering</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dlm_num_locks_in_lockres</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">total_locks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">granted</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span>
			<span class="n">total_locks</span><span class="o">++</span><span class="p">;</span>
		<span class="n">queue</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">total_locks</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_send_mig_lockres_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">dlm_migratable_lockres</span> <span class="o">*</span><span class="n">mres</span><span class="p">,</span>
				      <span class="n">u8</span> <span class="n">send_to</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">total_locks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">mig_cookie</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">mig_cookie</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">mres_total_locks</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">total_locks</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">sz</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">orig_flags</span> <span class="o">=</span> <span class="n">mres</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
	   <span class="n">orig_master</span> <span class="o">=</span> <span class="n">mres</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">num_locks</span> <span class="o">&gt;</span> <span class="n">DLM_MAX_MIGRATABLE_LOCKS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">num_locks</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_migratable_lockres</span><span class="p">)</span> <span class="o">+</span>
		<span class="p">(</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">num_locks</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_migratable_lock</span><span class="p">));</span>

	<span class="cm">/* add an all-done flag if we reached the last lock */</span>
	<span class="n">orig_flags</span> <span class="o">=</span> <span class="n">mres</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">total_locks</span> <span class="o">&gt;</span> <span class="n">mres_total_locks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">total_locks</span> <span class="o">==</span> <span class="n">mres_total_locks</span><span class="p">)</span>
		<span class="n">mres</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DLM_MRES_ALL_DONE</span><span class="p">;</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: sending mig lockres (%s) to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
	     <span class="n">orig_flags</span> <span class="o">&amp;</span> <span class="n">DLM_MRES_MIGRATION</span> <span class="o">?</span> <span class="s">&quot;migration&quot;</span> <span class="o">:</span> <span class="s">&quot;recovery&quot;</span><span class="p">,</span>
	     <span class="n">send_to</span><span class="p">);</span>

	<span class="cm">/* send it */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">o2net_send_message</span><span class="p">(</span><span class="n">DLM_MIG_LOCKRES_MSG</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">mres</span><span class="p">,</span>
				 <span class="n">sz</span><span class="p">,</span> <span class="n">send_to</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* XXX: negative status is not handled.</span>
<span class="cm">		 * this will end up killing this node. */</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s: res %.*s, Error %d send MIG_LOCKRES to &quot;</span>
		     <span class="s">&quot;node %u (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">mres</span><span class="o">-&gt;</span><span class="n">lockname_len</span><span class="p">,</span>
		     <span class="n">mres</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">send_to</span><span class="p">,</span>
		     <span class="p">(</span><span class="n">orig_flags</span> <span class="o">&amp;</span> <span class="n">DLM_MRES_MIGRATION</span> <span class="o">?</span>
		      <span class="s">&quot;migration&quot;</span> <span class="o">:</span> <span class="s">&quot;recovery&quot;</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* might get an -ENOMEM back here */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;node %u told me to kill &quot;</span>
				     <span class="s">&quot;myself!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">send_to</span><span class="p">);</span>
				<span class="n">BUG</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* zero and reinit the message buffer */</span>
	<span class="n">dlm_init_migratable_lockres</span><span class="p">(</span><span class="n">mres</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
				    <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">mres_total_locks</span><span class="p">,</span>
				    <span class="n">mig_cookie</span><span class="p">,</span> <span class="n">orig_flags</span><span class="p">,</span> <span class="n">orig_master</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_init_migratable_lockres</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_migratable_lockres</span> <span class="o">*</span><span class="n">mres</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lockname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">total_locks</span><span class="p">,</span> <span class="n">u64</span> <span class="n">cookie</span><span class="p">,</span>
					<span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="n">u8</span> <span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* mres here is one full page */</span>
	<span class="n">clear_page</span><span class="p">(</span><span class="n">mres</span><span class="p">);</span>
	<span class="n">mres</span><span class="o">-&gt;</span><span class="n">lockname_len</span> <span class="o">=</span> <span class="n">namelen</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">,</span> <span class="n">lockname</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>
	<span class="n">mres</span><span class="o">-&gt;</span><span class="n">num_locks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mres</span><span class="o">-&gt;</span><span class="n">total_locks</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">total_locks</span><span class="p">);</span>
	<span class="n">mres</span><span class="o">-&gt;</span><span class="n">mig_cookie</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">cookie</span><span class="p">);</span>
	<span class="n">mres</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">mres</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">=</span> <span class="n">master</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_prepare_lvb_for_migration</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">dlm_migratable_lockres</span> <span class="o">*</span><span class="n">mres</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">lksb</span><span class="p">)</span>
	       <span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Ignore lvb in all locks in the blocked list */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">queue</span> <span class="o">==</span> <span class="n">DLM_BLOCKED_LIST</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Only consider lvbs in locks with granted EX or PR lock levels */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">LKM_EXMODE</span> <span class="o">&amp;&amp;</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">LKM_PRMODE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dlm_lvb_is_empty</span><span class="p">(</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">lvb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">lvb</span><span class="p">,</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">lksb</span><span class="o">-&gt;</span><span class="n">lvb</span><span class="p">,</span> <span class="n">DLM_LVB_LEN</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Ensure the lvb copied for migration matches in other valid locks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">lvb</span><span class="p">,</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">lksb</span><span class="o">-&gt;</span><span class="n">lvb</span><span class="p">,</span> <span class="n">DLM_LVB_LEN</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;Mismatched lvb in lock cookie=%u:%llu, name=%.*s, &quot;</span>
	     <span class="s">&quot;node=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">dlm_get_lock_cookie_node</span><span class="p">(</span><span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">cookie</span><span class="p">)),</span>
	     <span class="n">dlm_get_lock_cookie_seq</span><span class="p">(</span><span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">cookie</span><span class="p">)),</span>
	     <span class="n">lock</span><span class="o">-&gt;</span><span class="n">lockres</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">lockres</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
	     <span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">node</span><span class="p">);</span>
	<span class="n">dlm_print_one_lock_resource</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">lockres</span><span class="p">);</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* returns 1 if this lock fills the network structure,</span>
<span class="cm"> * 0 otherwise */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_add_lock_to_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dlm_migratable_lockres</span> <span class="o">*</span><span class="n">mres</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_migratable_lock</span> <span class="o">*</span><span class="n">ml</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lock_num</span> <span class="o">=</span> <span class="n">mres</span><span class="o">-&gt;</span><span class="n">num_locks</span><span class="p">;</span>

	<span class="n">ml</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">[</span><span class="n">lock_num</span><span class="p">]);</span>
	<span class="n">ml</span><span class="o">-&gt;</span><span class="n">cookie</span> <span class="o">=</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">cookie</span><span class="p">;</span>
	<span class="n">ml</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">type</span><span class="p">;</span>
	<span class="n">ml</span><span class="o">-&gt;</span><span class="n">convert_type</span> <span class="o">=</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">convert_type</span><span class="p">;</span>
	<span class="n">ml</span><span class="o">-&gt;</span><span class="n">highest_blocked</span> <span class="o">=</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">highest_blocked</span><span class="p">;</span>
	<span class="n">ml</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">=</span> <span class="n">queue</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">lksb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ml</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">lksb</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
		<span class="n">dlm_prepare_lvb_for_migration</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">mres</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ml</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">node</span><span class="p">;</span>
	<span class="n">mres</span><span class="o">-&gt;</span><span class="n">num_locks</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/* we reached the max, send this network message */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">num_locks</span> <span class="o">==</span> <span class="n">DLM_MAX_MIGRATABLE_LOCKS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_add_dummy_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dlm_migratable_lockres</span> <span class="o">*</span><span class="n">mres</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lock</span> <span class="n">dummy</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dummy</span><span class="p">));</span>
	<span class="n">dummy</span><span class="p">.</span><span class="n">ml</span><span class="p">.</span><span class="n">cookie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dummy</span><span class="p">.</span><span class="n">ml</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">LKM_IVMODE</span><span class="p">;</span>
	<span class="n">dummy</span><span class="p">.</span><span class="n">ml</span><span class="p">.</span><span class="n">convert_type</span> <span class="o">=</span> <span class="n">LKM_IVMODE</span><span class="p">;</span>
	<span class="n">dummy</span><span class="p">.</span><span class="n">ml</span><span class="p">.</span><span class="n">highest_blocked</span> <span class="o">=</span> <span class="n">LKM_IVMODE</span><span class="p">;</span>
	<span class="n">dummy</span><span class="p">.</span><span class="n">lksb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dummy</span><span class="p">.</span><span class="n">ml</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">;</span>
	<span class="n">dlm_add_lock_to_array</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span> <span class="n">mres</span><span class="p">,</span> <span class="n">DLM_BLOCKED_LIST</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dlm_is_dummy_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dlm_migratable_lock</span> <span class="o">*</span><span class="n">ml</span><span class="p">,</span>
				    <span class="n">u8</span> <span class="o">*</span><span class="n">nodenum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ml</span><span class="o">-&gt;</span><span class="n">cookie</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ml</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">LKM_IVMODE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ml</span><span class="o">-&gt;</span><span class="n">convert_type</span> <span class="o">==</span> <span class="n">LKM_IVMODE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ml</span><span class="o">-&gt;</span><span class="n">highest_blocked</span> <span class="o">==</span> <span class="n">LKM_IVMODE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ml</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">==</span> <span class="n">DLM_BLOCKED_LIST</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">nodenum</span> <span class="o">=</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dlm_send_one_lockres</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">dlm_migratable_lockres</span> <span class="o">*</span><span class="n">mres</span><span class="p">,</span>
			 <span class="n">u8</span> <span class="n">send_to</span><span class="p">,</span> <span class="n">u8</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">total_locks</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mig_cookie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DLM_MRES_RECOVERY</span><span class="o">|</span><span class="n">DLM_MRES_MIGRATION</span><span class="p">)));</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;sending to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">send_to</span><span class="p">);</span>

	<span class="n">total_locks</span> <span class="o">=</span> <span class="n">dlm_num_locks_in_lockres</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">total_locks</span> <span class="o">&gt;</span> <span class="n">DLM_MAX_MIGRATABLE_LOCKS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* rare, but possible */</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;argh.  lockres has %d locks.  this will &quot;</span>
			  <span class="s">&quot;require more than one network packet to &quot;</span>
			  <span class="s">&quot;migrate</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">total_locks</span><span class="p">);</span>
		<span class="n">mig_cookie</span> <span class="o">=</span> <span class="n">dlm_get_next_mig_cookie</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">dlm_init_migratable_lockres</span><span class="p">(</span><span class="n">mres</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
				    <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">total_locks</span><span class="p">,</span>
				    <span class="n">mig_cookie</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>

	<span class="n">total_locks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">DLM_GRANTED_LIST</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">DLM_BLOCKED_LIST</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">queue</span> <span class="o">=</span> <span class="n">dlm_list_idx_to_ptr</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* add another lock. */</span>
			<span class="n">total_locks</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_add_lock_to_array</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">mres</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* this filled the lock message,</span>
<span class="cm">			 * we must send it immediately. */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_send_mig_lockres_msg</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mres</span><span class="p">,</span> <span class="n">send_to</span><span class="p">,</span>
						       <span class="n">res</span><span class="p">,</span> <span class="n">total_locks</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">total_locks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* send a dummy lock to indicate a mastery reference only */</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: sending dummy lock to %u, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
		     <span class="n">send_to</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_MRES_RECOVERY</span> <span class="o">?</span> <span class="s">&quot;recovery&quot;</span> <span class="o">:</span>
		     <span class="s">&quot;migration&quot;</span><span class="p">);</span>
		<span class="n">dlm_add_dummy_lock</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mres</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* flush any remaining locks */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_send_mig_lockres_msg</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mres</span><span class="p">,</span> <span class="n">send_to</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">total_locks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s: dlm_send_mig_lockres_msg returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_is_host_down</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: node %u went down while sending %s &quot;</span>
	     <span class="s">&quot;lockres %.*s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">send_to</span><span class="p">,</span>
	     <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_MRES_RECOVERY</span> <span class="o">?</span>  <span class="s">&quot;recovery&quot;</span> <span class="o">:</span> <span class="s">&quot;migration&quot;</span><span class="p">,</span>
	     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/*</span>
<span class="cm"> * this message will contain no more than one page worth of</span>
<span class="cm"> * recovery data, and it will work on only one lockres.</span>
<span class="cm"> * there may be many locks in this page, and we may need to wait</span>
<span class="cm"> * for additional packets to complete all the locks (rare, but</span>
<span class="cm"> * possible).</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * NOTE: the allocation error cases here are scary</span>
<span class="cm"> * we really cannot afford to fail an alloc in recovery</span>
<span class="cm"> * do we spin?  returning an error only delays the problem really</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">dlm_mig_lockres_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_migratable_lockres</span> <span class="o">*</span><span class="n">mres</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">dlm_migratable_lockres</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">real_master</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">extra_refs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_work_item</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_grab</span><span class="p">(</span><span class="n">dlm</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DLM_MRES_RECOVERY</span><span class="o">|</span><span class="n">DLM_MRES_MIGRATION</span><span class="p">)));</span>

	<span class="n">real_master</span> <span class="o">=</span> <span class="n">mres</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">real_master</span> <span class="o">==</span> <span class="n">DLM_LOCK_RES_OWNER_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* cannot migrate a lockres with no master */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_MRES_RECOVERY</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s message received from node %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="p">(</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_MRES_RECOVERY</span><span class="p">)</span> <span class="o">?</span>
		  <span class="s">&quot;recovery&quot;</span> <span class="o">:</span> <span class="s">&quot;migration&quot;</span><span class="p">,</span> <span class="n">mres</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_MRES_ALL_DONE</span><span class="p">)</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;all done flag.  all lockres data received!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="n">item</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span> <span class="o">||</span> <span class="o">!</span><span class="n">item</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>

	<span class="cm">/* lookup the lock to see if we have a secondary queue for this</span>
<span class="cm">	 * already...  just add the locks in and this will have its owner</span>
<span class="cm">	 * and RECOVERY flag changed when it completes. */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">dlm_lookup_lockres</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mres</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">,</span> <span class="n">mres</span><span class="o">-&gt;</span><span class="n">lockname_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
	 	<span class="cm">/* this will get a ref on res */</span>
		<span class="cm">/* mark it as recovering/migrating and hash it */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_MRES_RECOVERY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">DLM_LOCK_RES_RECOVERING</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_MIGRATING</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* this is at least the second</span>
<span class="cm">				 * lockres message */</span>
				<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;lock %.*s is already migrating</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">mres</span><span class="o">-&gt;</span><span class="n">lockname_len</span><span class="p">,</span>
					  <span class="n">mres</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_RECOVERING</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* caller should BUG */</span>
				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;node is attempting to migrate &quot;</span>
				     <span class="s">&quot;lock %.*s, but marked as recovering!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">mres</span><span class="o">-&gt;</span><span class="n">lockname_len</span><span class="p">,</span> <span class="n">mres</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">DLM_LOCK_RES_MIGRATING</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* need to allocate, just like if it was</span>
<span class="cm">		 * mastered here normally  */</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">dlm_new_lockres</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">mres</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">,</span> <span class="n">mres</span><span class="o">-&gt;</span><span class="n">lockname_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>

		<span class="cm">/* to match the ref that we would have gotten if</span>
<span class="cm">		 * dlm_lookup_lockres had succeeded */</span>
		<span class="n">dlm_lockres_get</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>

		<span class="cm">/* mark it as recovering/migrating and hash it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_MRES_RECOVERY</span><span class="p">)</span>
			<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">DLM_LOCK_RES_RECOVERING</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">DLM_LOCK_RES_MIGRATING</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="n">__dlm_insert_lockres</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

		<span class="cm">/* Add an extra ref for this lock-less lockres lest the</span>
<span class="cm">		 * dlm_thread purges it before we get the chance to add</span>
<span class="cm">		 * locks to it */</span>
		<span class="n">dlm_lockres_get</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>

		<span class="cm">/* There are three refs that need to be put.</span>
<span class="cm">		 * 1. Taken above.</span>
<span class="cm">		 * 2. kref_init in dlm_new_lockres()-&gt;dlm_init_lockres().</span>
<span class="cm">		 * 3. dlm_lookup_lockres()</span>
<span class="cm">		 * The first one is handled at the end of this function. The</span>
<span class="cm">		 * other two are handled in the worker thread after locks have</span>
<span class="cm">		 * been attached. Yes, we don&#39;t wait for purge time to match</span>
<span class="cm">		 * kref_init. The lockres will still have atleast one ref</span>
<span class="cm">		 * added because it is in the hash __dlm_insert_lockres() */</span>
		<span class="n">extra_refs</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* now that the new lockres is inserted,</span>
<span class="cm">		 * make it usable by other processes */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_LOCK_RES_IN_PROGRESS</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* at this point we have allocated everything we need,</span>
<span class="cm">	 * and we have a hashed lockres with an extra ref and</span>
<span class="cm">	 * the proper res-&gt;state flags. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="cm">/* drop this either when master requery finds a different master</span>
<span class="cm">	 * or when a lock is added by the recovery worker */</span>
	<span class="n">dlm_lockres_grab_inflight_ref</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">==</span> <span class="n">DLM_LOCK_RES_OWNER_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* migration cannot have an unknown master */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_MRES_RECOVERY</span><span class="p">));</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;recovery has passed me a lockres with an &quot;</span>
			  <span class="s">&quot;unknown owner.. will need to requery: &quot;</span>
			  <span class="s">&quot;%.*s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mres</span><span class="o">-&gt;</span><span class="n">lockname_len</span><span class="p">,</span> <span class="n">mres</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* take a reference now to pin the lockres, drop it</span>
<span class="cm">		 * when locks are added in the worker */</span>
		<span class="n">dlm_change_lockres_owner</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="cm">/* queue up work for dlm_mig_lockres_worker */</span>
	<span class="n">dlm_grab</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>  <span class="cm">/* get an extra ref for the work item */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">));</span>  <span class="cm">/* copy the whole message */</span>
	<span class="n">dlm_init_work_item</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">dlm_mig_lockres_worker</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ml</span><span class="p">.</span><span class="n">lockres</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span> <span class="cm">/* already have a ref */</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ml</span><span class="p">.</span><span class="n">real_master</span> <span class="o">=</span> <span class="n">real_master</span><span class="p">;</span>
	<span class="n">item</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ml</span><span class="p">.</span><span class="n">extra_ref</span> <span class="o">=</span> <span class="n">extra_refs</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_worker</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dispatched_work</span><span class="p">);</span>

<span class="nl">leave:</span>
	<span class="cm">/* One extra ref taken needs to be put here */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">extra_refs</span><span class="p">)</span>
		<span class="n">dlm_lockres_put</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>

	<span class="n">dlm_put</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
		<span class="n">mlog_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_mig_lockres_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_work_item</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_migratable_lockres</span> <span class="o">*</span><span class="n">mres</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">real_master</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">extra_ref</span><span class="p">;</span>

	<span class="n">dlm</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">dlm</span><span class="p">;</span>
	<span class="n">mres</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dlm_migratable_lockres</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ml</span><span class="p">.</span><span class="n">lockres</span><span class="p">;</span>
	<span class="n">real_master</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ml</span><span class="p">.</span><span class="n">real_master</span><span class="p">;</span>
	<span class="n">extra_ref</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ml</span><span class="p">.</span><span class="n">extra_ref</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">real_master</span> <span class="o">==</span> <span class="n">DLM_LOCK_RES_OWNER_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* this case is super-rare. only occurs if</span>
<span class="cm">		 * node death happens during migration. */</span>
<span class="nl">again:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_lockres_master_requery</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">real_master</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;dlm_lockres_master_requery ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">real_master</span> <span class="o">==</span> <span class="n">DLM_LOCK_RES_OWNER_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;lockres %.*s not claimed.  &quot;</span>
				   <span class="s">&quot;this node will take it.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">dlm_lockres_drop_inflight_ref</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;master needs to respond to sender &quot;</span>
				  <span class="s">&quot;that node %u still owns %.*s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">real_master</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
				  <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
			<span class="cm">/* cannot touch this lockres */</span>
			<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_process_recovery_data</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">mres</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;dlm_process_recovery_data returned  %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;dlm_process_recovery_data succeeded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DLM_MRES_MIGRATION</span><span class="o">|</span><span class="n">DLM_MRES_ALL_DONE</span><span class="p">))</span> <span class="o">==</span>
	                   <span class="p">(</span><span class="n">DLM_MRES_MIGRATION</span><span class="o">|</span><span class="n">DLM_MRES_ALL_DONE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_finish_migration</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">mres</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">mlog_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">leave:</span>
	<span class="cm">/* See comment in dlm_mig_lockres_handler() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">extra_ref</span><span class="p">)</span>
			<span class="n">dlm_lockres_put</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
		<span class="n">dlm_lockres_put</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_lockres_master_requery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
				      <span class="n">u8</span> <span class="o">*</span><span class="n">real_master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_node_iter</span> <span class="n">iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nodenum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="o">*</span><span class="n">real_master</span> <span class="o">=</span> <span class="n">DLM_LOCK_RES_OWNER_UNKNOWN</span><span class="p">;</span>

	<span class="cm">/* we only reach here if one of the two nodes in a</span>
<span class="cm">	 * migration died while the migration was in progress.</span>
<span class="cm">	 * at this point we need to requery the master.  we</span>
<span class="cm">	 * know that the new_master got as far as creating</span>
<span class="cm">	 * an mle on at least one node, but we do not know</span>
<span class="cm">	 * if any nodes had actually cleared the mle and set</span>
<span class="cm">	 * the master to the new_master.  the old master</span>
<span class="cm">	 * is supposed to set the owner to UNKNOWN in the</span>
<span class="cm">	 * event of a new_master death, so the only possible</span>
<span class="cm">	 * responses that we can get from nodes here are</span>
<span class="cm">	 * that the master is new_master, or that the master</span>
<span class="cm">	 * is UNKNOWN.</span>
<span class="cm">	 * if all nodes come back with UNKNOWN then we know</span>
<span class="cm">	 * the lock needs remastering here.</span>
<span class="cm">	 * if any node comes back with a valid master, check</span>
<span class="cm">	 * to see if that master is the one that we are</span>
<span class="cm">	 * recovering.  if so, then the new_master died and</span>
<span class="cm">	 * we need to remaster this lock.  if not, then the</span>
<span class="cm">	 * new_master survived and that node will respond to</span>
<span class="cm">	 * other nodes about the owner.</span>
<span class="cm">	 * if there is an owner, this node needs to dump this</span>
<span class="cm">	 * lockres and alert the sender that this lockres</span>
<span class="cm">	 * was rejected. */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">dlm_node_iter_init</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">domain_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">nodenum</span> <span class="o">=</span> <span class="n">dlm_node_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* do not send to self */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nodenum</span> <span class="o">==</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_do_master_requery</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">nodenum</span><span class="p">,</span> <span class="n">real_master</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_is_host_down</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
				<span class="n">BUG</span><span class="p">();</span>
			<span class="cm">/* host is down, so answer for that node would be</span>
<span class="cm">			 * DLM_LOCK_RES_OWNER_UNKNOWN.  continue. */</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">real_master</span> <span class="o">!=</span> <span class="n">DLM_LOCK_RES_OWNER_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;lock master is %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">real_master</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">dlm_do_master_requery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
			  <span class="n">u8</span> <span class="n">nodenum</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">real_master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_master_requery</span> <span class="n">req</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">DLM_LOCK_RES_OWNER_UNKNOWN</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">req</span><span class="p">));</span>
	<span class="n">req</span><span class="p">.</span><span class="n">node_idx</span> <span class="o">=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">;</span>
	<span class="n">req</span><span class="p">.</span><span class="n">namelen</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">o2net_send_message</span><span class="p">(</span><span class="n">DLM_MASTER_REQUERY_MSG</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">req</span><span class="p">),</span> <span class="n">nodenum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="cm">/* XXX: negative status not handled properly here. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;Error %d when sending message %u (key &quot;</span>
		     <span class="s">&quot;0x%x) to node %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">DLM_MASTER_REQUERY_MSG</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">nodenum</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">status</span> <span class="o">&gt;</span> <span class="n">DLM_LOCK_RES_OWNER_UNKNOWN</span><span class="p">);</span>
		<span class="o">*</span><span class="n">real_master</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node %u responded to master requery with %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">nodenum</span><span class="p">,</span> <span class="o">*</span><span class="n">real_master</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* this function cannot error, so unless the sending</span>
<span class="cm"> * or receiving of the message failed, the owner can</span>
<span class="cm"> * be trusted */</span>
<span class="kt">int</span> <span class="nf">dlm_master_requery_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_master_requery</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dlm_master_requery</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">master</span> <span class="o">=</span> <span class="n">DLM_LOCK_RES_OWNER_UNKNOWN</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">DLM_ASSERT_MASTER_REQUERY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_grab</span><span class="p">(</span><span class="n">dlm</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* since the domain has gone away on this</span>
<span class="cm">		 * node, the proper response is UNKNOWN */</span>
		<span class="k">return</span> <span class="n">master</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">dlm_lockid_hash</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">__dlm_lookup_lockres</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="n">master</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">master</span> <span class="o">==</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">dlm_dispatch_assert_master</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span>
							     <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mlog_errno</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
				<span class="cm">/* retry!? */</span>
				<span class="n">BUG</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="cm">/* put.. incase we are not the master */</span>
			<span class="n">dlm_lockres_put</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">dlm_put</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">master</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span>
<span class="nf">dlm_list_num_to_pointer</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">int</span> <span class="n">list_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">list_num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">list_num</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">granted</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">+=</span> <span class="n">list_num</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* TODO: do ast flush business</span>
<span class="cm"> * TODO: do MIGRATING and RECOVERING spinning</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm">* NOTE about in-flight requests during migration:</span>
<span class="cm">*</span>
<span class="cm">* Before attempting the migrate, the master has marked the lockres as</span>
<span class="cm">* MIGRATING and then flushed all of its pending ASTS.  So any in-flight</span>
<span class="cm">* requests either got queued before the MIGRATING flag got set, in which</span>
<span class="cm">* case the lock data will reflect the change and a return message is on</span>
<span class="cm">* the way, or the request failed to get in before MIGRATING got set.  In</span>
<span class="cm">* this case, the caller will be told to spin and wait for the MIGRATING</span>
<span class="cm">* flag to be dropped, then recheck the master.</span>
<span class="cm">* This holds true for the convert, cancel and unlock cases, and since lvb</span>
<span class="cm">* updates are tied to these same messages, it applies to lvb updates as</span>
<span class="cm">* well.  For the lock case, there is no way a lock can be on the master</span>
<span class="cm">* queue and not be on the secondary queue since the lock is always added</span>
<span class="cm">* locally first.  This means that the new target node will never be sent</span>
<span class="cm">* a lock that he doesn&#39;t already have on the list.</span>
<span class="cm">* In total, this means that the local lock is correct and should not be</span>
<span class="cm">* updated to match the one sent by the master.  Any messages sent back</span>
<span class="cm">* from the master before the MIGRATING flag will bring the lock properly</span>
<span class="cm">* up-to-date, and the change will be ordered properly for the waiter.</span>
<span class="cm">* We will *not* attempt to modify the lock underneath the waiter.</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_process_recovery_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dlm_migratable_lockres</span> <span class="o">*</span><span class="n">mres</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_migratable_lock</span> <span class="o">*</span><span class="n">ml</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmpq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">newlock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lockstatus</span> <span class="o">*</span><span class="n">lksb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">bad</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">from</span> <span class="o">=</span> <span class="n">O2NM_MAX_NODES</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">added</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__be64</span> <span class="n">c</span><span class="p">;</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;running %d locks for this lockres</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mres</span><span class="o">-&gt;</span><span class="n">num_locks</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">num_locks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ml</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dlm_is_dummy_lock</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">ml</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">from</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* placeholder, just need to set the refmap bit */</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">num_locks</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: dummy lock for %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">mres</span><span class="o">-&gt;</span><span class="n">lockname_len</span><span class="p">,</span> <span class="n">mres</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">,</span>
			     <span class="n">from</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">dlm_lockres_set_refmap_bit</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">from</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">added</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ml</span><span class="o">-&gt;</span><span class="n">highest_blocked</span> <span class="o">!=</span> <span class="n">LKM_IVMODE</span><span class="p">);</span>
		<span class="n">newlock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">lksb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">queue</span> <span class="o">=</span> <span class="n">dlm_list_num_to_pointer</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">tmpq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* if the lock is for the local node it needs to</span>
<span class="cm">		 * be moved to the proper location within the queue.</span>
<span class="cm">		 * do not allocate a new lock structure. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ml</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">==</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* MIGRATION ONLY! */</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_MRES_MIGRATION</span><span class="p">));</span>

			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">DLM_GRANTED_LIST</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">DLM_BLOCKED_LIST</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tmpq</span> <span class="o">=</span> <span class="n">dlm_list_idx_to_ptr</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
				<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">tmpq</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">cookie</span> <span class="o">!=</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">cookie</span><span class="p">)</span>
						<span class="n">lock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="k">else</span>
						<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* lock is always created locally first, and</span>
<span class="cm">			 * destroyed locally last.  it must be on the list */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">c</span> <span class="o">=</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">cookie</span><span class="p">;</span>
				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;Could not find local lock &quot;</span>
					       <span class="s">&quot;with cookie %u:%llu, node %u, &quot;</span>
					       <span class="s">&quot;list %u, flags 0x%x, type %d, &quot;</span>
					       <span class="s">&quot;conv %d, highest blocked %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">dlm_get_lock_cookie_node</span><span class="p">(</span><span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">c</span><span class="p">)),</span>
				     <span class="n">dlm_get_lock_cookie_seq</span><span class="p">(</span><span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">c</span><span class="p">)),</span>
				     <span class="n">ml</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span>
				     <span class="n">ml</span><span class="o">-&gt;</span><span class="n">convert_type</span><span class="p">,</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">highest_blocked</span><span class="p">);</span>
				<span class="n">__dlm_print_one_lock_resource</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
				<span class="n">BUG</span><span class="p">();</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">node</span> <span class="o">!=</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">c</span> <span class="o">=</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">cookie</span><span class="p">;</span>
				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;Mismatched node# in lock &quot;</span>
				     <span class="s">&quot;cookie %u:%llu, name %.*s, node %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">dlm_get_lock_cookie_node</span><span class="p">(</span><span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">c</span><span class="p">)),</span>
				     <span class="n">dlm_get_lock_cookie_seq</span><span class="p">(</span><span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">c</span><span class="p">)),</span>
				     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
				     <span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">node</span><span class="p">);</span>
				<span class="n">c</span> <span class="o">=</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">cookie</span><span class="p">;</span>
				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;Migrate lock cookie %u:%llu, &quot;</span>
				     <span class="s">&quot;node %u, list %u, flags 0x%x, type %d, &quot;</span>
				     <span class="s">&quot;conv %d, highest blocked %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">dlm_get_lock_cookie_node</span><span class="p">(</span><span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">c</span><span class="p">)),</span>
				     <span class="n">dlm_get_lock_cookie_seq</span><span class="p">(</span><span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">c</span><span class="p">)),</span>
				     <span class="n">ml</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span>
				     <span class="n">ml</span><span class="o">-&gt;</span><span class="n">convert_type</span><span class="p">,</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">highest_blocked</span><span class="p">);</span>
				<span class="n">__dlm_print_one_lock_resource</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
				<span class="n">BUG</span><span class="p">();</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">tmpq</span> <span class="o">!=</span> <span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">c</span> <span class="o">=</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">cookie</span><span class="p">;</span>
				<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Lock cookie %u:%llu was on list %u &quot;</span>
				     <span class="s">&quot;instead of list %u for %.*s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">dlm_get_lock_cookie_node</span><span class="p">(</span><span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">c</span><span class="p">)),</span>
				     <span class="n">dlm_get_lock_cookie_seq</span><span class="p">(</span><span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">c</span><span class="p">)),</span>
				     <span class="n">j</span><span class="p">,</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
				     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
				<span class="n">__dlm_print_one_lock_resource</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* see NOTE above about why we do not update</span>
<span class="cm">			 * to match the master here */</span>

			<span class="cm">/* move the lock to its proper place */</span>
			<span class="cm">/* do not alter lock refcount.  switching lists. */</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">added</span><span class="o">++</span><span class="p">;</span>

			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;just reordered a local lock!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* lock is for another node. */</span>
		<span class="n">newlock</span> <span class="o">=</span> <span class="n">dlm_new_lock</span><span class="p">(</span><span class="n">ml</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span>
				       <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">ml</span><span class="o">-&gt;</span><span class="n">cookie</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newlock</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lksb</span> <span class="o">=</span> <span class="n">newlock</span><span class="o">-&gt;</span><span class="n">lksb</span><span class="p">;</span>
		<span class="n">dlm_lock_attach_lockres</span><span class="p">(</span><span class="n">newlock</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ml</span><span class="o">-&gt;</span><span class="n">convert_type</span> <span class="o">!=</span> <span class="n">LKM_IVMODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">queue</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">converting</span><span class="p">);</span>
			<span class="n">newlock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">convert_type</span> <span class="o">=</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">convert_type</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lksb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">ml</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span>
				<span class="p">(</span><span class="n">DLM_LKSB_PUT_LVB</span><span class="o">|</span><span class="n">DLM_LKSB_GET_LVB</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ml</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">LKM_NLMODE</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">skip_lvb</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_lvb_is_empty</span><span class="p">(</span><span class="n">mres</span><span class="o">-&gt;</span><span class="n">lvb</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lksb</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_LKSB_PUT_LVB</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* other node was trying to update</span>
<span class="cm">				 * lvb when node died.  recreate the</span>
<span class="cm">				 * lksb with the updated lvb. */</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">lksb</span><span class="o">-&gt;</span><span class="n">lvb</span><span class="p">,</span> <span class="n">mres</span><span class="o">-&gt;</span><span class="n">lvb</span><span class="p">,</span> <span class="n">DLM_LVB_LEN</span><span class="p">);</span>
				<span class="cm">/* the lock resource lvb update must happen</span>
<span class="cm">				 * NOW, before the spinlock is dropped.</span>
<span class="cm">				 * we no longer wait for the AST to update</span>
<span class="cm">				 * the lvb. */</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">lvb</span><span class="p">,</span> <span class="n">mres</span><span class="o">-&gt;</span><span class="n">lvb</span><span class="p">,</span> <span class="n">DLM_LVB_LEN</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* otherwise, the node is sending its</span>
<span class="cm">				 * most recent valid lvb info */</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ml</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">LKM_EXMODE</span> <span class="o">&amp;&amp;</span>
				       <span class="n">ml</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">LKM_PRMODE</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_lvb_is_empty</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">lvb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
 				    <span class="p">(</span><span class="n">ml</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">LKM_EXMODE</span> <span class="o">||</span>
 				     <span class="n">memcmp</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">lvb</span><span class="p">,</span> <span class="n">mres</span><span class="o">-&gt;</span><span class="n">lvb</span><span class="p">,</span> <span class="n">DLM_LVB_LEN</span><span class="p">)))</span> <span class="p">{</span>
 					<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
 					<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: received bad &quot;</span>
 					     <span class="s">&quot;lvb! type=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
 					     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
 					     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
 					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;lockres lvb=[&quot;</span><span class="p">);</span>
 					<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">DLM_LVB_LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
 						<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x&quot;</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lvb</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
 					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">migrated lvb=[&quot;</span><span class="p">);</span>
 					<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">DLM_LVB_LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
 						<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%02x&quot;</span><span class="p">,</span> <span class="n">mres</span><span class="o">-&gt;</span><span class="n">lvb</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
 					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
 					<span class="n">dlm_print_one_lock_resource</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
 					<span class="n">BUG</span><span class="p">();</span>
				<span class="p">}</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">lvb</span><span class="p">,</span> <span class="n">mres</span><span class="o">-&gt;</span><span class="n">lvb</span><span class="p">,</span> <span class="n">DLM_LVB_LEN</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="nl">skip_lvb:</span>

		<span class="cm">/* NOTE:</span>
<span class="cm">		 * wrt lock queue ordering and recovery:</span>
<span class="cm">		 *    1. order of locks on granted queue is</span>
<span class="cm">		 *       meaningless.</span>
<span class="cm">		 *    2. order of locks on converting queue is</span>
<span class="cm">		 *       LOST with the node death.  sorry charlie.</span>
<span class="cm">		 *    3. order of locks on the blocked queue is</span>
<span class="cm">		 *       also LOST.</span>
<span class="cm">		 * order of locks does not affect integrity, it</span>
<span class="cm">		 * just means that a lock request may get pushed</span>
<span class="cm">		 * back in line as a result of the node death.</span>
<span class="cm">		 * also note that for a given node the lock order</span>
<span class="cm">		 * for its secondary queue locks is preserved</span>
<span class="cm">		 * relative to each other, but clearly *not*</span>
<span class="cm">		 * preserved relative to locks from other nodes.</span>
<span class="cm">		 */</span>
		<span class="n">bad</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">cookie</span> <span class="o">==</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">cookie</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">c</span> <span class="o">=</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">cookie</span><span class="p">;</span>
				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: %u:%llu: lock already &quot;</span>
				     <span class="s">&quot;exists on this lockres!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
				     <span class="n">dlm_get_lock_cookie_node</span><span class="p">(</span><span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">c</span><span class="p">)),</span>
				     <span class="n">dlm_get_lock_cookie_seq</span><span class="p">(</span><span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">c</span><span class="p">)));</span>

				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_NOTICE</span><span class="p">,</span> <span class="s">&quot;sent lock: type=%d, conv=%d, &quot;</span>
				     <span class="s">&quot;node=%u, cookie=%u:%llu, queue=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      			     <span class="n">ml</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">convert_type</span><span class="p">,</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span>
				     <span class="n">dlm_get_lock_cookie_node</span><span class="p">(</span><span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">ml</span><span class="o">-&gt;</span><span class="n">cookie</span><span class="p">)),</span>
				     <span class="n">dlm_get_lock_cookie_seq</span><span class="p">(</span><span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">ml</span><span class="o">-&gt;</span><span class="n">cookie</span><span class="p">)),</span>
				     <span class="n">ml</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

				<span class="n">__dlm_print_one_lock_resource</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
				<span class="n">bad</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bad</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dlm_lock_get</span><span class="p">(</span><span class="n">newlock</span><span class="p">);</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newlock</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: added lock for node %u, &quot;</span>
			     <span class="s">&quot;setting refmap bit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
			<span class="n">dlm_lockres_set_refmap_bit</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">ml</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
			<span class="n">added</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;done running all the locks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="nl">leave:</span>
	<span class="cm">/* balance the ref taken when the work was queued */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">dlm_lockres_drop_inflight_ref</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newlock</span><span class="p">)</span>
			<span class="n">dlm_lock_put</span><span class="p">(</span><span class="n">newlock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_move_lockres_to_recovery_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">DLM_LOCK_RES_RECOVERING</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">recovering</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
		     <span class="s">&quot;Recovering res %s:%.*s, is already on recovery list!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">recovering</span><span class="p">);</span>
		<span class="n">dlm_lockres_put</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* We need to hold a reference while on the recovery list */</span>
	<span class="n">dlm_lockres_get</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">recovering</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">resources</span><span class="p">);</span>

	<span class="cm">/* find any pending locks and put them back on proper list */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">DLM_BLOCKED_LIST</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="n">DLM_GRANTED_LIST</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">queue</span> <span class="o">=</span> <span class="n">dlm_list_idx_to_ptr</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dlm_lock_get</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">convert_pending</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* move converting lock back to granted */</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">DLM_CONVERTING_LIST</span><span class="p">);</span>
				<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node died with convert pending &quot;</span>
				     <span class="s">&quot;on %.*s. move back to granted list.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
				<span class="n">dlm_revert_pending_convert</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">lock</span><span class="p">);</span>
				<span class="n">lock</span><span class="o">-&gt;</span><span class="n">convert_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">lock_pending</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* remove pending lock requests completely */</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">DLM_BLOCKED_LIST</span><span class="p">);</span>
				<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node died with lock pending &quot;</span>
				     <span class="s">&quot;on %.*s. remove from blocked list and skip.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
				<span class="cm">/* lock will be floating until ref in</span>
<span class="cm">				 * dlmlock_remote is freed after the network</span>
<span class="cm">				 * call returns.  ok for it to not be on any</span>
<span class="cm">				 * list since no ast can be called</span>
<span class="cm">				 * (the master is dead). */</span>
				<span class="n">dlm_revert_pending_lock</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">lock</span><span class="p">);</span>
				<span class="n">lock</span><span class="o">-&gt;</span><span class="n">lock_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">unlock_pending</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* if an unlock was in progress, treat as</span>
<span class="cm">				 * if this had completed successfully</span>
<span class="cm">				 * before sending this lock state to the</span>
<span class="cm">				 * new master.  note that the dlm_unlock</span>
<span class="cm">				 * call is still responsible for calling</span>
<span class="cm">				 * the unlockast.  that will happen after</span>
<span class="cm">				 * the network call times out.  for now,</span>
<span class="cm">				 * just move lists to prepare the new</span>
<span class="cm">				 * recovery master.  */</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">DLM_GRANTED_LIST</span><span class="p">);</span>
				<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node died with unlock pending &quot;</span>
				     <span class="s">&quot;on %.*s. remove from blocked list and skip.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
				<span class="n">dlm_commit_pending_unlock</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">lock</span><span class="p">);</span>
				<span class="n">lock</span><span class="o">-&gt;</span><span class="n">unlock_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">cancel_pending</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* if a cancel was in progress, treat as</span>
<span class="cm">				 * if this had completed successfully</span>
<span class="cm">				 * before sending this lock state to the</span>
<span class="cm">				 * new master */</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">DLM_CONVERTING_LIST</span><span class="p">);</span>
				<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node died with cancel pending &quot;</span>
				     <span class="s">&quot;on %.*s. move back to granted list.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
				<span class="n">dlm_commit_pending_cancel</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">lock</span><span class="p">);</span>
				<span class="n">lock</span><span class="o">-&gt;</span><span class="n">cancel_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">dlm_lock_put</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>



<span class="cm">/* removes all recovered locks from the recovery list.</span>
<span class="cm"> * sets the res-&gt;owner to the new master.</span>
<span class="cm"> * unsets the RECOVERY flag and wakes waiters. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_finish_local_lockres_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
					      <span class="n">u8</span> <span class="n">dead_node</span><span class="p">,</span> <span class="n">u8</span> <span class="n">new_master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">hash_iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">bucket</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">resources</span><span class="p">,</span> <span class="n">recovering</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">==</span> <span class="n">dead_node</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: res %.*s, Changing owner from %u to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			     <span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">,</span> <span class="n">new_master</span><span class="p">);</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">recovering</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="cm">/* new_master has our reference from</span>
<span class="cm">			 * the lock state sent during recovery */</span>
			<span class="n">dlm_change_lockres_owner</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">new_master</span><span class="p">);</span>
			<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_LOCK_RES_RECOVERING</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">__dlm_lockres_has_locks</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
				<span class="n">__dlm_dirty_lockres</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
			<span class="n">dlm_lockres_put</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* this will become unnecessary eventually, but</span>
<span class="cm">	 * for now we need to run the whole hash, clear</span>
<span class="cm">	 * the RECOVERING state and set the owner</span>
<span class="cm">	 * if necessary */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DLM_HASH_BUCKETS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bucket</span> <span class="o">=</span> <span class="n">dlm_lockres_hash</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">hash_iter</span><span class="p">,</span> <span class="n">bucket</span><span class="p">,</span> <span class="n">hash_node</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_RECOVERING</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">dead_node</span> <span class="o">&amp;&amp;</span>
			    <span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">recovering</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">recovering</span><span class="p">);</span>
				<span class="n">dlm_lockres_put</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* new_master has our reference from</span>
<span class="cm">			 * the lock state sent during recovery */</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: res %.*s, Changing owner from %u to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			     <span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">,</span> <span class="n">new_master</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">dlm_change_lockres_owner</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">new_master</span><span class="p">);</span>
			<span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_LOCK_RES_RECOVERING</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">__dlm_lockres_has_locks</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
				<span class="n">__dlm_dirty_lockres</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dlm_lvb_needs_invalidation</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">local</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">local</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">LKM_EXMODE</span> <span class="o">&amp;&amp;</span>
		    <span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">LKM_PRMODE</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">LKM_EXMODE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_revalidate_lvb</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dead_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">blank_lvb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">local</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">search_node</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">==</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span>
		<span class="cm">/* if this node owned the lockres, and if the dead node</span>
<span class="cm">		 * had an EX when he died, blank out the lvb */</span>
		<span class="n">search_node</span> <span class="o">=</span> <span class="n">dead_node</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* if this is a secondary lockres, and we had no EX or PR</span>
<span class="cm">		 * locks granted, we can no longer trust the lvb */</span>
		<span class="n">search_node</span> <span class="o">=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">;</span>
		<span class="n">local</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* check local state for valid lvb */</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">DLM_GRANTED_LIST</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">DLM_CONVERTING_LIST</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">queue</span> <span class="o">=</span> <span class="n">dlm_list_idx_to_ptr</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">node</span> <span class="o">==</span> <span class="n">search_node</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dlm_lvb_needs_invalidation</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">local</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* zero the lksb lvb and lockres lvb */</span>
					<span class="n">blank_lvb</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">memset</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">lksb</span><span class="o">-&gt;</span><span class="n">lvb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DLM_LVB_LEN</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blank_lvb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;clearing %.*s lvb, dead node %u had EX</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">lvb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DLM_LVB_LEN</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_free_dead_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dead_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">freed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* this node is the lockres master:</span>
<span class="cm">	 * 1) remove any stale locks for the dead node</span>
<span class="cm">	 * 2) if the dead node had an EX when he died, blank out the lvb</span>
<span class="cm">	 */</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="cm">/* We do two dlm_lock_put(). One for removing from list and the other is</span>
<span class="cm">	 * to force the DLM_UNLOCK_FREE_LOCK action so as to free the locks */</span>

	<span class="cm">/* TODO: check pending_asts, pending_basts here */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">granted</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">node</span> <span class="o">==</span> <span class="n">dead_node</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">dlm_lock_put</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
			<span class="cm">/* Can&#39;t schedule DLM_UNLOCK_FREE_LOCK - do manually */</span>
			<span class="n">dlm_lock_put</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">freed</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">converting</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">node</span> <span class="o">==</span> <span class="n">dead_node</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">dlm_lock_put</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
			<span class="cm">/* Can&#39;t schedule DLM_UNLOCK_FREE_LOCK - do manually */</span>
			<span class="n">dlm_lock_put</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">freed</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">node</span> <span class="o">==</span> <span class="n">dead_node</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">dlm_lock_put</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
			<span class="cm">/* Can&#39;t schedule DLM_UNLOCK_FREE_LOCK - do manually */</span>
			<span class="n">dlm_lock_put</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">freed</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">freed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: freed %u locks for dead node %u, &quot;</span>
		     <span class="s">&quot;dropping ref from lockres</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">freed</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">refmap</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: freed %u locks for dead node %u, &quot;</span>
			     <span class="s">&quot;but ref was not set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">freed</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>
			<span class="n">__dlm_print_one_lock_resource</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">dlm_lockres_clear_refmap_bit</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">refmap</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s:%.*s: dead node %u had a ref, but had &quot;</span>
		     <span class="s">&quot;no locks and had not purged before dying</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>
		<span class="n">dlm_lockres_clear_refmap_bit</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* do not kick thread yet */</span>
	<span class="n">__dlm_dirty_lockres</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* if this node is the recovery master, and there are no</span>
<span class="cm"> * locks for a given lockres owned by this node that are in</span>
<span class="cm"> * either PR or EX mode, zero out the lvb before requesting.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_do_local_recovery_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dead_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">bucket</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span>


	<span class="cm">/* purge any stale mles */</span>
	<span class="n">dlm_clean_master_list</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * now clean up all lock resources.  there are two rules:</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1) if the dead node was the master, move the lockres</span>
<span class="cm">	 *    to the recovering list.  set the RECOVERING flag.</span>
<span class="cm">	 *    this lockres needs to be cleaned up before it can</span>
<span class="cm">	 *    be used further.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 2) if this node was the master, remove all locks from</span>
<span class="cm">	 *    each of the lockres queues that were owned by the</span>
<span class="cm">	 *    dead node.  once recovery finishes, the dlm thread</span>
<span class="cm">	 *    can be kicked again to see if any ASTs or BASTs</span>
<span class="cm">	 *    need to be fired as a result.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DLM_HASH_BUCKETS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bucket</span> <span class="o">=</span> <span class="n">dlm_lockres_hash</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">bucket</span><span class="p">,</span> <span class="n">hash_node</span><span class="p">)</span> <span class="p">{</span>
 			<span class="cm">/* always prune any $RECOVERY entries for dead nodes,</span>
<span class="cm"> 			 * otherwise hangs can occur during later recovery */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dlm_is_recovery_lock</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
						 <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
				<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">granted</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">ml</span><span class="p">.</span><span class="n">node</span> <span class="o">==</span> <span class="n">dead_node</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;AHA! there was &quot;</span>
						     <span class="s">&quot;a $RECOVERY lock for dead &quot;</span>
						     <span class="s">&quot;node %u (%s)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						     <span class="n">dead_node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
						<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
						<span class="n">dlm_lock_put</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="cm">/* zero the lvb if necessary */</span>
			<span class="n">dlm_revalidate_lvb</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">==</span> <span class="n">dead_node</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_DROPPING_REF</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">mlog</span><span class="p">(</span><span class="n">ML_NOTICE</span><span class="p">,</span> <span class="s">&quot;%s: res %.*s, Skip &quot;</span>
					     <span class="s">&quot;recovery as it is being freed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
					     <span class="n">res</span><span class="o">-&gt;</span><span class="n">lockname</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="n">dlm_move_lockres_to_recovery_list</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span>
									  <span class="n">res</span><span class="p">);</span>

			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">==</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dlm_free_dead_locks</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>
				<span class="n">__dlm_lockres_calc_usage</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__dlm_hb_node_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span> <span class="o">==</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: recovery master %d just died</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_RECO_STATE_FINALIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* finalize1 was reached, so it is safe to clear</span>
<span class="cm">			 * the new_master and dead_node.  that recovery</span>
<span class="cm">			 * is complete. */</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: dead master %d had reached &quot;</span>
			     <span class="s">&quot;finalize1 state, clearing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
			<span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_RECO_STATE_FINALIZE</span><span class="p">;</span>
			<span class="n">__dlm_reset_recovery</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Clean up join state on node death. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">joining_node</span> <span class="o">==</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Clearing join state for node %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="n">__dlm_set_joining_node</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">DLM_LOCK_RES_OWNER_UNKNOWN</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* check to see if the node is already considered dead */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">live_nodes_map</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;for domain %s, node %d is already dead. &quot;</span>
		     <span class="s">&quot;another node likely did recovery already.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check to see if we do not care about this node */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">domain_map</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* This also catches the case that we get a node down</span>
<span class="cm">		 * but haven&#39;t joined the domain yet. */</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node %u already removed from domain!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">live_nodes_map</span><span class="p">);</span>

	<span class="cm">/* make sure local cleanup occurs before the heartbeat events */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">recovery_map</span><span class="p">))</span>
		<span class="n">dlm_do_local_recovery_cleanup</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

	<span class="cm">/* notify anything attached to the heartbeat events */</span>
	<span class="n">dlm_hb_event_notify_attached</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;node %u being removed from domain map!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">domain_map</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">exit_domain_map</span><span class="p">);</span>
	<span class="cm">/* wake up migration waiters if a node goes down.</span>
<span class="cm">	 * perhaps later we can genericize this for other waiters. */</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">migration_wq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">recovery_map</span><span class="p">))</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;domain %s, node %u already added &quot;</span>
		     <span class="s">&quot;to recovery map!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">recovery_map</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_hb_node_down_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2nm_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_grab</span><span class="p">(</span><span class="n">dlm</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This will notify any dlm users that a node in our domain</span>
<span class="cm">	 * went away without notifying us first.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">domain_map</span><span class="p">))</span>
		<span class="n">dlm_fire_domain_eviction_callbacks</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">__dlm_hb_node_down</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">dlm_put</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_hb_node_up_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2nm_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_grab</span><span class="p">(</span><span class="n">dlm</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">live_nodes_map</span><span class="p">);</span>
	<span class="cm">/* do NOT notify mle attached to the heartbeat events.</span>
<span class="cm">	 * new nodes are not interesting in mastery until joined. */</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">dlm_put</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_reco_ast</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">astdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span> <span class="o">=</span> <span class="n">astdata</span><span class="p">;</span>
	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;ast for recovery lock fired!, this=%u, dlm=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_reco_bast</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">astdata</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blocked_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span> <span class="o">=</span> <span class="n">astdata</span><span class="p">;</span>
	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;bast for recovery lock fired!, this=%u, dlm=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_reco_unlock_ast</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">astdata</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dlm_status</span> <span class="n">st</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;unlockast for recovery lock fired!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * dlm_pick_recovery_master will continually attempt to use</span>
<span class="cm"> * dlmlock() on the special &quot;$RECOVERY&quot; lockres with the</span>
<span class="cm"> * LKM_NOQUEUE flag to get an EX.  every thread that enters</span>
<span class="cm"> * this function on each node racing to become the recovery</span>
<span class="cm"> * master will not stop attempting this until either:</span>
<span class="cm"> * a) this node gets the EX (and becomes the recovery master),</span>
<span class="cm"> * or b) dlm-&gt;reco.new_master gets set to some nodenum</span>
<span class="cm"> * != O2NM_INVALID_NODE_NUM (another node will do the reco).</span>
<span class="cm"> * so each time a recovery master is needed, the entire cluster</span>
<span class="cm"> * will sync at this point.  if the new master dies, that will</span>
<span class="cm"> * be detected in dlm_do_recovery */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_pick_recovery_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">dlm_status</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lockstatus</span> <span class="n">lksb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;starting recovery of %s at %lu, dead=%u, this=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">);</span>
<span class="nl">again:</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lksb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lksb</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">dlmlock</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">LKM_EXMODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lksb</span><span class="p">,</span> <span class="n">LKM_NOQUEUE</span><span class="o">|</span><span class="n">LKM_RECOVERY</span><span class="p">,</span>
		      <span class="n">DLM_RECOVERY_LOCK_NAME</span><span class="p">,</span> <span class="n">DLM_RECOVERY_LOCK_NAME_LEN</span><span class="p">,</span>
		      <span class="n">dlm_reco_ast</span><span class="p">,</span> <span class="n">dlm</span><span class="p">,</span> <span class="n">dlm_reco_bast</span><span class="p">);</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: dlmlock($RECOVERY) returned %d, lksb=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">lksb</span><span class="p">.</span><span class="n">status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">DLM_NORMAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;dlm=%s dlmlock says I got it (this=%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">);</span>

		<span class="cm">/* got the EX lock.  check to see if another node</span>
<span class="cm">		 * just became the reco master */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlm_reco_master_ready</span><span class="p">(</span><span class="n">dlm</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: got reco EX lock, but %u will &quot;</span>
			     <span class="s">&quot;do the recovery</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* see if recovery was already finished elsewhere */</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span> <span class="o">==</span> <span class="n">O2NM_INVALID_NODE_NUM</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: got reco EX lock, but &quot;</span>
				     <span class="s">&quot;node got recovered already</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span> <span class="o">!=</span> <span class="n">O2NM_INVALID_NODE_NUM</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s: new master is %u &quot;</span>
					     <span class="s">&quot;but no dead node!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span><span class="p">);</span>
					<span class="n">BUG</span><span class="p">();</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* if this node has actually become the recovery master,</span>
<span class="cm">		 * set the master and send the messages to begin recovery */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: dead=%u, this=%u, sending &quot;</span>
			     <span class="s">&quot;begin_reco now</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">dlm_send_begin_reco_message</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span>
				      <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">);</span>
			<span class="cm">/* this always succeeds */</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>

			<span class="cm">/* set the new_master to this node */</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">dlm_set_reco_master</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* recovery lock is a special case.  ast will not get fired,</span>
<span class="cm">		 * so just go ahead and unlock it. */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dlmunlock</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lksb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dlm_reco_unlock_ast</span><span class="p">,</span> <span class="n">dlm</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">DLM_DENIED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;got DLM_DENIED, trying LKM_CANCEL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">dlmunlock</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lksb</span><span class="p">,</span> <span class="n">LKM_CANCEL</span><span class="p">,</span> <span class="n">dlm_reco_unlock_ast</span><span class="p">,</span> <span class="n">dlm</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">DLM_NORMAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* this would really suck. this could only happen</span>
<span class="cm">			 * if there was a network error during the unlock</span>
<span class="cm">			 * because of node death.  this means the unlock</span>
<span class="cm">			 * is actually &quot;done&quot; and the lock structure is</span>
<span class="cm">			 * even freed.  we can continue, but only</span>
<span class="cm">			 * because this specific lock name is special. */</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;dlmunlock returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">DLM_NOTQUEUED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;dlm=%s dlmlock says another node got it (this=%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">);</span>
		<span class="cm">/* another node is master. wait on</span>
<span class="cm">		 * reco.new_master != O2NM_INVALID_NODE_NUM</span>
<span class="cm">		 * for at most one second */</span>
		<span class="n">wait_event_timeout</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_reco_thread_wq</span><span class="p">,</span>
					 <span class="n">dlm_reco_master_ready</span><span class="p">(</span><span class="n">dlm</span><span class="p">),</span>
					 <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">1000</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_reco_master_ready</span><span class="p">(</span><span class="n">dlm</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: reco master taking awhile</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* another node has informed this one that it is reco master */</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: reco master %u is ready to recover %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">DLM_RECOVERING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;dlm=%s dlmlock says master node died (this=%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>

		<span class="cm">/* dlmlock returned something other than NOTQUEUED or NORMAL */</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s: got %s from dlmlock($RECOVERY), &quot;</span>
		     <span class="s">&quot;lksb.status=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dlm_errname</span><span class="p">(</span><span class="n">ret</span><span class="p">),</span>
		     <span class="n">dlm_errname</span><span class="p">(</span><span class="n">lksb</span><span class="p">.</span><span class="n">status</span><span class="p">));</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">dlm_lookup_lockres</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">DLM_RECOVERY_LOCK_NAME</span><span class="p">,</span>
					 <span class="n">DLM_RECOVERY_LOCK_NAME_LEN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dlm_print_one_lock_resource</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
			<span class="n">dlm_lockres_put</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;recovery lock not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_send_begin_reco_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dead_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_begin_reco</span> <span class="n">br</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_node_iter</span> <span class="n">iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nodenum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: dead node is %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">dlm_node_iter_init</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">domain_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">iter</span><span class="p">.</span><span class="n">node_map</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">br</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">br</span><span class="p">));</span>
	<span class="n">br</span><span class="p">.</span><span class="n">node_idx</span> <span class="o">=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">;</span>
	<span class="n">br</span><span class="p">.</span><span class="n">dead_node</span> <span class="o">=</span> <span class="n">dead_node</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">nodenum</span> <span class="o">=</span> <span class="n">dlm_node_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nodenum</span> <span class="o">==</span> <span class="n">dead_node</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;not sending begin reco to dead node &quot;</span>
				  <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dead_node</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nodenum</span> <span class="o">==</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;not sending begin reco to self</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
<span class="nl">retry:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;attempting to send begin reco msg to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">nodenum</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">o2net_send_message</span><span class="p">(</span><span class="n">DLM_BEGIN_RECO_MSG</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">br</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">br</span><span class="p">),</span> <span class="n">nodenum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
		<span class="cm">/* negative status is handled ok by caller here */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlm_is_host_down</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* node is down.  not involved in recovery</span>
<span class="cm">			 * so just keep going */</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_NOTICE</span><span class="p">,</span> <span class="s">&quot;%s: node %u was down when sending &quot;</span>
			     <span class="s">&quot;begin reco msg (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">nodenum</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Prior to commit aad1b15310b9bcd59fa81ab8f2b1513b59553ea8,</span>
<span class="cm">		 * dlm_begin_reco_handler() returned EAGAIN and not -EAGAIN.</span>
<span class="cm">		 * We are handling both for compatibility reasons.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">==</span> <span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: trying to start recovery of node &quot;</span>
			     <span class="s">&quot;%u, but node %u is waiting for last recovery &quot;</span>
			     <span class="s">&quot;to complete, backoff for a bit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			     <span class="n">dead_node</span><span class="p">,</span> <span class="n">nodenum</span><span class="p">);</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>

			<span class="cm">/* this is now a serious problem, possibly ENOMEM</span>
<span class="cm">			 * in the network stack.  must retry */</span>
			<span class="n">mlog_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;begin reco of dlm %s to node %u &quot;</span>
			     <span class="s">&quot;returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">nodenum</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">dlm_lookup_lockres</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">DLM_RECOVERY_LOCK_NAME</span><span class="p">,</span>
						 <span class="n">DLM_RECOVERY_LOCK_NAME_LEN</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dlm_print_one_lock_resource</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
				<span class="n">dlm_lockres_put</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;recovery lock not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* sleep for a bit in hopes that we can avoid</span>
<span class="cm">			 * another ENOMEM */</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dlm_begin_reco_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_begin_reco</span> <span class="o">*</span><span class="n">br</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dlm_begin_reco</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>

	<span class="cm">/* ok to return 0, domain has gone away */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_grab</span><span class="p">(</span><span class="n">dlm</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_RECO_STATE_FINALIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: node %u wants to recover node %u (%u:%u) &quot;</span>
		     <span class="s">&quot;but this node is in finalize state, waiting on finalize2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">br</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">br</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: node %u wants to recover node %u (%u:%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">br</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">br</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">,</span>
	     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span><span class="p">);</span>

	<span class="n">dlm_fire_domain_eviction_callbacks</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">br</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span> <span class="o">!=</span> <span class="n">O2NM_INVALID_NODE_NUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">recovery_map</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: new_master %u died, changing &quot;</span>
			     <span class="s">&quot;to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span><span class="p">,</span>
			     <span class="n">br</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: new_master %u NOT DEAD, changing &quot;</span>
			     <span class="s">&quot;to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span><span class="p">,</span>
			     <span class="n">br</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">);</span>
			<span class="cm">/* may not have seen the new master as dead yet */</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span> <span class="o">!=</span> <span class="n">O2NM_INVALID_NODE_NUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_NOTICE</span><span class="p">,</span> <span class="s">&quot;%s: dead_node previously set to %u, &quot;</span>
		     <span class="s">&quot;node %u changing it to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">br</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">br</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dlm_set_reco_master</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">br</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">);</span>
	<span class="n">dlm_set_reco_dead_node</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">br</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">recovery_map</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;recovery master %u sees %u as dead, but this &quot;</span>
		     <span class="s">&quot;node has not yet.  marking %u as dead</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">br</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">br</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">br</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">domain_map</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">live_nodes_map</span><span class="p">))</span>
			<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%u not in domain/live_nodes map &quot;</span>
			     <span class="s">&quot;so setting it in reco map manually</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">br</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">);</span>
		<span class="cm">/* force the recovery cleanup in __dlm_hb_node_down</span>
<span class="cm">		 * both of these will be cleared in a moment */</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">domain_map</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">br</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">live_nodes_map</span><span class="p">);</span>
		<span class="n">__dlm_hb_node_down</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">br</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">dlm_kick_recovery_thread</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: recovery started by node %u, for %u (%u:%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">br</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">br</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">,</span>
	     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span><span class="p">);</span>

	<span class="n">dlm_put</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define DLM_FINALIZE_STAGE2  0x01</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_send_finalize_reco_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_finalize_reco</span> <span class="n">fr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_node_iter</span> <span class="n">iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nodenum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stage</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;finishing recovery for node %s:%u, &quot;</span>
	     <span class="s">&quot;stage %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">stage</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
	<span class="n">dlm_node_iter_init</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">domain_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

<span class="nl">stage2:</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fr</span><span class="p">));</span>
	<span class="n">fr</span><span class="p">.</span><span class="n">node_idx</span> <span class="o">=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">;</span>
	<span class="n">fr</span><span class="p">.</span><span class="n">dead_node</span> <span class="o">=</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stage</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">fr</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">DLM_FINALIZE_STAGE2</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">nodenum</span> <span class="o">=</span> <span class="n">dlm_node_iter_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nodenum</span> <span class="o">==</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">node_num</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">o2net_send_message</span><span class="p">(</span><span class="n">DLM_FINALIZE_RECO_MSG</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">fr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fr</span><span class="p">),</span> <span class="n">nodenum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;Error %d when sending message %u (key &quot;</span>
			     <span class="s">&quot;0x%x) to node %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">DLM_FINALIZE_RECO_MSG</span><span class="p">,</span>
			     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">nodenum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dlm_is_host_down</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* this has no effect on this recovery</span>
<span class="cm">				 * session, so set the status to zero to</span>
<span class="cm">				 * finish out the last recovery */</span>
				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;node %u went down after this &quot;</span>
				     <span class="s">&quot;node finished recovery.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nodenum</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stage</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* reset the node_iter back to the top and send finalize2 */</span>
		<span class="n">iter</span><span class="p">.</span><span class="n">curnode</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">stage</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">stage2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dlm_finalize_reco_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_finalize_reco</span> <span class="o">*</span><span class="n">fr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dlm_finalize_reco</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stage</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* ok to return 0, domain has gone away */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_grab</span><span class="p">(</span><span class="n">dlm</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DLM_FINALIZE_STAGE2</span><span class="p">)</span>
		<span class="n">stage</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: node %u finalizing recovery stage%d of &quot;</span>
	     <span class="s">&quot;node %u (%u:%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">fr</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">stage</span><span class="p">,</span>
	     <span class="n">fr</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span> <span class="o">!=</span> <span class="n">fr</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;node %u sent recovery finalize msg, but node &quot;</span>
		     <span class="s">&quot;%u is supposed to be the new master, dead=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">fr</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span><span class="p">,</span> <span class="n">fr</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span> <span class="o">!=</span> <span class="n">fr</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;node %u sent recovery finalize msg for dead &quot;</span>
		     <span class="s">&quot;node %u, but node %u is supposed to be dead</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">fr</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">fr</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">stage</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">dlm_finish_local_lockres_recovery</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">fr</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">fr</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_RECO_STATE_FINALIZE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s: received finalize1 from &quot;</span>
				     <span class="s">&quot;new master %u for dead node %u, but &quot;</span>
				     <span class="s">&quot;this node has already received it!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">fr</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">fr</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">);</span>
				<span class="n">dlm_print_reco_node_status</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
				<span class="n">BUG</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">state</span> <span class="o">|=</span> <span class="n">DLM_RECO_STATE_FINALIZE</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_RECO_STATE_FINALIZE</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">mlog</span><span class="p">(</span><span class="n">ML_ERROR</span><span class="p">,</span> <span class="s">&quot;%s: received finalize2 from &quot;</span>
				     <span class="s">&quot;new master %u for dead node %u, but &quot;</span>
				     <span class="s">&quot;this node did not have finalize1!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">fr</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">fr</span><span class="o">-&gt;</span><span class="n">dead_node</span><span class="p">);</span>
				<span class="n">dlm_print_reco_node_status</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
				<span class="n">BUG</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DLM_RECO_STATE_FINALIZE</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>
			<span class="n">dlm_reset_recovery</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
			<span class="n">dlm_kick_recovery_thread</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">mlog</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: recovery done, reco master was %u, dead now %u, master now %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">fr</span><span class="o">-&gt;</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">dead_node</span><span class="p">,</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">reco</span><span class="p">.</span><span class="n">new_master</span><span class="p">);</span>

	<span class="n">dlm_put</span><span class="p">(</span><span class="n">dlm</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
