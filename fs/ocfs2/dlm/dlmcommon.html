<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ocfs2 › dlm › dlmcommon.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>dlmcommon.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* -*- mode: c; c-basic-offset: 8; -*-</span>
<span class="cm"> * vim: noexpandtab sw=8 ts=8 sts=0:</span>
<span class="cm"> *</span>
<span class="cm"> * dlmcommon.h</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004 Oracle.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public</span>
<span class="cm"> * License as published by the Free Software Foundation; either</span>
<span class="cm"> * version 2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public</span>
<span class="cm"> * License along with this program; if not, write to the</span>
<span class="cm"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 021110-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef DLMCOMMON_H</span>
<span class="cp">#define DLMCOMMON_H</span>

<span class="cp">#include &lt;linux/kref.h&gt;</span>

<span class="cp">#define DLM_HB_NODE_DOWN_PRI     (0xf000000)</span>
<span class="cp">#define DLM_HB_NODE_UP_PRI       (0x8000000)</span>

<span class="cp">#define DLM_LOCKID_NAME_MAX    32</span>

<span class="cp">#define DLM_DOMAIN_NAME_MAX_LEN    255</span>
<span class="cp">#define DLM_LOCK_RES_OWNER_UNKNOWN     O2NM_MAX_NODES</span>
<span class="cp">#define DLM_THREAD_SHUFFLE_INTERVAL    5     </span><span class="c1">// flush everything every 5 passes</span>
<span class="cp">#define DLM_THREAD_MS                  200   </span><span class="c1">// flush at least every 200 ms</span>

<span class="cp">#define DLM_HASH_SIZE_DEFAULT	(1 &lt;&lt; 17)</span>
<span class="cp">#if DLM_HASH_SIZE_DEFAULT &lt; PAGE_SIZE</span>
<span class="cp"># define DLM_HASH_PAGES		1</span>
<span class="cp">#else</span>
<span class="cp"># define DLM_HASH_PAGES		(DLM_HASH_SIZE_DEFAULT / PAGE_SIZE)</span>
<span class="cp">#endif</span>
<span class="cp">#define DLM_BUCKETS_PER_PAGE	(PAGE_SIZE / sizeof(struct hlist_head))</span>
<span class="cp">#define DLM_HASH_BUCKETS	(DLM_HASH_PAGES * DLM_BUCKETS_PER_PAGE)</span>

<span class="cm">/* Intended to make it easier for us to switch out hash functions */</span>
<span class="cp">#define dlm_lockid_hash(_n, _l) full_name_hash(_n, _l)</span>

<span class="k">enum</span> <span class="n">dlm_mle_type</span> <span class="p">{</span>
	<span class="n">DLM_MLE_BLOCK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">DLM_MLE_MASTER</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">DLM_MLE_MIGRATION</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">DLM_MLE_NUM_TYPES</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">master_hash_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">hb_events</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">spinlock</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wq</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">woken</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">mle_refs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">inuse</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">maybe_map</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">O2NM_MAX_NODES</span><span class="p">)];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vote_map</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">O2NM_MAX_NODES</span><span class="p">)];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">response_map</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">O2NM_MAX_NODES</span><span class="p">)];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_map</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">O2NM_MAX_NODES</span><span class="p">)];</span>
	<span class="n">u8</span> <span class="n">master</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">new_master</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">dlm_mle_type</span> <span class="n">type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">o2hb_callback_func</span> <span class="n">mle_hb_up</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">o2hb_callback_func</span> <span class="n">mle_hb_down</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">mleres</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mname</span><span class="p">[</span><span class="n">DLM_LOCKID_NAME_MAX</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mnamelen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mnamehash</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">dlm_ast_type</span> <span class="p">{</span>
	<span class="n">DLM_AST</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">DLM_BAST</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">DLM_ASTUNLOCK</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>


<span class="cp">#define LKM_VALID_FLAGS (LKM_VALBLK | LKM_CONVERT | LKM_UNLOCK | \</span>
<span class="cp">			 LKM_CANCEL | LKM_INVVALBLK | LKM_FORCE | \</span>
<span class="cp">			 LKM_RECOVERY | LKM_LOCAL | LKM_NOQUEUE)</span>

<span class="cp">#define DLM_RECOVERY_LOCK_NAME       &quot;$RECOVERY&quot;</span>
<span class="cp">#define DLM_RECOVERY_LOCK_NAME_LEN   9</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dlm_is_recovery_lock</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lock_name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">name_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">name_len</span> <span class="o">==</span> <span class="n">DLM_RECOVERY_LOCK_NAME_LEN</span> <span class="o">&amp;&amp;</span>
	    <span class="n">memcmp</span><span class="p">(</span><span class="n">lock_name</span><span class="p">,</span> <span class="n">DLM_RECOVERY_LOCK_NAME</span><span class="p">,</span> <span class="n">name_len</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define DLM_RECO_STATE_ACTIVE    0x0001</span>
<span class="cp">#define DLM_RECO_STATE_FINALIZE  0x0002</span>

<span class="k">struct</span> <span class="n">dlm_recovery_ctxt</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">resources</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">received</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node_data</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">new_master</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">dead_node</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_map</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">O2NM_MAX_NODES</span><span class="p">)];</span>
	<span class="n">wait_queue_head_t</span> <span class="n">event</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">dlm_ctxt_state</span> <span class="p">{</span>
	<span class="n">DLM_CTXT_NEW</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">DLM_CTXT_JOINED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">DLM_CTXT_IN_SHUTDOWN</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">DLM_CTXT_LEAVING</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_ctxt</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">**</span><span class="n">lockres_hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">dirty_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">purge_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">pending_asts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">pending_basts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tracking_list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">purge_count</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">spinlock</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">ast_lock</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">track_lock</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">node_num</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">joining_node</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">dlm_join_events</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">live_nodes_map</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">O2NM_MAX_NODES</span><span class="p">)];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">domain_map</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">O2NM_MAX_NODES</span><span class="p">)];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exit_domain_map</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">O2NM_MAX_NODES</span><span class="p">)];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">recovery_map</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">O2NM_MAX_NODES</span><span class="p">)];</span>
	<span class="k">struct</span> <span class="n">dlm_recovery_ctxt</span> <span class="n">reco</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">master_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">**</span><span class="n">master_hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">mle_hb_events</span><span class="p">;</span>

	<span class="cm">/* these give a really vague idea of the system load */</span>
	<span class="n">atomic_t</span> <span class="n">mle_tot_count</span><span class="p">[</span><span class="n">DLM_MLE_NUM_TYPES</span><span class="p">];</span>
	<span class="n">atomic_t</span> <span class="n">mle_cur_count</span><span class="p">[</span><span class="n">DLM_MLE_NUM_TYPES</span><span class="p">];</span>
	<span class="n">atomic_t</span> <span class="n">res_tot_count</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">res_cur_count</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">dlm_debug_ctxt</span> <span class="o">*</span><span class="n">dlm_debug_ctxt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dlm_debugfs_subroot</span><span class="p">;</span>

	<span class="cm">/* NOTE: Next three are protected by dlm_domain_lock */</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">dlm_refs</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">dlm_ctxt_state</span> <span class="n">dlm_state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_joins</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">o2hb_callback_func</span> <span class="n">dlm_hb_up</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">o2hb_callback_func</span> <span class="n">dlm_hb_down</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">dlm_thread_task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">dlm_reco_thread_task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">dlm_worker</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">dlm_thread_wq</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">dlm_reco_thread_wq</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">ast_wq</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">migration_wq</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">dispatched_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">work_list</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">work_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">dlm_domain_handlers</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">dlm_eviction_callbacks</span><span class="p">;</span>

	<span class="cm">/* The filesystem specifies this at domain registration.  We</span>
<span class="cm">	 * cache it here to know what to tell other nodes. */</span>
	<span class="k">struct</span> <span class="n">dlm_protocol_version</span> <span class="n">fs_locking_proto</span><span class="p">;</span>
	<span class="cm">/* This is the inter-dlm communication version */</span>
	<span class="k">struct</span> <span class="n">dlm_protocol_version</span> <span class="n">dlm_locking_proto</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="nf">dlm_lockres_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">lockres_hash</span><span class="p">[(</span><span class="n">i</span> <span class="o">/</span> <span class="n">DLM_BUCKETS_PER_PAGE</span><span class="p">)</span> <span class="o">%</span> <span class="n">DLM_HASH_PAGES</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">DLM_BUCKETS_PER_PAGE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="nf">dlm_master_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
						 <span class="kt">unsigned</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dlm</span><span class="o">-&gt;</span><span class="n">master_hash</span><span class="p">[(</span><span class="n">i</span> <span class="o">/</span> <span class="n">DLM_BUCKETS_PER_PAGE</span><span class="p">)</span> <span class="o">%</span> <span class="n">DLM_HASH_PAGES</span><span class="p">]</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">DLM_BUCKETS_PER_PAGE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* these keventd work queue items are for less-frequently</span>
<span class="cm"> * called functions that cannot be directly called from the</span>
<span class="cm"> * net message handlers for some reason, usually because</span>
<span class="cm"> * they need to send net messages of their own. */</span>
<span class="kt">void</span> <span class="n">dlm_dispatch_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">dlm_lock_resource</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">dlm_work_item</span><span class="p">;</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">dlm_workfunc_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">dlm_work_item</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">dlm_request_all_locks_priv</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">reco_master</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dead_node</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_mig_lockres_priv</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">lockres</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">real_master</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">extra_ref</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_assert_master_priv</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">lockres</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">request_from</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">ignore_higher</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_deref_lockres_priv</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">deref_res</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">deref_node</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_work_item</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">dlm_workfunc_t</span> <span class="o">*</span><span class="n">func</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dlm_request_all_locks_priv</span> <span class="n">ral</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">dlm_mig_lockres_priv</span> <span class="n">ml</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">dlm_assert_master_priv</span> <span class="n">am</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">dlm_deref_lockres_priv</span> <span class="n">dl</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dlm_init_work_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">dlm_work_item</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span>
				      <span class="n">dlm_workfunc_t</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">));</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">i</span><span class="o">-&gt;</span><span class="n">dlm</span> <span class="o">=</span> <span class="n">dlm</span><span class="p">;</span>  <span class="cm">/* must have already done a dlm_grab on this! */</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__dlm_set_joining_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
					  <span class="n">u8</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">dlm</span><span class="o">-&gt;</span><span class="n">joining_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlm</span><span class="o">-&gt;</span><span class="n">dlm_join_events</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define DLM_LOCK_RES_UNINITED             0x00000001</span>
<span class="cp">#define DLM_LOCK_RES_RECOVERING           0x00000002</span>
<span class="cp">#define DLM_LOCK_RES_READY                0x00000004</span>
<span class="cp">#define DLM_LOCK_RES_DIRTY                0x00000008</span>
<span class="cp">#define DLM_LOCK_RES_IN_PROGRESS          0x00000010</span>
<span class="cp">#define DLM_LOCK_RES_MIGRATING            0x00000020</span>
<span class="cp">#define DLM_LOCK_RES_DROPPING_REF         0x00000040</span>
<span class="cp">#define DLM_LOCK_RES_BLOCK_DIRTY          0x00001000</span>
<span class="cp">#define DLM_LOCK_RES_SETREF_INPROG        0x00002000</span>

<span class="cm">/* max milliseconds to wait to sync up a network failure with a node death */</span>
<span class="cp">#define DLM_NODE_DEATH_WAIT_MAX (5 * 1000)</span>

<span class="cp">#define DLM_PURGE_INTERVAL_MS   (8 * 1000)</span>

<span class="k">struct</span> <span class="n">dlm_lock_resource</span>
<span class="p">{</span>
	<span class="cm">/* WARNING: Please see the comment in dlm_init_lockres before</span>
<span class="cm">	 * adding fields here. */</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">hash_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">lockname</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kref</span>      <span class="n">refs</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Please keep granted, converting, and blocked in this order,</span>
<span class="cm">	 * as some funcs want to iterate over all lists.</span>
<span class="cm">	 *</span>
<span class="cm">	 * All four lists are protected by the hash&#39;s reference.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">granted</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">converting</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">blocked</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">purge</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * These two lists require you to hold an additional reference</span>
<span class="cm">	 * while they are on the list.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">dirty</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">recovering</span><span class="p">;</span> <span class="c1">// dlm_recovery_ctxt.resources list</span>

	<span class="cm">/* Added during init and removed during release */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tracking</span><span class="p">;</span>	<span class="cm">/* dlm-&gt;tracking_list */</span>

	<span class="cm">/* unused lock resources have their last_used stamped and are</span>
<span class="cm">	 * put on a list for the dlm thread to run. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>    <span class="n">last_used</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="n">migration_pending</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">asts_reserved</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">spinlock</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wq</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">owner</span><span class="p">;</span>              <span class="c1">//node which owns the lock resource, or unknown</span>
	<span class="n">u16</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">lvb</span><span class="p">[</span><span class="n">DLM_LVB_LEN</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">inflight_locks</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">refmap</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">O2NM_MAX_NODES</span><span class="p">)];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_migratable_lock</span>
<span class="p">{</span>
	<span class="n">__be64</span> <span class="n">cookie</span><span class="p">;</span>

	<span class="cm">/* these 3 are just padding for the in-memory structure, but</span>
<span class="cm">	 * list and flags are actually used when sent over the wire */</span>
	<span class="n">__be16</span> <span class="n">pad1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">list</span><span class="p">;</span>  <span class="c1">// 0=granted, 1=converting, 2=blocked</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">s8</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">convert_type</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">highest_blocked</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">node</span><span class="p">;</span>
<span class="p">};</span>  <span class="c1">// 16 bytes</span>

<span class="k">struct</span> <span class="n">dlm_lock</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_migratable_lock</span> <span class="n">ml</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">ast_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">bast_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">lockres</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">spinlock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">lock_refs</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>ast and bast must be callable while holding a spinlock!</p></td><td class="code"><div class="highlight"><pre>	<span class="n">dlm_astlockfunc_t</span> <span class="o">*</span><span class="n">ast</span><span class="p">;</span>
	<span class="n">dlm_bastlockfunc_t</span> <span class="o">*</span><span class="n">bast</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">astdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lockstatus</span> <span class="o">*</span><span class="n">lksb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">ast_pending</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
		 <span class="nl">bast_pending:</span><span class="mi">1</span><span class="p">,</span>
		 <span class="nl">convert_pending:</span><span class="mi">1</span><span class="p">,</span>
		 <span class="nl">lock_pending:</span><span class="mi">1</span><span class="p">,</span>
		 <span class="nl">cancel_pending:</span><span class="mi">1</span><span class="p">,</span>
		 <span class="nl">unlock_pending:</span><span class="mi">1</span><span class="p">,</span>
		 <span class="nl">lksb_kernel_allocated:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>


<span class="cp">#define DLM_LKSB_UNUSED1           0x01</span>
<span class="cp">#define DLM_LKSB_PUT_LVB           0x02</span>
<span class="cp">#define DLM_LKSB_GET_LVB           0x04</span>
<span class="cp">#define DLM_LKSB_UNUSED2           0x08</span>
<span class="cp">#define DLM_LKSB_UNUSED3           0x10</span>
<span class="cp">#define DLM_LKSB_UNUSED4           0x20</span>
<span class="cp">#define DLM_LKSB_UNUSED5           0x40</span>
<span class="cp">#define DLM_LKSB_UNUSED6           0x80</span>


<span class="k">enum</span> <span class="n">dlm_lockres_list</span> <span class="p">{</span>
	<span class="n">DLM_GRANTED_LIST</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">DLM_CONVERTING_LIST</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">DLM_BLOCKED_LIST</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dlm_lvb_is_empty</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">lvb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">DLM_LVB_LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lvb</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">dlm_list_in_text</span><span class="p">(</span><span class="k">enum</span> <span class="n">dlm_lockres_list</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">DLM_GRANTED_LIST</span><span class="p">)</span>
		<span class="k">return</span> <span class="s">&quot;granted&quot;</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">DLM_CONVERTING_LIST</span><span class="p">)</span>
		<span class="k">return</span> <span class="s">&quot;converting&quot;</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">DLM_BLOCKED_LIST</span><span class="p">)</span>
		<span class="k">return</span> <span class="s">&quot;blocked&quot;</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span>
<span class="nf">dlm_list_idx_to_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dlm_lockres_list</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">DLM_GRANTED_LIST</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">granted</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">DLM_CONVERTING_LIST</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">converting</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">DLM_BLOCKED_LIST</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>




<span class="k">struct</span> <span class="n">dlm_node_iter</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_map</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">O2NM_MAX_NODES</span><span class="p">)];</span>
	<span class="kt">int</span> <span class="n">curnode</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">enum</span> <span class="p">{</span>
	<span class="n">DLM_MASTER_REQUEST_MSG</span>		<span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
	<span class="n">DLM_UNUSED_MSG1</span>			<span class="o">=</span> <span class="mi">501</span><span class="p">,</span>
	<span class="n">DLM_ASSERT_MASTER_MSG</span>		<span class="o">=</span> <span class="mi">502</span><span class="p">,</span>
	<span class="n">DLM_CREATE_LOCK_MSG</span>		<span class="o">=</span> <span class="mi">503</span><span class="p">,</span>
	<span class="n">DLM_CONVERT_LOCK_MSG</span>		<span class="o">=</span> <span class="mi">504</span><span class="p">,</span>
	<span class="n">DLM_PROXY_AST_MSG</span>		<span class="o">=</span> <span class="mi">505</span><span class="p">,</span>
	<span class="n">DLM_UNLOCK_LOCK_MSG</span>		<span class="o">=</span> <span class="mi">506</span><span class="p">,</span>
	<span class="n">DLM_DEREF_LOCKRES_MSG</span>		<span class="o">=</span> <span class="mi">507</span><span class="p">,</span>
	<span class="n">DLM_MIGRATE_REQUEST_MSG</span>		<span class="o">=</span> <span class="mi">508</span><span class="p">,</span>
	<span class="n">DLM_MIG_LOCKRES_MSG</span>		<span class="o">=</span> <span class="mi">509</span><span class="p">,</span>
	<span class="n">DLM_QUERY_JOIN_MSG</span>		<span class="o">=</span> <span class="mi">510</span><span class="p">,</span>
	<span class="n">DLM_ASSERT_JOINED_MSG</span>		<span class="o">=</span> <span class="mi">511</span><span class="p">,</span>
	<span class="n">DLM_CANCEL_JOIN_MSG</span>		<span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
	<span class="n">DLM_EXIT_DOMAIN_MSG</span>		<span class="o">=</span> <span class="mi">513</span><span class="p">,</span>
	<span class="n">DLM_MASTER_REQUERY_MSG</span>		<span class="o">=</span> <span class="mi">514</span><span class="p">,</span>
	<span class="n">DLM_LOCK_REQUEST_MSG</span>		<span class="o">=</span> <span class="mi">515</span><span class="p">,</span>
	<span class="n">DLM_RECO_DATA_DONE_MSG</span>		<span class="o">=</span> <span class="mi">516</span><span class="p">,</span>
	<span class="n">DLM_BEGIN_RECO_MSG</span>		<span class="o">=</span> <span class="mi">517</span><span class="p">,</span>
	<span class="n">DLM_FINALIZE_RECO_MSG</span>		<span class="o">=</span> <span class="mi">518</span><span class="p">,</span>
	<span class="n">DLM_QUERY_REGION</span>		<span class="o">=</span> <span class="mi">519</span><span class="p">,</span>
	<span class="n">DLM_QUERY_NODEINFO</span>		<span class="o">=</span> <span class="mi">520</span><span class="p">,</span>
	<span class="n">DLM_BEGIN_EXIT_DOMAIN_MSG</span>	<span class="o">=</span> <span class="mi">521</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_reco_node_data</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">node_num</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">DLM_RECO_NODE_DATA_DEAD</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="n">DLM_RECO_NODE_DATA_INIT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">DLM_RECO_NODE_DATA_REQUESTING</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">DLM_RECO_NODE_DATA_REQUESTED</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">DLM_RECO_NODE_DATA_RECEIVING</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">DLM_RECO_NODE_DATA_DONE</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">DLM_RECO_NODE_DATA_FINALIZE_SENT</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">enum</span> <span class="p">{</span>
	<span class="n">DLM_MASTER_RESP_NO</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">DLM_MASTER_RESP_YES</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">DLM_MASTER_RESP_MAYBE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">DLM_MASTER_RESP_ERROR</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">dlm_master_request</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">node_idx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">namelen</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">pad1</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">name</span><span class="p">[</span><span class="n">O2NM_MAX_NAME_LEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define DLM_ASSERT_RESPONSE_REASSERT       0x00000001</span>
<span class="cp">#define DLM_ASSERT_RESPONSE_MASTERY_REF    0x00000002</span>

<span class="cp">#define DLM_ASSERT_MASTER_MLE_CLEANUP      0x00000001</span>
<span class="cp">#define DLM_ASSERT_MASTER_REQUERY          0x00000002</span>
<span class="cp">#define DLM_ASSERT_MASTER_FINISH_MIGRATION 0x00000004</span>
<span class="k">struct</span> <span class="n">dlm_assert_master</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">node_idx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">namelen</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">pad1</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">name</span><span class="p">[</span><span class="n">O2NM_MAX_NAME_LEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define DLM_MIGRATE_RESPONSE_MASTERY_REF   0x00000001</span>

<span class="k">struct</span> <span class="n">dlm_migrate_request</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">master</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">new_master</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">namelen</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pad1</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">pad2</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">name</span><span class="p">[</span><span class="n">O2NM_MAX_NAME_LEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_master_requery</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">pad1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pad2</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">node_idx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">namelen</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">pad3</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">name</span><span class="p">[</span><span class="n">O2NM_MAX_NAME_LEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define DLM_MRES_RECOVERY   0x01</span>
<span class="cp">#define DLM_MRES_MIGRATION  0x02</span>
<span class="cp">#define DLM_MRES_ALL_DONE   0x04</span>

<span class="cm">/*</span>
<span class="cm"> * We would like to get one whole lockres into a single network</span>
<span class="cm"> * message whenever possible.  Generally speaking, there will be</span>
<span class="cm"> * at most one dlm_lock on a lockres for each node in the cluster,</span>
<span class="cm"> * plus (infrequently) any additional locks coming in from userdlm.</span>
<span class="cm"> *</span>
<span class="cm"> * struct _dlm_lockres_page</span>
<span class="cm"> * {</span>
<span class="cm"> * 	dlm_migratable_lockres mres;</span>
<span class="cm"> * 	dlm_migratable_lock ml[DLM_MAX_MIGRATABLE_LOCKS];</span>
<span class="cm"> * 	u8 pad[DLM_MIG_LOCKRES_RESERVED];</span>
<span class="cm"> * };</span>
<span class="cm"> *</span>
<span class="cm"> * from ../cluster/tcp.h</span>
<span class="cm"> *    NET_MAX_PAYLOAD_BYTES  (4096 - sizeof(net_msg))</span>
<span class="cm"> *    (roughly 4080 bytes)</span>
<span class="cm"> * and sizeof(dlm_migratable_lockres) = 112 bytes</span>
<span class="cm"> * and sizeof(dlm_migratable_lock) = 16 bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Choosing DLM_MAX_MIGRATABLE_LOCKS=240 and</span>
<span class="cm"> * DLM_MIG_LOCKRES_RESERVED=128 means we have this:</span>
<span class="cm"> *</span>
<span class="cm"> *  (DLM_MAX_MIGRATABLE_LOCKS * sizeof(dlm_migratable_lock)) +</span>
<span class="cm"> *     sizeof(dlm_migratable_lockres) + DLM_MIG_LOCKRES_RESERVED =</span>
<span class="cm"> *        NET_MAX_PAYLOAD_BYTES</span>
<span class="cm"> *  (240 * 16) + 112 + 128 = 4080</span>
<span class="cm"> *</span>
<span class="cm"> * So a lockres would need more than 240 locks before it would</span>
<span class="cm"> * use more than one network packet to recover.  Not too bad.</span>
<span class="cm"> */</span>
<span class="cp">#define DLM_MAX_MIGRATABLE_LOCKS   240</span>

<span class="k">struct</span> <span class="n">dlm_migratable_lockres</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">master</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">lockname_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">num_locks</span><span class="p">;</span>    <span class="c1">// locks sent in this structure</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">total_locks</span><span class="p">;</span> <span class="c1">// locks to be sent for this migration cookie</span>
	<span class="n">__be64</span> <span class="n">mig_cookie</span><span class="p">;</span>  <span class="c1">// cookie for this lockres migration</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>or zero if not needed
16 bytes</p></td><td class="code"><div class="highlight"><pre>	<span class="n">u8</span> <span class="n">lockname</span><span class="p">[</span><span class="n">DLM_LOCKID_NAME_MAX</span><span class="p">];</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>48 bytes</p></td><td class="code"><div class="highlight"><pre>	<span class="n">u8</span> <span class="n">lvb</span><span class="p">[</span><span class="n">DLM_LVB_LEN</span><span class="p">];</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>112 bytes</p></td><td class="code"><div class="highlight"><pre>	<span class="k">struct</span> <span class="n">dlm_migratable_lock</span> <span class="n">ml</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// 16 bytes each, begins at byte 112</span>
<span class="p">};</span>
<span class="cp">#define DLM_MIG_LOCKRES_MAX_LEN  \</span>
<span class="cp">	(sizeof(struct dlm_migratable_lockres) + \</span>
<span class="cp">	 (sizeof(struct dlm_migratable_lock) * \</span>
<span class="cp">	  DLM_MAX_MIGRATABLE_LOCKS) )</span>

<span class="cm">/* from above, 128 bytes</span>
<span class="cm"> * for some undetermined future use */</span>
<span class="cp">#define DLM_MIG_LOCKRES_RESERVED   (NET_MAX_PAYLOAD_BYTES - \</span>
<span class="cp">				    DLM_MIG_LOCKRES_MAX_LEN)</span>

<span class="k">struct</span> <span class="n">dlm_create_lock</span>
<span class="p">{</span>
	<span class="n">__be64</span> <span class="n">cookie</span><span class="p">;</span>

	<span class="n">__be32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pad1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">node_idx</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">requested_type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">namelen</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">name</span><span class="p">[</span><span class="n">O2NM_MAX_NAME_LEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_convert_lock</span>
<span class="p">{</span>
	<span class="n">__be64</span> <span class="n">cookie</span><span class="p">;</span>

	<span class="n">__be32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pad1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">node_idx</span><span class="p">;</span>
	<span class="n">s8</span> <span class="n">requested_type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">namelen</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">name</span><span class="p">[</span><span class="n">O2NM_MAX_NAME_LEN</span><span class="p">];</span>

	<span class="n">s8</span> <span class="n">lvb</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>
<span class="cp">#define DLM_CONVERT_LOCK_MAX_LEN  (sizeof(struct dlm_convert_lock)+DLM_LVB_LEN)</span>

<span class="k">struct</span> <span class="n">dlm_unlock_lock</span>
<span class="p">{</span>
	<span class="n">__be64</span> <span class="n">cookie</span><span class="p">;</span>

	<span class="n">__be32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">pad1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">node_idx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">namelen</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">name</span><span class="p">[</span><span class="n">O2NM_MAX_NAME_LEN</span><span class="p">];</span>

	<span class="n">s8</span> <span class="n">lvb</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>
<span class="cp">#define DLM_UNLOCK_LOCK_MAX_LEN  (sizeof(struct dlm_unlock_lock)+DLM_LVB_LEN)</span>

<span class="k">struct</span> <span class="n">dlm_proxy_ast</span>
<span class="p">{</span>
	<span class="n">__be64</span> <span class="n">cookie</span><span class="p">;</span>

	<span class="n">__be32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">node_idx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">blocked_type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">namelen</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">name</span><span class="p">[</span><span class="n">O2NM_MAX_NAME_LEN</span><span class="p">];</span>

	<span class="n">s8</span> <span class="n">lvb</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>
<span class="cp">#define DLM_PROXY_AST_MAX_LEN  (sizeof(struct dlm_proxy_ast)+DLM_LVB_LEN)</span>

<span class="cp">#define DLM_MOD_KEY (0x666c6172)</span>
<span class="k">enum</span> <span class="n">dlm_query_join_response_code</span> <span class="p">{</span>
	<span class="n">JOIN_DISALLOW</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">JOIN_OK</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">JOIN_OK_NO_MAP</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">JOIN_PROTOCOL_MISMATCH</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_query_join_packet</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">code</span><span class="p">;</span>	<span class="cm">/* Response code.  dlm_minor and fs_minor</span>
<span class="cm">			   are only valid if this is JOIN_OK */</span>
	<span class="n">u8</span> <span class="n">dlm_minor</span><span class="p">;</span>	<span class="cm">/* The minor version of the protocol the</span>
<span class="cm">			   dlm is speaking. */</span>
	<span class="n">u8</span> <span class="n">fs_minor</span><span class="p">;</span>	<span class="cm">/* The minor version of the protocol the</span>
<span class="cm">			   filesystem is speaking. */</span>
	<span class="n">u8</span> <span class="n">reserved</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">dlm_query_join_response</span> <span class="p">{</span>
	<span class="n">__be32</span> <span class="n">intval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_query_join_packet</span> <span class="n">packet</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_lock_request</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">node_idx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dead_node</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">pad1</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">pad2</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_reco_data_done</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">node_idx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dead_node</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">pad1</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">pad2</span><span class="p">;</span>

	<span class="cm">/* unused for now */</span>
	<span class="cm">/* eventually we can use this to attempt</span>
<span class="cm">	 * lvb recovery based on each node&#39;s info */</span>
	<span class="n">u8</span> <span class="n">reco_lvb</span><span class="p">[</span><span class="n">DLM_LVB_LEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_begin_reco</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">node_idx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dead_node</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">pad1</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">pad2</span><span class="p">;</span>
<span class="p">};</span>


<span class="cp">#define BITS_PER_BYTE 8</span>
<span class="cp">#define BITS_TO_BYTES(bits) (((bits)+BITS_PER_BYTE-1)/BITS_PER_BYTE)</span>

<span class="k">struct</span> <span class="n">dlm_query_join_request</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">node_idx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pad1</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">name_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_protocol_version</span> <span class="n">dlm_proto</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_protocol_version</span> <span class="n">fs_proto</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">domain</span><span class="p">[</span><span class="n">O2NM_MAX_NAME_LEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">node_map</span><span class="p">[</span><span class="n">BITS_TO_BYTES</span><span class="p">(</span><span class="n">O2NM_MAX_NODES</span><span class="p">)];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_assert_joined</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">node_idx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pad1</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">name_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">domain</span><span class="p">[</span><span class="n">O2NM_MAX_NAME_LEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_cancel_join</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">node_idx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pad1</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">name_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">domain</span><span class="p">[</span><span class="n">O2NM_MAX_NAME_LEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_query_region</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">qr_node</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">qr_numregions</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">qr_namelen</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pad1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">qr_domain</span><span class="p">[</span><span class="n">O2NM_MAX_NAME_LEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">qr_regions</span><span class="p">[</span><span class="n">O2HB_MAX_REGION_NAME_LEN</span> <span class="o">*</span> <span class="n">O2NM_MAX_REGIONS</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_node_info</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">ni_nodenum</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pad1</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">ni_ipv4_port</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">ni_ipv4_address</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_query_nodeinfo</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">qn_nodenum</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">qn_numnodes</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">qn_namelen</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pad1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">qn_domain</span><span class="p">[</span><span class="n">O2NM_MAX_NAME_LEN</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">dlm_node_info</span> <span class="n">qn_nodes</span><span class="p">[</span><span class="n">O2NM_MAX_NODES</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_exit_domain</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">node_idx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pad1</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_finalize_reco</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">node_idx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dead_node</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pad1</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">pad2</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_deref_lockres</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">pad1</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pad2</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">node_idx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">namelen</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">name</span><span class="p">[</span><span class="n">O2NM_MAX_NAME_LEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">dlm_status</span>
<span class="nf">__dlm_lockres_state_to_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">dlm_status</span> <span class="n">status</span> <span class="o">=</span> <span class="n">DLM_NORMAL</span><span class="p">;</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_RECOVERING</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">DLM_RECOVERING</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_MIGRATING</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">DLM_MIGRATING</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">DLM_LOCK_RES_IN_PROGRESS</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">DLM_FORWARD</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">dlm_get_lock_cookie_node</span><span class="p">(</span><span class="n">u64</span> <span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">cookie</span> <span class="o">&gt;&gt;=</span> <span class="mi">56</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">cookie</span> <span class="o">&amp;</span> <span class="mh">0xffULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">dlm_get_lock_cookie_seq</span><span class="p">(</span><span class="n">u64</span> <span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">cookie</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x00ffffffffffffffULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span> <span class="n">dlm_new_lock</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">u8</span> <span class="n">node</span><span class="p">,</span> <span class="n">u64</span> <span class="n">cookie</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dlm_lockstatus</span> <span class="o">*</span><span class="n">lksb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_lock_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_lock_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">dlm_lock_attach_lockres</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">dlm_create_lock_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_convert_lock_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_proxy_ast_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			  <span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">dlm_revert_pending_convert</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_revert_pending_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">dlm_unlock_lock_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_commit_pending_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_commit_pending_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">dlm_launch_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_complete_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_launch_recovery_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_complete_recovery_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_wait_for_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_kick_recovery_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_is_node_dead</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">node</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_wait_for_node_death</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_wait_for_node_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="n">u8</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">dlm_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm_grab</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_domain_fully_joined</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__dlm_lockres_calc_usage</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_lockres_calc_usage</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dlm_lockres_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* This is called on every lookup, so it might be worth</span>
<span class="cm">	 * inlining. */</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">dlm_lockres_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__dlm_unhash_lockres</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__dlm_insert_lockres</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span> <span class="n">__dlm_lookup_lockres_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
						     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
						     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
						     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span> <span class="n">__dlm_lookup_lockres</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
						<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span> <span class="n">dlm_lookup_lockres</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
					      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">dlm_is_host_down</span><span class="p">(</span><span class="kt">int</span> <span class="n">errno</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span> <span class="n">dlm_get_lock_resource</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
						 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lockid</span><span class="p">,</span>
						 <span class="kt">int</span> <span class="n">namelen</span><span class="p">,</span>
						 <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">dlm_new_lockres</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
					  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">dlm_lockres_set_refmap_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_lockres_clear_refmap_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">dlm_lockres_drop_inflight_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_lockres_grab_inflight_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">dlm_queue_ast</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_queue_bast</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__dlm_queue_ast</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__dlm_queue_bast</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_do_local_ast</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_do_remote_ast</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_do_local_bast</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">blocked_type</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_send_proxy_ast_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">msg_type</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">blocked_type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dlm_send_proxy_bast</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">blocked_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dlm_send_proxy_ast_msg</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">DLM_BAST</span><span class="p">,</span>
				      <span class="n">blocked_type</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dlm_send_proxy_ast</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dlm_send_proxy_ast_msg</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">DLM_AST</span><span class="p">,</span>
				      <span class="mi">0</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">dlm_print_one_lock_resource</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__dlm_print_one_lock_resource</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>

<span class="n">u8</span> <span class="n">dlm_nm_this_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_kick_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__dlm_dirty_lockres</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>


<span class="kt">int</span> <span class="n">dlm_nm_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_heartbeat_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_hb_node_down_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2nm_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_hb_node_up_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2nm_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">dlm_empty_lockres</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_finish_migration</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
			 <span class="n">u8</span> <span class="n">old_master</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_lockres_release_ast</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__dlm_lockres_reserve_ast</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">dlm_master_request_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_assert_master_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_assert_master_post_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ret_data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_deref_lockres_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_migrate_request_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_mig_lockres_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_master_requery_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_request_all_locks_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_reco_data_done_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_begin_reco_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_finalize_reco_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">o2net_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="o">**</span><span class="n">ret_data</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_do_master_requery</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
			  <span class="n">u8</span> <span class="n">nodenum</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">real_master</span><span class="p">);</span>


<span class="kt">int</span> <span class="n">dlm_dispatch_assert_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">ignore_higher</span><span class="p">,</span>
			       <span class="n">u8</span> <span class="n">request_from</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="n">flags</span><span class="p">);</span>


<span class="kt">int</span> <span class="n">dlm_send_one_lockres</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">dlm_migratable_lockres</span> <span class="o">*</span><span class="n">mres</span><span class="p">,</span>
			 <span class="n">u8</span> <span class="n">send_to</span><span class="p">,</span>
			 <span class="n">u8</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_move_lockres_to_recovery_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>

<span class="cm">/* will exit holding res-&gt;spinlock, but may drop in function */</span>
<span class="kt">void</span> <span class="n">__dlm_wait_on_lockres_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__dlm_wait_on_lockres_flags_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/* will exit holding res-&gt;spinlock, but may drop in function */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__dlm_wait_on_lockres</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__dlm_wait_on_lockres_flags</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="p">(</span><span class="n">DLM_LOCK_RES_IN_PROGRESS</span><span class="o">|</span>
				    	  <span class="n">DLM_LOCK_RES_RECOVERING</span><span class="o">|</span>
					  <span class="n">DLM_LOCK_RES_MIGRATING</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__dlm_unlink_mle</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__dlm_insert_mle</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_master_list_entry</span> <span class="o">*</span><span class="n">mle</span><span class="p">);</span>

<span class="cm">/* create/destroy slab caches */</span>
<span class="kt">int</span> <span class="n">dlm_init_master_caches</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_destroy_master_caches</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">dlm_init_lock_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_destroy_lock_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">dlm_init_mle_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_destroy_mle_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">dlm_hb_event_notify_attached</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node_up</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_drop_lockres_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_clean_master_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
			   <span class="n">u8</span> <span class="n">dead_node</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_force_free_mles</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_lock_basts_flushed</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__dlm_lockres_has_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__dlm_lockres_unused</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="nf">dlm_lock_mode_name</span><span class="p">(</span><span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">LKM_EXMODE</span>:
			<span class="k">return</span> <span class="s">&quot;EX&quot;</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LKM_PRMODE</span>:
			<span class="k">return</span> <span class="s">&quot;PR&quot;</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LKM_NLMODE</span>:
			<span class="k">return</span> <span class="s">&quot;NL&quot;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="s">&quot;UNKNOWN&quot;</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dlm_lock_compatible</span><span class="p">(</span><span class="kt">int</span> <span class="n">existing</span><span class="p">,</span> <span class="kt">int</span> <span class="n">request</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* NO_LOCK compatible with all */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request</span> <span class="o">==</span> <span class="n">LKM_NLMODE</span> <span class="o">||</span>
	    <span class="n">existing</span> <span class="o">==</span> <span class="n">LKM_NLMODE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* EX incompatible with all non-NO_LOCK */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request</span> <span class="o">==</span> <span class="n">LKM_EXMODE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* request must be PR, which is compatible with PR */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">existing</span> <span class="o">==</span> <span class="n">LKM_PRMODE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dlm_lock_on_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lock</span> <span class="o">*</span><span class="n">tmplock</span><span class="p">;</span>

	<span class="n">list_for_each</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmplock</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_lock</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmplock</span> <span class="o">==</span> <span class="n">lock</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">dlm_status</span> <span class="nf">dlm_err_to_dlm_status</span><span class="p">(</span><span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">dlm_status</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">DLM_SYSERR</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ETIMEDOUT</span> <span class="o">||</span> <span class="n">o2net_link_down</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">DLM_NOLOCKMGR</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">DLM_BADPARAM</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">DLM_IVBUFLEN</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">DLM_BADARGS</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dlm_node_iter_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">dlm_node_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">node_map</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">node_map</span><span class="p">));</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">curnode</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dlm_node_iter_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_node_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bit</span><span class="p">;</span>
	<span class="n">bit</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">node_map</span><span class="p">,</span> <span class="n">O2NM_MAX_NODES</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">curnode</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&gt;=</span> <span class="n">O2NM_MAX_NODES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">curnode</span> <span class="o">=</span> <span class="n">O2NM_MAX_NODES</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">curnode</span> <span class="o">=</span> <span class="n">bit</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">bit</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dlm_set_lockres_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
					 <span class="n">u8</span> <span class="n">owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">owner</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dlm_change_lockres_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ctxt</span> <span class="o">*</span><span class="n">dlm</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">dlm_lock_resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
					    <span class="n">u8</span> <span class="n">owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">owner</span> <span class="o">!=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">)</span>
		<span class="n">dlm_set_lockres_owner</span><span class="p">(</span><span class="n">dlm</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">owner</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* DLMCOMMON_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
