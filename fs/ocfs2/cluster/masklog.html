<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ocfs2 › cluster › masklog.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>masklog.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* -*- mode: c; c-basic-offset: 8; -*-</span>
<span class="cm"> * vim: noexpandtab sw=8 ts=8 sts=0:</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005 Oracle.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public</span>
<span class="cm"> * License as published by the Free Software Foundation; either</span>
<span class="cm"> * version 2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public</span>
<span class="cm"> * License along with this program; if not, write to the</span>
<span class="cm"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 021110-1307, USA.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef O2CLUSTER_MASKLOG_H</span>
<span class="cp">#define O2CLUSTER_MASKLOG_H</span>

<span class="cm">/*</span>
<span class="cm"> * For now this is a trivial wrapper around printk() that gives the critical</span>
<span class="cm"> * ability to enable sets of debugging output at run-time.  In the future this</span>
<span class="cm"> * will almost certainly be redirected to relayfs so that it can pay a</span>
<span class="cm"> * substantially lower heisenberg tax.</span>
<span class="cm"> *</span>
<span class="cm"> * Callers associate the message with a bitmask and a global bitmask is</span>
<span class="cm"> * maintained with help from /proc.  If any of the bits match the message is</span>
<span class="cm"> * output.</span>
<span class="cm"> *</span>
<span class="cm"> * We must have efficient bit tests on i386 and it seems gcc still emits crazy</span>
<span class="cm"> * code for the 64bit compare.  It emits very good code for the dual unsigned</span>
<span class="cm"> * long tests, though, completely avoiding tests that can never pass if the</span>
<span class="cm"> * caller gives a constant bitmask that fills one of the longs with all 0s.  So</span>
<span class="cm"> * the desire is to have almost all of the calls decided on by comparing just</span>
<span class="cm"> * one of the longs.  This leads to having infrequently given bits that are</span>
<span class="cm"> * frequently matched in the high bits.</span>
<span class="cm"> *</span>
<span class="cm"> * _ERROR and _NOTICE are used for messages that always go to the console and</span>
<span class="cm"> * have appropriate KERN_ prefixes.  We wrap these in our function instead of</span>
<span class="cm"> * just calling printk() so that this can eventually make its way through</span>
<span class="cm"> * relayfs along with the debugging messages.  Everything else gets KERN_DEBUG.</span>
<span class="cm"> * The inline tests and macro dance give GCC the opportunity to quite cleverly</span>
<span class="cm"> * only emit the appropriage printk() when the caller passes in a constant</span>
<span class="cm"> * mask, as is almost always the case.</span>
<span class="cm"> *</span>
<span class="cm"> * All this bitmask nonsense is managed from the files under</span>
<span class="cm"> * /sys/fs/o2cb/logmask/.  Reading the files gives a straightforward</span>
<span class="cm"> * indication of which bits are allowed (allow) or denied (off/deny).</span>
<span class="cm"> * 	ENTRY deny</span>
<span class="cm"> * 	EXIT deny</span>
<span class="cm"> * 	TCP off</span>
<span class="cm"> * 	MSG off</span>
<span class="cm"> * 	SOCKET off</span>
<span class="cm"> * 	ERROR allow</span>
<span class="cm"> * 	NOTICE allow</span>
<span class="cm"> *</span>
<span class="cm"> * Writing changes the state of a given bit and requires a strictly formatted</span>
<span class="cm"> * single write() call:</span>
<span class="cm"> *</span>
<span class="cm"> * 	write(fd, &quot;allow&quot;, 5);</span>
<span class="cm"> *</span>
<span class="cm"> * Echoing allow/deny/off string into the logmask files can flip the bits</span>
<span class="cm"> * on or off as expected; here is the bash script for example:</span>
<span class="cm"> *</span>
<span class="cm"> * log_mask=&quot;/sys/fs/o2cb/log_mask&quot;</span>
<span class="cm"> * for node in ENTRY EXIT TCP MSG SOCKET ERROR NOTICE; do</span>
<span class="cm"> *	echo allow &gt;&quot;$log_mask&quot;/&quot;$node&quot;</span>
<span class="cm"> * done</span>
<span class="cm"> *</span>
<span class="cm"> * The debugfs.ocfs2 tool can also flip the bits with the -l option:</span>
<span class="cm"> *</span>
<span class="cm"> * debugfs.ocfs2 -l TCP allow</span>
<span class="cm"> */</span>

<span class="cm">/* for task_struct */</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>

<span class="cm">/* bits that are frequently given and infrequently matched in the low word */</span>
<span class="cm">/* NOTE: If you add a flag, you need to also update masklog.c! */</span>
<span class="cp">#define ML_TCP		0x0000000000000001ULL </span><span class="cm">/* net cluster/tcp.c */</span><span class="cp"></span>
<span class="cp">#define ML_MSG		0x0000000000000002ULL </span><span class="cm">/* net network messages */</span><span class="cp"></span>
<span class="cp">#define ML_SOCKET	0x0000000000000004ULL </span><span class="cm">/* net socket lifetime */</span><span class="cp"></span>
<span class="cp">#define ML_HEARTBEAT	0x0000000000000008ULL </span><span class="cm">/* hb all heartbeat tracking */</span><span class="cp"></span>
<span class="cp">#define ML_HB_BIO	0x0000000000000010ULL </span><span class="cm">/* hb io tracing */</span><span class="cp"></span>
<span class="cp">#define ML_DLMFS	0x0000000000000020ULL </span><span class="cm">/* dlm user dlmfs */</span><span class="cp"></span>
<span class="cp">#define ML_DLM		0x0000000000000040ULL </span><span class="cm">/* dlm general debugging */</span><span class="cp"></span>
<span class="cp">#define ML_DLM_DOMAIN	0x0000000000000080ULL </span><span class="cm">/* dlm domain debugging */</span><span class="cp"></span>
<span class="cp">#define ML_DLM_THREAD	0x0000000000000100ULL </span><span class="cm">/* dlm domain thread */</span><span class="cp"></span>
<span class="cp">#define ML_DLM_MASTER	0x0000000000000200ULL </span><span class="cm">/* dlm master functions */</span><span class="cp"></span>
<span class="cp">#define ML_DLM_RECOVERY	0x0000000000000400ULL </span><span class="cm">/* dlm master functions */</span><span class="cp"></span>
<span class="cp">#define ML_DLM_GLUE	0x0000000000000800ULL </span><span class="cm">/* ocfs2 dlm glue layer */</span><span class="cp"></span>
<span class="cp">#define ML_VOTE		0x0000000000001000ULL </span><span class="cm">/* ocfs2 node messaging  */</span><span class="cp"></span>
<span class="cp">#define ML_CONN		0x0000000000002000ULL </span><span class="cm">/* net connection management */</span><span class="cp"></span>
<span class="cp">#define ML_QUORUM	0x0000000000004000ULL </span><span class="cm">/* net connection quorum */</span><span class="cp"></span>
<span class="cp">#define ML_BASTS	0x0000000000008000ULL </span><span class="cm">/* dlmglue asts and basts */</span><span class="cp"></span>
<span class="cp">#define ML_CLUSTER	0x0000000000010000ULL </span><span class="cm">/* cluster stack */</span><span class="cp"></span>

<span class="cm">/* bits that are infrequently given and frequently matched in the high word */</span>
<span class="cp">#define ML_ERROR	0x1000000000000000ULL </span><span class="cm">/* sent to KERN_ERR */</span><span class="cp"></span>
<span class="cp">#define ML_NOTICE	0x2000000000000000ULL </span><span class="cm">/* setn to KERN_NOTICE */</span><span class="cp"></span>
<span class="cp">#define ML_KTHREAD	0x4000000000000000ULL </span><span class="cm">/* kernel thread activity */</span><span class="cp"></span>

<span class="cp">#define MLOG_INITIAL_AND_MASK (ML_ERROR|ML_NOTICE)</span>
<span class="cp">#ifndef MLOG_MASK_PREFIX</span>
<span class="cp">#define MLOG_MASK_PREFIX 0</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * When logging is disabled, force the bit test to 0 for anything other</span>
<span class="cm"> * than errors and notices, allowing gcc to remove the code completely.</span>
<span class="cm"> * When enabled, allow all masks.</span>
<span class="cm"> */</span>
<span class="cp">#if defined(CONFIG_OCFS2_DEBUG_MASKLOG)</span>
<span class="cp">#define ML_ALLOWED_BITS ~0</span>
<span class="cp">#else</span>
<span class="cp">#define ML_ALLOWED_BITS (ML_ERROR|ML_NOTICE)</span>
<span class="cp">#endif</span>

<span class="cp">#define MLOG_MAX_BITS 64</span>

<span class="k">struct</span> <span class="n">mlog_bits</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">words</span><span class="p">[</span><span class="n">MLOG_MAX_BITS</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">mlog_bits</span> <span class="n">mlog_and_bits</span><span class="p">,</span> <span class="n">mlog_not_bits</span><span class="p">;</span>

<span class="cp">#if BITS_PER_LONG == 32</span>

<span class="cp">#define __mlog_test_u64(mask, bits)			\</span>
<span class="cp">	( (u32)(mask &amp; 0xffffffff) &amp; bits.words[0] || 	\</span>
<span class="cp">	  ((u64)(mask) &gt;&gt; 32) &amp; bits.words[1] )</span>
<span class="cp">#define __mlog_set_u64(mask, bits) do {			\</span>
<span class="cp">	bits.words[0] |= (u32)(mask &amp; 0xffffffff);	\</span>
<span class="cp">       	bits.words[1] |= (u64)(mask) &gt;&gt; 32;		\</span>
<span class="cp">} while (0)</span>
<span class="cp">#define __mlog_clear_u64(mask, bits) do {		\</span>
<span class="cp">	bits.words[0] &amp;= ~((u32)(mask &amp; 0xffffffff));	\</span>
<span class="cp">       	bits.words[1] &amp;= ~((u64)(mask) &gt;&gt; 32);		\</span>
<span class="cp">} while (0)</span>
<span class="cp">#define MLOG_BITS_RHS(mask) {				\</span>
<span class="cp">	{						\</span>
<span class="cp">		[0] = (u32)(mask &amp; 0xffffffff),		\</span>
<span class="cp">		[1] = (u64)(mask) &gt;&gt; 32,		\</span>
<span class="cp">	}						\</span>
<span class="cp">}</span>

<span class="cp">#else </span><span class="cm">/* 32bit long above, 64bit long below */</span><span class="cp"></span>

<span class="cp">#define __mlog_test_u64(mask, bits)	((mask) &amp; bits.words[0])</span>
<span class="cp">#define __mlog_set_u64(mask, bits) do {		\</span>
<span class="cp">	bits.words[0] |= (mask);		\</span>
<span class="cp">} while (0)</span>
<span class="cp">#define __mlog_clear_u64(mask, bits) do {	\</span>
<span class="cp">	bits.words[0] &amp;= ~(mask);		\</span>
<span class="cp">} while (0)</span>
<span class="cp">#define MLOG_BITS_RHS(mask) { { (mask) } }</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * smp_processor_id() &quot;helpfully&quot; screams when called outside preemptible</span>
<span class="cm"> * regions in current kernels.  sles doesn&#39;t have the variants that don&#39;t</span>
<span class="cm"> * scream.  just do this instead of trying to guess which we&#39;re building</span>
<span class="cm"> * against.. *sigh*.</span>
<span class="cm"> */</span>
<span class="cp">#define __mlog_cpu_guess ({		\</span>
<span class="cp">	unsigned long _cpu = get_cpu();	\</span>
<span class="cp">	put_cpu();			\</span>
<span class="cp">	_cpu;				\</span>
<span class="cp">})</span>

<span class="cm">/* In the following two macros, the whitespace after the &#39;,&#39; just</span>
<span class="cm"> * before ##args is intentional. Otherwise, gcc 2.95 will eat the</span>
<span class="cm"> * previous token if args expands to nothing.</span>
<span class="cm"> */</span>
<span class="cp">#define __mlog_printk(level, fmt, args...)				\</span>
<span class="cp">	printk(level &quot;(%s,%u,%lu):%s:%d &quot; fmt, current-&gt;comm,		\</span>
<span class="cp">	       task_pid_nr(current), __mlog_cpu_guess,			\</span>
<span class="cp">	       __PRETTY_FUNCTION__, __LINE__ , ##args)</span>

<span class="cp">#define mlog(mask, fmt, args...) do {					\</span>
<span class="cp">	u64 __m = MLOG_MASK_PREFIX | (mask);				\</span>
<span class="cp">	if ((__m &amp; ML_ALLOWED_BITS) &amp;&amp;					\</span>
<span class="cp">	    __mlog_test_u64(__m, mlog_and_bits) &amp;&amp;			\</span>
<span class="cp">	    !__mlog_test_u64(__m, mlog_not_bits)) {			\</span>
<span class="cp">		if (__m &amp; ML_ERROR)					\</span>
<span class="cp">			__mlog_printk(KERN_ERR, &quot;ERROR: &quot;fmt , ##args);	\</span>
<span class="cp">		else if (__m &amp; ML_NOTICE)				\</span>
<span class="cp">			__mlog_printk(KERN_NOTICE, fmt , ##args);	\</span>
<span class="cp">		else __mlog_printk(KERN_INFO, fmt , ##args);		\</span>
<span class="cp">	}								\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define mlog_errno(st) do {						\</span>
<span class="cp">	int _st = (st);							\</span>
<span class="cp">	if (_st != -ERESTARTSYS &amp;&amp; _st != -EINTR &amp;&amp;			\</span>
<span class="cp">	    _st != AOP_TRUNCATED_PAGE &amp;&amp; _st != -ENOSPC)		\</span>
<span class="cp">		mlog(ML_ERROR, &quot;status = %lld\n&quot;, (long long)_st);	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define mlog_bug_on_msg(cond, fmt, args...) do {			\</span>
<span class="cp">	if (cond) {							\</span>
<span class="cp">		mlog(ML_ERROR, &quot;bug expression: &quot; #cond &quot;\n&quot;);		\</span>
<span class="cp">		mlog(ML_ERROR, fmt, ##args);				\</span>
<span class="cp">		BUG();							\</span>
<span class="cp">	}								\</span>
<span class="cp">} while (0)</span>

<span class="cp">#include &lt;linux/kobject.h&gt;</span>
<span class="cp">#include &lt;linux/sysfs.h&gt;</span>
<span class="kt">int</span> <span class="n">mlog_sys_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="n">o2cb_subsys</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">mlog_sys_shutdown</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* O2CLUSTER_MASKLOG_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
