<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ocfs2 › ocfs2_fs.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ocfs2_fs.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* -*- mode: c; c-basic-offset: 8; -*-</span>
<span class="cm"> * vim: noexpandtab sw=8 ts=8 sts=0:</span>
<span class="cm"> *</span>
<span class="cm"> * ocfs2_fs.h</span>
<span class="cm"> *</span>
<span class="cm"> * On-disk structures for OCFS2.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2002, 2004 Oracle.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public</span>
<span class="cm"> * License, version 2,  as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public</span>
<span class="cm"> * License along with this program; if not, write to the</span>
<span class="cm"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 021110-1307, USA.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _OCFS2_FS_H</span>
<span class="cp">#define _OCFS2_FS_H</span>

<span class="cm">/* Version */</span>
<span class="cp">#define OCFS2_MAJOR_REV_LEVEL		0</span>
<span class="cp">#define OCFS2_MINOR_REV_LEVEL          	90</span>

<span class="cm">/*</span>
<span class="cm"> * An OCFS2 volume starts this way:</span>
<span class="cm"> * Sector 0: Valid ocfs1_vol_disk_hdr that cleanly fails to mount OCFS.</span>
<span class="cm"> * Sector 1: Valid ocfs1_vol_label that cleanly fails to mount OCFS.</span>
<span class="cm"> * Block OCFS2_SUPER_BLOCK_BLKNO: OCFS2 superblock.</span>
<span class="cm"> *</span>
<span class="cm"> * All other structures are found from the superblock information.</span>
<span class="cm"> *</span>
<span class="cm"> * OCFS2_SUPER_BLOCK_BLKNO is in blocks, not sectors.  eg, for a</span>
<span class="cm"> * blocksize of 2K, it is 4096 bytes into disk.</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_SUPER_BLOCK_BLKNO		2</span>

<span class="cm">/*</span>
<span class="cm"> * Cluster size limits. The maximum is kept arbitrarily at 1 MB, and could</span>
<span class="cm"> * grow if needed.</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_MIN_CLUSTERSIZE		4096</span>
<span class="cp">#define OCFS2_MAX_CLUSTERSIZE		1048576</span>

<span class="cm">/*</span>
<span class="cm"> * Blocks cannot be bigger than clusters, so the maximum blocksize is the</span>
<span class="cm"> * minimum cluster size.</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_MIN_BLOCKSIZE		512</span>
<span class="cp">#define OCFS2_MAX_BLOCKSIZE		OCFS2_MIN_CLUSTERSIZE</span>

<span class="cm">/* Filesystem magic number */</span>
<span class="cp">#define OCFS2_SUPER_MAGIC		0x7461636f</span>

<span class="cm">/* Object signatures */</span>
<span class="cp">#define OCFS2_SUPER_BLOCK_SIGNATURE	&quot;OCFSV2&quot;</span>
<span class="cp">#define OCFS2_INODE_SIGNATURE		&quot;INODE01&quot;</span>
<span class="cp">#define OCFS2_EXTENT_BLOCK_SIGNATURE	&quot;EXBLK01&quot;</span>
<span class="cp">#define OCFS2_GROUP_DESC_SIGNATURE      &quot;GROUP01&quot;</span>
<span class="cp">#define OCFS2_XATTR_BLOCK_SIGNATURE	&quot;XATTR01&quot;</span>
<span class="cp">#define OCFS2_DIR_TRAILER_SIGNATURE	&quot;DIRTRL1&quot;</span>
<span class="cp">#define OCFS2_DX_ROOT_SIGNATURE		&quot;DXDIR01&quot;</span>
<span class="cp">#define OCFS2_DX_LEAF_SIGNATURE		&quot;DXLEAF1&quot;</span>
<span class="cp">#define OCFS2_REFCOUNT_BLOCK_SIGNATURE	&quot;REFCNT1&quot;</span>

<span class="cm">/* Compatibility flags */</span>
<span class="cp">#define OCFS2_HAS_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	( OCFS2_SB(sb)-&gt;s_feature_compat &amp; (mask) )</span>
<span class="cp">#define OCFS2_HAS_RO_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	( OCFS2_SB(sb)-&gt;s_feature_ro_compat &amp; (mask) )</span>
<span class="cp">#define OCFS2_HAS_INCOMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	( OCFS2_SB(sb)-&gt;s_feature_incompat &amp; (mask) )</span>
<span class="cp">#define OCFS2_SET_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	OCFS2_SB(sb)-&gt;s_feature_compat |= (mask)</span>
<span class="cp">#define OCFS2_SET_RO_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	OCFS2_SB(sb)-&gt;s_feature_ro_compat |= (mask)</span>
<span class="cp">#define OCFS2_SET_INCOMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	OCFS2_SB(sb)-&gt;s_feature_incompat |= (mask)</span>
<span class="cp">#define OCFS2_CLEAR_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	OCFS2_SB(sb)-&gt;s_feature_compat &amp;= ~(mask)</span>
<span class="cp">#define OCFS2_CLEAR_RO_COMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	OCFS2_SB(sb)-&gt;s_feature_ro_compat &amp;= ~(mask)</span>
<span class="cp">#define OCFS2_CLEAR_INCOMPAT_FEATURE(sb,mask)			\</span>
<span class="cp">	OCFS2_SB(sb)-&gt;s_feature_incompat &amp;= ~(mask)</span>

<span class="cp">#define OCFS2_FEATURE_COMPAT_SUPP	(OCFS2_FEATURE_COMPAT_BACKUP_SB	\</span>
<span class="cp">					 | OCFS2_FEATURE_COMPAT_JBD2_SB)</span>
<span class="cp">#define OCFS2_FEATURE_INCOMPAT_SUPP	(OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT \</span>
<span class="cp">					 | OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC \</span>
<span class="cp">					 | OCFS2_FEATURE_INCOMPAT_INLINE_DATA \</span>
<span class="cp">					 | OCFS2_FEATURE_INCOMPAT_EXTENDED_SLOT_MAP \</span>
<span class="cp">					 | OCFS2_FEATURE_INCOMPAT_USERSPACE_STACK \</span>
<span class="cp">					 | OCFS2_FEATURE_INCOMPAT_XATTR \</span>
<span class="cp">					 | OCFS2_FEATURE_INCOMPAT_META_ECC \</span>
<span class="cp">					 | OCFS2_FEATURE_INCOMPAT_INDEXED_DIRS \</span>
<span class="cp">					 | OCFS2_FEATURE_INCOMPAT_REFCOUNT_TREE \</span>
<span class="cp">					 | OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG	\</span>
<span class="cp">					 | OCFS2_FEATURE_INCOMPAT_CLUSTERINFO)</span>
<span class="cp">#define OCFS2_FEATURE_RO_COMPAT_SUPP	(OCFS2_FEATURE_RO_COMPAT_UNWRITTEN \</span>
<span class="cp">					 | OCFS2_FEATURE_RO_COMPAT_USRQUOTA \</span>
<span class="cp">					 | OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)</span>

<span class="cm">/*</span>
<span class="cm"> * Heartbeat-only devices are missing journals and other files.  The</span>
<span class="cm"> * filesystem driver can&#39;t load them, but the library can.  Never put</span>
<span class="cm"> * this in OCFS2_FEATURE_INCOMPAT_SUPP, *ever*.</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_FEATURE_INCOMPAT_HEARTBEAT_DEV	0x0002</span>

<span class="cm">/*</span>
<span class="cm"> * tunefs sets this incompat flag before starting the resize and clears it</span>
<span class="cm"> * at the end. This flag protects users from inadvertently mounting the fs</span>
<span class="cm"> * after an aborted run without fsck-ing.</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_FEATURE_INCOMPAT_RESIZE_INPROG    0x0004</span>

<span class="cm">/* Used to denote a non-clustered volume */</span>
<span class="cp">#define OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT	0x0008</span>

<span class="cm">/* Support for sparse allocation in b-trees */</span>
<span class="cp">#define OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC	0x0010</span>

<span class="cm">/*</span>
<span class="cm"> * Tunefs sets this incompat flag before starting an operation which</span>
<span class="cm"> * would require cleanup on abort. This is done to protect users from</span>
<span class="cm"> * inadvertently mounting the fs after an aborted run without</span>
<span class="cm"> * fsck-ing.</span>
<span class="cm"> *</span>
<span class="cm"> * s_tunefs_flags on the super block describes precisely which</span>
<span class="cm"> * operations were in progress.</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_FEATURE_INCOMPAT_TUNEFS_INPROG	0x0020</span>

<span class="cm">/* Support for data packed into inode blocks */</span>
<span class="cp">#define OCFS2_FEATURE_INCOMPAT_INLINE_DATA	0x0040</span>

<span class="cm">/*</span>
<span class="cm"> * Support for alternate, userspace cluster stacks.  If set, the superblock</span>
<span class="cm"> * field s_cluster_info contains a tag for the alternate stack in use as</span>
<span class="cm"> * well as the name of the cluster being joined.</span>
<span class="cm"> * mount.ocfs2 must pass in a matching stack name.</span>
<span class="cm"> *</span>
<span class="cm"> * If not set, the classic stack will be used.  This is compatbile with</span>
<span class="cm"> * all older versions.</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_FEATURE_INCOMPAT_USERSPACE_STACK	0x0080</span>

<span class="cm">/* Support for the extended slot map */</span>
<span class="cp">#define OCFS2_FEATURE_INCOMPAT_EXTENDED_SLOT_MAP 0x100</span>

<span class="cm">/* Support for extended attributes */</span>
<span class="cp">#define OCFS2_FEATURE_INCOMPAT_XATTR		0x0200</span>

<span class="cm">/* Support for indexed directores */</span>
<span class="cp">#define OCFS2_FEATURE_INCOMPAT_INDEXED_DIRS	0x0400</span>

<span class="cm">/* Metadata checksum and error correction */</span>
<span class="cp">#define OCFS2_FEATURE_INCOMPAT_META_ECC		0x0800</span>

<span class="cm">/* Refcount tree support */</span>
<span class="cp">#define OCFS2_FEATURE_INCOMPAT_REFCOUNT_TREE	0x1000</span>

<span class="cm">/* Discontigous block groups */</span>
<span class="cp">#define OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG	0x2000</span>

<span class="cm">/*</span>
<span class="cm"> * Incompat bit to indicate useable clusterinfo with stackflags for all</span>
<span class="cm"> * cluster stacks (userspace adnd o2cb). If this bit is set,</span>
<span class="cm"> * INCOMPAT_USERSPACE_STACK becomes superfluous and thus should not be set.</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_FEATURE_INCOMPAT_CLUSTERINFO	0x4000</span>

<span class="cm">/*</span>
<span class="cm"> * backup superblock flag is used to indicate that this volume</span>
<span class="cm"> * has backup superblocks.</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_FEATURE_COMPAT_BACKUP_SB		0x0001</span>

<span class="cm">/*</span>
<span class="cm"> * The filesystem will correctly handle journal feature bits.</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_FEATURE_COMPAT_JBD2_SB		0x0002</span>

<span class="cm">/*</span>
<span class="cm"> * Unwritten extents support.</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_FEATURE_RO_COMPAT_UNWRITTEN	0x0001</span>

<span class="cm">/*</span>
<span class="cm"> * Maintain quota information for this filesystem</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_FEATURE_RO_COMPAT_USRQUOTA	0x0002</span>
<span class="cp">#define OCFS2_FEATURE_RO_COMPAT_GRPQUOTA	0x0004</span>

<span class="cm">/* The byte offset of the first backup block will be 1G.</span>
<span class="cm"> * The following will be 4G, 16G, 64G, 256G and 1T.</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_BACKUP_SB_START			1 &lt;&lt; 30</span>

<span class="cm">/* the max backup superblock nums */</span>
<span class="cp">#define OCFS2_MAX_BACKUP_SUPERBLOCKS	6</span>

<span class="cm">/*</span>
<span class="cm"> * Flags on ocfs2_super_block.s_tunefs_flags</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_TUNEFS_INPROG_REMOVE_SLOT		0x0001	</span><span class="cm">/* Removing slots */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Flags on ocfs2_dinode.i_flags</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_VALID_FL		(0x00000001)	</span><span class="cm">/* Inode is valid */</span><span class="cp"></span>
<span class="cp">#define OCFS2_UNUSED2_FL	(0x00000002)</span>
<span class="cp">#define OCFS2_ORPHANED_FL	(0x00000004)	</span><span class="cm">/* On the orphan list */</span><span class="cp"></span>
<span class="cp">#define OCFS2_UNUSED3_FL	(0x00000008)</span>
<span class="cm">/* System inode flags */</span>
<span class="cp">#define OCFS2_SYSTEM_FL		(0x00000010)	</span><span class="cm">/* System inode */</span><span class="cp"></span>
<span class="cp">#define OCFS2_SUPER_BLOCK_FL	(0x00000020)	</span><span class="cm">/* Super block */</span><span class="cp"></span>
<span class="cp">#define OCFS2_LOCAL_ALLOC_FL	(0x00000040)	</span><span class="cm">/* Slot local alloc bitmap */</span><span class="cp"></span>
<span class="cp">#define OCFS2_BITMAP_FL		(0x00000080)	</span><span class="cm">/* Allocation bitmap */</span><span class="cp"></span>
<span class="cp">#define OCFS2_JOURNAL_FL	(0x00000100)	</span><span class="cm">/* Slot local journal */</span><span class="cp"></span>
<span class="cp">#define OCFS2_HEARTBEAT_FL	(0x00000200)	</span><span class="cm">/* Heartbeat area */</span><span class="cp"></span>
<span class="cp">#define OCFS2_CHAIN_FL		(0x00000400)	</span><span class="cm">/* Chain allocator */</span><span class="cp"></span>
<span class="cp">#define OCFS2_DEALLOC_FL	(0x00000800)	</span><span class="cm">/* Truncate log */</span><span class="cp"></span>
<span class="cp">#define OCFS2_QUOTA_FL		(0x00001000)	</span><span class="cm">/* Quota file */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Flags on ocfs2_dinode.i_dyn_features</span>
<span class="cm"> *</span>
<span class="cm"> * These can change much more often than i_flags. When adding flags,</span>
<span class="cm"> * keep in mind that i_dyn_features is only 16 bits wide.</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_INLINE_DATA_FL	(0x0001)	</span><span class="cm">/* Data stored in inode block */</span><span class="cp"></span>
<span class="cp">#define OCFS2_HAS_XATTR_FL	(0x0002)</span>
<span class="cp">#define OCFS2_INLINE_XATTR_FL	(0x0004)</span>
<span class="cp">#define OCFS2_INDEXED_DIR_FL	(0x0008)</span>
<span class="cp">#define OCFS2_HAS_REFCOUNT_FL   (0x0010)</span>

<span class="cm">/* Inode attributes, keep in sync with EXT2 */</span>
<span class="cp">#define OCFS2_SECRM_FL			FS_SECRM_FL	</span><span class="cm">/* Secure deletion */</span><span class="cp"></span>
<span class="cp">#define OCFS2_UNRM_FL			FS_UNRM_FL	</span><span class="cm">/* Undelete */</span><span class="cp"></span>
<span class="cp">#define OCFS2_COMPR_FL			FS_COMPR_FL	</span><span class="cm">/* Compress file */</span><span class="cp"></span>
<span class="cp">#define OCFS2_SYNC_FL			FS_SYNC_FL	</span><span class="cm">/* Synchronous updates */</span><span class="cp"></span>
<span class="cp">#define OCFS2_IMMUTABLE_FL		FS_IMMUTABLE_FL	</span><span class="cm">/* Immutable file */</span><span class="cp"></span>
<span class="cp">#define OCFS2_APPEND_FL			FS_APPEND_FL	</span><span class="cm">/* writes to file may only append */</span><span class="cp"></span>
<span class="cp">#define OCFS2_NODUMP_FL			FS_NODUMP_FL	</span><span class="cm">/* do not dump file */</span><span class="cp"></span>
<span class="cp">#define OCFS2_NOATIME_FL		FS_NOATIME_FL	</span><span class="cm">/* do not update atime */</span><span class="cp"></span>
<span class="cm">/* Reserved for compression usage... */</span>
<span class="cp">#define OCFS2_DIRTY_FL			FS_DIRTY_FL</span>
<span class="cp">#define OCFS2_COMPRBLK_FL		FS_COMPRBLK_FL	</span><span class="cm">/* One or more compressed clusters */</span><span class="cp"></span>
<span class="cp">#define OCFS2_NOCOMP_FL			FS_NOCOMP_FL	</span><span class="cm">/* Don&#39;t compress */</span><span class="cp"></span>
<span class="cp">#define OCFS2_ECOMPR_FL			FS_ECOMPR_FL	</span><span class="cm">/* Compression error */</span><span class="cp"></span>
<span class="cm">/* End compression flags --- maybe not all used */</span>
<span class="cp">#define OCFS2_BTREE_FL			FS_BTREE_FL	</span><span class="cm">/* btree format dir */</span><span class="cp"></span>
<span class="cp">#define OCFS2_INDEX_FL			FS_INDEX_FL	</span><span class="cm">/* hash-indexed directory */</span><span class="cp"></span>
<span class="cp">#define OCFS2_IMAGIC_FL			FS_IMAGIC_FL	</span><span class="cm">/* AFS directory */</span><span class="cp"></span>
<span class="cp">#define OCFS2_JOURNAL_DATA_FL		FS_JOURNAL_DATA_FL </span><span class="cm">/* Reserved for ext3 */</span><span class="cp"></span>
<span class="cp">#define OCFS2_NOTAIL_FL			FS_NOTAIL_FL	</span><span class="cm">/* file tail should not be merged */</span><span class="cp"></span>
<span class="cp">#define OCFS2_DIRSYNC_FL		FS_DIRSYNC_FL	</span><span class="cm">/* dirsync behaviour (directories only) */</span><span class="cp"></span>
<span class="cp">#define OCFS2_TOPDIR_FL			FS_TOPDIR_FL	</span><span class="cm">/* Top of directory hierarchies*/</span><span class="cp"></span>
<span class="cp">#define OCFS2_RESERVED_FL		FS_RESERVED_FL	</span><span class="cm">/* reserved for ext2 lib */</span><span class="cp"></span>

<span class="cp">#define OCFS2_FL_VISIBLE		FS_FL_USER_VISIBLE	</span><span class="cm">/* User visible flags */</span><span class="cp"></span>
<span class="cp">#define OCFS2_FL_MODIFIABLE		FS_FL_USER_MODIFIABLE	</span><span class="cm">/* User modifiable flags */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Extent record flags (e_node.leaf.flags)</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_EXT_UNWRITTEN		(0x01)	</span><span class="cm">/* Extent is allocated but</span>
<span class="cm">						 * unwritten */</span><span class="cp"></span>
<span class="cp">#define OCFS2_EXT_REFCOUNTED		(0x02)  </span><span class="cm">/* Extent is reference</span>
<span class="cm">						 * counted in an associated</span>
<span class="cm">						 * refcount tree */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Journal Flags (ocfs2_dinode.id1.journal1.i_flags)</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_JOURNAL_DIRTY_FL	(0x00000001)	</span><span class="cm">/* Journal needs recovery */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * superblock s_state flags</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_ERROR_FS		(0x00000001)	</span><span class="cm">/* FS saw errors */</span><span class="cp"></span>

<span class="cm">/* Limit of space in ocfs2_dir_entry */</span>
<span class="cp">#define OCFS2_MAX_FILENAME_LEN		255</span>

<span class="cm">/* Maximum slots on an ocfs2 file system */</span>
<span class="cp">#define OCFS2_MAX_SLOTS			255</span>

<span class="cm">/* Slot map indicator for an empty slot */</span>
<span class="cp">#define OCFS2_INVALID_SLOT		-1</span>

<span class="cp">#define OCFS2_VOL_UUID_LEN		16</span>
<span class="cp">#define OCFS2_MAX_VOL_LABEL_LEN		64</span>

<span class="cm">/* The cluster stack fields */</span>
<span class="cp">#define OCFS2_STACK_LABEL_LEN		4</span>
<span class="cp">#define OCFS2_CLUSTER_NAME_LEN		16</span>

<span class="cm">/* Classic (historically speaking) cluster stack */</span>
<span class="cp">#define OCFS2_CLASSIC_CLUSTER_STACK	&quot;o2cb&quot;</span>

<span class="cm">/* Journal limits (in bytes) */</span>
<span class="cp">#define OCFS2_MIN_JOURNAL_SIZE		(4 * 1024 * 1024)</span>

<span class="cm">/*</span>
<span class="cm"> * Inline extended attribute size (in bytes)</span>
<span class="cm"> * The value chosen should be aligned to 16 byte boundaries.</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_MIN_XATTR_INLINE_SIZE     256</span>

<span class="cm">/*</span>
<span class="cm"> * Cluster info flags (ocfs2_cluster_info.ci_stackflags)</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_CLUSTER_O2CB_GLOBAL_HEARTBEAT	(0x01)</span>

<span class="k">struct</span> <span class="n">ocfs2_system_inode_info</span> <span class="p">{</span>
	<span class="kt">char</span>	<span class="o">*</span><span class="n">si_name</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">si_iflags</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">si_mode</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* System file index */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">BAD_BLOCK_SYSTEM_INODE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">GLOBAL_INODE_ALLOC_SYSTEM_INODE</span><span class="p">,</span>
	<span class="n">SLOT_MAP_SYSTEM_INODE</span><span class="p">,</span>
<span class="cp">#define OCFS2_FIRST_ONLINE_SYSTEM_INODE SLOT_MAP_SYSTEM_INODE</span>
	<span class="n">HEARTBEAT_SYSTEM_INODE</span><span class="p">,</span>
	<span class="n">GLOBAL_BITMAP_SYSTEM_INODE</span><span class="p">,</span>
	<span class="n">USER_QUOTA_SYSTEM_INODE</span><span class="p">,</span>
	<span class="n">GROUP_QUOTA_SYSTEM_INODE</span><span class="p">,</span>
<span class="cp">#define OCFS2_LAST_GLOBAL_SYSTEM_INODE GROUP_QUOTA_SYSTEM_INODE</span>
<span class="cp">#define OCFS2_FIRST_LOCAL_SYSTEM_INODE ORPHAN_DIR_SYSTEM_INODE</span>
	<span class="n">ORPHAN_DIR_SYSTEM_INODE</span><span class="p">,</span>
	<span class="n">EXTENT_ALLOC_SYSTEM_INODE</span><span class="p">,</span>
	<span class="n">INODE_ALLOC_SYSTEM_INODE</span><span class="p">,</span>
	<span class="n">JOURNAL_SYSTEM_INODE</span><span class="p">,</span>
	<span class="n">LOCAL_ALLOC_SYSTEM_INODE</span><span class="p">,</span>
	<span class="n">TRUNCATE_LOG_SYSTEM_INODE</span><span class="p">,</span>
	<span class="n">LOCAL_USER_QUOTA_SYSTEM_INODE</span><span class="p">,</span>
	<span class="n">LOCAL_GROUP_QUOTA_SYSTEM_INODE</span><span class="p">,</span>
<span class="cp">#define OCFS2_LAST_LOCAL_SYSTEM_INODE LOCAL_GROUP_QUOTA_SYSTEM_INODE</span>
	<span class="n">NUM_SYSTEM_INODES</span>
<span class="p">};</span>
<span class="cp">#define NUM_GLOBAL_SYSTEM_INODES OCFS2_FIRST_LOCAL_SYSTEM_INODE</span>
<span class="cp">#define NUM_LOCAL_SYSTEM_INODES	\</span>
<span class="cp">		(NUM_SYSTEM_INODES - OCFS2_FIRST_LOCAL_SYSTEM_INODE)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ocfs2_system_inode_info</span> <span class="n">ocfs2_system_inodes</span><span class="p">[</span><span class="n">NUM_SYSTEM_INODES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* Global system inodes (single copy) */</span>
	<span class="cm">/* The first two are only used from userspace mfks/tunefs */</span>
	<span class="p">[</span><span class="n">BAD_BLOCK_SYSTEM_INODE</span><span class="p">]</span>		<span class="o">=</span> <span class="p">{</span> <span class="s">&quot;bad_blocks&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="mo">0644</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">GLOBAL_INODE_ALLOC_SYSTEM_INODE</span><span class="p">]</span> 	<span class="o">=</span> <span class="p">{</span> <span class="s">&quot;global_inode_alloc&quot;</span><span class="p">,</span> <span class="n">OCFS2_BITMAP_FL</span> <span class="o">|</span> <span class="n">OCFS2_CHAIN_FL</span><span class="p">,</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="mo">0644</span> <span class="p">},</span>

	<span class="cm">/* These are used by the running filesystem */</span>
	<span class="p">[</span><span class="n">SLOT_MAP_SYSTEM_INODE</span><span class="p">]</span>			<span class="o">=</span> <span class="p">{</span> <span class="s">&quot;slot_map&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="mo">0644</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">HEARTBEAT_SYSTEM_INODE</span><span class="p">]</span>		<span class="o">=</span> <span class="p">{</span> <span class="s">&quot;heartbeat&quot;</span><span class="p">,</span> <span class="n">OCFS2_HEARTBEAT_FL</span><span class="p">,</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="mo">0644</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">GLOBAL_BITMAP_SYSTEM_INODE</span><span class="p">]</span>		<span class="o">=</span> <span class="p">{</span> <span class="s">&quot;global_bitmap&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="mo">0644</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">USER_QUOTA_SYSTEM_INODE</span><span class="p">]</span>		<span class="o">=</span> <span class="p">{</span> <span class="s">&quot;aquota.user&quot;</span><span class="p">,</span> <span class="n">OCFS2_QUOTA_FL</span><span class="p">,</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="mo">0644</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">GROUP_QUOTA_SYSTEM_INODE</span><span class="p">]</span>		<span class="o">=</span> <span class="p">{</span> <span class="s">&quot;aquota.group&quot;</span><span class="p">,</span> <span class="n">OCFS2_QUOTA_FL</span><span class="p">,</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="mo">0644</span> <span class="p">},</span>

	<span class="cm">/* Slot-specific system inodes (one copy per slot) */</span>
	<span class="p">[</span><span class="n">ORPHAN_DIR_SYSTEM_INODE</span><span class="p">]</span>		<span class="o">=</span> <span class="p">{</span> <span class="s">&quot;orphan_dir:%04d&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">S_IFDIR</span> <span class="o">|</span> <span class="mo">0755</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">EXTENT_ALLOC_SYSTEM_INODE</span><span class="p">]</span>		<span class="o">=</span> <span class="p">{</span> <span class="s">&quot;extent_alloc:%04d&quot;</span><span class="p">,</span> <span class="n">OCFS2_BITMAP_FL</span> <span class="o">|</span> <span class="n">OCFS2_CHAIN_FL</span><span class="p">,</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="mo">0644</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">INODE_ALLOC_SYSTEM_INODE</span><span class="p">]</span>		<span class="o">=</span> <span class="p">{</span> <span class="s">&quot;inode_alloc:%04d&quot;</span><span class="p">,</span> <span class="n">OCFS2_BITMAP_FL</span> <span class="o">|</span> <span class="n">OCFS2_CHAIN_FL</span><span class="p">,</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="mo">0644</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">JOURNAL_SYSTEM_INODE</span><span class="p">]</span>			<span class="o">=</span> <span class="p">{</span> <span class="s">&quot;journal:%04d&quot;</span><span class="p">,</span> <span class="n">OCFS2_JOURNAL_FL</span><span class="p">,</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="mo">0644</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">LOCAL_ALLOC_SYSTEM_INODE</span><span class="p">]</span>		<span class="o">=</span> <span class="p">{</span> <span class="s">&quot;local_alloc:%04d&quot;</span><span class="p">,</span> <span class="n">OCFS2_BITMAP_FL</span> <span class="o">|</span> <span class="n">OCFS2_LOCAL_ALLOC_FL</span><span class="p">,</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="mo">0644</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">TRUNCATE_LOG_SYSTEM_INODE</span><span class="p">]</span>		<span class="o">=</span> <span class="p">{</span> <span class="s">&quot;truncate_log:%04d&quot;</span><span class="p">,</span> <span class="n">OCFS2_DEALLOC_FL</span><span class="p">,</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="mo">0644</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">LOCAL_USER_QUOTA_SYSTEM_INODE</span><span class="p">]</span>		<span class="o">=</span> <span class="p">{</span> <span class="s">&quot;aquota.user:%04d&quot;</span><span class="p">,</span> <span class="n">OCFS2_QUOTA_FL</span><span class="p">,</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="mo">0644</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">LOCAL_GROUP_QUOTA_SYSTEM_INODE</span><span class="p">]</span>	<span class="o">=</span> <span class="p">{</span> <span class="s">&quot;aquota.group:%04d&quot;</span><span class="p">,</span> <span class="n">OCFS2_QUOTA_FL</span><span class="p">,</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="mo">0644</span> <span class="p">},</span>
<span class="p">};</span>

<span class="cm">/* Parameter passed from mount.ocfs2 to module */</span>
<span class="cp">#define OCFS2_HB_NONE			&quot;heartbeat=none&quot;</span>
<span class="cp">#define OCFS2_HB_LOCAL			&quot;heartbeat=local&quot;</span>
<span class="cp">#define OCFS2_HB_GLOBAL			&quot;heartbeat=global&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * OCFS2 directory file types.  Only the low 3 bits are used.  The</span>
<span class="cm"> * other bits are reserved for now.</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_FT_UNKNOWN	0</span>
<span class="cp">#define OCFS2_FT_REG_FILE	1</span>
<span class="cp">#define OCFS2_FT_DIR		2</span>
<span class="cp">#define OCFS2_FT_CHRDEV		3</span>
<span class="cp">#define OCFS2_FT_BLKDEV		4</span>
<span class="cp">#define OCFS2_FT_FIFO		5</span>
<span class="cp">#define OCFS2_FT_SOCK		6</span>
<span class="cp">#define OCFS2_FT_SYMLINK	7</span>

<span class="cp">#define OCFS2_FT_MAX		8</span>

<span class="cm">/*</span>
<span class="cm"> * OCFS2_DIR_PAD defines the directory entries boundaries</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: It must be a multiple of 4</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_DIR_PAD			4</span>
<span class="cp">#define OCFS2_DIR_ROUND			(OCFS2_DIR_PAD - 1)</span>
<span class="cp">#define OCFS2_DIR_MEMBER_LEN 		offsetof(struct ocfs2_dir_entry, name)</span>
<span class="cp">#define OCFS2_DIR_REC_LEN(name_len)	(((name_len) + OCFS2_DIR_MEMBER_LEN + \</span>
<span class="cp">                                          OCFS2_DIR_ROUND) &amp; \</span>
<span class="cp">					 ~OCFS2_DIR_ROUND)</span>
<span class="cp">#define OCFS2_DIR_MIN_REC_LEN	OCFS2_DIR_REC_LEN(1)</span>

<span class="cp">#define OCFS2_LINK_MAX		32000</span>
<span class="cp">#define	OCFS2_DX_LINK_MAX	((1U &lt;&lt; 31) - 1U)</span>
<span class="cp">#define	OCFS2_LINKS_HI_SHIFT	16</span>
<span class="cp">#define	OCFS2_DX_ENTRIES_MAX	(0xffffffffU)</span>

<span class="cp">#define S_SHIFT			12</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ocfs2_type_by_mode</span><span class="p">[</span><span class="n">S_IFMT</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">S_IFREG</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span>  <span class="o">=</span> <span class="n">OCFS2_FT_REG_FILE</span><span class="p">,</span>
	<span class="p">[</span><span class="n">S_IFDIR</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span>  <span class="o">=</span> <span class="n">OCFS2_FT_DIR</span><span class="p">,</span>
	<span class="p">[</span><span class="n">S_IFCHR</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span>  <span class="o">=</span> <span class="n">OCFS2_FT_CHRDEV</span><span class="p">,</span>
	<span class="p">[</span><span class="n">S_IFBLK</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span>  <span class="o">=</span> <span class="n">OCFS2_FT_BLKDEV</span><span class="p">,</span>
	<span class="p">[</span><span class="n">S_IFIFO</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span>  <span class="o">=</span> <span class="n">OCFS2_FT_FIFO</span><span class="p">,</span>
	<span class="p">[</span><span class="n">S_IFSOCK</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span> <span class="o">=</span> <span class="n">OCFS2_FT_SOCK</span><span class="p">,</span>
	<span class="p">[</span><span class="n">S_IFLNK</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span>  <span class="o">=</span> <span class="n">OCFS2_FT_SYMLINK</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Convenience casts</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_RAW_SB(dinode)		(&amp;((dinode)-&gt;id2.i_super))</span>

<span class="cm">/*</span>
<span class="cm"> * Block checking structure.  This is used in metadata to validate the</span>
<span class="cm"> * contents.  If OCFS2_FEATURE_INCOMPAT_META_ECC is not set, it is all</span>
<span class="cm"> * zeros.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_block_check</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__le32</span> <span class="n">bc_crc32e</span><span class="p">;</span>	<span class="cm">/* 802.3 Ethernet II CRC32 */</span>
	<span class="n">__le16</span> <span class="n">bc_ecc</span><span class="p">;</span>		<span class="cm">/* Single-error-correction parity vector.</span>
<span class="cm">				   This is a simple Hamming code dependent</span>
<span class="cm">				   on the blocksize.  OCFS2&#39;s maximum</span>
<span class="cm">				   blocksize, 4K, requires 16 parity bits,</span>
<span class="cm">				   so we fit in __le16. */</span>
	<span class="n">__le16</span> <span class="n">bc_reserved1</span><span class="p">;</span>
<span class="cm">/*08*/</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * On disk extent record for OCFS2</span>
<span class="cm"> * It describes a range of clusters on disk.</span>
<span class="cm"> *</span>
<span class="cm"> * Length fields are divided into interior and leaf node versions.</span>
<span class="cm"> * This leaves room for a flags field (OCFS2_EXT_*) in the leaf nodes.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_extent_rec</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__le32</span> <span class="n">e_cpos</span><span class="p">;</span>		<span class="cm">/* Offset into the file, in clusters */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">__le32</span> <span class="n">e_int_clusters</span><span class="p">;</span> <span class="cm">/* Clusters covered by all children */</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__le16</span> <span class="n">e_leaf_clusters</span><span class="p">;</span> <span class="cm">/* Clusters covered by this</span>
<span class="cm">						   extent */</span>
			<span class="n">__u8</span> <span class="n">e_reserved1</span><span class="p">;</span>
			<span class="n">__u8</span> <span class="n">e_flags</span><span class="p">;</span> <span class="cm">/* Extent flags */</span>
		<span class="p">};</span>
	<span class="p">};</span>
	<span class="n">__le64</span> <span class="n">e_blkno</span><span class="p">;</span>		<span class="cm">/* Physical disk offset, in blocks */</span>
<span class="cm">/*10*/</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ocfs2_chain_rec</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">c_free</span><span class="p">;</span>	<span class="cm">/* Number of free bits in this chain. */</span>
	<span class="n">__le32</span> <span class="n">c_total</span><span class="p">;</span>	<span class="cm">/* Number of total bits in this chain */</span>
	<span class="n">__le64</span> <span class="n">c_blkno</span><span class="p">;</span>	<span class="cm">/* Physical disk offset (blocks) of 1st group */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ocfs2_truncate_rec</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">t_start</span><span class="p">;</span>		<span class="cm">/* 1st cluster in this log */</span>
	<span class="n">__le32</span> <span class="n">t_clusters</span><span class="p">;</span>	<span class="cm">/* Number of total clusters covered */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * On disk extent list for OCFS2 (node in the tree).  Note that this</span>
<span class="cm"> * is contained inside ocfs2_dinode or ocfs2_extent_block, so the</span>
<span class="cm"> * offsets are relative to ocfs2_dinode.id2.i_list or</span>
<span class="cm"> * ocfs2_extent_block.h_list, respectively.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_extent_list</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__le16</span> <span class="n">l_tree_depth</span><span class="p">;</span>		<span class="cm">/* Extent tree depth from this</span>
<span class="cm">					   point.  0 means data extents</span>
<span class="cm">					   hang directly off this</span>
<span class="cm">					   header (a leaf)</span>
<span class="cm">					   NOTE: The high 8 bits cannot be</span>
<span class="cm">					   used - tree_depth is never that big.</span>
<span class="cm">					*/</span>
	<span class="n">__le16</span> <span class="n">l_count</span><span class="p">;</span>			<span class="cm">/* Number of extent records */</span>
	<span class="n">__le16</span> <span class="n">l_next_free_rec</span><span class="p">;</span>		<span class="cm">/* Next unused extent slot */</span>
	<span class="n">__le16</span> <span class="n">l_reserved1</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">l_reserved2</span><span class="p">;</span>		<span class="cm">/* Pad to</span>
<span class="cm">					   sizeof(ocfs2_extent_rec) */</span>
<span class="cm">/*10*/</span>	<span class="k">struct</span> <span class="n">ocfs2_extent_rec</span> <span class="n">l_recs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* Extent records */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * On disk allocation chain list for OCFS2.  Note that this is</span>
<span class="cm"> * contained inside ocfs2_dinode, so the offsets are relative to</span>
<span class="cm"> * ocfs2_dinode.id2.i_chain.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_chain_list</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__le16</span> <span class="n">cl_cpg</span><span class="p">;</span>			<span class="cm">/* Clusters per Block Group */</span>
	<span class="n">__le16</span> <span class="n">cl_bpc</span><span class="p">;</span>			<span class="cm">/* Bits per cluster */</span>
	<span class="n">__le16</span> <span class="n">cl_count</span><span class="p">;</span>		<span class="cm">/* Total chains in this list */</span>
	<span class="n">__le16</span> <span class="n">cl_next_free_rec</span><span class="p">;</span>	<span class="cm">/* Next unused chain slot */</span>
	<span class="n">__le64</span> <span class="n">cl_reserved1</span><span class="p">;</span>
<span class="cm">/*10*/</span>	<span class="k">struct</span> <span class="n">ocfs2_chain_rec</span> <span class="n">cl_recs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* Chain records */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * On disk deallocation log for OCFS2.  Note that this is</span>
<span class="cm"> * contained inside ocfs2_dinode, so the offsets are relative to</span>
<span class="cm"> * ocfs2_dinode.id2.i_dealloc.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_truncate_log</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__le16</span> <span class="n">tl_count</span><span class="p">;</span>		<span class="cm">/* Total records in this log */</span>
	<span class="n">__le16</span> <span class="n">tl_used</span><span class="p">;</span>			<span class="cm">/* Number of records in use */</span>
	<span class="n">__le32</span> <span class="n">tl_reserved1</span><span class="p">;</span>
<span class="cm">/*08*/</span>	<span class="k">struct</span> <span class="n">ocfs2_truncate_rec</span> <span class="n">tl_recs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* Truncate records */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * On disk extent block (indirect block) for OCFS2</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_extent_block</span>
<span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__u8</span> <span class="n">h_signature</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>		<span class="cm">/* Signature for verification */</span>
	<span class="k">struct</span> <span class="n">ocfs2_block_check</span> <span class="n">h_check</span><span class="p">;</span>	<span class="cm">/* Error checking */</span>
<span class="cm">/*10*/</span>	<span class="n">__le16</span> <span class="n">h_suballoc_slot</span><span class="p">;</span>		<span class="cm">/* Slot suballocator this</span>
<span class="cm">					   extent_header belongs to */</span>
	<span class="n">__le16</span> <span class="n">h_suballoc_bit</span><span class="p">;</span>		<span class="cm">/* Bit offset in suballocator</span>
<span class="cm">					   block group */</span>
	<span class="n">__le32</span> <span class="n">h_fs_generation</span><span class="p">;</span>		<span class="cm">/* Must match super block */</span>
	<span class="n">__le64</span> <span class="n">h_blkno</span><span class="p">;</span>			<span class="cm">/* Offset on disk, in blocks */</span>
<span class="cm">/*20*/</span>	<span class="n">__le64</span> <span class="n">h_suballoc_loc</span><span class="p">;</span>		<span class="cm">/* Suballocator block group this</span>
<span class="cm">					   eb belongs to.  Only valid</span>
<span class="cm">					   if allocated from a</span>
<span class="cm">					   discontiguous block group */</span>
	<span class="n">__le64</span> <span class="n">h_next_leaf_blk</span><span class="p">;</span>		<span class="cm">/* Offset on disk, in blocks,</span>
<span class="cm">					   of next leaf header pointing</span>
<span class="cm">					   to data */</span>
<span class="cm">/*30*/</span>	<span class="k">struct</span> <span class="n">ocfs2_extent_list</span> <span class="n">h_list</span><span class="p">;</span>	<span class="cm">/* Extent record list */</span>
<span class="cm">/* Actual on-disk size is one block */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * On disk slot map for OCFS2.  This defines the contents of the &quot;slot_map&quot;</span>
<span class="cm"> * system file.  A slot is valid if it contains a node number &gt;= 0.  The</span>
<span class="cm"> * value -1 (0xFFFF) is OCFS2_INVALID_SLOT.  This marks a slot empty.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_slot_map</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__le16</span> <span class="n">sm_slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="cm">/*</span>
<span class="cm"> * Actual on-disk size is one block.  OCFS2_MAX_SLOTS is 255,</span>
<span class="cm"> * 255 * sizeof(__le16) == 512B, within the 512B block minimum blocksize.</span>
<span class="cm"> */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ocfs2_extended_slot</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__u8</span>	<span class="n">es_valid</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">es_reserved1</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">__le32</span>	<span class="n">es_node_num</span><span class="p">;</span>
<span class="cm">/*10*/</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The extended slot map, used when OCFS2_FEATURE_INCOMPAT_EXTENDED_SLOT_MAP</span>
<span class="cm"> * is set.  It separates out the valid marker from the node number, and</span>
<span class="cm"> * has room to grow.  Unlike the old slot map, this format is defined by</span>
<span class="cm"> * i_size.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_slot_map_extended</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="k">struct</span> <span class="n">ocfs2_extended_slot</span> <span class="n">se_slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="cm">/*</span>
<span class="cm"> * Actual size is i_size of the slot_map system file.  It should</span>
<span class="cm"> * match s_max_slots * sizeof(struct ocfs2_extended_slot)</span>
<span class="cm"> */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * ci_stackflags is only valid if the incompat bit</span>
<span class="cm"> * OCFS2_FEATURE_INCOMPAT_CLUSTERINFO is set.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_cluster_info</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__u8</span>   <span class="n">ci_stack</span><span class="p">[</span><span class="n">OCFS2_STACK_LABEL_LEN</span><span class="p">];</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">__le32</span> <span class="n">ci_reserved</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__u8</span> <span class="n">ci_stackflags</span><span class="p">;</span>
			<span class="n">__u8</span> <span class="n">ci_reserved1</span><span class="p">;</span>
			<span class="n">__u8</span> <span class="n">ci_reserved2</span><span class="p">;</span>
			<span class="n">__u8</span> <span class="n">ci_reserved3</span><span class="p">;</span>
		<span class="p">};</span>
	<span class="p">};</span>
<span class="cm">/*08*/</span>	<span class="n">__u8</span>   <span class="n">ci_cluster</span><span class="p">[</span><span class="n">OCFS2_CLUSTER_NAME_LEN</span><span class="p">];</span>
<span class="cm">/*18*/</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * On disk superblock for OCFS2</span>
<span class="cm"> * Note that it is contained inside an ocfs2_dinode, so all offsets</span>
<span class="cm"> * are relative to the start of ocfs2_dinode.id2.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_super_block</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__le16</span> <span class="n">s_major_rev_level</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">s_minor_rev_level</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">s_mnt_count</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">s_max_mnt_count</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">s_state</span><span class="p">;</span>			<span class="cm">/* File system state */</span>
	<span class="n">__le16</span> <span class="n">s_errors</span><span class="p">;</span>			<span class="cm">/* Behaviour when detecting errors */</span>
	<span class="n">__le32</span> <span class="n">s_checkinterval</span><span class="p">;</span>		<span class="cm">/* Max time between checks */</span>
<span class="cm">/*10*/</span>	<span class="n">__le64</span> <span class="n">s_lastcheck</span><span class="p">;</span>		<span class="cm">/* Time of last check */</span>
	<span class="n">__le32</span> <span class="n">s_creator_os</span><span class="p">;</span>		<span class="cm">/* OS */</span>
	<span class="n">__le32</span> <span class="n">s_feature_compat</span><span class="p">;</span>		<span class="cm">/* Compatible feature set */</span>
<span class="cm">/*20*/</span>	<span class="n">__le32</span> <span class="n">s_feature_incompat</span><span class="p">;</span>	<span class="cm">/* Incompatible feature set */</span>
	<span class="n">__le32</span> <span class="n">s_feature_ro_compat</span><span class="p">;</span>	<span class="cm">/* Readonly-compatible feature set */</span>
	<span class="n">__le64</span> <span class="n">s_root_blkno</span><span class="p">;</span>		<span class="cm">/* Offset, in blocks, of root directory</span>
<span class="cm">					   dinode */</span>
<span class="cm">/*30*/</span>	<span class="n">__le64</span> <span class="n">s_system_dir_blkno</span><span class="p">;</span>	<span class="cm">/* Offset, in blocks, of system</span>
<span class="cm">					   directory dinode */</span>
	<span class="n">__le32</span> <span class="n">s_blocksize_bits</span><span class="p">;</span>		<span class="cm">/* Blocksize for this fs */</span>
	<span class="n">__le32</span> <span class="n">s_clustersize_bits</span><span class="p">;</span>	<span class="cm">/* Clustersize for this fs */</span>
<span class="cm">/*40*/</span>	<span class="n">__le16</span> <span class="n">s_max_slots</span><span class="p">;</span>		<span class="cm">/* Max number of simultaneous mounts</span>
<span class="cm">					   before tunefs required */</span>
	<span class="n">__le16</span> <span class="n">s_tunefs_flag</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">s_uuid_hash</span><span class="p">;</span>		<span class="cm">/* hash value of uuid */</span>
	<span class="n">__le64</span> <span class="n">s_first_cluster_group</span><span class="p">;</span>	<span class="cm">/* Block offset of 1st cluster</span>
<span class="cm">					 * group header */</span>
<span class="cm">/*50*/</span>	<span class="n">__u8</span>  <span class="n">s_label</span><span class="p">[</span><span class="n">OCFS2_MAX_VOL_LABEL_LEN</span><span class="p">];</span>	<span class="cm">/* Label for mounting, etc. */</span>
<span class="cm">/*90*/</span>	<span class="n">__u8</span>  <span class="n">s_uuid</span><span class="p">[</span><span class="n">OCFS2_VOL_UUID_LEN</span><span class="p">];</span>	<span class="cm">/* 128-bit uuid */</span>
<span class="cm">/*A0*/</span>  <span class="k">struct</span> <span class="n">ocfs2_cluster_info</span> <span class="n">s_cluster_info</span><span class="p">;</span> <span class="cm">/* Only valid if either</span>
<span class="cm">						     userspace or clusterinfo</span>
<span class="cm">						     INCOMPAT flag set. */</span>
<span class="cm">/*B8*/</span>	<span class="n">__le16</span> <span class="n">s_xattr_inline_size</span><span class="p">;</span>	<span class="cm">/* extended attribute inline size</span>
<span class="cm">					   for this fs*/</span>
	<span class="n">__le16</span> <span class="n">s_reserved0</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">s_dx_seed</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>		<span class="cm">/* seed[0-2] for dx dir hash.</span>
<span class="cm">					 * s_uuid_hash serves as seed[3]. */</span>
<span class="cm">/*C0*/</span>  <span class="n">__le64</span> <span class="n">s_reserved2</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>		<span class="cm">/* Fill out superblock */</span>
<span class="cm">/*140*/</span>

	<span class="cm">/*</span>
<span class="cm">	 * NOTE: As stated above, all offsets are relative to</span>
<span class="cm">	 * ocfs2_dinode.id2, which is at 0xC0 in the inode.</span>
<span class="cm">	 * 0xC0 + 0x140 = 0x200 or 512 bytes.  A superblock must fit within</span>
<span class="cm">	 * our smallest blocksize, which is 512 bytes.  To ensure this,</span>
<span class="cm">	 * we reserve the space in s_reserved2.  Anything past s_reserved2</span>
<span class="cm">	 * will not be available on the smallest blocksize.</span>
<span class="cm">	 */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Local allocation bitmap for OCFS2 slots</span>
<span class="cm"> * Note that it exists inside an ocfs2_dinode, so all offsets are</span>
<span class="cm"> * relative to the start of ocfs2_dinode.id2.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_local_alloc</span>
<span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__le32</span> <span class="n">la_bm_off</span><span class="p">;</span>	<span class="cm">/* Starting bit offset in main bitmap */</span>
	<span class="n">__le16</span> <span class="n">la_size</span><span class="p">;</span>		<span class="cm">/* Size of included bitmap, in bytes */</span>
	<span class="n">__le16</span> <span class="n">la_reserved1</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">la_reserved2</span><span class="p">;</span>
<span class="cm">/*10*/</span>	<span class="n">__u8</span>   <span class="n">la_bitmap</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Data-in-inode header. This is only used if i_dyn_features has</span>
<span class="cm"> * OCFS2_INLINE_DATA_FL set.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_inline_data</span>
<span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__le16</span>	<span class="n">id_count</span><span class="p">;</span>	<span class="cm">/* Number of bytes that can be used</span>
<span class="cm">				 * for data, starting at id_data */</span>
	<span class="n">__le16</span>	<span class="n">id_reserved0</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">id_reserved1</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">id_data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* Start of user data */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * On disk inode for OCFS2</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_dinode</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__u8</span> <span class="n">i_signature</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>		<span class="cm">/* Signature for validation */</span>
	<span class="n">__le32</span> <span class="n">i_generation</span><span class="p">;</span>		<span class="cm">/* Generation number */</span>
	<span class="n">__le16</span> <span class="n">i_suballoc_slot</span><span class="p">;</span>		<span class="cm">/* Slot suballocator this inode</span>
<span class="cm">					   belongs to */</span>
	<span class="n">__le16</span> <span class="n">i_suballoc_bit</span><span class="p">;</span>		<span class="cm">/* Bit offset in suballocator</span>
<span class="cm">					   block group */</span>
<span class="cm">/*10*/</span>	<span class="n">__le16</span> <span class="n">i_links_count_hi</span><span class="p">;</span>	<span class="cm">/* High 16 bits of links count */</span>
	<span class="n">__le16</span> <span class="n">i_xattr_inline_size</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">i_clusters</span><span class="p">;</span>		<span class="cm">/* Cluster count */</span>
	<span class="n">__le32</span> <span class="n">i_uid</span><span class="p">;</span>			<span class="cm">/* Owner UID */</span>
	<span class="n">__le32</span> <span class="n">i_gid</span><span class="p">;</span>			<span class="cm">/* Owning GID */</span>
<span class="cm">/*20*/</span>	<span class="n">__le64</span> <span class="n">i_size</span><span class="p">;</span>			<span class="cm">/* Size in bytes */</span>
	<span class="n">__le16</span> <span class="n">i_mode</span><span class="p">;</span>			<span class="cm">/* File mode */</span>
	<span class="n">__le16</span> <span class="n">i_links_count</span><span class="p">;</span>		<span class="cm">/* Links count */</span>
	<span class="n">__le32</span> <span class="n">i_flags</span><span class="p">;</span>			<span class="cm">/* File flags */</span>
<span class="cm">/*30*/</span>	<span class="n">__le64</span> <span class="n">i_atime</span><span class="p">;</span>			<span class="cm">/* Access time */</span>
	<span class="n">__le64</span> <span class="n">i_ctime</span><span class="p">;</span>			<span class="cm">/* Creation time */</span>
<span class="cm">/*40*/</span>	<span class="n">__le64</span> <span class="n">i_mtime</span><span class="p">;</span>			<span class="cm">/* Modification time */</span>
	<span class="n">__le64</span> <span class="n">i_dtime</span><span class="p">;</span>			<span class="cm">/* Deletion time */</span>
<span class="cm">/*50*/</span>	<span class="n">__le64</span> <span class="n">i_blkno</span><span class="p">;</span>			<span class="cm">/* Offset on disk, in blocks */</span>
	<span class="n">__le64</span> <span class="n">i_last_eb_blk</span><span class="p">;</span>		<span class="cm">/* Pointer to last extent</span>
<span class="cm">					   block */</span>
<span class="cm">/*60*/</span>	<span class="n">__le32</span> <span class="n">i_fs_generation</span><span class="p">;</span>		<span class="cm">/* Generation per fs-instance */</span>
	<span class="n">__le32</span> <span class="n">i_atime_nsec</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">i_ctime_nsec</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">i_mtime_nsec</span><span class="p">;</span>
<span class="cm">/*70*/</span>	<span class="n">__le32</span> <span class="n">i_attr</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">i_orphaned_slot</span><span class="p">;</span>		<span class="cm">/* Only valid when OCFS2_ORPHANED_FL</span>
<span class="cm">					   was set in i_flags */</span>
	<span class="n">__le16</span> <span class="n">i_dyn_features</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">i_xattr_loc</span><span class="p">;</span>
<span class="cm">/*80*/</span>	<span class="k">struct</span> <span class="n">ocfs2_block_check</span> <span class="n">i_check</span><span class="p">;</span>	<span class="cm">/* Error checking */</span>
<span class="cm">/*88*/</span>	<span class="n">__le64</span> <span class="n">i_dx_root</span><span class="p">;</span>		<span class="cm">/* Pointer to dir index root block */</span>
<span class="cm">/*90*/</span>	<span class="n">__le64</span> <span class="n">i_refcount_loc</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">i_suballoc_loc</span><span class="p">;</span>		<span class="cm">/* Suballocator block group this</span>
<span class="cm">					   inode belongs to.  Only valid</span>
<span class="cm">					   if allocated from a</span>
<span class="cm">					   discontiguous block group */</span>
<span class="cm">/*A0*/</span>	<span class="n">__le64</span> <span class="n">i_reserved2</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="cm">/*B8*/</span>	<span class="k">union</span> <span class="p">{</span>
		<span class="n">__le64</span> <span class="n">i_pad1</span><span class="p">;</span>		<span class="cm">/* Generic way to refer to this</span>
<span class="cm">					   64bit union */</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__le64</span> <span class="n">i_rdev</span><span class="p">;</span>	<span class="cm">/* Device number */</span>
		<span class="p">}</span> <span class="n">dev1</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>		<span class="cm">/* Info for bitmap system</span>
<span class="cm">					   inodes */</span>
			<span class="n">__le32</span> <span class="n">i_used</span><span class="p">;</span>	<span class="cm">/* Bits (ie, clusters) used  */</span>
			<span class="n">__le32</span> <span class="n">i_total</span><span class="p">;</span>	<span class="cm">/* Total bits (clusters)</span>
<span class="cm">					   available */</span>
		<span class="p">}</span> <span class="n">bitmap1</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>		<span class="cm">/* Info for journal system</span>
<span class="cm">					   inodes */</span>
			<span class="n">__le32</span> <span class="n">ij_flags</span><span class="p">;</span>	<span class="cm">/* Mounted, version, etc. */</span>
			<span class="n">__le32</span> <span class="n">ij_recovery_generation</span><span class="p">;</span> <span class="cm">/* Incremented when the</span>
<span class="cm">							  journal is recovered</span>
<span class="cm">							  after an unclean</span>
<span class="cm">							  shutdown */</span>
		<span class="p">}</span> <span class="n">journal1</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">id1</span><span class="p">;</span>				<span class="cm">/* Inode type dependent 1 */</span>
<span class="cm">/*C0*/</span>	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ocfs2_super_block</span>	<span class="n">i_super</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ocfs2_local_alloc</span>	<span class="n">i_lab</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ocfs2_chain_list</span>		<span class="n">i_chain</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ocfs2_extent_list</span>	<span class="n">i_list</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ocfs2_truncate_log</span>	<span class="n">i_dealloc</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ocfs2_inline_data</span>	<span class="n">i_data</span><span class="p">;</span>
		<span class="n">__u8</span>               		<span class="n">i_symlink</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">id2</span><span class="p">;</span>
<span class="cm">/* Actual on-disk size is one block */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * On-disk directory entry structure for OCFS2</span>
<span class="cm"> *</span>
<span class="cm"> * Packed as this structure could be accessed unaligned on 64-bit platforms</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_dir_entry</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__le64</span>   <span class="n">inode</span><span class="p">;</span>                  <span class="cm">/* Inode number */</span>
	<span class="n">__le16</span>   <span class="n">rec_len</span><span class="p">;</span>                <span class="cm">/* Directory entry length */</span>
	<span class="n">__u8</span>    <span class="n">name_len</span><span class="p">;</span>               <span class="cm">/* Name length */</span>
	<span class="n">__u8</span>    <span class="n">file_type</span><span class="p">;</span>
<span class="cm">/*0C*/</span>	<span class="kt">char</span>    <span class="n">name</span><span class="p">[</span><span class="n">OCFS2_MAX_FILENAME_LEN</span><span class="p">];</span>   <span class="cm">/* File name */</span>
<span class="cm">/* Actual on-disk length specified by rec_len */</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/*</span>
<span class="cm"> * Per-block record for the unindexed directory btree. This is carefully</span>
<span class="cm"> * crafted so that the rec_len and name_len records of an ocfs2_dir_entry are</span>
<span class="cm"> * mirrored. That way, the directory manipulation code needs a minimal amount</span>
<span class="cm"> * of update.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Keep this structure aligned to a multiple of 4 bytes.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_dir_block_trailer</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__le64</span>		<span class="n">db_compat_inode</span><span class="p">;</span>	<span class="cm">/* Always zero. Was inode */</span>

	<span class="n">__le16</span>		<span class="n">db_compat_rec_len</span><span class="p">;</span>	<span class="cm">/* Backwards compatible with</span>
<span class="cm">						 * ocfs2_dir_entry. */</span>
	<span class="n">__u8</span>		<span class="n">db_compat_name_len</span><span class="p">;</span>	<span class="cm">/* Always zero. Was name_len */</span>
	<span class="n">__u8</span>		<span class="n">db_reserved0</span><span class="p">;</span>
	<span class="n">__le16</span>		<span class="n">db_reserved1</span><span class="p">;</span>
	<span class="n">__le16</span>		<span class="n">db_free_rec_len</span><span class="p">;</span>	<span class="cm">/* Size of largest empty hole</span>
<span class="cm">						 * in this block. (unused) */</span>
<span class="cm">/*10*/</span>	<span class="n">__u8</span>		<span class="n">db_signature</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>	<span class="cm">/* Signature for verification */</span>
	<span class="n">__le64</span>		<span class="n">db_reserved2</span><span class="p">;</span>
	<span class="n">__le64</span>		<span class="n">db_free_next</span><span class="p">;</span>		<span class="cm">/* Next block in list (unused) */</span>
<span class="cm">/*20*/</span>	<span class="n">__le64</span>		<span class="n">db_blkno</span><span class="p">;</span>		<span class="cm">/* Offset on disk, in blocks */</span>
	<span class="n">__le64</span>		<span class="n">db_parent_dinode</span><span class="p">;</span>	<span class="cm">/* dinode which owns me, in</span>
<span class="cm">						   blocks */</span>
<span class="cm">/*30*/</span>	<span class="k">struct</span> <span class="n">ocfs2_block_check</span> <span class="n">db_check</span><span class="p">;</span>	<span class="cm">/* Error checking */</span>
<span class="cm">/*40*/</span>
<span class="p">};</span>

 <span class="cm">/*</span>
<span class="cm"> * A directory entry in the indexed tree. We don&#39;t store the full name here,</span>
<span class="cm"> * but instead provide a pointer to the full dirent in the unindexed tree.</span>
<span class="cm"> *</span>
<span class="cm"> * We also store name_len here so as to reduce the number of leaf blocks we</span>
<span class="cm"> * need to search in case of collisions.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_dx_entry</span> <span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">dx_major_hash</span><span class="p">;</span>	<span class="cm">/* Used to find logical</span>
<span class="cm">					 * cluster in index */</span>
	<span class="n">__le32</span>		<span class="n">dx_minor_hash</span><span class="p">;</span>	<span class="cm">/* Lower bits used to find</span>
<span class="cm">					 * block in cluster */</span>
	<span class="n">__le64</span>		<span class="n">dx_dirent_blk</span><span class="p">;</span>	<span class="cm">/* Physical block in unindexed</span>
<span class="cm">					 * tree holding this dirent. */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ocfs2_dx_entry_list</span> <span class="p">{</span>
	<span class="n">__le32</span>		<span class="n">de_reserved</span><span class="p">;</span>
	<span class="n">__le16</span>		<span class="n">de_count</span><span class="p">;</span>	<span class="cm">/* Maximum number of entries</span>
<span class="cm">					 * possible in de_entries */</span>
	<span class="n">__le16</span>		<span class="n">de_num_used</span><span class="p">;</span>	<span class="cm">/* Current number of</span>
<span class="cm">					 * de_entries entries */</span>
	<span class="k">struct</span>	<span class="n">ocfs2_dx_entry</span>		<span class="n">de_entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* Indexed dir entries</span>
<span class="cm">							 * in a packed array of</span>
<span class="cm">							 * length de_num_used */</span>
<span class="p">};</span>

<span class="cp">#define OCFS2_DX_FLAG_INLINE	0x01</span>

<span class="cm">/*</span>
<span class="cm"> * A directory indexing block. Each indexed directory has one of these,</span>
<span class="cm"> * pointed to by ocfs2_dinode.</span>
<span class="cm"> *</span>
<span class="cm"> * This block stores an indexed btree root, and a set of free space</span>
<span class="cm"> * start-of-list pointers.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_dx_root_block</span> <span class="p">{</span>
	<span class="n">__u8</span>		<span class="n">dr_signature</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>	<span class="cm">/* Signature for verification */</span>
	<span class="k">struct</span> <span class="n">ocfs2_block_check</span> <span class="n">dr_check</span><span class="p">;</span>	<span class="cm">/* Error checking */</span>
	<span class="n">__le16</span>		<span class="n">dr_suballoc_slot</span><span class="p">;</span>	<span class="cm">/* Slot suballocator this</span>
<span class="cm">						 * block belongs to. */</span>
	<span class="n">__le16</span>		<span class="n">dr_suballoc_bit</span><span class="p">;</span>	<span class="cm">/* Bit offset in suballocator</span>
<span class="cm">						 * block group */</span>
	<span class="n">__le32</span>		<span class="n">dr_fs_generation</span><span class="p">;</span>	<span class="cm">/* Must match super block */</span>
	<span class="n">__le64</span>		<span class="n">dr_blkno</span><span class="p">;</span>		<span class="cm">/* Offset on disk, in blocks */</span>
	<span class="n">__le64</span>		<span class="n">dr_last_eb_blk</span><span class="p">;</span>		<span class="cm">/* Pointer to last</span>
<span class="cm">						 * extent block */</span>
	<span class="n">__le32</span>		<span class="n">dr_clusters</span><span class="p">;</span>		<span class="cm">/* Clusters allocated</span>
<span class="cm">						 * to the indexed tree. */</span>
	<span class="n">__u8</span>		<span class="n">dr_flags</span><span class="p">;</span>		<span class="cm">/* OCFS2_DX_FLAG_* flags */</span>
	<span class="n">__u8</span>		<span class="n">dr_reserved0</span><span class="p">;</span>
	<span class="n">__le16</span>		<span class="n">dr_reserved1</span><span class="p">;</span>
	<span class="n">__le64</span>		<span class="n">dr_dir_blkno</span><span class="p">;</span>		<span class="cm">/* Pointer to parent inode */</span>
	<span class="n">__le32</span>		<span class="n">dr_num_entries</span><span class="p">;</span>		<span class="cm">/* Total number of</span>
<span class="cm">						 * names stored in</span>
<span class="cm">						 * this directory.*/</span>
	<span class="n">__le32</span>		<span class="n">dr_reserved2</span><span class="p">;</span>
	<span class="n">__le64</span>		<span class="n">dr_free_blk</span><span class="p">;</span>		<span class="cm">/* Pointer to head of free</span>
<span class="cm">						 * unindexed block list. */</span>
	<span class="n">__le64</span>		<span class="n">dr_suballoc_loc</span><span class="p">;</span>	<span class="cm">/* Suballocator block group</span>
<span class="cm">						   this root belongs to.</span>
<span class="cm">						   Only valid if allocated</span>
<span class="cm">						   from a discontiguous</span>
<span class="cm">						   block group */</span>
	<span class="n">__le64</span>		<span class="n">dr_reserved3</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ocfs2_extent_list</span> <span class="n">dr_list</span><span class="p">;</span> <span class="cm">/* Keep this aligned to 128</span>
<span class="cm">						   * bits for maximum space</span>
<span class="cm">						   * efficiency. */</span>
		<span class="k">struct</span> <span class="n">ocfs2_dx_entry_list</span> <span class="n">dr_entries</span><span class="p">;</span> <span class="cm">/* In-root-block list of</span>
<span class="cm">							* entries. We grow out</span>
<span class="cm">							* to extents if this</span>
<span class="cm">							* gets too big. */</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The header of a leaf block in the indexed tree.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_dx_leaf</span> <span class="p">{</span>
	<span class="n">__u8</span>		<span class="n">dl_signature</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span><span class="cm">/* Signature for verification */</span>
	<span class="k">struct</span> <span class="n">ocfs2_block_check</span> <span class="n">dl_check</span><span class="p">;</span>	<span class="cm">/* Error checking */</span>
	<span class="n">__le64</span>		<span class="n">dl_blkno</span><span class="p">;</span>	<span class="cm">/* Offset on disk, in blocks */</span>
	<span class="n">__le32</span>		<span class="n">dl_fs_generation</span><span class="p">;</span><span class="cm">/* Must match super block */</span>
	<span class="n">__le32</span>		<span class="n">dl_reserved0</span><span class="p">;</span>
	<span class="n">__le64</span>		<span class="n">dl_reserved1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_dx_entry_list</span>	<span class="n">dl_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Largest bitmap for a block (suballocator) group in bytes.  This limit</span>
<span class="cm"> * does not affect cluster groups (global allocator).  Cluster group</span>
<span class="cm"> * bitmaps run to the end of the block.</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_MAX_BG_BITMAP_SIZE	256</span>

<span class="cm">/*</span>
<span class="cm"> * On disk allocator group structure for OCFS2</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_group_desc</span>
<span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__u8</span>    <span class="n">bg_signature</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>        <span class="cm">/* Signature for validation */</span>
	<span class="n">__le16</span>   <span class="n">bg_size</span><span class="p">;</span>                <span class="cm">/* Size of included bitmap in</span>
<span class="cm">					   bytes. */</span>
	<span class="n">__le16</span>   <span class="n">bg_bits</span><span class="p">;</span>                <span class="cm">/* Bits represented by this</span>
<span class="cm">					   group. */</span>
	<span class="n">__le16</span>	<span class="n">bg_free_bits_count</span><span class="p">;</span>     <span class="cm">/* Free bits count */</span>
	<span class="n">__le16</span>   <span class="n">bg_chain</span><span class="p">;</span>               <span class="cm">/* What chain I am in. */</span>
<span class="cm">/*10*/</span>	<span class="n">__le32</span>   <span class="n">bg_generation</span><span class="p">;</span>
	<span class="n">__le32</span>	<span class="n">bg_reserved1</span><span class="p">;</span>
	<span class="n">__le64</span>   <span class="n">bg_next_group</span><span class="p">;</span>          <span class="cm">/* Next group in my list, in</span>
<span class="cm">					   blocks */</span>
<span class="cm">/*20*/</span>	<span class="n">__le64</span>   <span class="n">bg_parent_dinode</span><span class="p">;</span>       <span class="cm">/* dinode which owns me, in</span>
<span class="cm">					   blocks */</span>
	<span class="n">__le64</span>   <span class="n">bg_blkno</span><span class="p">;</span>               <span class="cm">/* Offset on disk, in blocks */</span>
<span class="cm">/*30*/</span>	<span class="k">struct</span> <span class="n">ocfs2_block_check</span> <span class="n">bg_check</span><span class="p">;</span>	<span class="cm">/* Error checking */</span>
	<span class="n">__le64</span>   <span class="n">bg_reserved2</span><span class="p">;</span>
<span class="cm">/*40*/</span>	<span class="k">union</span> <span class="p">{</span>
		<span class="n">__u8</span>    <span class="n">bg_bitmap</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Block groups may be discontiguous when</span>
<span class="cm">			 * OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG is set.</span>
<span class="cm">			 * The extents of a discontigous block group are</span>
<span class="cm">			 * stored in bg_list.  It is a flat list.</span>
<span class="cm">			 * l_tree_depth must always be zero.  A</span>
<span class="cm">			 * discontiguous group is signified by a non-zero</span>
<span class="cm">			 * bg_list-&gt;l_next_free_rec.  Only block groups</span>
<span class="cm">			 * can be discontiguous; Cluster groups cannot.</span>
<span class="cm">			 * We&#39;ve never made a block group with more than</span>
<span class="cm">			 * 2048 blocks (256 bytes of bg_bitmap).  This</span>
<span class="cm">			 * codifies that limit so that we can fit bg_list.</span>
<span class="cm">			 * bg_size of a discontiguous block group will</span>
<span class="cm">			 * be 256 to match bg_bitmap_filler.</span>
<span class="cm">			 */</span>
			<span class="n">__u8</span> <span class="n">bg_bitmap_filler</span><span class="p">[</span><span class="n">OCFS2_MAX_BG_BITMAP_SIZE</span><span class="p">];</span>
<span class="cm">/*140*/</span>			<span class="k">struct</span> <span class="n">ocfs2_extent_list</span> <span class="n">bg_list</span><span class="p">;</span>
		<span class="p">};</span>
	<span class="p">};</span>
<span class="cm">/* Actual on-disk size is one block */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ocfs2_refcount_rec</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__le64</span> <span class="n">r_cpos</span><span class="p">;</span>		<span class="cm">/* Physical offset, in clusters */</span>
	<span class="n">__le32</span> <span class="n">r_clusters</span><span class="p">;</span>	<span class="cm">/* Clusters covered by this extent */</span>
	<span class="n">__le32</span> <span class="n">r_refcount</span><span class="p">;</span>	<span class="cm">/* Reference count of this extent */</span>
<span class="cm">/*10*/</span>
<span class="p">};</span>
<span class="cp">#define OCFS2_32BIT_POS_MASK		(0xffffffffULL)</span>

<span class="cp">#define OCFS2_REFCOUNT_LEAF_FL          (0x00000001)</span>
<span class="cp">#define OCFS2_REFCOUNT_TREE_FL          (0x00000002)</span>

<span class="k">struct</span> <span class="n">ocfs2_refcount_list</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__le16</span> <span class="n">rl_count</span><span class="p">;</span>	<span class="cm">/* Maximum number of entries possible</span>
<span class="cm">				   in rl_records */</span>
	<span class="n">__le16</span> <span class="n">rl_used</span><span class="p">;</span>		<span class="cm">/* Current number of used records */</span>
	<span class="n">__le32</span> <span class="n">rl_reserved2</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">rl_reserved1</span><span class="p">;</span>	<span class="cm">/* Pad to sizeof(ocfs2_refcount_record) */</span>
<span class="cm">/*10*/</span>	<span class="k">struct</span> <span class="n">ocfs2_refcount_rec</span> <span class="n">rl_recs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* Refcount records */</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">ocfs2_refcount_block</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__u8</span> <span class="n">rf_signature</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>		<span class="cm">/* Signature for verification */</span>
	<span class="n">__le16</span> <span class="n">rf_suballoc_slot</span><span class="p">;</span>	<span class="cm">/* Slot suballocator this block</span>
<span class="cm">					   belongs to */</span>
	<span class="n">__le16</span> <span class="n">rf_suballoc_bit</span><span class="p">;</span>		<span class="cm">/* Bit offset in suballocator</span>
<span class="cm">					   block group */</span>
	<span class="n">__le32</span> <span class="n">rf_fs_generation</span><span class="p">;</span>	<span class="cm">/* Must match superblock */</span>
<span class="cm">/*10*/</span>	<span class="n">__le64</span> <span class="n">rf_blkno</span><span class="p">;</span>		<span class="cm">/* Offset on disk, in blocks */</span>
	<span class="n">__le64</span> <span class="n">rf_parent</span><span class="p">;</span>		<span class="cm">/* Parent block, only valid if</span>
<span class="cm">					   OCFS2_REFCOUNT_LEAF_FL is set in</span>
<span class="cm">					   rf_flags */</span>
<span class="cm">/*20*/</span>	<span class="k">struct</span> <span class="n">ocfs2_block_check</span> <span class="n">rf_check</span><span class="p">;</span>	<span class="cm">/* Error checking */</span>
	<span class="n">__le64</span> <span class="n">rf_last_eb_blk</span><span class="p">;</span>		<span class="cm">/* Pointer to last extent block */</span>
<span class="cm">/*30*/</span>	<span class="n">__le32</span> <span class="n">rf_count</span><span class="p">;</span>		<span class="cm">/* Number of inodes sharing this</span>
<span class="cm">					   refcount tree */</span>
	<span class="n">__le32</span> <span class="n">rf_flags</span><span class="p">;</span>		<span class="cm">/* See the flags above */</span>
	<span class="n">__le32</span> <span class="n">rf_clusters</span><span class="p">;</span>		<span class="cm">/* clusters covered by refcount tree. */</span>
	<span class="n">__le32</span> <span class="n">rf_cpos</span><span class="p">;</span>			<span class="cm">/* cluster offset in refcount tree.*/</span>
<span class="cm">/*40*/</span>	<span class="n">__le32</span> <span class="n">rf_generation</span><span class="p">;</span>		<span class="cm">/* generation number. all be the same</span>
<span class="cm">					 * for the same refcount tree. */</span>
	<span class="n">__le32</span> <span class="n">rf_reserved0</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">rf_suballoc_loc</span><span class="p">;</span>		<span class="cm">/* Suballocator block group this</span>
<span class="cm">					   refcount block belongs to. Only</span>
<span class="cm">					   valid if allocated from a</span>
<span class="cm">					   discontiguous block group */</span>
<span class="cm">/*50*/</span>	<span class="n">__le64</span> <span class="n">rf_reserved1</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
<span class="cm">/*80*/</span>	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ocfs2_refcount_list</span> <span class="n">rf_records</span><span class="p">;</span>  <span class="cm">/* List of refcount</span>
<span class="cm">							  records */</span>
		<span class="k">struct</span> <span class="n">ocfs2_extent_list</span> <span class="n">rf_list</span><span class="p">;</span>	<span class="cm">/* Extent record list,</span>
<span class="cm">							only valid if</span>
<span class="cm">							OCFS2_REFCOUNT_TREE_FL</span>
<span class="cm">							is set in rf_flags */</span>
	<span class="p">};</span>
<span class="cm">/* Actual on-disk size is one block */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * On disk extended attribute structure for OCFS2.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * ocfs2_xattr_entry indicates one extend attribute.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that it can be stored in inode, one block or one xattr bucket.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_xattr_entry</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">xe_name_hash</span><span class="p">;</span>    <span class="cm">/* hash value of xattr prefix+suffix. */</span>
	<span class="n">__le16</span>	<span class="n">xe_name_offset</span><span class="p">;</span>  <span class="cm">/* byte offset from the 1st entry in the</span>
<span class="cm">				    local xattr storage(inode, xattr block or</span>
<span class="cm">				    xattr bucket). */</span>
	<span class="n">__u8</span>	<span class="n">xe_name_len</span><span class="p">;</span>	 <span class="cm">/* xattr name len, doesn&#39;t include prefix. */</span>
	<span class="n">__u8</span>	<span class="n">xe_type</span><span class="p">;</span>         <span class="cm">/* the low 7 bits indicate the name prefix</span>
<span class="cm">				  * type and the highest bit indicates whether</span>
<span class="cm">				  * the EA is stored in the local storage. */</span>
	<span class="n">__le64</span>	<span class="n">xe_value_size</span><span class="p">;</span>	 <span class="cm">/* real xattr value length. */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * On disk structure for xattr header.</span>
<span class="cm"> *</span>
<span class="cm"> * One ocfs2_xattr_header describes how many ocfs2_xattr_entry records in</span>
<span class="cm"> * the local xattr storage.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_xattr_header</span> <span class="p">{</span>
	<span class="n">__le16</span>	<span class="n">xh_count</span><span class="p">;</span>                       <span class="cm">/* contains the count of how</span>
<span class="cm">						   many records are in the</span>
<span class="cm">						   local xattr storage. */</span>
	<span class="n">__le16</span>	<span class="n">xh_free_start</span><span class="p">;</span>                  <span class="cm">/* current offset for storing</span>
<span class="cm">						   xattr. */</span>
	<span class="n">__le16</span>	<span class="n">xh_name_value_len</span><span class="p">;</span>              <span class="cm">/* total length of name/value</span>
<span class="cm">						   length in this bucket. */</span>
	<span class="n">__le16</span>	<span class="n">xh_num_buckets</span><span class="p">;</span>                 <span class="cm">/* Number of xattr buckets</span>
<span class="cm">						   in this extent record,</span>
<span class="cm">						   only valid in the first</span>
<span class="cm">						   bucket. */</span>
	<span class="k">struct</span> <span class="n">ocfs2_block_check</span> <span class="n">xh_check</span><span class="p">;</span>	<span class="cm">/* Error checking</span>
<span class="cm">						   (Note, this is only</span>
<span class="cm">						    used for xattr</span>
<span class="cm">						    buckets.  A block uses</span>
<span class="cm">						    xb_check and sets</span>
<span class="cm">						    this field to zero.) */</span>
	<span class="k">struct</span> <span class="n">ocfs2_xattr_entry</span> <span class="n">xh_entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="cm">/* xattr entry list. */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * On disk structure for xattr value root.</span>
<span class="cm"> *</span>
<span class="cm"> * When an xattr&#39;s value is large enough, it is stored in an external</span>
<span class="cm"> * b-tree like file data.  The xattr value root points to this structure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_xattr_value_root</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__le32</span>	<span class="n">xr_clusters</span><span class="p">;</span>              <span class="cm">/* clusters covered by xattr value. */</span>
	<span class="n">__le32</span>	<span class="n">xr_reserved0</span><span class="p">;</span>
	<span class="n">__le64</span>	<span class="n">xr_last_eb_blk</span><span class="p">;</span>           <span class="cm">/* Pointer to last extent block */</span>
<span class="cm">/*10*/</span>	<span class="k">struct</span> <span class="n">ocfs2_extent_list</span> <span class="n">xr_list</span><span class="p">;</span> <span class="cm">/* Extent record list */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * On disk structure for xattr tree root.</span>
<span class="cm"> *</span>
<span class="cm"> * It is used when there are too many extended attributes for one file. These</span>
<span class="cm"> * attributes will be organized and stored in an indexed-btree.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_xattr_tree_root</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__le32</span>	<span class="n">xt_clusters</span><span class="p">;</span>              <span class="cm">/* clusters covered by xattr. */</span>
	<span class="n">__le32</span>	<span class="n">xt_reserved0</span><span class="p">;</span>
	<span class="n">__le64</span>	<span class="n">xt_last_eb_blk</span><span class="p">;</span>           <span class="cm">/* Pointer to last extent block */</span>
<span class="cm">/*10*/</span>	<span class="k">struct</span> <span class="n">ocfs2_extent_list</span> <span class="n">xt_list</span><span class="p">;</span> <span class="cm">/* Extent record list */</span>
<span class="p">};</span>

<span class="cp">#define OCFS2_XATTR_INDEXED	0x1</span>
<span class="cp">#define OCFS2_HASH_SHIFT	5</span>
<span class="cp">#define OCFS2_XATTR_ROUND	3</span>
<span class="cp">#define OCFS2_XATTR_SIZE(size)	(((size) + OCFS2_XATTR_ROUND) &amp; \</span>
<span class="cp">				~(OCFS2_XATTR_ROUND))</span>

<span class="cp">#define OCFS2_XATTR_BUCKET_SIZE			4096</span>
<span class="cp">#define OCFS2_XATTR_MAX_BLOCKS_PER_BUCKET 	(OCFS2_XATTR_BUCKET_SIZE \</span>
<span class="cp">						 / OCFS2_MIN_BLOCKSIZE)</span>

<span class="cm">/*</span>
<span class="cm"> * On disk structure for xattr block.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ocfs2_xattr_block</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__u8</span>	<span class="n">xb_signature</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>     <span class="cm">/* Signature for verification */</span>
	<span class="n">__le16</span>	<span class="n">xb_suballoc_slot</span><span class="p">;</span>    <span class="cm">/* Slot suballocator this</span>
<span class="cm">					block belongs to. */</span>
	<span class="n">__le16</span>	<span class="n">xb_suballoc_bit</span><span class="p">;</span>     <span class="cm">/* Bit offset in suballocator</span>
<span class="cm">					block group */</span>
	<span class="n">__le32</span>	<span class="n">xb_fs_generation</span><span class="p">;</span>    <span class="cm">/* Must match super block */</span>
<span class="cm">/*10*/</span>	<span class="n">__le64</span>	<span class="n">xb_blkno</span><span class="p">;</span>            <span class="cm">/* Offset on disk, in blocks */</span>
	<span class="k">struct</span> <span class="n">ocfs2_block_check</span> <span class="n">xb_check</span><span class="p">;</span>	<span class="cm">/* Error checking */</span>
<span class="cm">/*20*/</span>	<span class="n">__le16</span>	<span class="n">xb_flags</span><span class="p">;</span>            <span class="cm">/* Indicates whether this block contains</span>
<span class="cm">					real xattr or a xattr tree. */</span>
	<span class="n">__le16</span>	<span class="n">xb_reserved0</span><span class="p">;</span>
	<span class="n">__le32</span>  <span class="n">xb_reserved1</span><span class="p">;</span>
	<span class="n">__le64</span>	<span class="n">xb_suballoc_loc</span><span class="p">;</span>	<span class="cm">/* Suballocator block group this</span>
<span class="cm">					   xattr block belongs to. Only</span>
<span class="cm">					   valid if allocated from a</span>
<span class="cm">					   discontiguous block group */</span>
<span class="cm">/*30*/</span>	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ocfs2_xattr_header</span> <span class="n">xb_header</span><span class="p">;</span> <span class="cm">/* xattr header if this</span>
<span class="cm">							block contains xattr */</span>
		<span class="k">struct</span> <span class="n">ocfs2_xattr_tree_root</span> <span class="n">xb_root</span><span class="p">;</span><span class="cm">/* xattr tree root if this</span>
<span class="cm">							block cotains xattr</span>
<span class="cm">							tree. */</span>
	<span class="p">}</span> <span class="n">xb_attrs</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define OCFS2_XATTR_ENTRY_LOCAL		0x80</span>
<span class="cp">#define OCFS2_XATTR_TYPE_MASK		0x7F</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ocfs2_xattr_set_local</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_xattr_entry</span> <span class="o">*</span><span class="n">xe</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">local</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">local</span><span class="p">)</span>
		<span class="n">xe</span><span class="o">-&gt;</span><span class="n">xe_type</span> <span class="o">|=</span> <span class="n">OCFS2_XATTR_ENTRY_LOCAL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">xe</span><span class="o">-&gt;</span><span class="n">xe_type</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">OCFS2_XATTR_ENTRY_LOCAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_xattr_is_local</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_xattr_entry</span> <span class="o">*</span><span class="n">xe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xe</span><span class="o">-&gt;</span><span class="n">xe_type</span> <span class="o">&amp;</span> <span class="n">OCFS2_XATTR_ENTRY_LOCAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ocfs2_xattr_set_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_xattr_entry</span> <span class="o">*</span><span class="n">xe</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">xe</span><span class="o">-&gt;</span><span class="n">xe_type</span> <span class="o">|=</span> <span class="n">type</span> <span class="o">&amp;</span> <span class="n">OCFS2_XATTR_TYPE_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_xattr_get_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_xattr_entry</span> <span class="o">*</span><span class="n">xe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xe</span><span class="o">-&gt;</span><span class="n">xe_type</span> <span class="o">&amp;</span> <span class="n">OCFS2_XATTR_TYPE_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  On disk structures for global quota file</span>
<span class="cm"> */</span>

<span class="cm">/* Magic numbers and known versions for global quota files */</span>
<span class="cp">#define OCFS2_GLOBAL_QMAGICS {\</span>
<span class="cp">	0x0cf52470, </span><span class="cm">/* USRQUOTA */</span><span class="cp"> \</span>
<span class="cp">	0x0cf52471  </span><span class="cm">/* GRPQUOTA */</span><span class="cp"> \</span>
<span class="cp">}</span>

<span class="cp">#define OCFS2_GLOBAL_QVERSIONS {\</span>
<span class="cp">	0, \</span>
<span class="cp">	0, \</span>
<span class="cp">}</span>


<span class="cm">/* Each block of each quota file has a certain fixed number of bytes reserved</span>
<span class="cm"> * for OCFS2 internal use at its end. OCFS2 can use it for things like</span>
<span class="cm"> * checksums, etc. */</span>
<span class="cp">#define OCFS2_QBLK_RESERVED_SPACE 8</span>

<span class="cm">/* Generic header of all quota files */</span>
<span class="k">struct</span> <span class="n">ocfs2_disk_dqheader</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">dqh_magic</span><span class="p">;</span>	<span class="cm">/* Magic number identifying file */</span>
	<span class="n">__le32</span> <span class="n">dqh_version</span><span class="p">;</span>	<span class="cm">/* Quota format version */</span>
<span class="p">};</span>

<span class="cp">#define OCFS2_GLOBAL_INFO_OFF (sizeof(struct ocfs2_disk_dqheader))</span>

<span class="cm">/* Information header of global quota file (immediately follows the generic</span>
<span class="cm"> * header) */</span>
<span class="k">struct</span> <span class="n">ocfs2_global_disk_dqinfo</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__le32</span> <span class="n">dqi_bgrace</span><span class="p">;</span>	<span class="cm">/* Grace time for space softlimit excess */</span>
	<span class="n">__le32</span> <span class="n">dqi_igrace</span><span class="p">;</span>	<span class="cm">/* Grace time for inode softlimit excess */</span>
	<span class="n">__le32</span> <span class="n">dqi_syncms</span><span class="p">;</span>	<span class="cm">/* Time after which we sync local changes to</span>
<span class="cm">				 * global quota file */</span>
	<span class="n">__le32</span> <span class="n">dqi_blocks</span><span class="p">;</span>	<span class="cm">/* Number of blocks in quota file */</span>
<span class="cm">/*10*/</span>	<span class="n">__le32</span> <span class="n">dqi_free_blk</span><span class="p">;</span>	<span class="cm">/* First free block in quota file */</span>
	<span class="n">__le32</span> <span class="n">dqi_free_entry</span><span class="p">;</span>	<span class="cm">/* First block with free dquot entry in quota</span>
<span class="cm">				 * file */</span>
<span class="p">};</span>

<span class="cm">/* Structure with global user / group information. We reserve some space</span>
<span class="cm"> * for future use. */</span>
<span class="k">struct</span> <span class="n">ocfs2_global_disk_dqblk</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__le32</span> <span class="n">dqb_id</span><span class="p">;</span>          <span class="cm">/* ID the structure belongs to */</span>
	<span class="n">__le32</span> <span class="n">dqb_use_count</span><span class="p">;</span>   <span class="cm">/* Number of nodes having reference to this structure */</span>
	<span class="n">__le64</span> <span class="n">dqb_ihardlimit</span><span class="p">;</span>  <span class="cm">/* absolute limit on allocated inodes */</span>
<span class="cm">/*10*/</span>	<span class="n">__le64</span> <span class="n">dqb_isoftlimit</span><span class="p">;</span>  <span class="cm">/* preferred inode limit */</span>
	<span class="n">__le64</span> <span class="n">dqb_curinodes</span><span class="p">;</span>   <span class="cm">/* current # allocated inodes */</span>
<span class="cm">/*20*/</span>	<span class="n">__le64</span> <span class="n">dqb_bhardlimit</span><span class="p">;</span>  <span class="cm">/* absolute limit on disk space */</span>
	<span class="n">__le64</span> <span class="n">dqb_bsoftlimit</span><span class="p">;</span>  <span class="cm">/* preferred limit on disk space */</span>
<span class="cm">/*30*/</span>	<span class="n">__le64</span> <span class="n">dqb_curspace</span><span class="p">;</span>    <span class="cm">/* current space occupied */</span>
	<span class="n">__le64</span> <span class="n">dqb_btime</span><span class="p">;</span>       <span class="cm">/* time limit for excessive disk use */</span>
<span class="cm">/*40*/</span>	<span class="n">__le64</span> <span class="n">dqb_itime</span><span class="p">;</span>       <span class="cm">/* time limit for excessive inode use */</span>
	<span class="n">__le64</span> <span class="n">dqb_pad1</span><span class="p">;</span>
<span class="cm">/*50*/</span>	<span class="n">__le64</span> <span class="n">dqb_pad2</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  On-disk structures for local quota file</span>
<span class="cm"> */</span>

<span class="cm">/* Magic numbers and known versions for local quota files */</span>
<span class="cp">#define OCFS2_LOCAL_QMAGICS {\</span>
<span class="cp">	0x0cf524c0, </span><span class="cm">/* USRQUOTA */</span><span class="cp"> \</span>
<span class="cp">	0x0cf524c1  </span><span class="cm">/* GRPQUOTA */</span><span class="cp"> \</span>
<span class="cp">}</span>

<span class="cp">#define OCFS2_LOCAL_QVERSIONS {\</span>
<span class="cp">	0, \</span>
<span class="cp">	0, \</span>
<span class="cp">}</span>

<span class="cm">/* Quota flags in dqinfo header */</span>
<span class="cp">#define OLQF_CLEAN	0x0001	</span><span class="cm">/* Quota file is empty (this should be after\</span>
<span class="cm">				 * quota has been cleanly turned off) */</span><span class="cp"></span>

<span class="cp">#define OCFS2_LOCAL_INFO_OFF (sizeof(struct ocfs2_disk_dqheader))</span>

<span class="cm">/* Information header of local quota file (immediately follows the generic</span>
<span class="cm"> * header) */</span>
<span class="k">struct</span> <span class="n">ocfs2_local_disk_dqinfo</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">dqi_flags</span><span class="p">;</span>	<span class="cm">/* Flags for quota file */</span>
	<span class="n">__le32</span> <span class="n">dqi_chunks</span><span class="p">;</span>	<span class="cm">/* Number of chunks of quota structures</span>
<span class="cm">				 * with a bitmap */</span>
	<span class="n">__le32</span> <span class="n">dqi_blocks</span><span class="p">;</span>	<span class="cm">/* Number of blocks allocated for quota file */</span>
<span class="p">};</span>

<span class="cm">/* Header of one chunk of a quota file */</span>
<span class="k">struct</span> <span class="n">ocfs2_local_disk_chunk</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">dqc_free</span><span class="p">;</span>	<span class="cm">/* Number of free entries in the bitmap */</span>
	<span class="n">__u8</span> <span class="n">dqc_bitmap</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* Bitmap of entries in the corresponding</span>
<span class="cm">				 * chunk of quota file */</span>
<span class="p">};</span>

<span class="cm">/* One entry in local quota file */</span>
<span class="k">struct</span> <span class="n">ocfs2_local_disk_dqblk</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="n">__le64</span> <span class="n">dqb_id</span><span class="p">;</span>		<span class="cm">/* id this quota applies to */</span>
	<span class="n">__le64</span> <span class="n">dqb_spacemod</span><span class="p">;</span>	<span class="cm">/* Change in the amount of used space */</span>
<span class="cm">/*10*/</span>	<span class="n">__le64</span> <span class="n">dqb_inodemod</span><span class="p">;</span>	<span class="cm">/* Change in the amount of used inodes */</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * The quota trailer lives at the end of each quota block.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">ocfs2_disk_dqtrailer</span> <span class="p">{</span>
<span class="cm">/*00*/</span>	<span class="k">struct</span> <span class="n">ocfs2_block_check</span> <span class="n">dq_check</span><span class="p">;</span>	<span class="cm">/* Error checking */</span>
<span class="cm">/*08*/</span>	<span class="cm">/* Cannot be larger than OCFS2_QBLK_RESERVED_SPACE */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ocfs2_disk_dqtrailer</span> <span class="o">*</span><span class="nf">ocfs2_block_dqtrailer</span><span class="p">(</span><span class="kt">int</span> <span class="n">blocksize</span><span class="p">,</span>
								 <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">ptr</span> <span class="o">+=</span> <span class="n">blocksize</span> <span class="o">-</span> <span class="n">OCFS2_QBLK_RESERVED_SPACE</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_disk_dqtrailer</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef __KERNEL__</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_fast_symlink_chars</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span>  <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span>
		 <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dinode</span><span class="p">,</span> <span class="n">id2</span><span class="p">.</span><span class="n">i_symlink</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_max_inline_data_with_xattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">ocfs2_dinode</span> <span class="o">*</span><span class="n">di</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xattrsize</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">di</span><span class="o">-&gt;</span><span class="n">i_xattr_inline_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">di</span><span class="o">-&gt;</span><span class="n">i_dyn_features</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">OCFS2_INLINE_XATTR_FL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span>
			<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dinode</span><span class="p">,</span> <span class="n">id2</span><span class="p">.</span><span class="n">i_data</span><span class="p">.</span><span class="n">id_data</span><span class="p">)</span> <span class="o">-</span>
			<span class="n">xattrsize</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span>
			<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dinode</span><span class="p">,</span> <span class="n">id2</span><span class="p">.</span><span class="n">i_data</span><span class="p">.</span><span class="n">id_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_extent_recs_per_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dinode</span><span class="p">,</span> <span class="n">id2</span><span class="p">.</span><span class="n">i_list</span><span class="p">.</span><span class="n">l_recs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_extent_rec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_extent_recs_per_inode_with_xattr</span><span class="p">(</span>
						<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ocfs2_dinode</span> <span class="o">*</span><span class="n">di</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xattrsize</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">di</span><span class="o">-&gt;</span><span class="n">i_xattr_inline_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">di</span><span class="o">-&gt;</span><span class="n">i_dyn_features</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">OCFS2_INLINE_XATTR_FL</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span>
			<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dinode</span><span class="p">,</span> <span class="n">id2</span><span class="p">.</span><span class="n">i_list</span><span class="p">.</span><span class="n">l_recs</span><span class="p">)</span> <span class="o">-</span>
			<span class="n">xattrsize</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span>
			<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dinode</span><span class="p">,</span> <span class="n">id2</span><span class="p">.</span><span class="n">i_list</span><span class="p">.</span><span class="n">l_recs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_extent_rec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_extent_recs_per_dx_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dx_root_block</span><span class="p">,</span> <span class="n">dr_list</span><span class="p">.</span><span class="n">l_recs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_extent_rec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_chain_recs_per_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dinode</span><span class="p">,</span> <span class="n">id2</span><span class="p">.</span><span class="n">i_chain</span><span class="p">.</span><span class="n">cl_recs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_chain_rec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">ocfs2_extent_recs_per_eb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_extent_block</span><span class="p">,</span> <span class="n">h_list</span><span class="p">.</span><span class="n">l_recs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_extent_rec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">ocfs2_extent_recs_per_gd</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_group_desc</span><span class="p">,</span> <span class="n">bg_list</span><span class="p">.</span><span class="n">l_recs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_extent_rec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_dx_entries_per_leaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dx_leaf</span><span class="p">,</span> <span class="n">dl_list</span><span class="p">.</span><span class="n">de_entries</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dx_entry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_dx_entries_per_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dx_root_block</span><span class="p">,</span> <span class="n">dr_entries</span><span class="p">.</span><span class="n">de_entries</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dx_entry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">ocfs2_local_alloc_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dinode</span><span class="p">,</span> <span class="n">id2</span><span class="p">.</span><span class="n">i_lab</span><span class="p">.</span><span class="n">la_bitmap</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_group_bitmap_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">suballocator</span><span class="p">,</span>
					  <span class="n">u32</span> <span class="n">feature_incompat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_group_desc</span><span class="p">,</span> <span class="n">bg_bitmap</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The cluster allocator uses the entire block.  Suballocators have</span>
<span class="cm">	 * never used more than OCFS2_MAX_BG_BITMAP_SIZE.  Unfortunately, older</span>
<span class="cm">	 * code expects bg_size set to the maximum.  Thus we must keep</span>
<span class="cm">	 * bg_size as-is unless discontig_bg is enabled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">suballocator</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">feature_incompat</span> <span class="o">&amp;</span> <span class="n">OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG</span><span class="p">))</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">OCFS2_MAX_BG_BITMAP_SIZE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_truncate_recs_per_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dinode</span><span class="p">,</span> <span class="n">id2</span><span class="p">.</span><span class="n">i_dealloc</span><span class="p">.</span><span class="n">tl_recs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_truncate_rec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">ocfs2_backup_super_blkno</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">OCFS2_BACKUP_SB_START</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">OCFS2_MAX_BACKUP_SUPERBLOCKS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">&lt;&lt;=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">&gt;&gt;=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">offset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">ocfs2_xattr_recs_per_xb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_xattr_block</span><span class="p">,</span>
			 <span class="n">xb_attrs</span><span class="p">.</span><span class="n">xb_root</span><span class="p">.</span><span class="n">xt_list</span><span class="p">.</span><span class="n">l_recs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_extent_rec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">ocfs2_extent_recs_per_rb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_refcount_block</span><span class="p">,</span> <span class="n">rf_list</span><span class="p">.</span><span class="n">l_recs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_extent_rec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">ocfs2_refcount_recs_per_rb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_refcount_block</span><span class="p">,</span> <span class="n">rf_records</span><span class="p">.</span><span class="n">rl_recs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_refcount_rec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span>
<span class="nf">ocfs2_get_ref_rec_low_cpos</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ocfs2_refcount_rec</span> <span class="o">*</span><span class="n">rec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">r_cpos</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">OCFS2_32BIT_POS_MASK</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_fast_symlink_chars</span><span class="p">(</span><span class="kt">int</span> <span class="n">blocksize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blocksize</span> <span class="o">-</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dinode</span><span class="p">,</span> <span class="n">id2</span><span class="p">.</span><span class="n">i_symlink</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_max_inline_data_with_xattr</span><span class="p">(</span><span class="kt">int</span> <span class="n">blocksize</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">ocfs2_dinode</span> <span class="o">*</span><span class="n">di</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">di</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">di</span><span class="o">-&gt;</span><span class="n">i_dyn_features</span> <span class="o">&amp;</span> <span class="n">OCFS2_INLINE_XATTR_FL</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">blocksize</span> <span class="o">-</span>
			<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dinode</span><span class="p">,</span> <span class="n">id2</span><span class="p">.</span><span class="n">i_data</span><span class="p">.</span><span class="n">id_data</span><span class="p">)</span> <span class="o">-</span>
			<span class="n">di</span><span class="o">-&gt;</span><span class="n">i_xattr_inline_size</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">blocksize</span> <span class="o">-</span>
			<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dinode</span><span class="p">,</span> <span class="n">id2</span><span class="p">.</span><span class="n">i_data</span><span class="p">.</span><span class="n">id_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_extent_recs_per_inode</span><span class="p">(</span><span class="kt">int</span> <span class="n">blocksize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">blocksize</span> <span class="o">-</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dinode</span><span class="p">,</span> <span class="n">id2</span><span class="p">.</span><span class="n">i_list</span><span class="p">.</span><span class="n">l_recs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_extent_rec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_chain_recs_per_inode</span><span class="p">(</span><span class="kt">int</span> <span class="n">blocksize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">blocksize</span> <span class="o">-</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dinode</span><span class="p">,</span> <span class="n">id2</span><span class="p">.</span><span class="n">i_chain</span><span class="p">.</span><span class="n">cl_recs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_chain_rec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_extent_recs_per_eb</span><span class="p">(</span><span class="kt">int</span> <span class="n">blocksize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">blocksize</span> <span class="o">-</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_extent_block</span><span class="p">,</span> <span class="n">h_list</span><span class="p">.</span><span class="n">l_recs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_extent_rec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_extent_recs_per_gd</span><span class="p">(</span><span class="kt">int</span> <span class="n">blocksize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">blocksize</span> <span class="o">-</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_group_desc</span><span class="p">,</span> <span class="n">bg_list</span><span class="p">.</span><span class="n">l_recs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_extent_rec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_local_alloc_size</span><span class="p">(</span><span class="kt">int</span> <span class="n">blocksize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">blocksize</span> <span class="o">-</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dinode</span><span class="p">,</span> <span class="n">id2</span><span class="p">.</span><span class="n">i_lab</span><span class="p">.</span><span class="n">la_bitmap</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_group_bitmap_size</span><span class="p">(</span><span class="kt">int</span> <span class="n">blocksize</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">suballocator</span><span class="p">,</span>
					  <span class="kt">uint32_t</span> <span class="n">feature_incompat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_group_desc</span><span class="p">,</span> <span class="n">bg_bitmap</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The cluster allocator uses the entire block.  Suballocators have</span>
<span class="cm">	 * never used more than OCFS2_MAX_BG_BITMAP_SIZE.  Unfortunately, older</span>
<span class="cm">	 * code expects bg_size set to the maximum.  Thus we must keep</span>
<span class="cm">	 * bg_size as-is unless discontig_bg is enabled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">suballocator</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">feature_incompat</span> <span class="o">&amp;</span> <span class="n">OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG</span><span class="p">))</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">OCFS2_MAX_BG_BITMAP_SIZE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_truncate_recs_per_inode</span><span class="p">(</span><span class="kt">int</span> <span class="n">blocksize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">blocksize</span> <span class="o">-</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dinode</span><span class="p">,</span> <span class="n">id2</span><span class="p">.</span><span class="n">i_dealloc</span><span class="p">.</span><span class="n">tl_recs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_truncate_rec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="nf">ocfs2_backup_super_blkno</span><span class="p">(</span><span class="kt">int</span> <span class="n">blocksize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint64_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">OCFS2_BACKUP_SB_START</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">OCFS2_MAX_BACKUP_SUPERBLOCKS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">&lt;&lt;=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">/=</span> <span class="n">blocksize</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">offset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_xattr_recs_per_xb</span><span class="p">(</span><span class="kt">int</span> <span class="n">blocksize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">blocksize</span> <span class="o">-</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_xattr_block</span><span class="p">,</span>
			 <span class="n">xb_attrs</span><span class="p">.</span><span class="n">xb_root</span><span class="p">.</span><span class="n">xt_list</span><span class="p">.</span><span class="n">l_recs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_extent_rec</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif  </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_system_inode_is_global</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">type</span> <span class="o">&lt;=</span> <span class="n">OCFS2_LAST_GLOBAL_SYSTEM_INODE</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_sprintf_system_inode_name</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
						  <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">chars</span><span class="p">;</span>

        <span class="cm">/*</span>
<span class="cm">         * Global system inodes can only have one copy.  Everything</span>
<span class="cm">         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode</span>
<span class="cm">         * list has a copy per slot.</span>
<span class="cm">         */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&lt;=</span> <span class="n">OCFS2_LAST_GLOBAL_SYSTEM_INODE</span><span class="p">)</span>
		<span class="n">chars</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
				 <span class="n">ocfs2_system_inodes</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">si_name</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">chars</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
				 <span class="n">ocfs2_system_inodes</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">si_name</span><span class="p">,</span>
				 <span class="n">slot</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">chars</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ocfs2_set_de_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dir_entry</span> <span class="o">*</span><span class="n">de</span><span class="p">,</span>
				    <span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">de</span><span class="o">-&gt;</span><span class="n">file_type</span> <span class="o">=</span> <span class="n">ocfs2_type_by_mode</span><span class="p">[(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="n">S_SHIFT</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_gd_is_discontig</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_group_desc</span> <span class="o">*</span><span class="n">gd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_group_desc</span><span class="p">,</span> <span class="n">bg_bitmap</span><span class="p">)</span> <span class="o">+</span>
	     <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">bg_size</span><span class="p">))</span> <span class="o">!=</span>
	    <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_group_desc</span><span class="p">,</span> <span class="n">bg_list</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Only valid to check l_next_free_rec if</span>
<span class="cm">	 * bg_bitmap + bg_size == bg_list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">bg_list</span><span class="p">.</span><span class="n">l_next_free_rec</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif  </span><span class="cm">/* _OCFS2_FS_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
