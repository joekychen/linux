<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ocfs2 › ocfs2.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ocfs2.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* -*- mode: c; c-basic-offset: 8; -*-</span>
<span class="cm"> * vim: noexpandtab sw=8 ts=8 sts=0:</span>
<span class="cm"> *</span>
<span class="cm"> * ocfs2.h</span>
<span class="cm"> *</span>
<span class="cm"> * Defines macros and structures used in OCFS2</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2002, 2004 Oracle.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public</span>
<span class="cm"> * License as published by the Free Software Foundation; either</span>
<span class="cm"> * version 2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public</span>
<span class="cm"> * License along with this program; if not, write to the</span>
<span class="cm"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 021110-1307, USA.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef OCFS2_H</span>
<span class="cp">#define OCFS2_H</span>

<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/rbtree.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/kref.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/lockdep.h&gt;</span>
<span class="cp">#include &lt;linux/jbd2.h&gt;</span>

<span class="cm">/* For union ocfs2_dlm_lksb */</span>
<span class="cp">#include &quot;stackglue.h&quot;</span>

<span class="cp">#include &quot;ocfs2_fs.h&quot;</span>
<span class="cp">#include &quot;ocfs2_lockid.h&quot;</span>
<span class="cp">#include &quot;ocfs2_ioctl.h&quot;</span>

<span class="cm">/* For struct ocfs2_blockcheck_stats */</span>
<span class="cp">#include &quot;blockcheck.h&quot;</span>

<span class="cp">#include &quot;reservations.h&quot;</span>

<span class="cm">/* Caching of metadata buffers */</span>

<span class="cm">/* Most user visible OCFS2 inodes will have very few pieces of</span>
<span class="cm"> * metadata, but larger files (including bitmaps, etc) must be taken</span>
<span class="cm"> * into account when designing an access scheme. We allow a small</span>
<span class="cm"> * amount of inlined blocks to be stored on an array and grow the</span>
<span class="cm"> * structure into a rb tree when necessary. */</span>
<span class="cp">#define OCFS2_CACHE_INFO_MAX_ARRAY 2</span>

<span class="cm">/* Flags for ocfs2_caching_info */</span>

<span class="k">enum</span> <span class="n">ocfs2_caching_info_flags</span> <span class="p">{</span>
	<span class="cm">/* Indicates that the metadata cache is using the inline array */</span>
	<span class="n">OCFS2_CACHE_FL_INLINE</span>	<span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ocfs2_caching_operations</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ocfs2_caching_info</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The parent structure provides the locks, but because the</span>
<span class="cm">	 * parent structure can differ, it provides locking operations</span>
<span class="cm">	 * to struct ocfs2_caching_info.</span>
<span class="cm">	 */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ocfs2_caching_operations</span> <span class="o">*</span><span class="n">ci_ops</span><span class="p">;</span>

	<span class="cm">/* next two are protected by trans_inc_lock */</span>
	<span class="cm">/* which transaction were we created on? Zero if none. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ci_created_trans</span><span class="p">;</span>
	<span class="cm">/* last transaction we were a part of. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ci_last_trans</span><span class="p">;</span>

	<span class="cm">/* Cache structures */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">ci_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">ci_num_cached</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
	<span class="n">sector_t</span>	<span class="n">ci_array</span><span class="p">[</span><span class="n">OCFS2_CACHE_INFO_MAX_ARRAY</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">rb_root</span>	<span class="n">ci_tree</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ci_cache</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/*</span>
<span class="cm"> * Need this prototype here instead of in uptodate.h because journal.h</span>
<span class="cm"> * uses it.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">ocfs2_metadata_cache_get_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_caching_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">);</span>

<span class="cm">/* this limits us to 256 nodes</span>
<span class="cm"> * if we need more, we can do a kmalloc for the map */</span>
<span class="cp">#define OCFS2_NODE_MAP_MAX_NODES    256</span>
<span class="k">struct</span> <span class="n">ocfs2_node_map</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">num_nodes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">map</span><span class="p">[</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">OCFS2_NODE_MAP_MAX_NODES</span><span class="p">)];</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ocfs2_ast_action</span> <span class="p">{</span>
	<span class="n">OCFS2_AST_INVALID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">OCFS2_AST_ATTACH</span><span class="p">,</span>
	<span class="n">OCFS2_AST_CONVERT</span><span class="p">,</span>
	<span class="n">OCFS2_AST_DOWNCONVERT</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* actions for an unlockast function to take. */</span>
<span class="k">enum</span> <span class="n">ocfs2_unlock_action</span> <span class="p">{</span>
	<span class="n">OCFS2_UNLOCK_INVALID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">OCFS2_UNLOCK_CANCEL_CONVERT</span><span class="p">,</span>
	<span class="n">OCFS2_UNLOCK_DROP_LOCK</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* ocfs2_lock_res-&gt;l_flags flags. */</span>
<span class="cp">#define OCFS2_LOCK_ATTACHED      (0x00000001) </span><span class="cm">/* we have initialized</span>
<span class="cm">					       * the lvb */</span><span class="cp"></span>
<span class="cp">#define OCFS2_LOCK_BUSY          (0x00000002) </span><span class="cm">/* we are currently in</span>
<span class="cm">					       * dlm_lock */</span><span class="cp"></span>
<span class="cp">#define OCFS2_LOCK_BLOCKED       (0x00000004) </span><span class="cm">/* blocked waiting to</span>
<span class="cm">					       * downconvert*/</span><span class="cp"></span>
<span class="cp">#define OCFS2_LOCK_LOCAL         (0x00000008) </span><span class="cm">/* newly created inode */</span><span class="cp"></span>
<span class="cp">#define OCFS2_LOCK_NEEDS_REFRESH (0x00000010)</span>
<span class="cp">#define OCFS2_LOCK_REFRESHING    (0x00000020)</span>
<span class="cp">#define OCFS2_LOCK_INITIALIZED   (0x00000040) </span><span class="cm">/* track initialization</span>
<span class="cm">					       * for shutdown paths */</span><span class="cp"></span>
<span class="cp">#define OCFS2_LOCK_FREEING       (0x00000080) </span><span class="cm">/* help dlmglue track</span>
<span class="cm">					       * when to skip queueing</span>
<span class="cm">					       * a lock because it&#39;s</span>
<span class="cm">					       * about to be</span>
<span class="cm">					       * dropped. */</span><span class="cp"></span>
<span class="cp">#define OCFS2_LOCK_QUEUED        (0x00000100) </span><span class="cm">/* queued for downconvert */</span><span class="cp"></span>
<span class="cp">#define OCFS2_LOCK_NOCACHE       (0x00000200) </span><span class="cm">/* don&#39;t use a holder count */</span><span class="cp"></span>
<span class="cp">#define OCFS2_LOCK_PENDING       (0x00000400) </span><span class="cm">/* This lockres is pending a</span>
<span class="cm">						 call to dlm_lock.  Only</span>
<span class="cm">						 exists with BUSY set. */</span><span class="cp"></span>
<span class="cp">#define OCFS2_LOCK_UPCONVERT_FINISHING (0x00000800) </span><span class="cm">/* blocks the dc thread</span>
<span class="cm">						     * from downconverting</span>
<span class="cm">						     * before the upconvert</span>
<span class="cm">						     * has completed */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">ocfs2_lock_res_ops</span><span class="p">;</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ocfs2_lock_callback</span><span class="p">)(</span><span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_OCFS2_FS_STATS</span>
<span class="k">struct</span> <span class="n">ocfs2_lock_stats</span> <span class="p">{</span>
	<span class="n">u64</span>		<span class="n">ls_total</span><span class="p">;</span>	<span class="cm">/* Total wait in NSEC */</span>
	<span class="n">u32</span>		<span class="n">ls_gets</span><span class="p">;</span>	<span class="cm">/* Num acquires */</span>
	<span class="n">u32</span>		<span class="n">ls_fail</span><span class="p">;</span>	<span class="cm">/* Num failed acquires */</span>

	<span class="cm">/* Storing max wait in usecs saves 24 bytes per inode */</span>
	<span class="n">u32</span>		<span class="n">ls_max</span><span class="p">;</span>		<span class="cm">/* Max wait in USEC */</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">ocfs2_lock_res</span> <span class="p">{</span>
	<span class="kt">void</span>                    <span class="o">*</span><span class="n">l_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_lock_res_ops</span> <span class="o">*</span><span class="n">l_ops</span><span class="p">;</span>


	<span class="k">struct</span> <span class="n">list_head</span>         <span class="n">l_blocked_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>         <span class="n">l_mask_waiters</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		 <span class="n">l_flags</span><span class="p">;</span>
	<span class="kt">char</span>                     <span class="n">l_name</span><span class="p">[</span><span class="n">OCFS2_LOCK_ID_MAX_LEN</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>             <span class="n">l_ro_holders</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>             <span class="n">l_ex_holders</span><span class="p">;</span>
	<span class="kt">signed</span> <span class="kt">char</span>		 <span class="n">l_level</span><span class="p">;</span>
	<span class="kt">signed</span> <span class="kt">char</span>		 <span class="n">l_requested</span><span class="p">;</span>
	<span class="kt">signed</span> <span class="kt">char</span>		 <span class="n">l_blocking</span><span class="p">;</span>

	<span class="cm">/* Data packed - type enum ocfs2_lock_type */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>            <span class="n">l_type</span><span class="p">;</span>

	<span class="cm">/* used from AST/BAST funcs. */</span>
	<span class="cm">/* Data packed - enum type ocfs2_ast_action */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>            <span class="n">l_action</span><span class="p">;</span>
	<span class="cm">/* Data packed - enum type ocfs2_unlock_action */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>            <span class="n">l_unlock_action</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>             <span class="n">l_pending_gen</span><span class="p">;</span>

	<span class="n">spinlock_t</span>               <span class="n">l_lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ocfs2_dlm_lksb</span>    <span class="n">l_lksb</span><span class="p">;</span>

	<span class="n">wait_queue_head_t</span>        <span class="n">l_event</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>         <span class="n">l_debug_list</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_OCFS2_FS_STATS</span>
	<span class="k">struct</span> <span class="n">ocfs2_lock_stats</span>  <span class="n">l_lock_prmode</span><span class="p">;</span>		<span class="cm">/* PR mode stats */</span>
	<span class="n">u32</span>                      <span class="n">l_lock_refresh</span><span class="p">;</span>	<span class="cm">/* Disk refreshes */</span>
	<span class="k">struct</span> <span class="n">ocfs2_lock_stats</span>  <span class="n">l_lock_exmode</span><span class="p">;</span>		<span class="cm">/* EX mode stats */</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span>
	<span class="k">struct</span> <span class="n">lockdep_map</span>	 <span class="n">l_lockdep_map</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ocfs2_orphan_scan_state</span> <span class="p">{</span>
	<span class="n">ORPHAN_SCAN_ACTIVE</span><span class="p">,</span>
	<span class="n">ORPHAN_SCAN_INACTIVE</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ocfs2_orphan_scan</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mutex</span> 		<span class="n">os_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_super</span> 	<span class="o">*</span><span class="n">os_osb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_lock_res</span> 	<span class="n">os_lockres</span><span class="p">;</span>     <span class="cm">/* lock to synchronize scans */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> 	<span class="n">os_orphan_scan_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span>		<span class="n">os_scantime</span><span class="p">;</span>  <span class="cm">/* time this node ran the scan */</span>
	<span class="n">u32</span>			<span class="n">os_count</span><span class="p">;</span>      <span class="cm">/* tracks node specific scans */</span>
	<span class="n">u32</span>  			<span class="n">os_seqno</span><span class="p">;</span>       <span class="cm">/* tracks cluster wide scans */</span>
	<span class="n">atomic_t</span>		<span class="n">os_state</span><span class="p">;</span>              <span class="cm">/* ACTIVE or INACTIVE */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ocfs2_dlm_debug</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">d_refcnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_locking_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">d_lockres_tracking</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ocfs2_vol_state</span>
<span class="p">{</span>
	<span class="n">VOLUME_INIT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">VOLUME_MOUNTED</span><span class="p">,</span>
	<span class="n">VOLUME_MOUNTED_QUOTAS</span><span class="p">,</span>
	<span class="n">VOLUME_DISMOUNTED</span><span class="p">,</span>
	<span class="n">VOLUME_DISABLED</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ocfs2_alloc_stats</span>
<span class="p">{</span>
	<span class="n">atomic_t</span> <span class="n">moves</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">local_data</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">bitmap_data</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">bg_allocs</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">bg_extends</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ocfs2_local_alloc_state</span>
<span class="p">{</span>
	<span class="n">OCFS2_LA_UNUSED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* Local alloc will never be used for</span>
<span class="cm">				 * this mountpoint. */</span>
	<span class="n">OCFS2_LA_ENABLED</span><span class="p">,</span>	<span class="cm">/* Local alloc is in use. */</span>
	<span class="n">OCFS2_LA_THROTTLED</span><span class="p">,</span>	<span class="cm">/* Local alloc is in use, but number</span>
<span class="cm">				 * of bits has been reduced. */</span>
	<span class="n">OCFS2_LA_DISABLED</span>	<span class="cm">/* Local alloc has temporarily been</span>
<span class="cm">				 * disabled. */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">ocfs2_mount_options</span>
<span class="p">{</span>
	<span class="n">OCFS2_MOUNT_HB_LOCAL</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* Local heartbeat */</span>
	<span class="n">OCFS2_MOUNT_BARRIER</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* Use block barriers */</span>
	<span class="n">OCFS2_MOUNT_NOINTR</span>  <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>   <span class="cm">/* Don&#39;t catch signals */</span>
	<span class="n">OCFS2_MOUNT_ERRORS_PANIC</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span> <span class="cm">/* Panic on errors */</span>
	<span class="n">OCFS2_MOUNT_DATA_WRITEBACK</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span> <span class="cm">/* No data ordering */</span>
	<span class="n">OCFS2_MOUNT_LOCALFLOCKS</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">,</span> <span class="cm">/* No cluster aware user file locks */</span>
	<span class="n">OCFS2_MOUNT_NOUSERXATTR</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">,</span> <span class="cm">/* No user xattr */</span>
	<span class="n">OCFS2_MOUNT_INODE64</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">,</span>	<span class="cm">/* Allow inode numbers &gt; 2^32 */</span>
	<span class="n">OCFS2_MOUNT_POSIX_ACL</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">,</span>	<span class="cm">/* Force POSIX access control lists */</span>
	<span class="n">OCFS2_MOUNT_NO_POSIX_ACL</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">,</span>	<span class="cm">/* Disable POSIX access</span>
<span class="cm">						   control lists */</span>
	<span class="n">OCFS2_MOUNT_USRQUOTA</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">,</span> <span class="cm">/* We support user quotas */</span>
	<span class="n">OCFS2_MOUNT_GRPQUOTA</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">,</span> <span class="cm">/* We support group quotas */</span>
	<span class="n">OCFS2_MOUNT_COHERENCY_BUFFERED</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">,</span> <span class="cm">/* Allow concurrent O_DIRECT</span>
<span class="cm">						     writes */</span>
	<span class="n">OCFS2_MOUNT_HB_NONE</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">,</span> <span class="cm">/* No heartbeat */</span>
	<span class="n">OCFS2_MOUNT_HB_GLOBAL</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">,</span> <span class="cm">/* Global heartbeat */</span>
<span class="p">};</span>

<span class="cp">#define OCFS2_OSB_SOFT_RO			0x0001</span>
<span class="cp">#define OCFS2_OSB_HARD_RO			0x0002</span>
<span class="cp">#define OCFS2_OSB_ERROR_FS			0x0004</span>
<span class="cp">#define OCFS2_OSB_DROP_DENTRY_LOCK_IMMED	0x0008</span>

<span class="cp">#define OCFS2_DEFAULT_ATIME_QUANTUM		60</span>

<span class="k">struct</span> <span class="n">ocfs2_journal</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ocfs2_slot_info</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ocfs2_recovery_map</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ocfs2_replay_map</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ocfs2_quota_recovery</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ocfs2_dentry_lock</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ocfs2_super</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">commit_task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">root_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">sys_root_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">global_system_inodes</span><span class="p">[</span><span class="n">NUM_GLOBAL_SYSTEM_INODES</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">**</span><span class="n">local_system_inodes</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ocfs2_slot_info</span> <span class="o">*</span><span class="n">slot_info</span><span class="p">;</span>

	<span class="n">u32</span> <span class="o">*</span><span class="n">slot_recovery_generations</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">node_map_lock</span><span class="p">;</span>

	<span class="n">u64</span> <span class="n">root_blkno</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">system_dir_blkno</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">bitmap_blkno</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bitmap_cpg</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">uuid</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">uuid_str</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">uuid_hash</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">vol_label</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">first_cluster_group_blkno</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fs_generation</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">s_feature_compat</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">s_feature_incompat</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">s_feature_ro_compat</span><span class="p">;</span>

	<span class="cm">/* Protects s_next_generation, osb_flags and s_inode_steal_slot.</span>
<span class="cm">	 * Could protect more on osb as it&#39;s very short lived.</span>
<span class="cm">	 */</span>
	<span class="n">spinlock_t</span> <span class="n">osb_lock</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">s_next_generation</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">osb_flags</span><span class="p">;</span>
	<span class="n">s16</span> <span class="n">s_inode_steal_slot</span><span class="p">;</span>
	<span class="n">s16</span> <span class="n">s_meta_steal_slot</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">s_num_inodes_stolen</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">s_num_meta_stolen</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">s_mount_opt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">s_atime_quantum</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_slots</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">node_num</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot_num</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">preferred_slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_sectsize_bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_clustersize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_clustersize_bits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">s_xattr_inline_size</span><span class="p">;</span>

	<span class="n">atomic_t</span> <span class="n">vol_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">recovery_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_recovery_map</span> <span class="o">*</span><span class="n">recovery_map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_replay_map</span> <span class="o">*</span><span class="n">replay_map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">recovery_thread_task</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">disable_recovery</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">checkpoint_event</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">needs_checkpoint</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_journal</span> <span class="o">*</span><span class="n">journal</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">osb_commit_interval</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">delayed_work</span>		<span class="n">la_enable_wq</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Must hold local alloc i_mutex and osb-&gt;osb_lock to change</span>
<span class="cm">	 * local_alloc_bits. Reads can be done under either lock.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">local_alloc_bits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">local_alloc_default_bits</span><span class="p">;</span>
	<span class="cm">/* osb_clusters_at_boot can become stale! Do not trust it to</span>
<span class="cm">	 * be up to date. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">osb_clusters_at_boot</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">ocfs2_local_alloc_state</span> <span class="n">local_alloc_state</span><span class="p">;</span> <span class="cm">/* protected</span>
<span class="cm">							 * by osb_lock */</span>

	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">local_alloc_bh</span><span class="p">;</span>

	<span class="n">u64</span> <span class="n">la_last_gd</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ocfs2_reservation_map</span>	<span class="n">osb_la_resmap</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">osb_resv_level</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">osb_dir_resv_level</span><span class="p">;</span>

	<span class="cm">/* Next three fields are for local node slot recovery during</span>
<span class="cm">	 * mount. */</span>
	<span class="kt">int</span> <span class="n">dirty</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_dinode</span> <span class="o">*</span><span class="n">local_alloc_copy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_quota_recovery</span> <span class="o">*</span><span class="n">quota_rec</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ocfs2_blockcheck_stats</span> <span class="n">osb_ecc_stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_alloc_stats</span> <span class="n">alloc_stats</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">dev_str</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>		<span class="cm">/* &quot;major,minor&quot; of the device */</span>

	<span class="n">u8</span> <span class="n">osb_stackflags</span><span class="p">;</span>

	<span class="kt">char</span> <span class="n">osb_cluster_stack</span><span class="p">[</span><span class="n">OCFS2_STACK_LABEL_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ocfs2_cluster_connection</span> <span class="o">*</span><span class="n">cconn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_lock_res</span> <span class="n">osb_super_lockres</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_lock_res</span> <span class="n">osb_rename_lockres</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_lock_res</span> <span class="n">osb_nfs_sync_lockres</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_dlm_debug</span> <span class="o">*</span><span class="n">osb_dlm_debug</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">osb_debug_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">osb_ctxt</span><span class="p">;</span>

	<span class="n">wait_queue_head_t</span> <span class="n">recovery_event</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">dc_task_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">dc_task</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">dc_event</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dc_wake_sequence</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dc_work_sequence</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Any thread can add locks to the list, but the downconvert</span>
<span class="cm">	 * thread is the only one allowed to remove locks. Any change</span>
<span class="cm">	 * to this rule requires updating</span>
<span class="cm">	 * ocfs2_downconvert_thread_do_work().</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">blocked_lock_list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">blocked_lock_count</span><span class="p">;</span>

	<span class="cm">/* List of dentry locks to release. Anyone can add locks to</span>
<span class="cm">	 * the list, ocfs2_wq processes the list  */</span>
	<span class="k">struct</span> <span class="n">ocfs2_dentry_lock</span> <span class="o">*</span><span class="n">dentry_lock_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">dentry_lock_work</span><span class="p">;</span>

	<span class="n">wait_queue_head_t</span>		<span class="n">osb_mount_event</span><span class="p">;</span>

	<span class="cm">/* Truncate log info */</span>
	<span class="k">struct</span> <span class="n">inode</span>			<span class="o">*</span><span class="n">osb_tl_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>		<span class="o">*</span><span class="n">osb_tl_bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>		<span class="n">osb_truncate_log_wq</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * How many clusters in our truncate log.</span>
<span class="cm">	 * It must be protected by osb_tl_inode-&gt;i_mutex.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">truncated_clusters</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ocfs2_node_map</span>		<span class="n">osb_recovering_orphan_dirs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="o">*</span><span class="n">osb_orphan_wipes</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>		<span class="n">osb_wipe_event</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ocfs2_orphan_scan</span>	<span class="n">osb_orphan_scan</span><span class="p">;</span>

	<span class="cm">/* used to protect metaecc calculation check of xattr. */</span>
	<span class="n">spinlock_t</span> <span class="n">osb_xattr_lock</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">osb_dx_mask</span><span class="p">;</span>
	<span class="n">u32</span>				<span class="n">osb_dx_seed</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="cm">/* the group we used to allocate inodes. */</span>
	<span class="n">u64</span>				<span class="n">osb_inode_alloc_group</span><span class="p">;</span>

	<span class="cm">/* rb tree root for refcount lock. */</span>
	<span class="k">struct</span> <span class="n">rb_root</span>	<span class="n">osb_rf_lock_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_refcount_tree</span> <span class="o">*</span><span class="n">osb_ref_tree_lru</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define OCFS2_SB(sb)	    ((struct ocfs2_super *)(sb)-&gt;s_fs_info)</span>

<span class="cm">/* Useful typedef for passing around journal access functions */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ocfs2_journal_access_func</span><span class="p">)(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">ocfs2_caching_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_should_order_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OCFS2_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_mount_opt</span> <span class="o">&amp;</span> <span class="n">OCFS2_MOUNT_DATA_WRITEBACK</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_sparse_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">s_feature_incompat</span> <span class="o">&amp;</span> <span class="n">OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_writes_unwritten_extents</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Support for sparse files is a pre-requisite</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ocfs2_sparse_alloc</span><span class="p">(</span><span class="n">osb</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">s_feature_ro_compat</span> <span class="o">&amp;</span> <span class="n">OCFS2_FEATURE_RO_COMPAT_UNWRITTEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_supports_inline_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">s_feature_incompat</span> <span class="o">&amp;</span> <span class="n">OCFS2_FEATURE_INCOMPAT_INLINE_DATA</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_supports_xattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">s_feature_incompat</span> <span class="o">&amp;</span> <span class="n">OCFS2_FEATURE_INCOMPAT_XATTR</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_meta_ecc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">s_feature_incompat</span> <span class="o">&amp;</span> <span class="n">OCFS2_FEATURE_INCOMPAT_META_ECC</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_supports_indexed_dirs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">s_feature_incompat</span> <span class="o">&amp;</span> <span class="n">OCFS2_FEATURE_INCOMPAT_INDEXED_DIRS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_supports_discontig_bg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">s_feature_incompat</span> <span class="o">&amp;</span> <span class="n">OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ocfs2_link_max</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ocfs2_supports_indexed_dirs</span><span class="p">(</span><span class="n">osb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">OCFS2_DX_LINK_MAX</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">OCFS2_LINK_MAX</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ocfs2_read_links_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dinode</span> <span class="o">*</span><span class="n">di</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">nlink</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">di</span><span class="o">-&gt;</span><span class="n">i_links_count</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">di</span><span class="o">-&gt;</span><span class="n">i_links_count_hi</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">di</span><span class="o">-&gt;</span><span class="n">i_dyn_features</span> <span class="o">&amp;</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">OCFS2_INDEXED_DIR_FL</span><span class="p">))</span>
		<span class="n">nlink</span> <span class="o">|=</span> <span class="p">(</span><span class="n">hi</span> <span class="o">&lt;&lt;</span> <span class="n">OCFS2_LINKS_HI_SHIFT</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nlink</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ocfs2_set_links_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dinode</span> <span class="o">*</span><span class="n">di</span><span class="p">,</span> <span class="n">u32</span> <span class="n">nlink</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">;</span>

	<span class="n">lo</span> <span class="o">=</span> <span class="n">nlink</span><span class="p">;</span>
	<span class="n">hi</span> <span class="o">=</span> <span class="n">nlink</span> <span class="o">&gt;&gt;</span> <span class="n">OCFS2_LINKS_HI_SHIFT</span><span class="p">;</span>

	<span class="n">di</span><span class="o">-&gt;</span><span class="n">i_links_count</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
	<span class="n">di</span><span class="o">-&gt;</span><span class="n">i_links_count_hi</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">hi</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ocfs2_add_links_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_dinode</span> <span class="o">*</span><span class="n">di</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">links</span> <span class="o">=</span> <span class="n">ocfs2_read_links_count</span><span class="p">(</span><span class="n">di</span><span class="p">);</span>

	<span class="n">links</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">ocfs2_set_links_count</span><span class="p">(</span><span class="n">di</span><span class="p">,</span> <span class="n">links</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_refcount_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">s_feature_incompat</span> <span class="o">&amp;</span> <span class="n">OCFS2_FEATURE_INCOMPAT_REFCOUNT_TREE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* set / clear functions because cluster events can make these happen</span>
<span class="cm"> * in parallel so we want the transitions to be atomic. this also</span>
<span class="cm"> * means that any future flags osb_flags must be protected by spinlock</span>
<span class="cm"> * too! */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ocfs2_set_osb_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">osb_lock</span><span class="p">);</span>
	<span class="n">osb</span><span class="o">-&gt;</span><span class="n">osb_flags</span> <span class="o">|=</span> <span class="n">flag</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">osb_lock</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>  <span class="nf">ocfs2_test_osb_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">,</span>
						 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">osb_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">osb</span><span class="o">-&gt;</span><span class="n">osb_flags</span> <span class="o">&amp;</span> <span class="n">flag</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">osb_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ocfs2_set_ro_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">hard</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">osb_lock</span><span class="p">);</span>
	<span class="n">osb</span><span class="o">-&gt;</span><span class="n">osb_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">OCFS2_OSB_SOFT_RO</span><span class="o">|</span><span class="n">OCFS2_OSB_HARD_RO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hard</span><span class="p">)</span>
		<span class="n">osb</span><span class="o">-&gt;</span><span class="n">osb_flags</span> <span class="o">|=</span> <span class="n">OCFS2_OSB_HARD_RO</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">osb</span><span class="o">-&gt;</span><span class="n">osb_flags</span> <span class="o">|=</span> <span class="n">OCFS2_OSB_SOFT_RO</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">osb_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_is_hard_readonly</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">osb_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">osb</span><span class="o">-&gt;</span><span class="n">osb_flags</span> <span class="o">&amp;</span> <span class="n">OCFS2_OSB_HARD_RO</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">osb_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_is_soft_readonly</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">osb_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">osb</span><span class="o">-&gt;</span><span class="n">osb_flags</span> <span class="o">&amp;</span> <span class="n">OCFS2_OSB_SOFT_RO</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">osb_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_clusterinfo_valid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">s_feature_incompat</span> <span class="o">&amp;</span>
		<span class="p">(</span><span class="n">OCFS2_FEATURE_INCOMPAT_USERSPACE_STACK</span> <span class="o">|</span>
		 <span class="n">OCFS2_FEATURE_INCOMPAT_CLUSTERINFO</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_userspace_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ocfs2_clusterinfo_valid</span><span class="p">(</span><span class="n">osb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">memcmp</span><span class="p">(</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">osb_cluster_stack</span><span class="p">,</span> <span class="n">OCFS2_CLASSIC_CLUSTER_STACK</span><span class="p">,</span>
		   <span class="n">OCFS2_STACK_LABEL_LEN</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_o2cb_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ocfs2_clusterinfo_valid</span><span class="p">(</span><span class="n">osb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">osb_cluster_stack</span><span class="p">,</span> <span class="n">OCFS2_CLASSIC_CLUSTER_STACK</span><span class="p">,</span>
		   <span class="n">OCFS2_STACK_LABEL_LEN</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_cluster_o2cb_global_heartbeat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ocfs2_o2cb_stack</span><span class="p">(</span><span class="n">osb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">osb_stackflags</span> <span class="o">&amp;</span> <span class="n">OCFS2_CLUSTER_O2CB_GLOBAL_HEARTBEAT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_mount_local</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">s_feature_incompat</span> <span class="o">&amp;</span> <span class="n">OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_uses_extended_slot_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">s_feature_incompat</span> <span class="o">&amp;</span>
		<span class="n">OCFS2_FEATURE_INCOMPAT_EXTENDED_SLOT_MAP</span><span class="p">);</span>
<span class="p">}</span>


<span class="cp">#define OCFS2_IS_VALID_DINODE(ptr)					\</span>
<span class="cp">	(!strcmp((ptr)-&gt;i_signature, OCFS2_INODE_SIGNATURE))</span>

<span class="cp">#define OCFS2_IS_VALID_EXTENT_BLOCK(ptr)				\</span>
<span class="cp">	(!strcmp((ptr)-&gt;h_signature, OCFS2_EXTENT_BLOCK_SIGNATURE))</span>

<span class="cp">#define OCFS2_IS_VALID_GROUP_DESC(ptr)					\</span>
<span class="cp">	(!strcmp((ptr)-&gt;bg_signature, OCFS2_GROUP_DESC_SIGNATURE))</span>


<span class="cp">#define OCFS2_IS_VALID_XATTR_BLOCK(ptr)					\</span>
<span class="cp">	(!strcmp((ptr)-&gt;xb_signature, OCFS2_XATTR_BLOCK_SIGNATURE))</span>

<span class="cp">#define OCFS2_IS_VALID_DIR_TRAILER(ptr)					\</span>
<span class="cp">	(!strcmp((ptr)-&gt;db_signature, OCFS2_DIR_TRAILER_SIGNATURE))</span>

<span class="cp">#define OCFS2_IS_VALID_DX_ROOT(ptr)					\</span>
<span class="cp">	(!strcmp((ptr)-&gt;dr_signature, OCFS2_DX_ROOT_SIGNATURE))</span>

<span class="cp">#define OCFS2_IS_VALID_DX_LEAF(ptr)					\</span>
<span class="cp">	(!strcmp((ptr)-&gt;dl_signature, OCFS2_DX_LEAF_SIGNATURE))</span>

<span class="cp">#define OCFS2_IS_VALID_REFCOUNT_BLOCK(ptr)				\</span>
<span class="cp">	(!strcmp((ptr)-&gt;rf_signature, OCFS2_REFCOUNT_BLOCK_SIGNATURE))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ino_from_blkno</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					   <span class="n">u64</span> <span class="n">blkno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">blkno</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">ULONG_MAX</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">ocfs2_clusters_to_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					   <span class="n">u32</span> <span class="n">clusters</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">c_to_b_bits</span> <span class="o">=</span> <span class="n">OCFS2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_clustersize_bits</span> <span class="o">-</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">clusters</span> <span class="o">&lt;&lt;</span> <span class="n">c_to_b_bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">ocfs2_blocks_to_clusters</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					   <span class="n">u64</span> <span class="n">blocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">b_to_c_bits</span> <span class="o">=</span> <span class="n">OCFS2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_clustersize_bits</span> <span class="o">-</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">blocks</span> <span class="o">&gt;&gt;</span> <span class="n">b_to_c_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ocfs2_clusters_for_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
						    <span class="n">u64</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cl_bits</span> <span class="o">=</span> <span class="n">OCFS2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_clustersize_bits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clusters</span><span class="p">;</span>

	<span class="n">bytes</span> <span class="o">+=</span> <span class="n">OCFS2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_clustersize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* OCFS2 just cannot have enough clusters to overflow this */</span>
	<span class="n">clusters</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">bytes</span> <span class="o">&gt;&gt;</span> <span class="n">cl_bits</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">clusters</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">ocfs2_blocks_for_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					 <span class="n">u64</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bytes</span> <span class="o">+=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">bytes</span> <span class="o">&gt;&gt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">ocfs2_clusters_to_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					  <span class="n">u32</span> <span class="n">clusters</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">clusters</span> <span class="o">&lt;&lt;</span> <span class="n">OCFS2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_clustersize_bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">ocfs2_block_to_cluster_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					       <span class="n">u64</span> <span class="n">blocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">OCFS2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_clustersize_bits</span> <span class="o">-</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clusters</span><span class="p">;</span>

	<span class="n">clusters</span> <span class="o">=</span> <span class="n">ocfs2_blocks_to_clusters</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">blocks</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">clusters</span> <span class="o">&lt;&lt;</span> <span class="n">bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">ocfs2_align_bytes_to_clusters</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
						<span class="n">u64</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cl_bits</span> <span class="o">=</span> <span class="n">OCFS2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_clustersize_bits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clusters</span><span class="p">;</span>

	<span class="n">clusters</span> <span class="o">=</span> <span class="n">ocfs2_clusters_for_bytes</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">clusters</span> <span class="o">&lt;&lt;</span> <span class="n">cl_bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">ocfs2_align_bytes_to_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					      <span class="n">u64</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">blocks</span><span class="p">;</span>

        <span class="n">blocks</span> <span class="o">=</span> <span class="n">ocfs2_blocks_for_bytes</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">blocks</span> <span class="o">&lt;&lt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ocfs2_align_bytes_to_sectors</span><span class="p">(</span><span class="n">u64</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)((</span><span class="n">bytes</span> <span class="o">+</span> <span class="mi">511</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ocfs2_page_index_to_clusters</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
							<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pg_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">clusters</span> <span class="o">=</span> <span class="n">pg_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cbits</span> <span class="o">=</span> <span class="n">OCFS2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_clustersize_bits</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">&gt;</span> <span class="n">cbits</span><span class="p">))</span>
		<span class="n">clusters</span> <span class="o">=</span> <span class="n">pg_index</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">cbits</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">&lt;</span> <span class="n">cbits</span><span class="p">)</span>
		<span class="n">clusters</span> <span class="o">=</span> <span class="n">pg_index</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">cbits</span> <span class="o">-</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">clusters</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the 1st page index which covers the given clusters.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">pgoff_t</span> <span class="nf">ocfs2_align_clusters_to_page_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
							<span class="n">u32</span> <span class="n">clusters</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cbits</span> <span class="o">=</span> <span class="n">OCFS2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_clustersize_bits</span><span class="p">;</span>
        <span class="n">pgoff_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">&gt;</span> <span class="n">cbits</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">pgoff_t</span><span class="p">)</span><span class="n">clusters</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">cbits</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">&lt;</span> <span class="n">cbits</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">pgoff_t</span><span class="p">)</span><span class="n">clusters</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">cbits</span> <span class="o">-</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ocfs2_pages_per_cluster</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cbits</span> <span class="o">=</span> <span class="n">OCFS2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_clustersize_bits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pages_per_cluster</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">&lt;</span> <span class="n">cbits</span><span class="p">)</span>
		<span class="n">pages_per_cluster</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">cbits</span> <span class="o">-</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pages_per_cluster</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ocfs2_megabytes_to_clusters</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
						       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">megs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">OCFS2_MAX_CLUSTERSIZE</span> <span class="o">&gt;</span> <span class="mi">1048576</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">megs</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">OCFS2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_clustersize_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ocfs2_clusters_to_megabytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
						       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clusters</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">clusters</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">OCFS2_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_clustersize_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">_ocfs2_set_bit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__set_bit_le</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="n">bitmap</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define ocfs2_set_bit(bit, addr) _ocfs2_set_bit((bit), (unsigned long *)(addr))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">_ocfs2_clear_bit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__clear_bit_le</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="n">bitmap</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define ocfs2_clear_bit(bit, addr) _ocfs2_clear_bit((bit), (unsigned long *)(addr))</span>

<span class="cp">#define ocfs2_test_bit test_bit_le</span>
<span class="cp">#define ocfs2_find_next_zero_bit find_next_zero_bit_le</span>
<span class="cp">#define ocfs2_find_next_bit find_next_bit_le</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">correct_addr_and_bit_unaligned</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">bit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if BITS_PER_LONG == 64</span>
	<span class="o">*</span><span class="n">bit</span> <span class="o">+=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="mi">7UL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">7UL</span><span class="p">);</span>
<span class="cp">#elif BITS_PER_LONG == 32</span>
	<span class="o">*</span><span class="n">bit</span> <span class="o">+=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="mi">3UL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3UL</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#error &quot;how many bits you are?!&quot;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ocfs2_set_bit_unaligned</span><span class="p">(</span><span class="kt">int</span> <span class="n">bit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap</span> <span class="o">=</span> <span class="n">correct_addr_and_bit_unaligned</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bit</span><span class="p">,</span> <span class="n">bitmap</span><span class="p">);</span>
	<span class="n">ocfs2_set_bit</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="n">bitmap</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ocfs2_clear_bit_unaligned</span><span class="p">(</span><span class="kt">int</span> <span class="n">bit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap</span> <span class="o">=</span> <span class="n">correct_addr_and_bit_unaligned</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bit</span><span class="p">,</span> <span class="n">bitmap</span><span class="p">);</span>
	<span class="n">ocfs2_clear_bit</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="n">bitmap</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_test_bit_unaligned</span><span class="p">(</span><span class="kt">int</span> <span class="n">bit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bitmap</span> <span class="o">=</span> <span class="n">correct_addr_and_bit_unaligned</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bit</span><span class="p">,</span> <span class="n">bitmap</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ocfs2_test_bit</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="n">bitmap</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_find_next_zero_bit_unaligned</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span><span class="p">,</span>
							<span class="kt">int</span> <span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fix</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">tmpmax</span><span class="p">;</span>
	<span class="n">bitmap</span> <span class="o">=</span> <span class="n">correct_addr_and_bit_unaligned</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fix</span><span class="p">,</span> <span class="n">bitmap</span><span class="p">);</span>
	<span class="n">tmpmax</span> <span class="o">=</span> <span class="n">max</span> <span class="o">+</span> <span class="n">fix</span><span class="p">;</span>
	<span class="n">start</span> <span class="o">+=</span> <span class="n">fix</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ocfs2_find_next_zero_bit</span><span class="p">(</span><span class="n">bitmap</span><span class="p">,</span> <span class="n">tmpmax</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span> <span class="o">-</span> <span class="n">fix</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">max</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif  </span><span class="cm">/* OCFS2_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
