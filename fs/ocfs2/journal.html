<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › ocfs2 › journal.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>journal.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* -*- mode: c; c-basic-offset: 8; -*-</span>
<span class="cm"> * vim: noexpandtab sw=8 ts=8 sts=0:</span>
<span class="cm"> *</span>
<span class="cm"> * journal.h</span>
<span class="cm"> *</span>
<span class="cm"> * Defines journalling api and structures.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2003, 2005 Oracle.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public</span>
<span class="cm"> * License as published by the Free Software Foundation; either</span>
<span class="cm"> * version 2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public</span>
<span class="cm"> * License along with this program; if not, write to the</span>
<span class="cm"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 021110-1307, USA.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef OCFS2_JOURNAL_H</span>
<span class="cp">#define OCFS2_JOURNAL_H</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/jbd2.h&gt;</span>

<span class="k">enum</span> <span class="n">ocfs2_journal_state</span> <span class="p">{</span>
	<span class="n">OCFS2_JOURNAL_FREE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">OCFS2_JOURNAL_LOADED</span><span class="p">,</span>
	<span class="n">OCFS2_JOURNAL_IN_SHUTDOWN</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ocfs2_super</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ocfs2_dinode</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The recovery_list is a simple linked list of node numbers to recover.</span>
<span class="cm"> * It is protected by the recovery_lock.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">ocfs2_recovery_map</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rm_used</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">rm_entries</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">ocfs2_journal</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">ocfs2_journal_state</span>   <span class="n">j_state</span><span class="p">;</span>    <span class="cm">/* Journals current state   */</span>

	<span class="n">journal_t</span>                 <span class="o">*</span><span class="n">j_journal</span><span class="p">;</span> <span class="cm">/* The kernels journal type */</span>
	<span class="k">struct</span> <span class="n">inode</span>              <span class="o">*</span><span class="n">j_inode</span><span class="p">;</span>   <span class="cm">/* Kernel inode pointing to</span>
<span class="cm">					       * this journal             */</span>
	<span class="k">struct</span> <span class="n">ocfs2_super</span>        <span class="o">*</span><span class="n">j_osb</span><span class="p">;</span>     <span class="cm">/* pointer to the super</span>
<span class="cm">					       * block for the node</span>
<span class="cm">					       * we&#39;re currently</span>
<span class="cm">					       * running on -- not</span>
<span class="cm">					       * necessarily the super</span>
<span class="cm">					       * block from the node</span>
<span class="cm">					       * which we usually run</span>
<span class="cm">					       * from (recovery,</span>
<span class="cm">					       * etc)                     */</span>
	<span class="k">struct</span> <span class="n">buffer_head</span>        <span class="o">*</span><span class="n">j_bh</span><span class="p">;</span>      <span class="cm">/* Journal disk inode block */</span>
	<span class="n">atomic_t</span>                  <span class="n">j_num_trans</span><span class="p">;</span> <span class="cm">/* Number of transactions</span>
<span class="cm">					        * currently in the system. */</span>
	<span class="n">spinlock_t</span>                <span class="n">j_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>             <span class="n">j_trans_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span>       <span class="n">j_trans_barrier</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>         <span class="n">j_checkpointed</span><span class="p">;</span>

	<span class="cm">/* both fields protected by j_lock*/</span>
	<span class="k">struct</span> <span class="n">list_head</span>          <span class="n">j_la_cleanups</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span>        <span class="n">j_recovery_work</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="n">spinlock_t</span> <span class="n">trans_inc_lock</span><span class="p">;</span>

<span class="cm">/* wrap j_trans_id so we never have it equal to zero. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">ocfs2_inc_trans_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_journal</span> <span class="o">*</span><span class="n">j</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_id</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_inc_lock</span><span class="p">);</span>
	<span class="n">old_id</span> <span class="o">=</span> <span class="n">j</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">j</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">))</span>
		<span class="n">j</span><span class="o">-&gt;</span><span class="n">j_trans_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_inc_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">old_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ocfs2_set_ci_lock_trans</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_journal</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">ocfs2_caching_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_inc_lock</span><span class="p">);</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">ci_last_trans</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_inc_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Used to figure out whether it&#39;s safe to drop a metadata lock on an</span>
<span class="cm"> * cached object. Returns true if all the object&#39;s changes have been</span>
<span class="cm"> * checkpointed to disk. You should be holding the spinlock on the</span>
<span class="cm"> * metadata lock while calling this to be sure that nobody can take</span>
<span class="cm"> * the lock and put it on another transaction. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_ci_fully_checkpointed</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_caching_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span>
		<span class="n">OCFS2_SB</span><span class="p">(</span><span class="n">ocfs2_metadata_cache_get_super</span><span class="p">(</span><span class="n">ci</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">journal</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_inc_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">time_after</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">ci_last_trans</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_inc_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* convenience function to check if an object backed by struct</span>
<span class="cm"> * ocfs2_caching_info  is still new (has never hit disk) Will do you a</span>
<span class="cm"> * favor and set created_trans = 0 when you&#39;ve</span>
<span class="cm"> * been checkpointed.  returns &#39;1&#39; if the ci is still new. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_ci_is_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_caching_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ocfs2_journal</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span>
		<span class="n">OCFS2_SB</span><span class="p">(</span><span class="n">ocfs2_metadata_cache_get_super</span><span class="p">(</span><span class="n">ci</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">journal</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_inc_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">,</span> <span class="n">ci</span><span class="o">-&gt;</span><span class="n">ci_created_trans</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ci</span><span class="o">-&gt;</span><span class="n">ci_created_trans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_inc_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Wrapper for inodes so we can check system files */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_inode_is_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* System files are never &quot;new&quot; as they&#39;re written out by</span>
<span class="cm">	 * mkfs. This helps us early during mount, before we have the</span>
<span class="cm">	 * journal open and j_trans_id could be junk. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OCFS2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ip_flags</span> <span class="o">&amp;</span> <span class="n">OCFS2_INODE_SYSTEM_FILE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ocfs2_ci_is_new</span><span class="p">(</span><span class="n">INODE_CACHE</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ocfs2_ci_set_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ocfs2_caching_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_inc_lock</span><span class="p">);</span>
	<span class="n">ci</span><span class="o">-&gt;</span><span class="n">ci_created_trans</span> <span class="o">=</span> <span class="n">osb</span><span class="o">-&gt;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_trans_id</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans_inc_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Exported only for the journal struct init code in super.c. Do not call. */</span>
<span class="kt">void</span> <span class="n">ocfs2_orphan_scan_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ocfs2_orphan_scan_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ocfs2_orphan_scan_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ocfs2_orphan_scan_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ocfs2_complete_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ocfs2_wait_for_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ocfs2_recovery_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ocfs2_recovery_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ocfs2_compute_replay_slots</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> *  Journal Control:</span>
<span class="cm"> *  Initialize, Load, Shutdown, Wipe a journal.</span>
<span class="cm"> *</span>
<span class="cm"> *  ocfs2_journal_init     - Initialize journal structures in the OSB.</span>
<span class="cm"> *  ocfs2_journal_load     - Load the given journal off disk. Replay it if</span>
<span class="cm"> *                          there&#39;s transactions still in there.</span>
<span class="cm"> *  ocfs2_journal_shutdown - Shutdown a journal, this will flush all</span>
<span class="cm"> *                          uncommitted, uncheckpointed transactions.</span>
<span class="cm"> *  ocfs2_journal_wipe     - Wipe transactions from a journal. Optionally</span>
<span class="cm"> *                          zero out each block.</span>
<span class="cm"> *  ocfs2_recovery_thread  - Perform recovery on a node. osb is our own osb.</span>
<span class="cm"> *  ocfs2_mark_dead_nodes - Start recovery on nodes we won&#39;t get a heartbeat</span>
<span class="cm"> *                          event on.</span>
<span class="cm"> *  ocfs2_start_checkpoint - Kick the commit thread to do a checkpoint.</span>
<span class="cm"> */</span>
<span class="kt">void</span>   <span class="n">ocfs2_set_journal_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">);</span>
<span class="kt">int</span>    <span class="n">ocfs2_journal_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_journal</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="o">*</span><span class="n">dirty</span><span class="p">);</span>
<span class="kt">void</span>   <span class="n">ocfs2_journal_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">);</span>
<span class="kt">int</span>    <span class="n">ocfs2_journal_wipe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_journal</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">full</span><span class="p">);</span>
<span class="kt">int</span>    <span class="n">ocfs2_journal_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_journal</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="kt">int</span> <span class="n">local</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">replayed</span><span class="p">);</span>
<span class="kt">int</span>    <span class="n">ocfs2_check_journals_nolocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">);</span>
<span class="kt">void</span>   <span class="n">ocfs2_recovery_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">node_num</span><span class="p">);</span>
<span class="kt">int</span>    <span class="n">ocfs2_mark_dead_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">);</span>
<span class="kt">void</span>   <span class="n">ocfs2_complete_mount_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ocfs2_complete_quota_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ocfs2_start_checkpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">needs_checkpoint</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">checkpoint_event</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ocfs2_checkpoint_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span> <span class="o">=</span> <span class="n">OCFS2_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ocfs2_mount_local</span><span class="p">(</span><span class="n">osb</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ocfs2_ci_fully_checkpointed</span><span class="p">(</span><span class="n">INODE_CACHE</span><span class="p">(</span><span class="n">inode</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* WARNING: This only kicks off a single</span>
<span class="cm">		 * checkpoint. If someone races you and adds more</span>
<span class="cm">		 * metadata to the journal, you won&#39;t know, and will</span>
<span class="cm">		 * wind up waiting *a lot* longer than necessary. Right</span>
<span class="cm">		 * now we only use this in clear_inode so that&#39;s</span>
<span class="cm">		 * OK. */</span>
		<span class="n">ocfs2_start_checkpoint</span><span class="p">(</span><span class="n">osb</span><span class="p">);</span>

		<span class="n">wait_event</span><span class="p">(</span><span class="n">osb</span><span class="o">-&gt;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpointed</span><span class="p">,</span>
			   <span class="n">ocfs2_ci_fully_checkpointed</span><span class="p">(</span><span class="n">INODE_CACHE</span><span class="p">(</span><span class="n">inode</span><span class="p">)));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Transaction Handling:</span>
<span class="cm"> *  Manage the lifetime of a transaction handle.</span>
<span class="cm"> *</span>
<span class="cm"> *  ocfs2_start_trans      - Begin a transaction. Give it an upper estimate of</span>
<span class="cm"> *                          the number of blocks that will be changed during</span>
<span class="cm"> *                          this handle.</span>
<span class="cm"> *  ocfs2_commit_trans - Complete a handle. It might return -EIO if</span>
<span class="cm"> *                       the journal was aborted. The majority of paths don&#39;t</span>
<span class="cm"> *                       check the return value as an error there comes too</span>
<span class="cm"> *                       late to do anything (and will be picked up in a</span>
<span class="cm"> *                       later transaction).</span>
<span class="cm"> *  ocfs2_extend_trans     - Extend a handle by nblocks credits. This may</span>
<span class="cm"> *                          commit the handle to disk in the process, but will</span>
<span class="cm"> *                          not release any locks taken during the transaction.</span>
<span class="cm"> *  ocfs2_journal_access* - Notify the handle that we want to journal this</span>
<span class="cm"> *                          buffer. Will have to call ocfs2_journal_dirty once</span>
<span class="cm"> *                          we&#39;ve actually dirtied it. Type is one of . or .</span>
<span class="cm"> *                          Always call the specific flavor of</span>
<span class="cm"> *                          ocfs2_journal_access_*() unless you intend to</span>
<span class="cm"> *                          manage the checksum by hand.</span>
<span class="cm"> *  ocfs2_journal_dirty    - Mark a journalled buffer as having dirty data.</span>
<span class="cm"> *  ocfs2_jbd2_file_inode  - Mark an inode so that its data goes out before</span>
<span class="cm"> *                           the current handle commits.</span>
<span class="cm"> */</span>

<span class="cm">/* You must always start_trans with a number of buffs &gt; 0, but it&#39;s</span>
<span class="cm"> * perfectly legal to go through an entire transaction without having</span>
<span class="cm"> * dirtied any buffers. */</span>
<span class="n">handle_t</span>		    <span class="o">*</span><span class="n">ocfs2_start_trans</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">,</span>
					       <span class="kt">int</span> <span class="n">max_buffs</span><span class="p">);</span>
<span class="kt">int</span>			     <span class="n">ocfs2_commit_trans</span><span class="p">(</span><span class="k">struct</span> <span class="n">ocfs2_super</span> <span class="o">*</span><span class="n">osb</span><span class="p">,</span>
						<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">);</span>
<span class="kt">int</span>			     <span class="n">ocfs2_extend_trans</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Create access is for when we get a newly created buffer and we&#39;re</span>
<span class="cm"> * not gonna read it off disk, but rather fill it ourselves.  Right</span>
<span class="cm"> * now, we don&#39;t do anything special with this (it turns into a write</span>
<span class="cm"> * request), but this is a good placeholder in case we do...</span>
<span class="cm"> *</span>
<span class="cm"> * Write access is for when we read a block off disk and are going to</span>
<span class="cm"> * modify it. This way the journalling layer knows it may need to make</span>
<span class="cm"> * a copy of that block (if it&#39;s part of another, uncommitted</span>
<span class="cm"> * transaction) before we do so.</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_JOURNAL_ACCESS_CREATE 0</span>
<span class="cp">#define OCFS2_JOURNAL_ACCESS_WRITE  1</span>
<span class="cp">#define OCFS2_JOURNAL_ACCESS_UNDO   2</span>


<span class="cm">/* ocfs2_inode */</span>
<span class="kt">int</span> <span class="n">ocfs2_journal_access_di</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ocfs2_caching_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
<span class="cm">/* ocfs2_extent_block */</span>
<span class="kt">int</span> <span class="n">ocfs2_journal_access_eb</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ocfs2_caching_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
<span class="cm">/* ocfs2_refcount_block */</span>
<span class="kt">int</span> <span class="n">ocfs2_journal_access_rb</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ocfs2_caching_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
<span class="cm">/* ocfs2_group_desc */</span>
<span class="kt">int</span> <span class="n">ocfs2_journal_access_gd</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ocfs2_caching_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
<span class="cm">/* ocfs2_xattr_block */</span>
<span class="kt">int</span> <span class="n">ocfs2_journal_access_xb</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ocfs2_caching_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
<span class="cm">/* quota blocks */</span>
<span class="kt">int</span> <span class="n">ocfs2_journal_access_dq</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ocfs2_caching_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
<span class="cm">/* dirblock */</span>
<span class="kt">int</span> <span class="n">ocfs2_journal_access_db</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ocfs2_caching_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
<span class="cm">/* ocfs2_dx_root_block */</span>
<span class="kt">int</span> <span class="n">ocfs2_journal_access_dr</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ocfs2_caching_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
<span class="cm">/* ocfs2_dx_leaf */</span>
<span class="kt">int</span> <span class="n">ocfs2_journal_access_dl</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ocfs2_caching_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
<span class="cm">/* Anything that has no ecc */</span>
<span class="kt">int</span> <span class="n">ocfs2_journal_access</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ocfs2_caching_info</span> <span class="o">*</span><span class="n">ci</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * A word about the journal_access/journal_dirty &quot;dance&quot;. It is</span>
<span class="cm"> * entirely legal to journal_access a buffer more than once (as long</span>
<span class="cm"> * as the access type is the same -- I&#39;m not sure what will happen if</span>
<span class="cm"> * access type is different but this should never happen anyway) It is</span>
<span class="cm"> * also legal to journal_dirty a buffer more than once. In fact, you</span>
<span class="cm"> * can even journal_access a buffer after you&#39;ve done a</span>
<span class="cm"> * journal_access/journal_dirty pair. The only thing you cannot do</span>
<span class="cm"> * however, is journal_dirty a buffer which you haven&#39;t yet passed to</span>
<span class="cm"> * journal_access at least once.</span>
<span class="cm"> *</span>
<span class="cm"> * That said, 99% of the time this doesn&#39;t matter and this is what the</span>
<span class="cm"> * path looks like:</span>
<span class="cm"> *</span>
<span class="cm"> *	&lt;read a bh&gt;</span>
<span class="cm"> *	ocfs2_journal_access(handle, bh,	OCFS2_JOURNAL_ACCESS_WRITE);</span>
<span class="cm"> *	&lt;modify the bh&gt;</span>
<span class="cm"> * 	ocfs2_journal_dirty(handle, bh);</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">ocfs2_journal_dirty</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  Credit Macros:</span>
<span class="cm"> *  Convenience macros to calculate number of credits needed.</span>
<span class="cm"> *</span>
<span class="cm"> *  For convenience sake, I have a set of macros here which calculate</span>
<span class="cm"> *  the *maximum* number of sectors which will be changed for various</span>
<span class="cm"> *  metadata updates.</span>
<span class="cm"> */</span>

<span class="cm">/* simple file updates like chmod, etc. */</span>
<span class="cp">#define OCFS2_INODE_UPDATE_CREDITS 1</span>

<span class="cm">/* extended attribute block update */</span>
<span class="cp">#define OCFS2_XATTR_BLOCK_UPDATE_CREDITS 1</span>

<span class="cm">/* Update of a single quota block */</span>
<span class="cp">#define OCFS2_QUOTA_BLOCK_UPDATE_CREDITS 1</span>

<span class="cm">/* global quotafile inode update, data block */</span>
<span class="cp">#define OCFS2_QINFO_WRITE_CREDITS (OCFS2_INODE_UPDATE_CREDITS + \</span>
<span class="cp">				   OCFS2_QUOTA_BLOCK_UPDATE_CREDITS)</span>

<span class="cp">#define OCFS2_LOCAL_QINFO_WRITE_CREDITS OCFS2_QUOTA_BLOCK_UPDATE_CREDITS</span>
<span class="cm">/*</span>
<span class="cm"> * The two writes below can accidentally see global info dirty due</span>
<span class="cm"> * to set_info() quotactl so make them prepared for the writes.</span>
<span class="cm"> */</span>
<span class="cm">/* quota data block, global info */</span>
<span class="cm">/* Write to local quota file */</span>
<span class="cp">#define OCFS2_QWRITE_CREDITS (OCFS2_QINFO_WRITE_CREDITS + \</span>
<span class="cp">			      OCFS2_QUOTA_BLOCK_UPDATE_CREDITS)</span>

<span class="cm">/* global quota data block, local quota data block, global quota inode,</span>
<span class="cm"> * global quota info */</span>
<span class="cp">#define OCFS2_QSYNC_CREDITS (OCFS2_QINFO_WRITE_CREDITS + \</span>
<span class="cp">			     2 * OCFS2_QUOTA_BLOCK_UPDATE_CREDITS)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_quota_trans_credits</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">credits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">OCFS2_HAS_RO_COMPAT_FEATURE</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">OCFS2_FEATURE_RO_COMPAT_USRQUOTA</span><span class="p">))</span>
		<span class="n">credits</span> <span class="o">+=</span> <span class="n">OCFS2_QWRITE_CREDITS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OCFS2_HAS_RO_COMPAT_FEATURE</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">OCFS2_FEATURE_RO_COMPAT_GRPQUOTA</span><span class="p">))</span>
		<span class="n">credits</span> <span class="o">+=</span> <span class="n">OCFS2_QWRITE_CREDITS</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">credits</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* group extend. inode update and last group update. */</span>
<span class="cp">#define OCFS2_GROUP_EXTEND_CREDITS	(OCFS2_INODE_UPDATE_CREDITS + 1)</span>

<span class="cm">/* group add. inode update and the new group update. */</span>
<span class="cp">#define OCFS2_GROUP_ADD_CREDITS	(OCFS2_INODE_UPDATE_CREDITS + 1)</span>

<span class="cm">/* get one bit out of a suballocator: dinode + group descriptor +</span>
<span class="cm"> * prev. group desc. if we relink. */</span>
<span class="cp">#define OCFS2_SUBALLOC_ALLOC (3)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_inline_to_extents_credits</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">OCFS2_SUBALLOC_ALLOC</span> <span class="o">+</span> <span class="n">OCFS2_INODE_UPDATE_CREDITS</span> <span class="o">+</span>
	       <span class="n">ocfs2_quota_trans_credits</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* dinode + group descriptor update. We don&#39;t relink on free yet. */</span>
<span class="cp">#define OCFS2_SUBALLOC_FREE  (2)</span>

<span class="cp">#define OCFS2_TRUNCATE_LOG_UPDATE OCFS2_INODE_UPDATE_CREDITS</span>
<span class="cp">#define OCFS2_TRUNCATE_LOG_FLUSH_ONE_REC (OCFS2_SUBALLOC_FREE 		      \</span>
<span class="cp">					 + OCFS2_TRUNCATE_LOG_UPDATE)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_remove_extent_credits</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">OCFS2_TRUNCATE_LOG_UPDATE</span> <span class="o">+</span> <span class="n">OCFS2_INODE_UPDATE_CREDITS</span> <span class="o">+</span>
	       <span class="n">ocfs2_quota_trans_credits</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* data block for new dir/symlink, allocation of directory block, dx_root</span>
<span class="cm"> * update for free list */</span>
<span class="cp">#define OCFS2_DIR_LINK_ADDITIONAL_CREDITS (1 + OCFS2_SUBALLOC_ALLOC + 1)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_add_dir_index_credits</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* 1 block for index, 2 allocs (data, metadata), 1 clusters</span>
<span class="cm">	 * worth of blocks for initial extent. */</span>
	<span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">OCFS2_SUBALLOC_ALLOC</span> <span class="o">+</span>
		<span class="n">ocfs2_clusters_to_blocks</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* parent fe, parent block, new file entry, index leaf, inode alloc fe, inode</span>
<span class="cm"> * alloc group descriptor + mkdir/symlink blocks + dir blocks + xattr</span>
<span class="cm"> * blocks + quota update */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_mknod_credits</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_dir</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">xattr_credits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dir_credits</span> <span class="o">=</span> <span class="n">OCFS2_DIR_LINK_ADDITIONAL_CREDITS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_dir</span><span class="p">)</span>
		<span class="n">dir_credits</span> <span class="o">+=</span> <span class="n">ocfs2_add_dir_index_credits</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">OCFS2_SUBALLOC_ALLOC</span> <span class="o">+</span> <span class="n">dir_credits</span> <span class="o">+</span> <span class="n">xattr_credits</span> <span class="o">+</span>
	       <span class="n">ocfs2_quota_trans_credits</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* local alloc metadata change + main bitmap updates */</span>
<span class="cp">#define OCFS2_WINDOW_MOVE_CREDITS (OCFS2_INODE_UPDATE_CREDITS                 \</span>
<span class="cp">				  + OCFS2_SUBALLOC_ALLOC + OCFS2_SUBALLOC_FREE)</span>

<span class="cm">/* used when we don&#39;t need an allocation change for a dir extend. One</span>
<span class="cm"> * for the dinode, one for the new block. */</span>
<span class="cp">#define OCFS2_SIMPLE_DIR_EXTEND_CREDITS (2)</span>

<span class="cm">/* file update (nlink, etc) + directory mtime/ctime + dir entry block + quota</span>
<span class="cm"> * update on dir + index leaf + dx root update for free list +</span>
<span class="cm"> * previous dirblock update in the free list */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_link_credits</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">OCFS2_INODE_UPDATE_CREDITS</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span>
	       <span class="n">ocfs2_quota_trans_credits</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* inode + dir inode (if we unlink a dir), + dir entry block + orphan</span>
<span class="cm"> * dir inode link + dir inode index leaf + dir index root */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_unlink_credits</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* The quota update from ocfs2_link_credits is unused here... */</span>
	<span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">OCFS2_INODE_UPDATE_CREDITS</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">ocfs2_link_credits</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* dinode + orphan dir dinode + inode alloc dinode + orphan dir entry +</span>
<span class="cm"> * inode alloc group descriptor + orphan dir index root +</span>
<span class="cm"> * orphan dir index leaf */</span>
<span class="cp">#define OCFS2_DELETE_INODE_CREDITS (3 * OCFS2_INODE_UPDATE_CREDITS + 4)</span>

<span class="cm">/* dinode update, old dir dinode update, new dir dinode update, old</span>
<span class="cm"> * dir dir entry, new dir dir entry, dir entry update for renaming</span>
<span class="cm"> * directory + target unlink + 3 x dir index leaves */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_rename_credits</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">OCFS2_INODE_UPDATE_CREDITS</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">+</span> <span class="n">ocfs2_unlink_credits</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* global bitmap dinode, group desc., relinked group,</span>
<span class="cm"> * suballocator dinode, group desc., relinked group,</span>
<span class="cm"> * dinode, xattr block */</span>
<span class="cp">#define OCFS2_XATTR_BLOCK_CREATE_CREDITS (OCFS2_SUBALLOC_ALLOC * 2 + \</span>
<span class="cp">					  + OCFS2_INODE_UPDATE_CREDITS \</span>
<span class="cp">					  + OCFS2_XATTR_BLOCK_UPDATE_CREDITS)</span>

<span class="cm">/* inode update, removal of dx root block from allocator */</span>
<span class="cp">#define OCFS2_DX_ROOT_REMOVE_CREDITS (OCFS2_INODE_UPDATE_CREDITS +	\</span>
<span class="cp">				      OCFS2_SUBALLOC_FREE)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_calc_dxi_expand_credits</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">credits</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">OCFS2_SUBALLOC_ALLOC</span><span class="p">;</span>

	<span class="n">credits</span> <span class="o">+=</span> <span class="n">ocfs2_clusters_to_blocks</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">credits</span> <span class="o">+=</span> <span class="n">ocfs2_quota_trans_credits</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">credits</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* inode update, new refcount block and its allocation credits. */</span>
<span class="cp">#define OCFS2_REFCOUNT_TREE_CREATE_CREDITS (OCFS2_INODE_UPDATE_CREDITS + 1 \</span>
<span class="cp">					    + OCFS2_SUBALLOC_ALLOC)</span>

<span class="cm">/* inode and the refcount block update. */</span>
<span class="cp">#define OCFS2_REFCOUNT_TREE_SET_CREDITS (OCFS2_INODE_UPDATE_CREDITS + 1)</span>

<span class="cm">/*</span>
<span class="cm"> * inode and the refcount block update.</span>
<span class="cm"> * It doesn&#39;t include the credits for sub alloc change.</span>
<span class="cm"> * So if we need to free the bit, OCFS2_SUBALLOC_FREE needs to be added.</span>
<span class="cm"> */</span>
<span class="cp">#define OCFS2_REFCOUNT_TREE_REMOVE_CREDITS (OCFS2_INODE_UPDATE_CREDITS + 1)</span>

<span class="cm">/* 2 metadata alloc, 2 new blocks and root refcount block */</span>
<span class="cp">#define OCFS2_EXPAND_REFCOUNT_TREE_CREDITS (OCFS2_SUBALLOC_ALLOC * 2 + 3)</span>

<span class="cm">/*</span>
<span class="cm"> * Please note that the caller must make sure that root_el is the root</span>
<span class="cm"> * of extent tree. So for an inode, it should be &amp;fe-&gt;id2.i_list. Otherwise</span>
<span class="cm"> * the result may be wrong.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_calc_extend_credits</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">ocfs2_extent_list</span> <span class="o">*</span><span class="n">root_el</span><span class="p">,</span>
					    <span class="n">u32</span> <span class="n">bits_wanted</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bitmap_blocks</span><span class="p">,</span> <span class="n">sysfile_bitmap_blocks</span><span class="p">,</span> <span class="n">extent_blocks</span><span class="p">;</span>

	<span class="cm">/* bitmap dinode, group desc. + relinked group. */</span>
	<span class="n">bitmap_blocks</span> <span class="o">=</span> <span class="n">OCFS2_SUBALLOC_ALLOC</span><span class="p">;</span>

	<span class="cm">/* we might need to shift tree depth so lets assume an</span>
<span class="cm">	 * absolute worst case of complete fragmentation.  Even with</span>
<span class="cm">	 * that, we only need one update for the dinode, and then</span>
<span class="cm">	 * however many metadata chunks needed * a remaining suballoc</span>
<span class="cm">	 * alloc. */</span>
	<span class="n">sysfile_bitmap_blocks</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span>
		<span class="p">(</span><span class="n">OCFS2_SUBALLOC_ALLOC</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ocfs2_extend_meta_needed</span><span class="p">(</span><span class="n">root_el</span><span class="p">);</span>

	<span class="cm">/* this does not include *new* metadata blocks, which are</span>
<span class="cm">	 * accounted for in sysfile_bitmap_blocks. root_el +</span>
<span class="cm">	 * prev. last_eb_blk + blocks along edge of tree.</span>
<span class="cm">	 * calc_symlink_credits passes because we just need 1</span>
<span class="cm">	 * credit for the dinode there. */</span>
	<span class="n">extent_blocks</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">root_el</span><span class="o">-&gt;</span><span class="n">l_tree_depth</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">bitmap_blocks</span> <span class="o">+</span> <span class="n">sysfile_bitmap_blocks</span> <span class="o">+</span> <span class="n">extent_blocks</span> <span class="o">+</span>
	       <span class="n">ocfs2_quota_trans_credits</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_calc_symlink_credits</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">blocks</span> <span class="o">=</span> <span class="n">ocfs2_mknod_credits</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* links can be longer than one block so we may update many</span>
<span class="cm">	 * within our single allocated extent. */</span>
	<span class="n">blocks</span> <span class="o">+=</span> <span class="n">ocfs2_clusters_to_blocks</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">blocks</span> <span class="o">+</span> <span class="n">ocfs2_quota_trans_credits</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_calc_group_alloc_credits</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
						 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">blocks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bitmap_blocks</span> <span class="o">=</span> <span class="n">OCFS2_SUBALLOC_ALLOC</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* parent inode update + new block group header + bitmap inode update</span>
<span class="cm">	   + bitmap blocks affected */</span>
	<span class="n">blocks</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">bitmap_blocks</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">blocks</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocating a discontiguous block group requires the credits from</span>
<span class="cm"> * ocfs2_calc_group_alloc_credits() as well as enough credits to fill</span>
<span class="cm"> * the group descriptor&#39;s extent list.  The caller already has started</span>
<span class="cm"> * the transaction with ocfs2_calc_group_alloc_credits().  They extend</span>
<span class="cm"> * it with these credits.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_calc_bg_discontig_credits</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ocfs2_extent_recs_per_gd</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_calc_tree_trunc_credits</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">clusters_to_del</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ocfs2_dinode</span> <span class="o">*</span><span class="n">fe</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ocfs2_extent_list</span> <span class="o">*</span><span class="n">last_el</span><span class="p">)</span>
<span class="p">{</span>
 	<span class="cm">/* for dinode + all headers in this pass + update to next leaf */</span>
	<span class="n">u16</span> <span class="n">next_free</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">last_el</span><span class="o">-&gt;</span><span class="n">l_next_free_rec</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">tree_depth</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">id2</span><span class="p">.</span><span class="n">i_list</span><span class="p">.</span><span class="n">l_tree_depth</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">credits</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">tree_depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">next_free</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* We may be deleting metadata blocks, so metadata alloc dinode +</span>
<span class="cm">	   one desc. block for each possible delete. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tree_depth</span> <span class="o">&amp;&amp;</span> <span class="n">next_free</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ocfs2_rec_clusters</span><span class="p">(</span><span class="n">last_el</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last_el</span><span class="o">-&gt;</span><span class="n">l_recs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="n">clusters_to_del</span><span class="p">)</span>
		<span class="n">credits</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">tree_depth</span><span class="p">;</span>

	<span class="cm">/* update to the truncate log. */</span>
	<span class="n">credits</span> <span class="o">+=</span> <span class="n">OCFS2_TRUNCATE_LOG_UPDATE</span><span class="p">;</span>

	<span class="n">credits</span> <span class="o">+=</span> <span class="n">ocfs2_quota_trans_credits</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">credits</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_jbd2_file_inode</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">jbd2_journal_file_inode</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">OCFS2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ip_jinode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ocfs2_begin_ordered_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					       <span class="n">loff_t</span> <span class="n">new_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">jbd2_journal_begin_ordered_truncate</span><span class="p">(</span>
				<span class="n">OCFS2_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_journal</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">OCFS2_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ip_jinode</span><span class="p">,</span>
				<span class="n">new_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* OCFS2_JOURNAL_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
