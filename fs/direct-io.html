<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › direct-io.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>direct-io.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * fs/direct-io.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2002, Linus Torvalds.</span>
<span class="cm"> *</span>
<span class="cm"> * O_DIRECT</span>
<span class="cm"> *</span>
<span class="cm"> * 04Jul2002	Andrew Morton</span>
<span class="cm"> *		Initial version</span>
<span class="cm"> * 11Sep2002	janetinc@us.ibm.com</span>
<span class="cm"> * 		added readv/writev support.</span>
<span class="cm"> * 29Oct2002	Andrew Morton</span>
<span class="cm"> *		rewrote bio_add_page() support.</span>
<span class="cm"> * 30Oct2002	pbadari@us.ibm.com</span>
<span class="cm"> *		added support for non-aligned IO.</span>
<span class="cm"> * 06Nov2002	pbadari@us.ibm.com</span>
<span class="cm"> *		added asynchronous IO support.</span>
<span class="cm"> * 21Jul2003	nathans@sgi.com</span>
<span class="cm"> *		added IO completion notifier.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/task_io_accounting_ops.h&gt;</span>
<span class="cp">#include &lt;linux/bio.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/rwsem.h&gt;</span>
<span class="cp">#include &lt;linux/uio.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * How many user pages to map in one call to get_user_pages().  This determines</span>
<span class="cm"> * the size of a structure in the slab cache</span>
<span class="cm"> */</span>
<span class="cp">#define DIO_PAGES	64</span>

<span class="cm">/*</span>
<span class="cm"> * This code generally works in units of &quot;dio_blocks&quot;.  A dio_block is</span>
<span class="cm"> * somewhere between the hard sector size and the filesystem block size.  it</span>
<span class="cm"> * is determined on a per-invocation basis.   When talking to the filesystem</span>
<span class="cm"> * we need to convert dio_blocks to fs_blocks by scaling the dio_block quantity</span>
<span class="cm"> * down by dio-&gt;blkfactor.  Similarly, fs-blocksize quantities are converted</span>
<span class="cm"> * to bio_block quantities by shifting left by blkfactor.</span>
<span class="cm"> *</span>
<span class="cm"> * If blkfactor is zero then the user&#39;s request was aligned to the filesystem&#39;s</span>
<span class="cm"> * blocksize.</span>
<span class="cm"> */</span>

<span class="cm">/* dio_state only used in the submission path */</span>

<span class="k">struct</span> <span class="n">dio_submit</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>		<span class="cm">/* bio under assembly */</span>
	<span class="kt">unsigned</span> <span class="n">blkbits</span><span class="p">;</span>		<span class="cm">/* doesn&#39;t change */</span>
	<span class="kt">unsigned</span> <span class="n">blkfactor</span><span class="p">;</span>		<span class="cm">/* When we&#39;re using an alignment which</span>
<span class="cm">					   is finer than the filesystem&#39;s soft</span>
<span class="cm">					   blocksize, this specifies how much</span>
<span class="cm">					   finer.  blkfactor=2 means 1/4-block</span>
<span class="cm">					   alignment.  Does not change */</span>
	<span class="kt">unsigned</span> <span class="n">start_zero_done</span><span class="p">;</span>	<span class="cm">/* flag: sub-blocksize zeroing has</span>
<span class="cm">					   been performed at the start of a</span>
<span class="cm">					   write */</span>
	<span class="kt">int</span> <span class="n">pages_in_io</span><span class="p">;</span>		<span class="cm">/* approximate total IO pages */</span>
	<span class="kt">size_t</span>	<span class="n">size</span><span class="p">;</span>			<span class="cm">/* total request size (doesn&#39;t change)*/</span>
	<span class="n">sector_t</span> <span class="n">block_in_file</span><span class="p">;</span>		<span class="cm">/* Current offset into the underlying</span>
<span class="cm">					   file in dio_block units. */</span>
	<span class="kt">unsigned</span> <span class="n">blocks_available</span><span class="p">;</span>	<span class="cm">/* At block_in_file.  changes */</span>
	<span class="kt">int</span> <span class="n">reap_counter</span><span class="p">;</span>		<span class="cm">/* rate limit reaping */</span>
	<span class="n">sector_t</span> <span class="n">final_block_in_request</span><span class="p">;</span><span class="cm">/* doesn&#39;t change */</span>
	<span class="kt">unsigned</span> <span class="n">first_block_in_page</span><span class="p">;</span>	<span class="cm">/* doesn&#39;t change, Used only once */</span>
	<span class="kt">int</span> <span class="n">boundary</span><span class="p">;</span>			<span class="cm">/* prev block is at a boundary */</span>
	<span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">;</span>		<span class="cm">/* block mapping function */</span>
	<span class="n">dio_submit_t</span> <span class="o">*</span><span class="n">submit_io</span><span class="p">;</span>	<span class="cm">/* IO submition function */</span>

	<span class="n">loff_t</span> <span class="n">logical_offset_in_bio</span><span class="p">;</span>	<span class="cm">/* current first logical block in bio */</span>
	<span class="n">sector_t</span> <span class="n">final_block_in_bio</span><span class="p">;</span>	<span class="cm">/* current final block in bio + 1 */</span>
	<span class="n">sector_t</span> <span class="n">next_block_for_io</span><span class="p">;</span>	<span class="cm">/* next block to be put under IO,</span>
<span class="cm">					   in dio_blocks units */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Deferred addition of a page to the dio.  These variables are</span>
<span class="cm">	 * private to dio_send_cur_page(), submit_page_section() and</span>
<span class="cm">	 * dio_bio_add_page().</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">cur_page</span><span class="p">;</span>		<span class="cm">/* The page */</span>
	<span class="kt">unsigned</span> <span class="n">cur_page_offset</span><span class="p">;</span>	<span class="cm">/* Offset into it, in bytes */</span>
	<span class="kt">unsigned</span> <span class="n">cur_page_len</span><span class="p">;</span>		<span class="cm">/* Nr of bytes at cur_page_offset */</span>
	<span class="n">sector_t</span> <span class="n">cur_page_block</span><span class="p">;</span>	<span class="cm">/* Where it starts */</span>
	<span class="n">loff_t</span> <span class="n">cur_page_fs_offset</span><span class="p">;</span>	<span class="cm">/* Offset in file */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Page fetching state. These variables belong to dio_refill_pages().</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">curr_page</span><span class="p">;</span>			<span class="cm">/* changes */</span>
	<span class="kt">int</span> <span class="n">total_pages</span><span class="p">;</span>		<span class="cm">/* doesn&#39;t change */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">curr_user_address</span><span class="p">;</span><span class="cm">/* changes */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Page queue.  These variables belong to dio_refill_pages() and</span>
<span class="cm">	 * dio_get_page().</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="n">head</span><span class="p">;</span>			<span class="cm">/* next page to process */</span>
	<span class="kt">unsigned</span> <span class="n">tail</span><span class="p">;</span>			<span class="cm">/* last valid page + 1 */</span>
<span class="p">};</span>

<span class="cm">/* dio_state communicated between submission path and end_io */</span>
<span class="k">struct</span> <span class="n">dio</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>			<span class="cm">/* doesn&#39;t change */</span>
	<span class="kt">int</span> <span class="n">rw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">i_size</span><span class="p">;</span>			<span class="cm">/* i_size when submitted */</span>
	<span class="n">dio_iodone_t</span> <span class="o">*</span><span class="n">end_io</span><span class="p">;</span>		<span class="cm">/* IO completion function */</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>			<span class="cm">/* copy from map_bh.b_private */</span>

	<span class="cm">/* BIO completion state */</span>
	<span class="n">spinlock_t</span> <span class="n">bio_lock</span><span class="p">;</span>		<span class="cm">/* protects BIO fields below */</span>
	<span class="kt">int</span> <span class="n">page_errors</span><span class="p">;</span>		<span class="cm">/* errno from get_user_pages() */</span>
	<span class="kt">int</span> <span class="n">is_async</span><span class="p">;</span>			<span class="cm">/* is IO async ? */</span>
	<span class="kt">int</span> <span class="n">io_error</span><span class="p">;</span>			<span class="cm">/* IO error in completion path */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">refcount</span><span class="p">;</span>		<span class="cm">/* direct_io_worker() and bios */</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio_list</span><span class="p">;</span>		<span class="cm">/* singly linked via bi_private */</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">waiter</span><span class="p">;</span>	<span class="cm">/* waiting task (NULL if none) */</span>

	<span class="cm">/* AIO related stuff */</span>
	<span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">;</span>		<span class="cm">/* kiocb */</span>
	<span class="kt">ssize_t</span> <span class="n">result</span><span class="p">;</span>                 <span class="cm">/* IO result */</span>

	<span class="cm">/*</span>
<span class="cm">	 * pages[] (and any fields placed after it) are not zeroed out at</span>
<span class="cm">	 * allocation time.  Don&#39;t add new fields after pages[] unless you</span>
<span class="cm">	 * wish that they not be zeroed.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pages</span><span class="p">[</span><span class="n">DIO_PAGES</span><span class="p">];</span>	<span class="cm">/* page buffer */</span>
<span class="p">}</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">dio_cache</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * How many pages are in the queue?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">dio_pages_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">dio_submit</span> <span class="o">*</span><span class="n">sdio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">-</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Go grab and pin some userspace pages.   Typically we&#39;ll get 64 at a time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dio_refill_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">dio</span> <span class="o">*</span><span class="n">dio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dio_submit</span> <span class="o">*</span><span class="n">sdio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_pages</span><span class="p">;</span>

	<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">total_pages</span> <span class="o">-</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">curr_page</span><span class="p">,</span> <span class="n">DIO_PAGES</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_user_pages_fast</span><span class="p">(</span>
		<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">curr_user_address</span><span class="p">,</span>		<span class="cm">/* Where from? */</span>
		<span class="n">nr_pages</span><span class="p">,</span>			<span class="cm">/* How many pages? */</span>
		<span class="n">dio</span><span class="o">-&gt;</span><span class="n">rw</span> <span class="o">==</span> <span class="n">READ</span><span class="p">,</span>		<span class="cm">/* Write to memory? */</span>
		<span class="o">&amp;</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>		<span class="cm">/* Put results here */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">blocks_available</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">WRITE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">ZERO_PAGE</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * A memory fault, but the filesystem has some outstanding</span>
<span class="cm">		 * mapped blocks.  We need to use those blocks up to avoid</span>
<span class="cm">		 * leaking stale data in the file.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">page_errors</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dio</span><span class="o">-&gt;</span><span class="n">page_errors</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">page_cache_get</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">dio</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">curr_user_address</span> <span class="o">+=</span> <span class="n">ret</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">curr_page</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>	
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get another userspace page.  Returns an ERR_PTR on error.  Pages are</span>
<span class="cm"> * buffered inside the dio so that we can call get_user_pages() against a</span>
<span class="cm"> * decent number of pages, less frequently.  To provide nicer use of the</span>
<span class="cm"> * L1 cache.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">dio_get_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">dio</span> <span class="o">*</span><span class="n">dio</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">dio_submit</span> <span class="o">*</span><span class="n">sdio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dio_pages_present</span><span class="p">(</span><span class="n">sdio</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">dio_refill_pages</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="n">sdio</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dio_pages_present</span><span class="p">(</span><span class="n">sdio</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dio</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">++</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dio_complete() - called when all DIO BIO I/O has been completed</span>
<span class="cm"> * @offset: the byte offset in the file of the completed operation</span>
<span class="cm"> *</span>
<span class="cm"> * This releases locks as dictated by the locking type, lets interested parties</span>
<span class="cm"> * know that a DIO operation has completed, and calculates the resulting return</span>
<span class="cm"> * code for the operation.</span>
<span class="cm"> *</span>
<span class="cm"> * It lets the filesystem know if it registered an interest earlier via</span>
<span class="cm"> * get_block.  Pass the private field of the map buffer_head so that</span>
<span class="cm"> * filesystems can use it to hold additional state between get_block calls and</span>
<span class="cm"> * dio_complete.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">dio_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">dio</span> <span class="o">*</span><span class="n">dio</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">,</span> <span class="n">bool</span> <span class="n">is_async</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">transferred</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * AIO submission can race with bio completion to get here while</span>
<span class="cm">	 * expecting to have the last io completed by bio completion.</span>
<span class="cm">	 * In that case -EIOCBQUEUED is in fact not an error we want</span>
<span class="cm">	 * to preserve through this call.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIOCBQUEUED</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transferred</span> <span class="o">=</span> <span class="n">dio</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">;</span>

		<span class="cm">/* Check for short read case */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">rw</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">transferred</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">dio</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">))</span>
			<span class="n">transferred</span> <span class="o">=</span> <span class="n">dio</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dio</span><span class="o">-&gt;</span><span class="n">page_errors</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dio</span><span class="o">-&gt;</span><span class="n">io_error</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">transferred</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">end_io</span> <span class="o">&amp;&amp;</span> <span class="n">dio</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dio</span><span class="o">-&gt;</span><span class="n">end_io</span><span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">transferred</span><span class="p">,</span>
			    <span class="n">dio</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">is_async</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_async</span><span class="p">)</span>
			<span class="n">aio_complete</span><span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">inode_dio_done</span><span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">dio_bio_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">dio</span> <span class="o">*</span><span class="n">dio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * Asynchronous IO callback. </span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dio_bio_end_aio</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dio</span> <span class="o">*</span><span class="n">dio</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">remaining</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* cleanup the bio */</span>
	<span class="n">dio_bio_complete</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">remaining</span> <span class="o">=</span> <span class="o">--</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">dio</span><span class="o">-&gt;</span><span class="n">waiter</span><span class="p">)</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">waiter</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dio_complete</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="n">dio</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">dio_cache</span><span class="p">,</span> <span class="n">dio</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The BIO completion handler simply queues the BIO up for the process-context</span>
<span class="cm"> * handler.</span>
<span class="cm"> *</span>
<span class="cm"> * During I/O bi_private points at the dio.  After I/O, bi_private is used to</span>
<span class="cm"> * implement a singly-linked list of completed BIOs, at dio-&gt;bio_list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dio_bio_end_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dio</span> <span class="o">*</span><span class="n">dio</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_list</span><span class="p">;</span>
	<span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_list</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">refcount</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">dio</span><span class="o">-&gt;</span><span class="n">waiter</span><span class="p">)</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">waiter</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dio_end_io - handle the end io action for the given bio</span>
<span class="cm"> * @bio: The direct io bio thats being completed</span>
<span class="cm"> * @error: Error if there was one</span>
<span class="cm"> *</span>
<span class="cm"> * This is meant to be called by any filesystem that uses their own dio_submit_t</span>
<span class="cm"> * so that the DIO specific endio actions are dealt with after the filesystem</span>
<span class="cm"> * has done it&#39;s completion work.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dio_end_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dio</span> <span class="o">*</span><span class="n">dio</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">is_async</span><span class="p">)</span>
		<span class="n">dio_bio_end_aio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dio_bio_end_io</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dio_end_io</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">dio_bio_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">dio</span> <span class="o">*</span><span class="n">dio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dio_submit</span> <span class="o">*</span><span class="n">sdio</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
	      <span class="n">sector_t</span> <span class="n">first_sector</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_vecs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * bio_alloc() is guaranteed to return a bio when called with</span>
<span class="cm">	 * __GFP_WAIT and we request a valid number of vectors.</span>
<span class="cm">	 */</span>
	<span class="n">bio</span> <span class="o">=</span> <span class="n">bio_alloc</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">nr_vecs</span><span class="p">);</span>

	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">bdev</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">first_sector</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">is_async</span><span class="p">)</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">dio_bio_end_aio</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">dio_bio_end_io</span><span class="p">;</span>

	<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>
	<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">logical_offset_in_bio</span> <span class="o">=</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page_fs_offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * In the AIO read case we speculatively dirty the pages before starting IO.</span>
<span class="cm"> * During IO completion, any of these pages which happen to have been written</span>
<span class="cm"> * back will be redirtied by bio_check_pages_dirty().</span>
<span class="cm"> *</span>
<span class="cm"> * bios hold a dio reference between submit_bio and -&gt;end_io.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dio_bio_submit</span><span class="p">(</span><span class="k">struct</span> <span class="n">dio</span> <span class="o">*</span><span class="n">dio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dio_submit</span> <span class="o">*</span><span class="n">sdio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span> <span class="o">=</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">dio</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dio</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">is_async</span> <span class="o">&amp;&amp;</span> <span class="n">dio</span><span class="o">-&gt;</span><span class="n">rw</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span>
		<span class="n">bio_set_pages_dirty</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">submit_io</span><span class="p">)</span>
		<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">submit_io</span><span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">rw</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">dio</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">,</span>
			       <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">logical_offset_in_bio</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">submit_bio</span><span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">rw</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

	<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">boundary</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">logical_offset_in_bio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release any resources in case of a failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dio_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">dio</span> <span class="o">*</span><span class="n">dio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dio_submit</span> <span class="o">*</span><span class="n">sdio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">dio_pages_present</span><span class="p">(</span><span class="n">sdio</span><span class="p">))</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">dio_get_page</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="n">sdio</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wait for the next BIO to complete.  Remove it and return it.  NULL is</span>
<span class="cm"> * returned once all BIOs have been completed.  This must only be called once</span>
<span class="cm"> * all bios have been issued so that dio-&gt;refcount can only decrease.  This</span>
<span class="cm"> * requires that that the caller hold a reference on the dio.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="nf">dio_await_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">dio</span> <span class="o">*</span><span class="n">dio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait as long as the list is empty and there are bios in flight.  bio</span>
<span class="cm">	 * completion drops the count, maybe adds to the list, and wakes while</span>
<span class="cm">	 * holding the bio_lock so we don&#39;t need set_current_state()&#39;s barrier</span>
<span class="cm">	 * and can call it after testing our condition.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">refcount</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">dio</span><span class="o">-&gt;</span><span class="n">waiter</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">io_schedule</span><span class="p">();</span>
		<span class="cm">/* wake up sets us TASK_RUNNING */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">dio</span><span class="o">-&gt;</span><span class="n">waiter</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bio</span> <span class="o">=</span> <span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_list</span><span class="p">;</span>
		<span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_list</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bio</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process one completed BIO.  No locks are held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dio_bio_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">dio</span> <span class="o">*</span><span class="n">dio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">uptodate</span> <span class="o">=</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">BIO_UPTODATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">page_no</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uptodate</span><span class="p">)</span>
		<span class="n">dio</span><span class="o">-&gt;</span><span class="n">io_error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">is_async</span> <span class="o">&amp;&amp;</span> <span class="n">dio</span><span class="o">-&gt;</span><span class="n">rw</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bio_check_pages_dirty</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>	<span class="cm">/* transfers ownership */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">page_no</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">page_no</span> <span class="o">&lt;</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span><span class="p">;</span> <span class="n">page_no</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">bvec</span><span class="p">[</span><span class="n">page_no</span><span class="p">].</span><span class="n">bv_page</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">rw</span> <span class="o">==</span> <span class="n">READ</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">set_page_dirty_lock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">uptodate</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wait on and process all in-flight BIOs.  This must only be called once</span>
<span class="cm"> * all bios have been issued so that the refcount can only decrease.</span>
<span class="cm"> * This just waits for all bios to make it through dio_bio_complete.  IO</span>
<span class="cm"> * errors are propagated through dio-&gt;io_error and should be propagated via</span>
<span class="cm"> * dio_complete().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dio_await_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">dio</span> <span class="o">*</span><span class="n">dio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">bio</span> <span class="o">=</span> <span class="n">dio_await_one</span><span class="p">(</span><span class="n">dio</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="p">)</span>
			<span class="n">dio_bio_complete</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A really large O_DIRECT read or write can generate a lot of BIOs.  So</span>
<span class="cm"> * to keep the memory consumption sane we periodically reap any completed BIOs</span>
<span class="cm"> * during the BIO generation phase.</span>
<span class="cm"> *</span>
<span class="cm"> * This also helps to limit the peak amount of pinned userspace memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dio_bio_reap</span><span class="p">(</span><span class="k">struct</span> <span class="n">dio</span> <span class="o">*</span><span class="n">dio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dio_submit</span> <span class="o">*</span><span class="n">sdio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">reap_counter</span><span class="o">++</span> <span class="o">&gt;=</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">ret2</span><span class="p">;</span>

			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">bio</span> <span class="o">=</span> <span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_list</span><span class="p">;</span>
			<span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_list</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">ret2</span> <span class="o">=</span> <span class="n">dio_bio_complete</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">ret2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">reap_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Call into the fs to map some more disk blocks.  We record the current number</span>
<span class="cm"> * of available blocks at sdio-&gt;blocks_available.  These are in units of the</span>
<span class="cm"> * fs blocksize, (1 &lt;&lt; inode-&gt;i_blkbits).</span>
<span class="cm"> *</span>
<span class="cm"> * The fs is allowed to map lots of blocks at once.  If it wants to do that,</span>
<span class="cm"> * it uses the passed inode-relative block number as the file offset, as usual.</span>
<span class="cm"> *</span>
<span class="cm"> * get_block() is passed the number of i_blkbits-sized blocks which direct_io</span>
<span class="cm"> * has remaining to do.  The fs should not map more than this number of blocks.</span>
<span class="cm"> *</span>
<span class="cm"> * If the fs has mapped a lot of blocks, it should populate bh-&gt;b_size to</span>
<span class="cm"> * indicate how much contiguous disk space has been made available at</span>
<span class="cm"> * bh-&gt;b_blocknr.</span>
<span class="cm"> *</span>
<span class="cm"> * If *any* of the mapped blocks are new, then the fs must set buffer_new().</span>
<span class="cm"> * This isn&#39;t very efficient...</span>
<span class="cm"> *</span>
<span class="cm"> * In the case of filesystem holes: the fs may return an arbitrarily-large</span>
<span class="cm"> * hole by returning an appropriate value in b_size and by clearing</span>
<span class="cm"> * buffer_mapped().  However the direct-io code will only process holes one</span>
<span class="cm"> * block at a time - it will repeatedly call get_block() as it walks the hole.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_more_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">dio</span> <span class="o">*</span><span class="n">dio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dio_submit</span> <span class="o">*</span><span class="n">sdio</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">map_bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">fs_startblk</span><span class="p">;</span>	<span class="cm">/* Into file, in filesystem-sized blocks */</span>
	<span class="n">sector_t</span> <span class="n">fs_endblk</span><span class="p">;</span>	<span class="cm">/* Into file, in filesystem-sized blocks */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fs_count</span><span class="p">;</span>	<span class="cm">/* Number of filesystem-sized blocks */</span>
	<span class="kt">int</span> <span class="n">create</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there was a memory error and we&#39;ve overwritten all the</span>
<span class="cm">	 * mapped blocks then we can now return that memory error</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dio</span><span class="o">-&gt;</span><span class="n">page_errors</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">block_in_file</span> <span class="o">&gt;=</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">final_block_in_request</span><span class="p">);</span>
		<span class="n">fs_startblk</span> <span class="o">=</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">block_in_file</span> <span class="o">&gt;&gt;</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">blkfactor</span><span class="p">;</span>
		<span class="n">fs_endblk</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">final_block_in_request</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
					<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">blkfactor</span><span class="p">;</span>
		<span class="n">fs_count</span> <span class="o">=</span> <span class="n">fs_endblk</span> <span class="o">-</span> <span class="n">fs_startblk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">map_bh</span><span class="o">-&gt;</span><span class="n">b_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">map_bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">=</span> <span class="n">fs_count</span> <span class="o">&lt;&lt;</span> <span class="n">dio</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * For writes inside i_size on a DIO_SKIP_HOLES filesystem we</span>
<span class="cm">		 * forbid block creations: only overwrites are permitted.</span>
<span class="cm">		 * We will return early to the caller once we see an</span>
<span class="cm">		 * unmapped buffer head returned, and the caller will fall</span>
<span class="cm">		 * back to buffered I/O.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Otherwise the decision is left to the get_blocks method,</span>
<span class="cm">		 * which may decide to handle it or also return an unmapped</span>
<span class="cm">		 * buffer head.</span>
<span class="cm">		 */</span>
		<span class="n">create</span> <span class="o">=</span> <span class="n">dio</span><span class="o">-&gt;</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">WRITE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DIO_SKIP_HOLES</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">block_in_file</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
							<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">))</span>
				<span class="n">create</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">get_block</span><span class="p">)(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">,</span> <span class="n">fs_startblk</span><span class="p">,</span>
						<span class="n">map_bh</span><span class="p">,</span> <span class="n">create</span><span class="p">);</span>

		<span class="cm">/* Store for completion */</span>
		<span class="n">dio</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">map_bh</span><span class="o">-&gt;</span><span class="n">b_private</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * There is no bio.  Make one now.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dio_new_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">dio</span> <span class="o">*</span><span class="n">dio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dio_submit</span> <span class="o">*</span><span class="n">sdio</span><span class="p">,</span>
		<span class="n">sector_t</span> <span class="n">start_sector</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">map_bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sector_t</span> <span class="n">sector</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">dio_bio_reap</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="n">sdio</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">sector</span> <span class="o">=</span> <span class="n">start_sector</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">blkbits</span> <span class="o">-</span> <span class="mi">9</span><span class="p">);</span>
	<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">pages_in_io</span><span class="p">,</span> <span class="n">bio_get_nr_vecs</span><span class="p">(</span><span class="n">map_bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">));</span>
	<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">nr_pages</span><span class="p">,</span> <span class="n">BIO_MAX_PAGES</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">nr_pages</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">dio_bio_alloc</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="n">sdio</span><span class="p">,</span> <span class="n">map_bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">,</span> <span class="n">sector</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>
	<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">boundary</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Attempt to put the current chunk of &#39;cur_page&#39; into the current BIO.  If</span>
<span class="cm"> * that was successful then update final_block_in_bio and take a ref against</span>
<span class="cm"> * the just-added page.</span>
<span class="cm"> *</span>
<span class="cm"> * Return zero on success.  Non-zero means the caller needs to start a new BIO.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dio_bio_add_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">dio_submit</span> <span class="o">*</span><span class="n">sdio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">bio_add_page</span><span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">,</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page</span><span class="p">,</span>
			<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page_len</span><span class="p">,</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page_offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Decrement count only, if we are done with this page</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page_len</span> <span class="o">+</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page_offset</span><span class="p">)</span> <span class="o">==</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
			<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">pages_in_io</span><span class="o">--</span><span class="p">;</span>
		<span class="n">page_cache_get</span><span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page</span><span class="p">);</span>
		<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">final_block_in_bio</span> <span class="o">=</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page_block</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page_len</span> <span class="o">&gt;&gt;</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
		
<span class="cm">/*</span>
<span class="cm"> * Put cur_page under IO.  The section of cur_page which is described by</span>
<span class="cm"> * cur_page_offset,cur_page_len is put into a BIO.  The section of cur_page</span>
<span class="cm"> * starts on-disk at cur_page_block.</span>
<span class="cm"> *</span>
<span class="cm"> * We take a ref against the page here (on behalf of its presence in the bio).</span>
<span class="cm"> *</span>
<span class="cm"> * The caller of this function is responsible for removing cur_page from the</span>
<span class="cm"> * dio, and for dropping the refcount which came from that presence.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dio_send_cur_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">dio</span> <span class="o">*</span><span class="n">dio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dio_submit</span> <span class="o">*</span><span class="n">sdio</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">map_bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">loff_t</span> <span class="n">cur_offset</span> <span class="o">=</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page_fs_offset</span><span class="p">;</span>
		<span class="n">loff_t</span> <span class="n">bio_next_offset</span> <span class="o">=</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">logical_offset_in_bio</span> <span class="o">+</span>
			<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * See whether this new request is contiguous with the old.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Btrfs cannot handle having logically non-contiguous requests</span>
<span class="cm">		 * submitted.  For example if you have</span>
<span class="cm">		 *</span>
<span class="cm">		 * Logical:  [0-4095][HOLE][8192-12287]</span>
<span class="cm">		 * Physical: [0-4095]      [4096-8191]</span>
<span class="cm">		 *</span>
<span class="cm">		 * We cannot submit those pages together as one BIO.  So if our</span>
<span class="cm">		 * current logical offset in the file does not equal what would</span>
<span class="cm">		 * be the next logical offset in the bio, submit the bio we</span>
<span class="cm">		 * have.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">final_block_in_bio</span> <span class="o">!=</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page_block</span> <span class="o">||</span>
		    <span class="n">cur_offset</span> <span class="o">!=</span> <span class="n">bio_next_offset</span><span class="p">)</span>
			<span class="n">dio_bio_submit</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="n">sdio</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Submit now if the underlying fs is about to perform a</span>
<span class="cm">		 * metadata read</span>
<span class="cm">		 */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">boundary</span><span class="p">)</span>
			<span class="n">dio_bio_submit</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="n">sdio</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">bio</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dio_new_bio</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="n">sdio</span><span class="p">,</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page_block</span><span class="p">,</span> <span class="n">map_bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dio_bio_add_page</span><span class="p">(</span><span class="n">sdio</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dio_bio_submit</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="n">sdio</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dio_new_bio</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="n">sdio</span><span class="p">,</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page_block</span><span class="p">,</span> <span class="n">map_bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">dio_bio_add_page</span><span class="p">(</span><span class="n">sdio</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * An autonomous function to put a chunk of a page under deferred IO.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller doesn&#39;t actually know (or care) whether this piece of page is in</span>
<span class="cm"> * a BIO, or is under IO or whatever.  We just take care of all possible </span>
<span class="cm"> * situations here.  The separation between the logic of do_direct_IO() and</span>
<span class="cm"> * that of submit_page_section() is important for clarity.  Please don&#39;t break.</span>
<span class="cm"> *</span>
<span class="cm"> * The chunk of page starts on-disk at blocknr.</span>
<span class="cm"> *</span>
<span class="cm"> * We perform deferred IO, by recording the last-submitted page inside our</span>
<span class="cm"> * private part of the dio structure.  If possible, we just expand the IO</span>
<span class="cm"> * across that page here.</span>
<span class="cm"> *</span>
<span class="cm"> * If that doesn&#39;t work out then we put the old page into the bio and add this</span>
<span class="cm"> * page to the dio instead.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">submit_page_section</span><span class="p">(</span><span class="k">struct</span> <span class="n">dio</span> <span class="o">*</span><span class="n">dio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dio_submit</span> <span class="o">*</span><span class="n">sdio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">blocknr</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">map_bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Read accounting is performed in submit_bio()</span>
<span class="cm">		 */</span>
		<span class="n">task_io_account_write</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Can we just grow the current page&#39;s presence in the dio?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page</span> <span class="o">==</span> <span class="n">page</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page_offset</span> <span class="o">+</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page_len</span> <span class="o">==</span> <span class="n">offset</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page_block</span> <span class="o">+</span>
	    <span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page_len</span> <span class="o">&gt;&gt;</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">)</span> <span class="o">==</span> <span class="n">blocknr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page_len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If sdio-&gt;boundary then we want to schedule the IO now to</span>
<span class="cm">		 * avoid metadata seeks.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">boundary</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">dio_send_cur_page</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="n">sdio</span><span class="p">,</span> <span class="n">map_bh</span><span class="p">);</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page</span><span class="p">);</span>
			<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there&#39;s a deferred page already there then send it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dio_send_cur_page</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="n">sdio</span><span class="p">,</span> <span class="n">map_bh</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page</span><span class="p">);</span>
		<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">page_cache_get</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>		<span class="cm">/* It is in dio */</span>
	<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page_block</span> <span class="o">=</span> <span class="n">blocknr</span><span class="p">;</span>
	<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">cur_page_fs_offset</span> <span class="o">=</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">block_in_file</span> <span class="o">&lt;&lt;</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clean any dirty buffers in the blockdev mapping which alias newly-created</span>
<span class="cm"> * file blocks.  Only called for S_ISREG files - blockdevs do not set</span>
<span class="cm"> * buffer_new</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">clean_blockdev_aliases</span><span class="p">(</span><span class="k">struct</span> <span class="n">dio</span> <span class="o">*</span><span class="n">dio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">map_bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">nblocks</span><span class="p">;</span>

	<span class="n">nblocks</span> <span class="o">=</span> <span class="n">map_bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">&gt;&gt;</span> <span class="n">dio</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nblocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unmap_underlying_metadata</span><span class="p">(</span><span class="n">map_bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">,</span>
					  <span class="n">map_bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If we are not writing the entire block and get_block() allocated</span>
<span class="cm"> * the block for us, we need to fill-in the unused portion of the</span>
<span class="cm"> * block with zeros. This happens only if user-buffer, fileoffset or</span>
<span class="cm"> * io length is not filesystem block-size multiple.</span>
<span class="cm"> *</span>
<span class="cm"> * `end&#39; is zero if we&#39;re doing the start of the IO, 1 at the end of the</span>
<span class="cm"> * IO.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dio_zero_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">dio</span> <span class="o">*</span><span class="n">dio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dio_submit</span> <span class="o">*</span><span class="n">sdio</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">end</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">map_bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">dio_blocks_per_fs_block</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">this_chunk_blocks</span><span class="p">;</span>	<span class="cm">/* In dio_blocks */</span>
	<span class="kt">unsigned</span> <span class="n">this_chunk_bytes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">start_zero_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">blkfactor</span> <span class="o">||</span> <span class="o">!</span><span class="n">buffer_new</span><span class="p">(</span><span class="n">map_bh</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dio_blocks_per_fs_block</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">blkfactor</span><span class="p">;</span>
	<span class="n">this_chunk_blocks</span> <span class="o">=</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">block_in_file</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dio_blocks_per_fs_block</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this_chunk_blocks</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to zero out part of an fs block.  It is either at the</span>
<span class="cm">	 * beginning or the end of the fs block.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span><span class="p">)</span> 
		<span class="n">this_chunk_blocks</span> <span class="o">=</span> <span class="n">dio_blocks_per_fs_block</span> <span class="o">-</span> <span class="n">this_chunk_blocks</span><span class="p">;</span>

	<span class="n">this_chunk_bytes</span> <span class="o">=</span> <span class="n">this_chunk_blocks</span> <span class="o">&lt;&lt;</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">ZERO_PAGE</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">submit_page_section</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="n">sdio</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">this_chunk_bytes</span><span class="p">,</span>
				<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">next_block_for_io</span><span class="p">,</span> <span class="n">map_bh</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">next_block_for_io</span> <span class="o">+=</span> <span class="n">this_chunk_blocks</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Walk the user pages, and the file, mapping blocks to disk and generating</span>
<span class="cm"> * a sequence of (page,offset,len,block) mappings.  These mappings are injected</span>
<span class="cm"> * into submit_page_section(), which takes care of the next stage of submission</span>
<span class="cm"> *</span>
<span class="cm"> * Direct IO against a blockdev is different from a file.  Because we can</span>
<span class="cm"> * happily perform page-sized but 512-byte aligned IOs.  It is important that</span>
<span class="cm"> * blockdev IO be able to have fine alignment and large sizes.</span>
<span class="cm"> *</span>
<span class="cm"> * So what we do is to permit the -&gt;get_block function to populate bh.b_size</span>
<span class="cm"> * with the size of IO which is permitted at this offset and this i_blkbits.</span>
<span class="cm"> *</span>
<span class="cm"> * For best results, the blockdev should be set up with 512-byte i_blkbits and</span>
<span class="cm"> * it should set b_size to PAGE_SIZE or more inside get_block().  This gives</span>
<span class="cm"> * fine alignment but still allows this function to work in PAGE_SIZE units.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_direct_IO</span><span class="p">(</span><span class="k">struct</span> <span class="n">dio</span> <span class="o">*</span><span class="n">dio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dio_submit</span> <span class="o">*</span><span class="n">sdio</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">map_bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">blkbits</span> <span class="o">=</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">blocks_per_page</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">block_in_page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* The I/O can start at any block offset within the first page */</span>
	<span class="n">block_in_page</span> <span class="o">=</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">first_block_in_page</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">block_in_file</span> <span class="o">&lt;</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">final_block_in_request</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">dio_get_page</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="n">sdio</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">block_in_page</span> <span class="o">&lt;</span> <span class="n">blocks_per_page</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="n">offset_in_page</span> <span class="o">=</span> <span class="n">block_in_page</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="n">this_chunk_bytes</span><span class="p">;</span>	<span class="cm">/* # of bytes mapped */</span>
			<span class="kt">unsigned</span> <span class="n">this_chunk_blocks</span><span class="p">;</span>	<span class="cm">/* # of blocks */</span>
			<span class="kt">unsigned</span> <span class="n">u</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">blocks_available</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Need to go and map some more disk</span>
<span class="cm">				 */</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">blkmask</span><span class="p">;</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dio_remainder</span><span class="p">;</span>

				<span class="n">ret</span> <span class="o">=</span> <span class="n">get_more_blocks</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="n">sdio</span><span class="p">,</span> <span class="n">map_bh</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">map_bh</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">do_holes</span><span class="p">;</span>

				<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">blocks_available</span> <span class="o">=</span>
						<span class="n">map_bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">&gt;&gt;</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">blkbits</span><span class="p">;</span>
				<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">next_block_for_io</span> <span class="o">=</span>
					<span class="n">map_bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">&lt;&lt;</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">blkfactor</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">buffer_new</span><span class="p">(</span><span class="n">map_bh</span><span class="p">))</span>
					<span class="n">clean_blockdev_aliases</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="n">map_bh</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">blkfactor</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">do_holes</span><span class="p">;</span>

				<span class="n">blkmask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">blkfactor</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">dio_remainder</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">block_in_file</span> <span class="o">&amp;</span> <span class="n">blkmask</span><span class="p">);</span>

				<span class="cm">/*</span>
<span class="cm">				 * If we are at the start of IO and that IO</span>
<span class="cm">				 * starts partway into a fs-block,</span>
<span class="cm">				 * dio_remainder will be non-zero.  If the IO</span>
<span class="cm">				 * is a read then we can simply advance the IO</span>
<span class="cm">				 * cursor to the first block which is to be</span>
<span class="cm">				 * read.  But if the IO is a write and the</span>
<span class="cm">				 * block was newly allocated we cannot do that;</span>
<span class="cm">				 * the start of the fs block must be zeroed out</span>
<span class="cm">				 * on-disk</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_new</span><span class="p">(</span><span class="n">map_bh</span><span class="p">))</span>
					<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">next_block_for_io</span> <span class="o">+=</span> <span class="n">dio_remainder</span><span class="p">;</span>
				<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">blocks_available</span> <span class="o">-=</span> <span class="n">dio_remainder</span><span class="p">;</span>
			<span class="p">}</span>
<span class="nl">do_holes:</span>
			<span class="cm">/* Handle holes */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">map_bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">loff_t</span> <span class="n">i_size_aligned</span><span class="p">;</span>

				<span class="cm">/* AKPM: eargh, -ENOTBLK is a hack */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">WRITE</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">ENOTBLK</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/*</span>
<span class="cm">				 * Be sure to account for a partial block as the</span>
<span class="cm">				 * last block in the file</span>
<span class="cm">				 */</span>
				<span class="n">i_size_aligned</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">),</span>
							<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">block_in_file</span> <span class="o">&gt;=</span>
						<span class="n">i_size_aligned</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* We hit eof */</span>
					<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">zero_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">block_in_page</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">,</span>
						<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">);</span>
				<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">block_in_file</span><span class="o">++</span><span class="p">;</span>
				<span class="n">block_in_page</span><span class="o">++</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">next_block</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * If we&#39;re performing IO which has an alignment which</span>
<span class="cm">			 * is finer than the underlying fs, go check to see if</span>
<span class="cm">			 * we must zero out the start of this block.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">blkfactor</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">start_zero_done</span><span class="p">))</span>
				<span class="n">dio_zero_block</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="n">sdio</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">map_bh</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Work out, in this_chunk_blocks, how much disk we</span>
<span class="cm">			 * can add to this page</span>
<span class="cm">			 */</span>
			<span class="n">this_chunk_blocks</span> <span class="o">=</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">blocks_available</span><span class="p">;</span>
			<span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">offset_in_page</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">this_chunk_blocks</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">)</span>
				<span class="n">this_chunk_blocks</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
			<span class="n">u</span> <span class="o">=</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">final_block_in_request</span> <span class="o">-</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">block_in_file</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">this_chunk_blocks</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">)</span>
				<span class="n">this_chunk_blocks</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
			<span class="n">this_chunk_bytes</span> <span class="o">=</span> <span class="n">this_chunk_blocks</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">;</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">this_chunk_bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

			<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">boundary</span> <span class="o">=</span> <span class="n">buffer_boundary</span><span class="p">(</span><span class="n">map_bh</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">submit_page_section</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="n">sdio</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
						  <span class="n">offset_in_page</span><span class="p">,</span>
						  <span class="n">this_chunk_bytes</span><span class="p">,</span>
						  <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">next_block_for_io</span><span class="p">,</span>
						  <span class="n">map_bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">next_block_for_io</span> <span class="o">+=</span> <span class="n">this_chunk_blocks</span><span class="p">;</span>

			<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">block_in_file</span> <span class="o">+=</span> <span class="n">this_chunk_blocks</span><span class="p">;</span>
			<span class="n">block_in_page</span> <span class="o">+=</span> <span class="n">this_chunk_blocks</span><span class="p">;</span>
			<span class="n">sdio</span><span class="o">-&gt;</span><span class="n">blocks_available</span> <span class="o">-=</span> <span class="n">this_chunk_blocks</span><span class="p">;</span>
<span class="nl">next_block:</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">block_in_file</span> <span class="o">&gt;</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">final_block_in_request</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sdio</span><span class="o">-&gt;</span><span class="n">block_in_file</span> <span class="o">==</span> <span class="n">sdio</span><span class="o">-&gt;</span><span class="n">final_block_in_request</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Drop the ref which was taken in get_user_pages() */</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">block_in_page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">drop_refcount</span><span class="p">(</span><span class="k">struct</span> <span class="n">dio</span> <span class="o">*</span><span class="n">dio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sync will always be dropping the final ref and completing the</span>
<span class="cm">	 * operation.  AIO can if it was a broken operation described above or</span>
<span class="cm">	 * in fact if all the bios race to complete before we get here.  In</span>
<span class="cm">	 * that case dio_complete() translates the EIOCBQUEUED into the proper</span>
<span class="cm">	 * return code that the caller will hand to aio_complete().</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is managed by the bio_lock instead of being an atomic_t so that</span>
<span class="cm">	 * completion paths can drop their ref and use the remaining count to</span>
<span class="cm">	 * decide to wake the submission path atomically.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret2</span> <span class="o">=</span> <span class="o">--</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is a library function for use by filesystem drivers.</span>
<span class="cm"> *</span>
<span class="cm"> * The locking rules are governed by the flags parameter:</span>
<span class="cm"> *  - if the flags value contains DIO_LOCKING we use a fancy locking</span>
<span class="cm"> *    scheme for dumb filesystems.</span>
<span class="cm"> *    For writes this function is called under i_mutex and returns with</span>
<span class="cm"> *    i_mutex held, for reads, i_mutex is not held on entry, but it is</span>
<span class="cm"> *    taken and dropped again before returning.</span>
<span class="cm"> *  - if the flags value does NOT contain DIO_LOCKING we don&#39;t use any</span>
<span class="cm"> *    internal locking but rather rely on the filesystem to synchronize</span>
<span class="cm"> *    direct I/O reads/writes versus each other and truncate.</span>
<span class="cm"> *</span>
<span class="cm"> * To help with locking against truncate we incremented the i_dio_count</span>
<span class="cm"> * counter before starting direct I/O, and decrement it once we are done.</span>
<span class="cm"> * Truncate can wait for it to reach zero to provide exclusion.  It is</span>
<span class="cm"> * expected that filesystem provide exclusion between new direct I/O</span>
<span class="cm"> * and truncates.  For DIO_LOCKING filesystems this is done by i_mutex,</span>
<span class="cm"> * but other filesystems need to take care of this on their own.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: if you pass &quot;sdio&quot; to anything by pointer make sure that function</span>
<span class="cm"> * is always inlined. Otherwise gcc is unable to split the structure into</span>
<span class="cm"> * individual fields and will generate much worse code. This is important</span>
<span class="cm"> * for the whole file.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">ssize_t</span>
<span class="nf">do_blockdev_direct_IO</span><span class="p">(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> 
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="n">get_block</span><span class="p">,</span> <span class="n">dio_iodone_t</span> <span class="n">end_io</span><span class="p">,</span>
	<span class="n">dio_submit_t</span> <span class="n">submit_io</span><span class="p">,</span>	<span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">seg</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blkbits</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blocksize_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dio</span> <span class="o">*</span><span class="n">dio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dio_submit</span> <span class="n">sdio</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">user_addr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="n">map_bh</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">WRITE</span><span class="p">)</span>
		<span class="n">rw</span> <span class="o">=</span> <span class="n">WRITE_ODIRECT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Avoid references to bdev if not absolutely needed to give</span>
<span class="cm">	 * the early prefetch in the caller enough time.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="n">blocksize_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bdev</span><span class="p">)</span>
			<span class="n">blkbits</span> <span class="o">=</span> <span class="n">blksize_bits</span><span class="p">(</span><span class="n">bdev_logical_block_size</span><span class="p">(</span><span class="n">bdev</span><span class="p">));</span>
		<span class="n">blocksize_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="n">blocksize_mask</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check the memory alignment.  Blocks cannot straddle pages */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">seg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">seg</span> <span class="o">&lt;</span> <span class="n">nr_segs</span><span class="p">;</span> <span class="n">seg</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">iov</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">iov_base</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">iov</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">iov_len</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="n">blocksize_mask</span><span class="p">)</span> <span class="o">||</span>
			     <span class="p">(</span><span class="n">size</span> <span class="o">&amp;</span> <span class="n">blocksize_mask</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bdev</span><span class="p">)</span>
				<span class="n">blkbits</span> <span class="o">=</span> <span class="n">blksize_bits</span><span class="p">(</span>
					 <span class="n">bdev_logical_block_size</span><span class="p">(</span><span class="n">bdev</span><span class="p">));</span>
			<span class="n">blocksize_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="n">blocksize_mask</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">size</span> <span class="o">&amp;</span> <span class="n">blocksize_mask</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* watch out for a 0 len io from a tricksy fs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">READ</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">==</span> <span class="n">offset</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dio</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">dio_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dio</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Believe it or not, zeroing out the page array caused a .5%</span>
<span class="cm">	 * performance regression in a database benchmark.  So, we take</span>
<span class="cm">	 * care to only zero out what&#39;s needed.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dio</span><span class="p">,</span> <span class="n">pages</span><span class="p">));</span>

	<span class="n">dio</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DIO_LOCKING</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span>
					<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>

			<span class="cm">/* will be released by direct_io_worker */</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

			<span class="n">retval</span> <span class="o">=</span> <span class="n">filemap_write_and_wait_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
							      <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
				<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">dio_cache</span><span class="p">,</span> <span class="n">dio</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Will be decremented at I/O completion time.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_dio_count</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * For file extending writes updating i_size before data</span>
<span class="cm">	 * writeouts complete can expose uninitialized blocks. So</span>
<span class="cm">	 * even for AIO, we need to wait for i/o to complete before</span>
<span class="cm">	 * returning in this case.</span>
<span class="cm">	 */</span>
	<span class="n">dio</span><span class="o">-&gt;</span><span class="n">is_async</span> <span class="o">=</span> <span class="o">!</span><span class="n">is_sync_kiocb</span><span class="p">(</span><span class="n">iocb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">((</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">)));</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dio</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>
	<span class="n">dio</span><span class="o">-&gt;</span><span class="n">rw</span> <span class="o">=</span> <span class="n">rw</span><span class="p">;</span>
	<span class="n">sdio</span><span class="p">.</span><span class="n">blkbits</span> <span class="o">=</span> <span class="n">blkbits</span><span class="p">;</span>
	<span class="n">sdio</span><span class="p">.</span><span class="n">blkfactor</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span> <span class="o">-</span> <span class="n">blkbits</span><span class="p">;</span>
	<span class="n">sdio</span><span class="p">.</span><span class="n">block_in_file</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">;</span>

	<span class="n">sdio</span><span class="p">.</span><span class="n">get_block</span> <span class="o">=</span> <span class="n">get_block</span><span class="p">;</span>
	<span class="n">dio</span><span class="o">-&gt;</span><span class="n">end_io</span> <span class="o">=</span> <span class="n">end_io</span><span class="p">;</span>
	<span class="n">sdio</span><span class="p">.</span><span class="n">submit_io</span> <span class="o">=</span> <span class="n">submit_io</span><span class="p">;</span>
	<span class="n">sdio</span><span class="p">.</span><span class="n">final_block_in_bio</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">sdio</span><span class="p">.</span><span class="n">next_block_for_io</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">dio</span><span class="o">-&gt;</span><span class="n">iocb</span> <span class="o">=</span> <span class="n">iocb</span><span class="p">;</span>
	<span class="n">dio</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">bio_lock</span><span class="p">);</span>
	<span class="n">dio</span><span class="o">-&gt;</span><span class="n">refcount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In case of non-aligned buffers, we may need 2 more</span>
<span class="cm">	 * pages since we need to zero out first and last block.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sdio</span><span class="p">.</span><span class="n">blkfactor</span><span class="p">))</span>
		<span class="n">sdio</span><span class="p">.</span><span class="n">pages_in_io</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">seg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">seg</span> <span class="o">&lt;</span> <span class="n">nr_segs</span><span class="p">;</span> <span class="n">seg</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">user_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">iov</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">iov_base</span><span class="p">;</span>
		<span class="n">sdio</span><span class="p">.</span><span class="n">pages_in_io</span> <span class="o">+=</span>
			<span class="p">((</span><span class="n">user_addr</span> <span class="o">+</span> <span class="n">iov</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span>
				<span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">user_addr</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">seg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">seg</span> <span class="o">&lt;</span> <span class="n">nr_segs</span><span class="p">;</span> <span class="n">seg</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">user_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">iov</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">iov_base</span><span class="p">;</span>
		<span class="n">sdio</span><span class="p">.</span><span class="n">size</span> <span class="o">+=</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">iov</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">iov_len</span><span class="p">;</span>

		<span class="cm">/* Index into the first page of the first block */</span>
		<span class="n">sdio</span><span class="p">.</span><span class="n">first_block_in_page</span> <span class="o">=</span> <span class="p">(</span><span class="n">user_addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">;</span>
		<span class="n">sdio</span><span class="p">.</span><span class="n">final_block_in_request</span> <span class="o">=</span> <span class="n">sdio</span><span class="p">.</span><span class="n">block_in_file</span> <span class="o">+</span>
						<span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">);</span>
		<span class="cm">/* Page fetching state */</span>
		<span class="n">sdio</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sdio</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sdio</span><span class="p">.</span><span class="n">curr_page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">sdio</span><span class="p">.</span><span class="n">total_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">user_addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sdio</span><span class="p">.</span><span class="n">total_pages</span><span class="o">++</span><span class="p">;</span>
			<span class="n">bytes</span> <span class="o">-=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="p">(</span><span class="n">user_addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">sdio</span><span class="p">.</span><span class="n">total_pages</span> <span class="o">+=</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">sdio</span><span class="p">.</span><span class="n">curr_user_address</span> <span class="o">=</span> <span class="n">user_addr</span><span class="p">;</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">do_direct_IO</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdio</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map_bh</span><span class="p">);</span>

		<span class="n">dio</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">+=</span> <span class="n">iov</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">-</span>
			<span class="p">((</span><span class="n">sdio</span><span class="p">.</span><span class="n">final_block_in_request</span> <span class="o">-</span> <span class="n">sdio</span><span class="p">.</span><span class="n">block_in_file</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
					<span class="n">blkbits</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dio_cleanup</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdio</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="cm">/* end iovec loop */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOTBLK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The remaining part of the request will be</span>
<span class="cm">		 * be handled by buffered I/O when we return</span>
<span class="cm">		 */</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * There may be some unwritten disk at the end of a part-written</span>
<span class="cm">	 * fs-block-sized block.  Go zero that now.</span>
<span class="cm">	 */</span>
	<span class="n">dio_zero_block</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdio</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map_bh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdio</span><span class="p">.</span><span class="n">cur_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">ssize_t</span> <span class="n">ret2</span><span class="p">;</span>

		<span class="n">ret2</span> <span class="o">=</span> <span class="n">dio_send_cur_page</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdio</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map_bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">ret2</span><span class="p">;</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">sdio</span><span class="p">.</span><span class="n">cur_page</span><span class="p">);</span>
		<span class="n">sdio</span><span class="p">.</span><span class="n">cur_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdio</span><span class="p">.</span><span class="n">bio</span><span class="p">)</span>
		<span class="n">dio_bio_submit</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdio</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * It is possible that, we return short IO due to end of file.</span>
<span class="cm">	 * In that case, we need to release all the pages we got hold on.</span>
<span class="cm">	 */</span>
	<span class="n">dio_cleanup</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdio</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * All block lookups have been performed. For READ requests</span>
<span class="cm">	 * we can let i_mutex go now that its achieved its purpose</span>
<span class="cm">	 * of protecting us from looking up uninitialized blocks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">READ</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DIO_LOCKING</span><span class="p">))</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The only time we want to leave bios in flight is when a successful</span>
<span class="cm">	 * partial aio read or full aio write have been setup.  In that case</span>
<span class="cm">	 * bio completion will call aio_complete.  The only time it&#39;s safe to</span>
<span class="cm">	 * call aio_complete is when we return -EIOCBQUEUED, so we key on that.</span>
<span class="cm">	 * This had *better* be the only place that raises -EIOCBQUEUED.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIOCBQUEUED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">is_async</span> <span class="o">&amp;&amp;</span> <span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dio</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">READ</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">dio</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="n">sdio</span><span class="p">.</span><span class="n">size</span><span class="p">)))</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIOCBQUEUED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EIOCBQUEUED</span><span class="p">)</span>
		<span class="n">dio_await_completion</span><span class="p">(</span><span class="n">dio</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drop_refcount</span><span class="p">(</span><span class="n">dio</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">dio_complete</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">retval</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">dio_cache</span><span class="p">,</span> <span class="n">dio</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EIOCBQUEUED</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">ssize_t</span>
<span class="nf">__blockdev_direct_IO</span><span class="p">(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="n">get_block</span><span class="p">,</span> <span class="n">dio_iodone_t</span> <span class="n">end_io</span><span class="p">,</span>
	<span class="n">dio_submit_t</span> <span class="n">submit_io</span><span class="p">,</span>	<span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The block device state is needed in the end to finally</span>
<span class="cm">	 * submit everything.  Since it&#39;s likely to be cache cold</span>
<span class="cm">	 * prefetch it here as first thing to hide some of the</span>
<span class="cm">	 * latency.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Attempt to prefetch the pieces we likely need later.</span>
<span class="cm">	 */</span>
	<span class="n">prefetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="o">-&gt;</span><span class="n">part_tbl</span><span class="p">);</span>
	<span class="n">prefetch</span><span class="p">(</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_queue</span><span class="p">);</span>
	<span class="n">prefetch</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_queue</span> <span class="o">+</span> <span class="n">SMP_CACHE_BYTES</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">do_blockdev_direct_IO</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">bdev</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
				     <span class="n">nr_segs</span><span class="p">,</span> <span class="n">get_block</span><span class="p">,</span> <span class="n">end_io</span><span class="p">,</span>
				     <span class="n">submit_io</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__blockdev_direct_IO</span><span class="p">);</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">dio_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dio_cache</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">dio</span><span class="p">,</span> <span class="n">SLAB_PANIC</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">dio_init</span><span class="p">)</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
