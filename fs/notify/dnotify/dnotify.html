<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › notify › dnotify › dnotify.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>dnotify.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Directory notifications for Linux.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2000,2001,2002 Stephen Rothwell</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2009 Eric Paris &lt;Red Hat Inc&gt;</span>
<span class="cm"> * dnotify was largly rewritten to use the new fsnotify infrastructure</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; either version 2, or (at your option) any</span>
<span class="cm"> * later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/dnotify.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/fdtable.h&gt;</span>
<span class="cp">#include &lt;linux/fsnotify_backend.h&gt;</span>

<span class="kt">int</span> <span class="n">dir_notify_enable</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">dnotify_struct_cache</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">dnotify_mark_cache</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">dnotify_group</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">dnotify_mark_mutex</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * dnotify will attach one of these to each inode (i_fsnotify_marks) which</span>
<span class="cm"> * is being watched by dnotify.  If multiple userspace applications are watching</span>
<span class="cm"> * the same directory with dnotify their information is chained in dn</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dnotify_mark</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="n">fsn_mark</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dnotify_struct</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * When a process starts or stops watching an inode the set of events which</span>
<span class="cm"> * dnotify cares about for that inode may change.  This function runs the</span>
<span class="cm"> * list of everything receiving dnotify events about this directory and calculates</span>
<span class="cm"> * the set of all those events.  After it updates what dnotify is interested in</span>
<span class="cm"> * it calls the fsnotify function so it can update the set of all events relevant</span>
<span class="cm"> * to this inode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dnotify_recalc_inode_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">fsn_mark</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="n">new_mask</span><span class="p">,</span> <span class="n">old_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dnotify_struct</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dnotify_mark</span> <span class="o">*</span><span class="n">dn_mark</span>  <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">fsn_mark</span><span class="p">,</span>
						     <span class="k">struct</span> <span class="n">dnotify_mark</span><span class="p">,</span>
						     <span class="n">fsn_mark</span><span class="p">);</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsn_mark</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">old_mask</span> <span class="o">=</span> <span class="n">fsn_mark</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">new_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">dn</span> <span class="o">=</span> <span class="n">dn_mark</span><span class="o">-&gt;</span><span class="n">dn</span><span class="p">;</span> <span class="n">dn</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">dn</span> <span class="o">=</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">dn_next</span><span class="p">)</span>
		<span class="n">new_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">dn_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FS_DN_MULTISHOT</span><span class="p">);</span>
	<span class="n">fsnotify_set_mark_mask_locked</span><span class="p">(</span><span class="n">fsn_mark</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_mask</span> <span class="o">==</span> <span class="n">new_mask</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fsn_mark</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">.</span><span class="n">inode</span><span class="p">)</span>
		<span class="n">fsnotify_recalc_inode_mask</span><span class="p">(</span><span class="n">fsn_mark</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">.</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Mains fsnotify call where events are delivered to dnotify.</span>
<span class="cm"> * Find the dnotify mark on the relevant inode, run the list of dnotify structs</span>
<span class="cm"> * on that mark and determine which of them has expressed interest in receiving</span>
<span class="cm"> * events of this type.  When found send the correct process and signal and</span>
<span class="cm"> * destroy the dnotify struct if it was not registered to receive multiple</span>
<span class="cm"> * events.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dnotify_handle_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">inode_mark</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">vfsmount_mark</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">fsnotify_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dnotify_mark</span> <span class="o">*</span><span class="n">dn_mark</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">to_tell</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dnotify_struct</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dnotify_struct</span> <span class="o">**</span><span class="n">prev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fown_struct</span> <span class="o">*</span><span class="n">fown</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">test_mask</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FS_EVENT_ON_CHILD</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">vfsmount_mark</span><span class="p">);</span>

	<span class="n">to_tell</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">to_tell</span><span class="p">;</span>

	<span class="n">dn_mark</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">inode_mark</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dnotify_mark</span><span class="p">,</span> <span class="n">fsn_mark</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_mark</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dn_mark</span><span class="o">-&gt;</span><span class="n">dn</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">dn</span> <span class="o">=</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">dn_mask</span> <span class="o">&amp;</span> <span class="n">test_mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">dn_next</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">fown</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">dn_filp</span><span class="o">-&gt;</span><span class="n">f_owner</span><span class="p">;</span>
		<span class="n">send_sigio</span><span class="p">(</span><span class="n">fown</span><span class="p">,</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">dn_fd</span><span class="p">,</span> <span class="n">POLL_MSG</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">dn_mask</span> <span class="o">&amp;</span> <span class="n">FS_DN_MULTISHOT</span><span class="p">)</span>
			<span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">dn_next</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">dn_next</span><span class="p">;</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">dnotify_struct_cache</span><span class="p">,</span> <span class="n">dn</span><span class="p">);</span>
			<span class="n">dnotify_recalc_inode_mask</span><span class="p">(</span><span class="n">inode_mark</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_mark</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Given an inode and mask determine if dnotify would be interested in sending</span>
<span class="cm"> * userspace notification for that pair.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">dnotify_should_send_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">group</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">inode_mark</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">vfsmount_mark</span><span class="p">,</span>
				      <span class="n">__u32</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* not a dir, dnotify doesn&#39;t care */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dnotify_free_mark</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">fsn_mark</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dnotify_mark</span> <span class="o">*</span><span class="n">dn_mark</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">fsn_mark</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">dnotify_mark</span><span class="p">,</span>
						    <span class="n">fsn_mark</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dn_mark</span><span class="o">-&gt;</span><span class="n">dn</span><span class="p">);</span>

	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">dnotify_mark_cache</span><span class="p">,</span> <span class="n">dn_mark</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">fsnotify_ops</span> <span class="n">dnotify_fsnotify_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">handle_event</span> <span class="o">=</span> <span class="n">dnotify_handle_event</span><span class="p">,</span>
	<span class="p">.</span><span class="n">should_send_event</span> <span class="o">=</span> <span class="n">dnotify_should_send_event</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free_group_priv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">freeing_mark</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">free_event_priv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Called every time a file is closed.  Looks first for a dnotify mark on the</span>
<span class="cm"> * inode.  If one is found run all of the -&gt;dn structures attached to that</span>
<span class="cm"> * mark for one relevant to this process closing the file and remove that</span>
<span class="cm"> * dnotify_struct.  If that was the last dnotify_struct also remove the</span>
<span class="cm"> * fsnotify_mark.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dnotify_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">fl_owner_t</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">fsn_mark</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dnotify_mark</span> <span class="o">*</span><span class="n">dn_mark</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dnotify_struct</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dnotify_struct</span> <span class="o">**</span><span class="n">prev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">fsn_mark</span> <span class="o">=</span> <span class="n">fsnotify_find_inode_mark</span><span class="p">(</span><span class="n">dnotify_group</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsn_mark</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">dn_mark</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">fsn_mark</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dnotify_mark</span><span class="p">,</span> <span class="n">fsn_mark</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dnotify_mark_mutex</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsn_mark</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dn_mark</span><span class="o">-&gt;</span><span class="n">dn</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">dn</span> <span class="o">=</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">dn_owner</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">dn_filp</span> <span class="o">==</span> <span class="n">filp</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">dn</span><span class="o">-&gt;</span><span class="n">dn_next</span><span class="p">;</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">dnotify_struct_cache</span><span class="p">,</span> <span class="n">dn</span><span class="p">);</span>
			<span class="n">dnotify_recalc_inode_mask</span><span class="p">(</span><span class="n">fsn_mark</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dn</span><span class="o">-&gt;</span><span class="n">dn_next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsn_mark</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* nothing else could have found us thanks to the dnotify_mark_mutex */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dn_mark</span><span class="o">-&gt;</span><span class="n">dn</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">fsnotify_destroy_mark</span><span class="p">(</span><span class="n">fsn_mark</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dnotify_mark_mutex</span><span class="p">);</span>

	<span class="n">fsnotify_put_mark</span><span class="p">(</span><span class="n">fsn_mark</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* this conversion is done only at watch creation */</span>
<span class="k">static</span> <span class="n">__u32</span> <span class="nf">convert_arg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="n">new_mask</span> <span class="o">=</span> <span class="n">FS_EVENT_ON_CHILD</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="n">DN_MULTISHOT</span><span class="p">)</span>
		<span class="n">new_mask</span> <span class="o">|=</span> <span class="n">FS_DN_MULTISHOT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="n">DN_DELETE</span><span class="p">)</span>
		<span class="n">new_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="n">FS_DELETE</span> <span class="o">|</span> <span class="n">FS_MOVED_FROM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="n">DN_MODIFY</span><span class="p">)</span>
		<span class="n">new_mask</span> <span class="o">|=</span> <span class="n">FS_MODIFY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="n">DN_ACCESS</span><span class="p">)</span>
		<span class="n">new_mask</span> <span class="o">|=</span> <span class="n">FS_ACCESS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="n">DN_ATTRIB</span><span class="p">)</span>
		<span class="n">new_mask</span> <span class="o">|=</span> <span class="n">FS_ATTRIB</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="n">DN_RENAME</span><span class="p">)</span>
		<span class="n">new_mask</span> <span class="o">|=</span> <span class="n">FS_DN_RENAME</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="n">DN_CREATE</span><span class="p">)</span>
		<span class="n">new_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="n">FS_CREATE</span> <span class="o">|</span> <span class="n">FS_MOVED_TO</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">new_mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If multiple processes watch the same inode with dnotify there is only one</span>
<span class="cm"> * dnotify mark in inode-&gt;i_fsnotify_marks but we chain a dnotify_struct</span>
<span class="cm"> * onto that mark.  This function either attaches the new dnotify_struct onto</span>
<span class="cm"> * that list, or it |= the mask onto an existing dnofiy_struct.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">attach_dn</span><span class="p">(</span><span class="k">struct</span> <span class="n">dnotify_struct</span> <span class="o">*</span><span class="n">dn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dnotify_mark</span> <span class="o">*</span><span class="n">dn_mark</span><span class="p">,</span>
		     <span class="n">fl_owner_t</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dnotify_struct</span> <span class="o">*</span><span class="n">odn</span><span class="p">;</span>

	<span class="n">odn</span> <span class="o">=</span> <span class="n">dn_mark</span><span class="o">-&gt;</span><span class="n">dn</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">odn</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* adding more events to existing dnofiy_struct? */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">odn</span><span class="o">-&gt;</span><span class="n">dn_owner</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">odn</span><span class="o">-&gt;</span><span class="n">dn_filp</span> <span class="o">==</span> <span class="n">filp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">odn</span><span class="o">-&gt;</span><span class="n">dn_fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
			<span class="n">odn</span><span class="o">-&gt;</span><span class="n">dn_mask</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">odn</span> <span class="o">=</span> <span class="n">odn</span><span class="o">-&gt;</span><span class="n">dn_next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dn</span><span class="o">-&gt;</span><span class="n">dn_mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">dn</span><span class="o">-&gt;</span><span class="n">dn_fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
	<span class="n">dn</span><span class="o">-&gt;</span><span class="n">dn_filp</span> <span class="o">=</span> <span class="n">filp</span><span class="p">;</span>
	<span class="n">dn</span><span class="o">-&gt;</span><span class="n">dn_owner</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">dn</span><span class="o">-&gt;</span><span class="n">dn_next</span> <span class="o">=</span> <span class="n">dn_mark</span><span class="o">-&gt;</span><span class="n">dn</span><span class="p">;</span>
	<span class="n">dn_mark</span><span class="o">-&gt;</span><span class="n">dn</span> <span class="o">=</span> <span class="n">dn</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When a process calls fcntl to attach a dnotify watch to a directory it ends</span>
<span class="cm"> * up here.  Allocate both a mark for fsnotify to add and a dnotify_struct to be</span>
<span class="cm"> * attached to the fsnotify_mark.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fcntl_dirnotify</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dnotify_mark</span> <span class="o">*</span><span class="n">new_dn_mark</span><span class="p">,</span> <span class="o">*</span><span class="n">dn_mark</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fsnotify_mark</span> <span class="o">*</span><span class="n">new_fsn_mark</span><span class="p">,</span> <span class="o">*</span><span class="n">fsn_mark</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dnotify_struct</span> <span class="o">*</span><span class="n">dn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="n">fl_owner_t</span> <span class="n">id</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">destroy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">mask</span><span class="p">;</span>

	<span class="cm">/* we use these to tell if we need to kfree */</span>
	<span class="n">new_fsn_mark</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir_notify_enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* a 0 mask means we are explicitly removing the watch */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">DN_MULTISHOT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dnotify_flush</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* dnotify only works on directories */</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTDIR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* expect most fcntl to add new rather than augment old */</span>
	<span class="n">dn</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">dnotify_struct_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* new fsnotify mark, we expect most fcntl calls to add a new mark */</span>
	<span class="n">new_dn_mark</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">dnotify_mark_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_dn_mark</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* convert the userspace DN_* &quot;arg&quot; to the internal FS_* defines in fsnotify */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">convert_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>

	<span class="cm">/* set up the new_fsn_mark and new_dn_mark */</span>
	<span class="n">new_fsn_mark</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">new_dn_mark</span><span class="o">-&gt;</span><span class="n">fsn_mark</span><span class="p">;</span>
	<span class="n">fsnotify_init_mark</span><span class="p">(</span><span class="n">new_fsn_mark</span><span class="p">,</span> <span class="n">dnotify_free_mark</span><span class="p">);</span>
	<span class="n">new_fsn_mark</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">new_dn_mark</span><span class="o">-&gt;</span><span class="n">dn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* this is needed to prevent the fcntl/close race described below */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dnotify_mark_mutex</span><span class="p">);</span>

	<span class="cm">/* add the new_fsn_mark or find an old one. */</span>
	<span class="n">fsn_mark</span> <span class="o">=</span> <span class="n">fsnotify_find_inode_mark</span><span class="p">(</span><span class="n">dnotify_group</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fsn_mark</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dn_mark</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">fsn_mark</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dnotify_mark</span><span class="p">,</span> <span class="n">fsn_mark</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsn_mark</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fsnotify_add_mark</span><span class="p">(</span><span class="n">new_fsn_mark</span><span class="p">,</span> <span class="n">dnotify_group</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_fsn_mark</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">fsn_mark</span> <span class="o">=</span> <span class="n">new_fsn_mark</span><span class="p">;</span>
		<span class="n">dn_mark</span> <span class="o">=</span> <span class="n">new_dn_mark</span><span class="p">;</span>
		<span class="cm">/* we used new_fsn_mark, so don&#39;t free it */</span>
		<span class="n">new_fsn_mark</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">f</span> <span class="o">=</span> <span class="n">fcheck</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="cm">/* if (f != filp) means that we lost a race and another task/thread</span>
<span class="cm">	 * actually closed the fd we are still playing with before we grabbed</span>
<span class="cm">	 * the dnotify_mark_mutex and fsn_mark-&gt;lock.  Since closing the fd is the</span>
<span class="cm">	 * only time we clean up the marks we need to get our mark off</span>
<span class="cm">	 * the list. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">!=</span> <span class="n">filp</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if we added ourselves, shoot ourselves, it&#39;s possible that</span>
<span class="cm">		 * the flush actually did shoot this fsn_mark.  That&#39;s fine too</span>
<span class="cm">		 * since multiple calls to destroy_mark is perfectly safe, if</span>
<span class="cm">		 * we found a dn_mark already attached to the inode, just sod</span>
<span class="cm">		 * off silently as the flush at close time dealt with it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dn_mark</span> <span class="o">==</span> <span class="n">new_dn_mark</span><span class="p">)</span>
			<span class="n">destroy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">__f_setown</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">task_pid</span><span class="p">(</span><span class="n">current</span><span class="p">),</span> <span class="n">PIDTYPE_PID</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if we added, we must shoot */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dn_mark</span> <span class="o">==</span> <span class="n">new_dn_mark</span><span class="p">)</span>
			<span class="n">destroy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">attach_dn</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span> <span class="n">dn_mark</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="cm">/* !error means that we attached the dn to the dn_mark, so don&#39;t free it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">dn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* -EEXIST means that we didn&#39;t add this new dn and used an old one.</span>
<span class="cm">	 * that isn&#39;t an error (and the unused dn should be freed) */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dnotify_recalc_inode_mask</span><span class="p">(</span><span class="n">fsn_mark</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsn_mark</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">destroy</span><span class="p">)</span>
		<span class="n">fsnotify_destroy_mark</span><span class="p">(</span><span class="n">fsn_mark</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dnotify_mark_mutex</span><span class="p">);</span>
	<span class="n">fsnotify_put_mark</span><span class="p">(</span><span class="n">fsn_mark</span><span class="p">);</span>
<span class="nl">out_err:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_fsn_mark</span><span class="p">)</span>
		<span class="n">fsnotify_put_mark</span><span class="p">(</span><span class="n">new_fsn_mark</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dn</span><span class="p">)</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">dnotify_struct_cache</span><span class="p">,</span> <span class="n">dn</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">dnotify_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dnotify_struct_cache</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">dnotify_struct</span><span class="p">,</span> <span class="n">SLAB_PANIC</span><span class="p">);</span>
	<span class="n">dnotify_mark_cache</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">dnotify_mark</span><span class="p">,</span> <span class="n">SLAB_PANIC</span><span class="p">);</span>

	<span class="n">dnotify_group</span> <span class="o">=</span> <span class="n">fsnotify_alloc_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dnotify_fsnotify_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dnotify_group</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;unable to allocate fsnotify group for dnotify</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">dnotify_init</span><span class="p">)</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
