f | sys.c | s | 5.2K | 170 | Randy Dunlap | rdunlap@xenotime.net | 1339472002 |  | exofs: fix sparse non-ANSI function warning  Fix sparse non-ANSI function warning:    fs/exofs/sys.c:112:28: warning: non-ANSI function declaration of function 'exofs_sysfs_dbg_print'  Signed-off-by: Randy Dunlap <rdunlap@xenotime.net> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | ore_raid.c | s | 18K | 591 | Boaz Harrosh | bharrosh@panasas.com | 1326012193 |  | ore: Must support none-PAGE-aligned IO  NFS might send us offsets that are not PAGE aligned. So we must read in the reminder of the first/last pages, in cases we need it for Parity calculations.  We only add an sg segments to read the partial page. But we don't mark it as read=true because it is a lock-for-write page.  TODO: In some cases (IO spans a single unit) we can just adjust the raid_unit offset/length, but this is left for later Kernels.  [Bug in 3.2.0 Kernel] CC: Stable Tree <stable@kernel.org> Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
f | dir.c | s | 16K | 604 | Cong Wang | amwang@redhat.com | 1332251302 |  | exofs: remove the second argument of k[un]map_atomic()  Ack-by: Boaz Harrosh <bharrosh@panasas.com> Signed-off-by: Cong Wang <amwang@redhat.com>
f | ore_raid.h | s | 2.7K | 68 | Boaz Harrosh | bharrosh@panasas.com | 1319501733 |  | ore: RAID5 Write  This is finally the RAID5 Write support.  The bigger part of this patch is not the XOR engine itself, But the read4write logic, which is a complete mini prepare_for_striping reading engine that can read scattered pages of a stripe into cache so it can be used for XOR calculation. That is, if the write was not stripe aligned.  The main algorithm behind the XOR engine is the 2 dimensional array: 	struct __stripe_pages_2d. A drawing might save 1000 words ---  __stripe_pages_2d        ||  n = pages_in_stripe_unit;  w = group_width - parity;        ||                            pages array presented to the XOR lib        ||                                                ||        V                                                ||  __1_page_stripe[0].pages --> [c0][c1]..[cw][c_par] <---||        ||                                                ||  __1_page_stripe[1].pages --> [c0][c1]..[cw][c_par] <---        || ...    ||                         ...        ||  __1_page_stripe[n].pages --> [c0][c1]..[cw][c_par]                                ^                                ||            data added columns first then row  --- The pages are put on this array columns first. .i.e: 	p0-of-c0, p1-of-c0, ... pn-of-c0, p0-of-c1, ... So we are doing a corner turn of the pages.  Note that pages will zigzag down and left. but are put sequentially in growing order. So when the time comes to XOR the stripe, only the beginning and end of the array need be checked. We scan the array and any NULL spot will be field by pages-to-be-read.  The FS that wants to support RAID5 needs to supply an operations-vector that searches a given page in cache, and specifies if the page is uptodate or need reading. All these pages to be read are put on a slave ore_io_state and synchronously read. All the pages of a stripe are read in one IO, using the scatter gather mechanism.  In write we constrain our IO to only be incomplete on a single stripe. Meaning either the complete IO is within a single stripe so we might have pages to read from both beginning  or end of the strip. Or we have some reading to do at beginning but end at strip boundary. The left over pages are pushed to the next IO by the API already established by previous work, where an IO offset/length combination presented to the ORE might get the length truncated and the user must re-submit the leftover pages. (Both exofs and NFS support this)  But any ORE user should make it's best effort to align it's IO before hand and avoid complications. A cached ore_layout->stripe_size member can be used for that calculation. (NOTE: that ORE demands that stripe_size may not be bigger then 32bit)  What else? Well read it and tell me.  Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
f | super.c | s | 26K | 899 | Sachin Bhamare | sbhamare@panasas.com | 1337592241 |  | exofs:  Add SYSFS info for autologin/pNFS export  Introduce sysfs infrastructure for exofs cluster filesystem.  Each OSD target shows up as below in the sysfs hierarchy: 	/sys/fs/exofs/<osdname>_<partition_id>/devX  Where <osdname>_<partition_id> is the unique identification of a Superblock.  Where devX: 0 <= X < device_table_size. They are ordered in device-table order as specified to the mkfs.exofs command  Each OSD device  devX has following attributes : 	osdname - ReadOnly 	systemid - ReadOnly 	uri - Read/Write  It is up to user-mode to update devX/uri for support of autologin.  These sysfs information are used both for autologin as well as support for exporting exofs via a pNFSD server in user-mode. (.eg NFS-Ganesha)  Signed-off-by: Sachin Bhamare <sbhamare@panasas.com> Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
f | inode.c | s | 36K | 1255 | Jan Kara | jack@suse.cz | 1336283021 |  | vfs: Rename end_writeback() to clear_inode()  After we moved inode_sync_wait() from end_writeback() it doesn't make sense to call the function end_writeback() anymore. Rename it to clear_inode() which well says what the function really does - set I_CLEAR flag.  Signed-off-by: Jan Kara <jack@suse.cz> Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>
f | Kbuild | g | 533B |  | Sachin Bhamare | sbhamare@panasas.com | 1337592241 |  | exofs:  Add SYSFS info for autologin/pNFS export  Introduce sysfs infrastructure for exofs cluster filesystem.  Each OSD target shows up as below in the sysfs hierarchy: 	/sys/fs/exofs/<osdname>_<partition_id>/devX  Where <osdname>_<partition_id> is the unique identification of a Superblock.  Where devX: 0 <= X < device_table_size. They are ordered in device-table order as specified to the mkfs.exofs command  Each OSD device  devX has following attributes : 	osdname - ReadOnly 	systemid - ReadOnly 	uri - Read/Write  It is up to user-mode to update devX/uri for support of autologin.  These sysfs information are used both for autologin as well as support for exporting exofs via a pNFSD server in user-mode. (.eg NFS-Ganesha)  Signed-off-by: Sachin Bhamare <sbhamare@panasas.com> Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
f | BUGS | g | 235B |  | Boaz Harrosh | bharrosh@panasas.com | 1238517878 |  | exofs: Documentation  Added some documentation in exofs.txt, as well as a BUGS file.  For further reading, operation instructions, example scripts and up to date infomation and code please see: http://open-osd.org  Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
f | exofs.h | s | 8.0K | 212 | Sachin Bhamare | sbhamare@panasas.com | 1337592241 |  | exofs:  Add SYSFS info for autologin/pNFS export  Introduce sysfs infrastructure for exofs cluster filesystem.  Each OSD target shows up as below in the sysfs hierarchy: 	/sys/fs/exofs/<osdname>_<partition_id>/devX  Where <osdname>_<partition_id> is the unique identification of a Superblock.  Where devX: 0 <= X < device_table_size. They are ordered in device-table order as specified to the mkfs.exofs command  Each OSD device  devX has following attributes : 	osdname - ReadOnly 	systemid - ReadOnly 	uri - Read/Write  It is up to user-mode to update devX/uri for support of autologin.  These sysfs information are used both for autologin as well as support for exporting exofs via a pNFSD server in user-mode. (.eg NFS-Ganesha)  Signed-off-by: Sachin Bhamare <sbhamare@panasas.com> Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
f | Kconfig | g | 323B |  | Boaz Harrosh | bharrosh@panasas.com | 1325861294 |  | ore: FIX breakage when MISC_FILESYSTEMS is not set  As Reported by Randy Dunlap  When MISC_FILESYSTEMS is not enabled and NFS4.1 is:  fs/built-in.o: In function `objio_alloc_io_state': objio_osd.c:(.text+0xcb525): undefined reference to `ore_get_rw_state' fs/built-in.o: In function `_write_done': objio_osd.c:(.text+0xcb58d): undefined reference to `ore_check_io' fs/built-in.o: In function `_read_done': ...  When MISC_FILESYSTEMS, which is more of a GUI thing then anything else, is not selected. exofs/Kconfig is never examined during Kconfig, and it can not do it's magic stuff to automatically select everything needed.  We must split exofs/Kconfig in two. The ore one is always included. And the exofs one is left in it's old place in the menu.  [Needed for the 3.2.0 Kernel] CC: Stable Tree <stable@kernel.org> Reported-by: Randy Dunlap <rdunlap@xenotime.net> Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
f | symlink.c | s | 1.8K | 49 | Boaz Harrosh | bharrosh@panasas.com | 1245596027 |  | exofs: Remove IBM copyrights  Boaz, Congrats on getting all the OSD stuff into 2.6.30! I just pulled the git, and saw that the IBM copyrights are still there. Please remove them from all files:  * Copyright (C) 2005, 2006  * International Business Machines  IBM has revoked all rights on the code - they gave it to me.  Thanks! Avishay  Signed-off-by: Avishay Traeger <avishay@gmail.com> Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
f | Kconfig.ore | g | 461B |  | Boaz Harrosh | bharrosh@panasas.com | 1325861294 |  | ore: FIX breakage when MISC_FILESYSTEMS is not set  As Reported by Randy Dunlap  When MISC_FILESYSTEMS is not enabled and NFS4.1 is:  fs/built-in.o: In function `objio_alloc_io_state': objio_osd.c:(.text+0xcb525): undefined reference to `ore_get_rw_state' fs/built-in.o: In function `_write_done': objio_osd.c:(.text+0xcb58d): undefined reference to `ore_check_io' fs/built-in.o: In function `_read_done': ...  When MISC_FILESYSTEMS, which is more of a GUI thing then anything else, is not selected. exofs/Kconfig is never examined during Kconfig, and it can not do it's magic stuff to automatically select everything needed.  We must split exofs/Kconfig in two. The ore one is always included. And the exofs one is left in it's old place in the menu.  [Needed for the 3.2.0 Kernel] CC: Stable Tree <stable@kernel.org> Reported-by: Randy Dunlap <rdunlap@xenotime.net> Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
f | ore.c | s | 29K | 967 | Boaz Harrosh | bharrosh@panasas.com | 1325861347 |  | ore: fix BUG_ON, too few sgs when reading  When reading RAID5 files, in rare cases, we calculated too few sg segments. There should be two extra for the beginning and end partial units.  Also "too few sg segments" should not be a BUG_ON there is all the mechanics in place to handle it, as a short read. So just return -ENOMEM and the rest of the code will gracefully split the IO.  [Bug in 3.2.0 Kernel] CC: Stable Tree <stable@kernel.org> Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
f | namei.c | s | 7.2K | 273 | Al Viro | viro@zeniv.linux.org.uk | 1332293372 |  | vfs: check i_nlink limits in vfs_{mkdir,rename_dir,link}  New field of struct super_block - ->s_max_links.  Maximal allowed value of ->i_nlink or 0; in the latter case all checks still need to be done in ->link/->mkdir/->rename instances.  Note that this limit applies both to directoris and to non-directories.  Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
f | file.c | s | 2.5K | 78 | Josef Bacik | josef@redhat.com | 1311209279 |  | fs: push i_mutex and filemap_write_and_wait down into ->fsync() handlers  Btrfs needs to be able to control how filemap_write_and_wait_range() is called in fsync to make it less of a painful operation, so push down taking i_mutex and the calling of filemap_write_and_wait() down into the ->fsync() handlers.  Some file systems can drop taking the i_mutex altogether it seems, like ext3 and ocfs2.  For correctness sake I just pushed everything down in all cases to make sure that we keep the current behavior the same for everybody, and then each individual fs maintainer can make up their mind about what to do from there. Thanks,  Acked-by: Jan Kara <jack@suse.cz> Signed-off-by: Josef Bacik <josef@redhat.com> Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
f | common.h | s | 8.6K | 232 | Lucas De Marchi | lucas.demarchi@profusion.mobi | 1301581583 |  | Fix common misspellings  Fixes generated by 'codespell' and manually reviewed.  Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>
