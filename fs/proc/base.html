<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › proc › base.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>base.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/fs/proc/base.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992 Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> *  proc base directory handling functions</span>
<span class="cm"> *</span>
<span class="cm"> *  1999, Al Viro. Rewritten. Now it covers the whole per-process part.</span>
<span class="cm"> *  Instead of using magical inumbers to determine the kind of object</span>
<span class="cm"> *  we allocate and fill in-core inodes upon lookup. They don&#39;t even</span>
<span class="cm"> *  go into icache. We cache the reference to task_struct upon lookup too.</span>
<span class="cm"> *  Eventually it should become a filesystem in its own. We don&#39;t use the</span>
<span class="cm"> *  rest of procfs anymore.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  Changelog:</span>
<span class="cm"> *  17-Jan-2005</span>
<span class="cm"> *  Allan Bezerra</span>
<span class="cm"> *  Bruna Moreira &lt;bruna.moreira@indt.org.br&gt;</span>
<span class="cm"> *  Edjard Mota &lt;edjard.mota@indt.org.br&gt;</span>
<span class="cm"> *  Ilias Biris &lt;ilias.biris@indt.org.br&gt;</span>
<span class="cm"> *  Mauricio Lin &lt;mauricio.lin@indt.org.br&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Embedded Linux Lab - 10LE Instituto Nokia de Tecnologia - INdT</span>
<span class="cm"> *</span>
<span class="cm"> *  A new process specific entry (smaps) included in /proc. It shows the</span>
<span class="cm"> *  size of rss for each memory area. The maps entry lacks information</span>
<span class="cm"> *  about physical memory size (rss) for each mapped file, i.e.,</span>
<span class="cm"> *  rss information for executables and library files.</span>
<span class="cm"> *  This additional information is useful for any tools that need to know</span>
<span class="cm"> *  about physical memory consumption for a process specific library.</span>
<span class="cm"> *</span>
<span class="cm"> *  Changelog:</span>
<span class="cm"> *  21-Feb-2005</span>
<span class="cm"> *  Embedded Linux Lab - 10LE Instituto Nokia de Tecnologia - INdT</span>
<span class="cm"> *  Pud inclusion in the page table walking.</span>
<span class="cm"> *</span>
<span class="cm"> *  ChangeLog:</span>
<span class="cm"> *  10-Mar-2005</span>
<span class="cm"> *  10LE Instituto Nokia de Tecnologia - INdT:</span>
<span class="cm"> *  A better way to walks through the page table as suggested by Hugh Dickins.</span>
<span class="cm"> *</span>
<span class="cm"> *  Simo Piiroinen &lt;simo.piiroinen@nokia.com&gt;:</span>
<span class="cm"> *  Smaps information related to shared, private, clean and dirty pages.</span>
<span class="cm"> *</span>
<span class="cm"> *  Paul Mundt &lt;paul.mundt@nokia.com&gt;:</span>
<span class="cm"> *  Overall revision about smaps.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/task_io_accounting_ops.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/fdtable.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/mnt_namespace.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/stacktrace.h&gt;</span>
<span class="cp">#include &lt;linux/resource.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/tracehook.h&gt;</span>
<span class="cp">#include &lt;linux/cgroup.h&gt;</span>
<span class="cp">#include &lt;linux/cpuset.h&gt;</span>
<span class="cp">#include &lt;linux/audit.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/nsproxy.h&gt;</span>
<span class="cp">#include &lt;linux/oom.h&gt;</span>
<span class="cp">#include &lt;linux/elf.h&gt;</span>
<span class="cp">#include &lt;linux/pid_namespace.h&gt;</span>
<span class="cp">#include &lt;linux/user_namespace.h&gt;</span>
<span class="cp">#include &lt;linux/fs_struct.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/flex_array.h&gt;</span>
<span class="cp">#ifdef CONFIG_HARDWALL</span>
<span class="cp">#include &lt;asm/hardwall.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;trace/events/oom.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cm">/* NOTE:</span>
<span class="cm"> *	Implementing inode permission operations in /proc is almost</span>
<span class="cm"> *	certainly an error.  Permission checks need to happen during</span>
<span class="cm"> *	each system call not at open time.  The reason is that most of</span>
<span class="cm"> *	what we wish to check for permissions in /proc varies at runtime.</span>
<span class="cm"> *</span>
<span class="cm"> *	The classic example of a problem is opening file descriptors</span>
<span class="cm"> *	in /proc for a task before it execs a suid executable.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">pid_entry</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">umode_t</span> <span class="n">mode</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="o">*</span><span class="n">iop</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">fop</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">proc_op</span> <span class="n">op</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define NOD(NAME, MODE, IOP, FOP, OP) {			\</span>
<span class="cp">	.name = (NAME),					\</span>
<span class="cp">	.len  = sizeof(NAME) - 1,			\</span>
<span class="cp">	.mode = MODE,					\</span>
<span class="cp">	.iop  = IOP,					\</span>
<span class="cp">	.fop  = FOP,					\</span>
<span class="cp">	.op   = OP,					\</span>
<span class="cp">}</span>

<span class="cp">#define DIR(NAME, MODE, iops, fops)	\</span>
<span class="cp">	NOD(NAME, (S_IFDIR|(MODE)), &amp;iops, &amp;fops, {} )</span>
<span class="cp">#define LNK(NAME, get_link)					\</span>
<span class="cp">	NOD(NAME, (S_IFLNK|S_IRWXUGO),				\</span>
<span class="cp">		&amp;proc_pid_link_inode_operations, NULL,		\</span>
<span class="cp">		{ .proc_get_link = get_link } )</span>
<span class="cp">#define REG(NAME, MODE, fops)				\</span>
<span class="cp">	NOD(NAME, (S_IFREG|(MODE)), NULL, &amp;fops, {})</span>
<span class="cp">#define INF(NAME, MODE, read)				\</span>
<span class="cp">	NOD(NAME, (S_IFREG|(MODE)), 			\</span>
<span class="cp">		NULL, &amp;proc_info_file_operations,	\</span>
<span class="cp">		{ .proc_read = read } )</span>
<span class="cp">#define ONE(NAME, MODE, show)				\</span>
<span class="cp">	NOD(NAME, (S_IFREG|(MODE)), 			\</span>
<span class="cp">		NULL, &amp;proc_single_file_operations,	\</span>
<span class="cp">		{ .proc_show = show } )</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">proc_fd_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Count the number of hardlinks for the pid_entry table, excluding the .</span>
<span class="cm"> * and .. links.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">pid_entry_count_dirs</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pid_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mode</span><span class="p">))</span>
			<span class="o">++</span><span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_task_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">task_lock</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">get_fs_root</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_cwd_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">task_lock</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">get_fs_pwd</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
			<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">task_unlock</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_root_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">get_task_root</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_pid_cmdline</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">get_task_mm</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">arg_end</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_mm</span><span class="p">;</span>	<span class="cm">/* Shh! No looking before we&#39;re done */</span>

 	<span class="n">len</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">arg_end</span> <span class="o">-</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">arg_start</span><span class="p">;</span>
 
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
 
	<span class="n">res</span> <span class="o">=</span> <span class="n">access_process_vm</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">arg_start</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>If the nul at the end of args has been overwritten, then
assume application is using setproctitle(3).</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">buffer</span><span class="p">[</span><span class="n">res</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">strnlen</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		    <span class="n">res</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">env_end</span> <span class="o">-</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">env_start</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">res</span><span class="p">)</span>
				<span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">res</span><span class="p">;</span>
			<span class="n">res</span> <span class="o">+=</span> <span class="n">access_process_vm</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">env_start</span><span class="p">,</span> <span class="n">buffer</span><span class="o">+</span><span class="n">res</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">strnlen</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out_mm:</span>
	<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_pid_auxv</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">mm_access</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">PTRACE_MODE_READ</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nwords</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">nwords</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">saved_auxv</span><span class="p">[</span><span class="n">nwords</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* AT_NULL */</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">nwords</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">saved_auxv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">saved_auxv</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
		<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#ifdef CONFIG_KALLSYMS</span>
<span class="cm">/*</span>
<span class="cm"> * Provides a wchan file via kallsyms in a proper one-value-per-file format.</span>
<span class="cm"> * Returns the resolved symbol.  If that fails, simply return the address.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_pid_wchan</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">wchan</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">symname</span><span class="p">[</span><span class="n">KSYM_NAME_LEN</span><span class="p">];</span>

	<span class="n">wchan</span> <span class="o">=</span> <span class="n">get_wchan</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lookup_symbol_name</span><span class="p">(</span><span class="n">wchan</span><span class="p">,</span> <span class="n">symname</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptrace_may_access</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">PTRACE_MODE_READ</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;%lu&quot;</span><span class="p">,</span> <span class="n">wchan</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">symname</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_KALLSYMS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lock_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">mutex_lock_killable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cred_guard_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptrace_may_access</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">PTRACE_MODE_ATTACH</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cred_guard_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unlock_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cred_guard_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_STACKTRACE</span>

<span class="cp">#define MAX_STACK_TRACE_DEPTH	64</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_pid_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stack_trace</span> <span class="n">trace</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">entries</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">entries</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">MAX_STACK_TRACE_DEPTH</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entries</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entries</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">trace</span><span class="p">.</span><span class="n">nr_entries</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">trace</span><span class="p">.</span><span class="n">max_entries</span>	<span class="o">=</span> <span class="n">MAX_STACK_TRACE_DEPTH</span><span class="p">;</span>
	<span class="n">trace</span><span class="p">.</span><span class="n">entries</span>		<span class="o">=</span> <span class="n">entries</span><span class="p">;</span>
	<span class="n">trace</span><span class="p">.</span><span class="n">skip</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">lock_trace</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">save_stack_trace_tsk</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trace</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">trace</span><span class="p">.</span><span class="n">nr_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;[&lt;%pK&gt;] %pS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">unlock_trace</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">entries</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SCHEDSTATS</span>
<span class="cm">/*</span>
<span class="cm"> * Provides /proc/PID/schedstat</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_pid_schedstat</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;%llu %llu %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">.</span><span class="n">sum_exec_runtime</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">sched_info</span><span class="p">.</span><span class="n">run_delay</span><span class="p">,</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="n">sched_info</span><span class="p">.</span><span class="n">pcount</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_LATENCYTOP</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lstats_show_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;Latency Top version : v0.1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">latency_record</span> <span class="o">*</span><span class="n">lr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">latency_record</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lr</span><span class="o">-&gt;</span><span class="n">backtrace</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">q</span><span class="p">;</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%i %li %li&quot;</span><span class="p">,</span>
				   <span class="n">lr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">lr</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">,</span> <span class="n">lr</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="n">LT_BACKTRACEDEPTH</span><span class="p">;</span> <span class="n">q</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bt</span> <span class="o">=</span> <span class="n">lr</span><span class="o">-&gt;</span><span class="n">backtrace</span><span class="p">[</span><span class="n">q</span><span class="p">];</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bt</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bt</span> <span class="o">==</span> <span class="n">ULONG_MAX</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; %ps&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">bt</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lstats_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">lstats_show_proc</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">lstats_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="n">clear_all_latency_tracing</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_lstats_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">lstats_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">lstats_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_oom_score</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">totalpages</span> <span class="o">=</span> <span class="n">totalram_pages</span> <span class="o">+</span> <span class="n">total_swap_pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">points</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid_alive</span><span class="p">(</span><span class="n">task</span><span class="p">))</span>
		<span class="n">points</span> <span class="o">=</span> <span class="n">oom_badness</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">totalpages</span><span class="p">)</span> <span class="o">*</span>
						<span class="mi">1000</span> <span class="o">/</span> <span class="n">totalpages</span><span class="p">;</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">points</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">limit_names</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">unit</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">limit_names</span> <span class="n">lnames</span><span class="p">[</span><span class="n">RLIM_NLIMITS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">RLIMIT_CPU</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;Max cpu time&quot;</span><span class="p">,</span> <span class="s">&quot;seconds&quot;</span><span class="p">},</span>
	<span class="p">[</span><span class="n">RLIMIT_FSIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;Max file size&quot;</span><span class="p">,</span> <span class="s">&quot;bytes&quot;</span><span class="p">},</span>
	<span class="p">[</span><span class="n">RLIMIT_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;Max data size&quot;</span><span class="p">,</span> <span class="s">&quot;bytes&quot;</span><span class="p">},</span>
	<span class="p">[</span><span class="n">RLIMIT_STACK</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;Max stack size&quot;</span><span class="p">,</span> <span class="s">&quot;bytes&quot;</span><span class="p">},</span>
	<span class="p">[</span><span class="n">RLIMIT_CORE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;Max core file size&quot;</span><span class="p">,</span> <span class="s">&quot;bytes&quot;</span><span class="p">},</span>
	<span class="p">[</span><span class="n">RLIMIT_RSS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;Max resident set&quot;</span><span class="p">,</span> <span class="s">&quot;bytes&quot;</span><span class="p">},</span>
	<span class="p">[</span><span class="n">RLIMIT_NPROC</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;Max processes&quot;</span><span class="p">,</span> <span class="s">&quot;processes&quot;</span><span class="p">},</span>
	<span class="p">[</span><span class="n">RLIMIT_NOFILE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;Max open files&quot;</span><span class="p">,</span> <span class="s">&quot;files&quot;</span><span class="p">},</span>
	<span class="p">[</span><span class="n">RLIMIT_MEMLOCK</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;Max locked memory&quot;</span><span class="p">,</span> <span class="s">&quot;bytes&quot;</span><span class="p">},</span>
	<span class="p">[</span><span class="n">RLIMIT_AS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;Max address space&quot;</span><span class="p">,</span> <span class="s">&quot;bytes&quot;</span><span class="p">},</span>
	<span class="p">[</span><span class="n">RLIMIT_LOCKS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;Max file locks&quot;</span><span class="p">,</span> <span class="s">&quot;locks&quot;</span><span class="p">},</span>
	<span class="p">[</span><span class="n">RLIMIT_SIGPENDING</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;Max pending signals&quot;</span><span class="p">,</span> <span class="s">&quot;signals&quot;</span><span class="p">},</span>
	<span class="p">[</span><span class="n">RLIMIT_MSGQUEUE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;Max msgqueue size&quot;</span><span class="p">,</span> <span class="s">&quot;bytes&quot;</span><span class="p">},</span>
	<span class="p">[</span><span class="n">RLIMIT_NICE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;Max nice priority&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">},</span>
	<span class="p">[</span><span class="n">RLIMIT_RTPRIO</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;Max realtime priority&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">},</span>
	<span class="p">[</span><span class="n">RLIMIT_RTTIME</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;Max realtime timeout&quot;</span><span class="p">,</span> <span class="s">&quot;us&quot;</span><span class="p">},</span>
<span class="p">};</span>

<span class="cm">/* Display limits for a process */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_pid_limits</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">bufptr</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">rlimit</span> <span class="n">rlim</span><span class="p">[</span><span class="n">RLIM_NLIMITS</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lock_task_sighand</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">rlim</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rlimit</span><span class="p">)</span> <span class="o">*</span> <span class="n">RLIM_NLIMITS</span><span class="p">);</span>
	<span class="n">unlock_task_sighand</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * print the file header</span>
<span class="cm">	 */</span>
	<span class="n">count</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufptr</span><span class="p">[</span><span class="n">count</span><span class="p">],</span> <span class="s">&quot;%-25s %-20s %-20s %-10s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="s">&quot;Limit&quot;</span><span class="p">,</span> <span class="s">&quot;Soft Limit&quot;</span><span class="p">,</span> <span class="s">&quot;Hard Limit&quot;</span><span class="p">,</span> <span class="s">&quot;Units&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RLIM_NLIMITS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rlim</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rlim_cur</span> <span class="o">==</span> <span class="n">RLIM_INFINITY</span><span class="p">)</span>
			<span class="n">count</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufptr</span><span class="p">[</span><span class="n">count</span><span class="p">],</span> <span class="s">&quot;%-25s %-20s &quot;</span><span class="p">,</span>
					 <span class="n">lnames</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;unlimited&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">count</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufptr</span><span class="p">[</span><span class="n">count</span><span class="p">],</span> <span class="s">&quot;%-25s %-20lu &quot;</span><span class="p">,</span>
					 <span class="n">lnames</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">rlim</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rlim_cur</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rlim</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rlim_max</span> <span class="o">==</span> <span class="n">RLIM_INFINITY</span><span class="p">)</span>
			<span class="n">count</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufptr</span><span class="p">[</span><span class="n">count</span><span class="p">],</span> <span class="s">&quot;%-20s &quot;</span><span class="p">,</span> <span class="s">&quot;unlimited&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">count</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufptr</span><span class="p">[</span><span class="n">count</span><span class="p">],</span> <span class="s">&quot;%-20lu &quot;</span><span class="p">,</span>
					 <span class="n">rlim</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rlim_max</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lnames</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">unit</span><span class="p">)</span>
			<span class="n">count</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufptr</span><span class="p">[</span><span class="n">count</span><span class="p">],</span> <span class="s">&quot;%-10s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">lnames</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">unit</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">count</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufptr</span><span class="p">[</span><span class="n">count</span><span class="p">],</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HAVE_ARCH_TRACEHOOK</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_pid_syscall</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">nr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">args</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">sp</span><span class="p">,</span> <span class="n">pc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">lock_trace</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task_current_syscall</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pc</span><span class="p">))</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;running</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;%ld 0x%lx 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">pc</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span>
		       <span class="s">&quot;%ld 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">nr</span><span class="p">,</span>
		       <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
		       <span class="n">sp</span><span class="p">,</span> <span class="n">pc</span><span class="p">);</span>
	<span class="n">unlock_trace</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HAVE_ARCH_TRACEHOOK */</span><span class="cp"></span>

<span class="cm">/************************************************************************/</span>
<span class="cm">/*                       Here the fs part begins                        */</span>
<span class="cm">/************************************************************************/</span>

<span class="cm">/* permission checks */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_fd_access_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">allowed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Allow access to a task&#39;s file descriptors if it is us or we</span>
<span class="cm">	 * may use ptrace attach to the process and find out that</span>
<span class="cm">	 * information.</span>
<span class="cm">	 */</span>
	<span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">allowed</span> <span class="o">=</span> <span class="n">ptrace_may_access</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">PTRACE_MODE_READ</span><span class="p">);</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">allowed</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">proc_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MODE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">inode_change_ok</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span> <span class="o">!=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">vmtruncate</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">setattr_copy</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
	<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * May current process learn task&#39;s sched/cmdline info (for hide_pid_min=1)</span>
<span class="cm"> * or euid/egid (for hide_pid_min=2)?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">has_pid_permissions</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">pid</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">hide_pid_min</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="o">-&gt;</span><span class="n">hide_pid</span> <span class="o">&lt;</span> <span class="n">hide_pid_min</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_group_p</span><span class="p">(</span><span class="n">pid</span><span class="o">-&gt;</span><span class="n">pid_gid</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ptrace_may_access</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">PTRACE_MODE_READ</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_pid_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">pid</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">has_perms</span><span class="p">;</span>

	<span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="n">has_perms</span> <span class="o">=</span> <span class="n">has_pid_permissions</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_perms</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="o">-&gt;</span><span class="n">hide_pid</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Let&#39;s make getdents(), stat(), and open()</span>
<span class="cm">			 * consistent with each other.  If a process</span>
<span class="cm">			 * may not stat() a file, it shouldn&#39;t be seen</span>
<span class="cm">			 * in procfs at all.</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">generic_permission</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>



<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">proc_def_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">proc_setattr</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define PROC_BLOCK_SIZE	(3*1024)		</span><span class="cm">/* 4K page size but our output routines use some slack for overruns */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">proc_info_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
			  <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">length</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">length</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_task</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">PROC_BLOCK_SIZE</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">PROC_BLOCK_SIZE</span><span class="p">;</span>

	<span class="n">length</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">page</span> <span class="o">=</span> <span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_TEMPORARY</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">length</span> <span class="o">=</span> <span class="n">PROC_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">proc_read</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">page</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="n">free_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="nl">out_no_task:</span>
	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_info_file_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">proc_info_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_single_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ns</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="n">pid</span> <span class="o">=</span> <span class="n">proc_pid</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">task</span> <span class="o">=</span> <span class="n">get_pid_task</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">PIDTYPE_PID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">PROC_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">proc_show</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>

	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_single_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">proc_single_show</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_single_file_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">proc_single_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__mem_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>

	<span class="n">mm</span> <span class="o">=</span> <span class="n">mm_access</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* ensure this mm_struct can&#39;t be freed */</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_count</span><span class="p">);</span>
		<span class="cm">/* but do not pin its memory */</span>
		<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* OK to pass negative loff_t, we can catch out-of-range */</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">|=</span> <span class="n">FMODE_UNSIGNED_OFFSET</span><span class="p">;</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">mm</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__mem_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">PTRACE_MODE_ATTACH</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mem_rw</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppos</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">copied</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_TEMPORARY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">free</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">this_len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">this_len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">copied</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">this_len</span> <span class="o">=</span> <span class="n">access_remote_vm</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">this_len</span><span class="p">,</span> <span class="n">write</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copied</span><span class="p">)</span>
				<span class="n">copied</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">this_len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">copied</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">buf</span> <span class="o">+=</span> <span class="n">this_len</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">+=</span> <span class="n">this_len</span><span class="p">;</span>
		<span class="n">copied</span> <span class="o">+=</span> <span class="n">this_len</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">this_len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">ppos</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="nl">free:</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mem_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mem_rw</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mem_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mem_rw</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">loff_t</span> <span class="nf">mem_lseek</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">orig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">orig</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">force_successful_syscall_return</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="p">)</span>
		<span class="n">mmdrop</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_mem_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">mem_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">mem_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">mem_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">mem_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">mem_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">environ_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__mem_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">PTRACE_MODE_READ</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">environ_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">src</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_TEMPORARY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">free</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">this_len</span><span class="p">,</span> <span class="n">retval</span><span class="p">,</span> <span class="n">max_len</span><span class="p">;</span>

		<span class="n">this_len</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">env_end</span> <span class="o">-</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">env_start</span> <span class="o">+</span> <span class="n">src</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">this_len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">max_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">?</span> <span class="n">PAGE_SIZE</span> <span class="o">:</span> <span class="n">count</span><span class="p">;</span>
		<span class="n">this_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">this_len</span> <span class="o">&gt;</span> <span class="n">max_len</span><span class="p">)</span> <span class="o">?</span> <span class="n">max_len</span> <span class="o">:</span> <span class="n">this_len</span><span class="p">;</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">access_remote_vm</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">env_start</span> <span class="o">+</span> <span class="n">src</span><span class="p">),</span>
			<span class="n">page</span><span class="p">,</span> <span class="n">this_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">retval</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">+=</span> <span class="n">retval</span><span class="p">;</span>
		<span class="n">src</span> <span class="o">+=</span> <span class="n">retval</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">retval</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">ppos</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
	<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>

<span class="nl">free:</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_environ_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">environ_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">environ_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">mem_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">oom_adjust_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">PROC_NUMBUF</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">oom_adjust</span> <span class="o">=</span> <span class="n">OOM_DISABLE</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lock_task_sighand</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">oom_adjust</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_adj</span><span class="p">;</span>
		<span class="n">unlock_task_sighand</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oom_adjust</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">oom_adjust_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">PROC_NUMBUF</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">oom_adjust</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">kstrtoint</span><span class="p">(</span><span class="n">strstrip</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oom_adjust</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">oom_adjust</span> <span class="o">&lt;</span> <span class="n">OOM_ADJUST_MIN</span> <span class="o">||</span> <span class="n">oom_adjust</span> <span class="o">&gt;</span> <span class="n">OOM_ADJUST_MAX</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="n">oom_adjust</span> <span class="o">!=</span> <span class="n">OOM_DISABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">task_lock</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_task_lock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lock_task_sighand</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_task_lock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oom_adjust</span> <span class="o">&lt;</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_adj</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_RESOURCE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_sighand</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Warn that /proc/pid/oom_adj is deprecated, see</span>
<span class="cm">	 * Documentation/feature-removal-schedule.txt.</span>
<span class="cm">	 */</span>
	<span class="n">printk_once</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s (%d): /proc/%d/oom_adj is deprecated, please use /proc/%d/oom_score_adj instead.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">),</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">),</span>
		  <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_adj</span> <span class="o">=</span> <span class="n">oom_adjust</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Scale /proc/pid/oom_score_adj appropriately ensuring that a maximum</span>
<span class="cm">	 * value is always attainable.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_adj</span> <span class="o">==</span> <span class="n">OOM_ADJUST_MAX</span><span class="p">)</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_score_adj</span> <span class="o">=</span> <span class="n">OOM_SCORE_ADJ_MAX</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_score_adj</span> <span class="o">=</span> <span class="p">(</span><span class="n">oom_adjust</span> <span class="o">*</span> <span class="n">OOM_SCORE_ADJ_MAX</span><span class="p">)</span> <span class="o">/</span>
								<span class="o">-</span><span class="n">OOM_DISABLE</span><span class="p">;</span>
	<span class="n">trace_oom_score_adj_update</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="nl">err_sighand:</span>
	<span class="n">unlock_task_sighand</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
<span class="nl">err_task_lock:</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">err</span> <span class="o">:</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_oom_adjust_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">oom_adjust_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">oom_adjust_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">oom_score_adj_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
					<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">PROC_NUMBUF</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">oom_score_adj</span> <span class="o">=</span> <span class="n">OOM_SCORE_ADJ_MIN</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lock_task_sighand</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">oom_score_adj</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_score_adj</span><span class="p">;</span>
		<span class="n">unlock_task_sighand</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oom_score_adj</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">oom_score_adj_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
					<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">PROC_NUMBUF</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">oom_score_adj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">kstrtoint</span><span class="p">(</span><span class="n">strstrip</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oom_score_adj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oom_score_adj</span> <span class="o">&lt;</span> <span class="n">OOM_SCORE_ADJ_MIN</span> <span class="o">||</span>
			<span class="n">oom_score_adj</span> <span class="o">&gt;</span> <span class="n">OOM_SCORE_ADJ_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">task_lock</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_task_lock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lock_task_sighand</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_task_lock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oom_score_adj</span> <span class="o">&lt;</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_score_adj_min</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_RESOURCE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_sighand</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_score_adj</span> <span class="o">=</span> <span class="n">oom_score_adj</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">has_capability_noaudit</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">CAP_SYS_RESOURCE</span><span class="p">))</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_score_adj_min</span> <span class="o">=</span> <span class="n">oom_score_adj</span><span class="p">;</span>
	<span class="n">trace_oom_score_adj_update</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Scale /proc/pid/oom_adj appropriately ensuring that OOM_DISABLE is</span>
<span class="cm">	 * always attainable.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_score_adj</span> <span class="o">==</span> <span class="n">OOM_SCORE_ADJ_MIN</span><span class="p">)</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_adj</span> <span class="o">=</span> <span class="n">OOM_DISABLE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_adj</span> <span class="o">=</span> <span class="p">(</span><span class="n">oom_score_adj</span> <span class="o">*</span> <span class="n">OOM_ADJUST_MAX</span><span class="p">)</span> <span class="o">/</span>
							<span class="n">OOM_SCORE_ADJ_MAX</span><span class="p">;</span>
<span class="nl">err_sighand:</span>
	<span class="n">unlock_task_sighand</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
<span class="nl">err_task_lock:</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">err</span> <span class="o">:</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_oom_score_adj_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">oom_score_adj_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">oom_score_adj_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_AUDITSYSCALL</span>
<span class="cp">#define TMPBUFLEN 21</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">proc_loginuid_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">tmpbuf</span><span class="p">[</span><span class="n">TMPBUFLEN</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">tmpbuf</span><span class="p">,</span> <span class="n">TMPBUFLEN</span><span class="p">,</span> <span class="s">&quot;%u&quot;</span><span class="p">,</span>
				<span class="n">audit_get_loginuid</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">tmpbuf</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">proc_loginuid_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
				   <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">loginuid</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="n">pid_task</span><span class="p">(</span><span class="n">proc_pid</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">PIDTYPE_PID</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ppos</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* No partial writes. */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">page</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_TEMPORARY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free_page</span><span class="p">;</span>

	<span class="n">page</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">loginuid</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">length</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_page</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">audit_set_loginuid</span><span class="p">(</span><span class="n">loginuid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

<span class="nl">out_free_page:</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_loginuid_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">proc_loginuid_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">proc_loginuid_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">proc_sessionid_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">tmpbuf</span><span class="p">[</span><span class="n">TMPBUFLEN</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">tmpbuf</span><span class="p">,</span> <span class="n">TMPBUFLEN</span><span class="p">,</span> <span class="s">&quot;%u&quot;</span><span class="p">,</span>
				<span class="n">audit_get_sessionid</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">tmpbuf</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_sessionid_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">proc_sessionid_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_FAULT_INJECTION</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">proc_fault_inject_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
				      <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">PROC_NUMBUF</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">make_it_fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="n">make_it_fail</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">make_it_fail</span><span class="p">;</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="s">&quot;%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">make_it_fail</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">proc_fault_inject_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">PROC_NUMBUF</span><span class="p">],</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">make_it_fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_RESOURCE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">make_it_fail</span> <span class="o">=</span> <span class="n">simple_strtol</span><span class="p">(</span><span class="n">strstrip</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">end</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="n">task</span><span class="o">-&gt;</span><span class="n">make_it_fail</span> <span class="o">=</span> <span class="n">make_it_fail</span><span class="p">;</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_fault_inject_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">proc_fault_inject_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">proc_fault_inject_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>


<span class="cp">#ifdef CONFIG_SCHED_DEBUG</span>
<span class="cm">/*</span>
<span class="cm"> * Print out various scheduling related per-task fields:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sched_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="n">proc_sched_show_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>

	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sched_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
	    <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="n">proc_sched_set_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sched_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">sched_show</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_pid_sched_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">sched_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">sched_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SCHED_AUTOGROUP</span>
<span class="cm">/*</span>
<span class="cm"> * Print out autogroup related information:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sched_autogroup_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="n">proc_sched_autogroup_show_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>

	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sched_autogroup_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
	    <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">PROC_NUMBUF</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">nice</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">kstrtoint</span><span class="p">(</span><span class="n">strstrip</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nice</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">proc_sched_autogroup_set_nice</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nice</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sched_autogroup_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">single_open</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">sched_autogroup_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

		<span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_pid_sched_autogroup_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">sched_autogroup_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">sched_autogroup_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SCHED_AUTOGROUP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">comm_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">TASK_COMM_LEN</span><span class="p">];</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">same_thread_group</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
		<span class="n">set_task_comm</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">count</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">comm_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>

	<span class="n">task_lock</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">comm_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">comm_show</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_pid_set_comm_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">comm_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">comm_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_exe_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">exe_path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">exe_file</span><span class="p">;</span>

	<span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">mm</span> <span class="o">=</span> <span class="n">get_task_mm</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">exe_file</span> <span class="o">=</span> <span class="n">get_mm_exe_file</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exe_file</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">exe_path</span> <span class="o">=</span> <span class="n">exe_file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">;</span>
		<span class="n">path_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exe_file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">);</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">exe_file</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">proc_pid_follow_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="cm">/* We don&#39;t need a base pointer in the /proc filesystem */</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>

	<span class="cm">/* Are we allowed to snoop on the tasks file descriptors? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">proc_fd_access_allowed</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">PROC_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">proc_get_link</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_proc_readlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_TEMPORARY</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">pathname</span> <span class="o">=</span> <span class="n">d_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pathname</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pathname</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">pathname</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">buflen</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">buflen</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="n">len</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_pid_readlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>

	<span class="cm">/* Are we allowed to snoop on the tasks file descriptors? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">proc_fd_access_allowed</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">PROC_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">proc_get_link</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">do_proc_readlink</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">buflen</span><span class="p">);</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">proc_pid_link_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readlink</span>	<span class="o">=</span> <span class="n">proc_pid_readlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">follow_link</span>	<span class="o">=</span> <span class="n">proc_pid_follow_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">proc_setattr</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/* building an inode */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">task_dumpable</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dumpable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>

	<span class="n">task_lock</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">mm</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="p">)</span>
		<span class="n">dumpable</span> <span class="o">=</span> <span class="n">get_dumpable</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">dumpable</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">proc_pid_make_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_inode</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">;</span>

	<span class="cm">/* We need a new inode */</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">new_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Common stuff */</span>
	<span class="n">ei</span> <span class="o">=</span> <span class="n">PROC_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">get_next_ino</span><span class="p">();</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">proc_def_inode_operations</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * grab the reference to task.</span>
<span class="cm">	 */</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">get_task_pid</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">PIDTYPE_PID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task_dumpable</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">cred</span> <span class="o">=</span> <span class="n">__task_cred</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">egid</span><span class="p">;</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">security_task_to_inode</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">pid_getattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstat</span> <span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">pid</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>

	<span class="n">generic_fillattr</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">GLOBAL_ROOT_UID</span><span class="p">;</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">gid</span> <span class="o">=</span> <span class="n">GLOBAL_ROOT_GID</span><span class="p">;</span>
	<span class="n">task</span> <span class="o">=</span> <span class="n">pid_task</span><span class="p">(</span><span class="n">proc_pid</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">PIDTYPE_PID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_pid_permissions</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
			<span class="cm">/*</span>
<span class="cm">			 * This doesn&#39;t prevent learning whether PID exists,</span>
<span class="cm">			 * it only makes getattr() consistent with readdir().</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">==</span> <span class="p">(</span><span class="n">S_IFDIR</span><span class="o">|</span><span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IXUGO</span><span class="p">))</span> <span class="o">||</span>
		    <span class="n">task_dumpable</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cred</span> <span class="o">=</span> <span class="n">__task_cred</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">;</span>
			<span class="n">stat</span><span class="o">-&gt;</span><span class="n">gid</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">egid</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* dentry stuff */</span>

<span class="cm">/*</span>
<span class="cm"> *	Exceptional case: normally we are not allowed to unhash a busy</span>
<span class="cm"> * directory. In this case, however, we can do it - no aliasing problems</span>
<span class="cm"> * due to the way we treat inodes.</span>
<span class="cm"> *</span>
<span class="cm"> * Rewrite the inode&#39;s ownerships here because the owning task may have</span>
<span class="cm"> * performed a setuid(), etc.</span>
<span class="cm"> *</span>
<span class="cm"> * Before the /proc/pid/status file was created the only way to read</span>
<span class="cm"> * the effective uid of a /process was to stat /proc/pid.  Reading</span>
<span class="cm"> * /proc/pid/status is slow enough that procps and other packages</span>
<span class="cm"> * kept stating /proc/pid.  To keep the rules in /proc simple I have</span>
<span class="cm"> * made this apply to all per process world readable and executable</span>
<span class="cm"> * directories.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pid_revalidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span> <span class="o">&amp;&amp;</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_RCU</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">==</span> <span class="p">(</span><span class="n">S_IFDIR</span><span class="o">|</span><span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IXUGO</span><span class="p">))</span> <span class="o">||</span>
		    <span class="n">task_dumpable</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rcu_read_lock</span><span class="p">();</span>
			<span class="n">cred</span> <span class="o">=</span> <span class="n">__task_cred</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">egid</span><span class="p">;</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">GLOBAL_ROOT_UID</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">GLOBAL_ROOT_GID</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">S_ISUID</span> <span class="o">|</span> <span class="n">S_ISGID</span><span class="p">);</span>
		<span class="n">security_task_to_inode</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pid_delete_dentry</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Is the task we represent dead?</span>
<span class="cm">	 * If so, then don&#39;t put the dentry on the lru list,</span>
<span class="cm">	 * kill it immediately.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">proc_pid</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tasks</span><span class="p">[</span><span class="n">PIDTYPE_PID</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="n">pid_dentry_operations</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">d_revalidate</span>	<span class="o">=</span> <span class="n">pid_revalidate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">d_delete</span>	<span class="o">=</span> <span class="n">pid_delete_dentry</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Lookups */</span>

<span class="cm">/*</span>
<span class="cm"> * Fill a directory entry.</span>
<span class="cm"> *</span>
<span class="cm"> * If possible create the dcache entry and derive our inode number and</span>
<span class="cm"> * file type from dcache entry.</span>
<span class="cm"> *</span>
<span class="cm"> * Since all of the proc inode numbers are dynamically generated, the inode</span>
<span class="cm"> * numbers do not exist until the inode is cache.  This means creating the</span>
<span class="cm"> * the dcache entry in readdir is necessary to keep the inode numbers</span>
<span class="cm"> * reported by readdir in sync with the inode numbers reported</span>
<span class="cm"> * by stat.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">proc_fill_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dirent</span><span class="p">,</span> <span class="n">filldir_t</span> <span class="n">filldir</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
	<span class="n">instantiate_t</span> <span class="n">instantiate</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span> <span class="o">*</span><span class="n">dir</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">qname</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">ino</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">type</span> <span class="o">=</span> <span class="n">DT_UNKNOWN</span><span class="p">;</span>

	<span class="n">qname</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">qname</span><span class="p">.</span><span class="n">len</span>  <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">qname</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="n">full_name_hash</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">child</span> <span class="o">=</span> <span class="n">d_lookup</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qname</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">d_alloc</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qname</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">child</span> <span class="o">=</span> <span class="n">instantiate</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="p">)</span>
				<span class="n">dput</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">child</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">child</span> <span class="o">||</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">end_instantiate</span><span class="p">;</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ino</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
<span class="nl">end_instantiate:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ino</span><span class="p">)</span>
		<span class="n">ino</span> <span class="o">=</span> <span class="n">find_inode_number</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qname</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ino</span><span class="p">)</span>
		<span class="n">ino</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">name_to_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">name</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">name</span><span class="o">++</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="o">~</span><span class="mi">0U</span><span class="o">-</span><span class="mi">9</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">n</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="n">n</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="o">~</span><span class="mi">0U</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define PROC_FDINFO_MAX 64</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_fd_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">files</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">proc_fd</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">files</span> <span class="o">=</span> <span class="n">get_files_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">files</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are not taking a ref to the file structure, so we must</span>
<span class="cm">		 * hold -&gt;file_lock.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">file_lock</span><span class="p">);</span>
		<span class="n">file</span> <span class="o">=</span> <span class="n">fcheck_files</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">f_flags</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">fdtable</span> <span class="o">*</span><span class="n">fdt</span><span class="p">;</span>

			<span class="n">fdt</span> <span class="o">=</span> <span class="n">files_fdtable</span><span class="p">(</span><span class="n">files</span><span class="p">);</span>
			<span class="n">f_flags</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">O_CLOEXEC</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">close_on_exec</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">fdt</span><span class="p">))</span>
				<span class="n">f_flags</span> <span class="o">|=</span> <span class="n">O_CLOEXEC</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">;</span>
				<span class="n">path_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">)</span>
				<span class="n">snprintf</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">PROC_FDINFO_MAX</span><span class="p">,</span>
					 <span class="s">&quot;pos:</span><span class="se">\t</span><span class="s">%lli</span><span class="se">\n</span><span class="s">&quot;</span>
					 <span class="s">&quot;flags:</span><span class="se">\t</span><span class="s">0%o</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">,</span>
					 <span class="n">f_flags</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">file_lock</span><span class="p">);</span>
			<span class="n">put_files_struct</span><span class="p">(</span><span class="n">files</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">file_lock</span><span class="p">);</span>
		<span class="n">put_files_struct</span><span class="p">(</span><span class="n">files</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_fd_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">proc_fd_info</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tid_fd_revalidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">files</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span> <span class="o">&amp;&amp;</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_RCU</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">fd</span> <span class="o">=</span> <span class="n">proc_fd</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">files</span> <span class="o">=</span> <span class="n">get_files_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">files</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
			<span class="n">rcu_read_lock</span><span class="p">();</span>
			<span class="n">file</span> <span class="o">=</span> <span class="n">fcheck_files</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">unsigned</span> <span class="n">f_mode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span><span class="p">;</span>

				<span class="n">rcu_read_unlock</span><span class="p">();</span>
				<span class="n">put_files_struct</span><span class="p">(</span><span class="n">files</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">task_dumpable</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">rcu_read_lock</span><span class="p">();</span>
					<span class="n">cred</span> <span class="o">=</span> <span class="n">__task_cred</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
					<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">;</span>
					<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">egid</span><span class="p">;</span>
					<span class="n">rcu_read_unlock</span><span class="p">();</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">GLOBAL_ROOT_UID</span><span class="p">;</span>
					<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">GLOBAL_ROOT_GID</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
					<span class="kt">unsigned</span> <span class="n">i_mode</span> <span class="o">=</span> <span class="n">S_IFLNK</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span>
						<span class="n">i_mode</span> <span class="o">|=</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IXUSR</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span>
						<span class="n">i_mode</span> <span class="o">|=</span> <span class="n">S_IWUSR</span> <span class="o">|</span> <span class="n">S_IXUSR</span><span class="p">;</span>
					<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">i_mode</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">security_task_to_inode</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
				<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
			<span class="n">put_files_struct</span><span class="p">(</span><span class="n">files</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="n">tid_fd_dentry_operations</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">.</span><span class="n">d_revalidate</span>	<span class="o">=</span> <span class="n">tid_fd_revalidate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">d_delete</span>	<span class="o">=</span> <span class="n">pid_delete_dentry</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">proc_fd_instantiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">fd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
 	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
 	<span class="k">struct</span> <span class="n">proc_inode</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">proc_pid_make_inode</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">ei</span> <span class="o">=</span> <span class="n">PROC_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">S_IFLNK</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">proc_pid_link_inode_operations</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">proc_get_link</span> <span class="o">=</span> <span class="n">proc_fd_link</span><span class="p">;</span>
	<span class="n">d_set_d_op</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tid_fd_dentry_operations</span><span class="p">);</span>
	<span class="n">d_add</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="cm">/* Close the race of the process dying before we return the dentry */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tid_fd_revalidate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">proc_lookupfd_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
					   <span class="n">instantiate_t</span> <span class="n">instantiate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">name_to_int</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_task</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">~</span><span class="mi">0U</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">instantiate</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fd</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="nl">out_no_task:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_readfd_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">dirent</span><span class="p">,</span>
			      <span class="n">filldir_t</span> <span class="n">filldir</span><span class="p">,</span> <span class="n">instantiate_t</span> <span class="n">instantiate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">ino</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span> <span class="n">files</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_task</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fd</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="s">&quot;.&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">DT_DIR</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="o">++</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">ino</span> <span class="o">=</span> <span class="n">parent_ino</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="s">&quot;..&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">DT_DIR</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="o">++</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">files</span> <span class="o">=</span> <span class="n">get_files_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">files</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">rcu_read_lock</span><span class="p">();</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">fd</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>
			     <span class="n">fd</span> <span class="o">&lt;</span> <span class="n">files_fdtable</span><span class="p">(</span><span class="n">files</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">max_fds</span><span class="p">;</span>
			     <span class="n">fd</span><span class="o">++</span><span class="p">,</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">PROC_NUMBUF</span><span class="p">];</span>
				<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
				<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fcheck_files</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">fd</span><span class="p">))</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="n">rcu_read_unlock</span><span class="p">();</span>

				<span class="n">len</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
				<span class="n">rv</span> <span class="o">=</span> <span class="n">proc_fill_cache</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">dirent</span><span class="p">,</span> <span class="n">filldir</span><span class="p">,</span>
						     <span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">instantiate</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
						     <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fd</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out_fd_loop</span><span class="p">;</span>
				<span class="n">rcu_read_lock</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="nl">out_fd_loop:</span>
			<span class="n">put_files_struct</span><span class="p">(</span><span class="n">files</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="nl">out_no_task:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">proc_lookupfd</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">proc_lookupfd_common</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">proc_fd_instantiate</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_readfd</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dirent</span><span class="p">,</span> <span class="n">filldir_t</span> <span class="n">filldir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">proc_readfd_common</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">dirent</span><span class="p">,</span> <span class="n">filldir</span><span class="p">,</span> <span class="n">proc_fd_instantiate</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">proc_fdinfo_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				      <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">tmp</span><span class="p">[</span><span class="n">PROC_FDINFO_MAX</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">proc_fd_info</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_fdinfo_file_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>           <span class="o">=</span> <span class="n">nonseekable_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">proc_fdinfo_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_fd_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">generic_read_dir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readdir</span>	<span class="o">=</span> <span class="n">proc_readfd</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_CHECKPOINT_RESTORE</span>

<span class="cm">/*</span>
<span class="cm"> * dname_to_vma_addr - maps a dentry name into two unsigned longs</span>
<span class="cm"> * which represent vma start and end addresses.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dname_to_vma_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;%lx-%lx&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">map_files_d_revalidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_start</span><span class="p">,</span> <span class="n">vm_end</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">exact_vma_exists</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span> <span class="o">&amp;&amp;</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_RCU</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_notask</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_notask</span><span class="p">;</span>

	<span class="n">mm</span> <span class="o">=</span> <span class="n">mm_access</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">PTRACE_MODE_READ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dname_to_vma_addr</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vm_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vm_end</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="n">exact_vma_exists</span> <span class="o">=</span> <span class="o">!!</span><span class="n">find_exact_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vm_start</span><span class="p">,</span> <span class="n">vm_end</span><span class="p">);</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">exact_vma_exists</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task_dumpable</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rcu_read_lock</span><span class="p">();</span>
			<span class="n">cred</span> <span class="o">=</span> <span class="n">__task_cred</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">egid</span><span class="p">;</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">GLOBAL_ROOT_UID</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">GLOBAL_ROOT_GID</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">security_task_to_inode</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

<span class="nl">out_notask:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="n">tid_map_files_dentry_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">d_revalidate</span>	<span class="o">=</span> <span class="n">map_files_d_revalidate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">d_delete</span>	<span class="o">=</span> <span class="n">pid_delete_dentry</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_map_files_get_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_start</span><span class="p">,</span> <span class="n">vm_end</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">mm</span> <span class="o">=</span> <span class="n">get_task_mm</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">dname_to_vma_addr</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vm_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vm_end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_mmput</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_exact_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vm_start</span><span class="p">,</span> <span class="n">vm_end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">;</span>
		<span class="n">path_get</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

<span class="nl">out_mmput:</span>
	<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">map_files_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span>	<span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">name</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span> <span class="cm">/* max: %lx-%lx\0 */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span>
<span class="nf">proc_map_files_instantiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_inode</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">proc_pid_make_inode</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>

	<span class="n">ei</span> <span class="o">=</span> <span class="n">PROC_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">proc_get_link</span> <span class="o">=</span> <span class="n">proc_map_files_get_link</span><span class="p">;</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">proc_pid_link_inode_operations</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">S_IFLNK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">|=</span> <span class="n">S_IRUSR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">|=</span> <span class="n">S_IWUSR</span><span class="p">;</span>

	<span class="n">d_set_d_op</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tid_map_files_dentry_operations</span><span class="p">);</span>
	<span class="n">d_add</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">proc_map_files_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_start</span><span class="p">,</span> <span class="n">vm_end</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EACCES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>
	<span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EACCES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptrace_may_access</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">PTRACE_MODE_READ</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_put_task</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dname_to_vma_addr</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vm_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vm_end</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_put_task</span><span class="p">;</span>

	<span class="n">mm</span> <span class="o">=</span> <span class="n">get_task_mm</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put_task</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_exact_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vm_start</span><span class="p">,</span> <span class="n">vm_end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_vma</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">proc_map_files_instantiate</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">);</span>

<span class="nl">out_no_vma:</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="nl">out_put_task:</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">proc_map_files_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">lookup</span>		<span class="o">=</span> <span class="n">proc_map_files_lookup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">permission</span>	<span class="o">=</span> <span class="n">proc_fd_permission</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">proc_setattr</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">proc_map_files_readdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dirent</span><span class="p">,</span> <span class="n">filldir_t</span> <span class="n">filldir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">ino</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptrace_may_access</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">PTRACE_MODE_READ</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_put_task</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">ino</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="s">&quot;.&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">DT_DIR</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_put_task</span><span class="p">;</span>
		<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="o">++</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">ino</span> <span class="o">=</span> <span class="n">parent_ino</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="s">&quot;..&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">DT_DIR</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_put_task</span><span class="p">;</span>
		<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="o">++</span><span class="p">;</span>
	<span class="nl">default:</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_files</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">flex_array</span> <span class="o">*</span><span class="n">fa</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">map_files_info</span> <span class="n">info</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">map_files_info</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

		<span class="n">mm</span> <span class="o">=</span> <span class="n">get_task_mm</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_put_task</span><span class="p">;</span>
		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

		<span class="n">nr_files</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We need two passes here:</span>
<span class="cm">		 *</span>
<span class="cm">		 *  1) Collect vmas of mapped files with mmap_sem taken</span>
<span class="cm">		 *  2) Release mmap_sem and instantiate entries</span>
<span class="cm">		 *</span>
<span class="cm">		 * otherwise we get lockdep complained, since filldir()</span>
<span class="cm">		 * routine might require mmap_sem taken in might_fault().</span>
<span class="cm">		 */</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">vma</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">vma</span><span class="p">;</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">&amp;&amp;</span> <span class="o">++</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">)</span>
				<span class="n">nr_files</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nr_files</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fa</span> <span class="o">=</span> <span class="n">flex_array_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="p">),</span> <span class="n">nr_files</span><span class="p">,</span>
						<span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fa</span> <span class="o">||</span> <span class="n">flex_array_prealloc</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nr_files</span><span class="p">,</span>
							<span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">fa</span><span class="p">)</span>
					<span class="n">flex_array_free</span><span class="p">(</span><span class="n">fa</span><span class="p">);</span>
				<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
				<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_put_task</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">vma</span><span class="p">;</span>
					<span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>

				<span class="n">get_file</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">);</span>
				<span class="n">info</span><span class="p">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">;</span>
				<span class="n">info</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">name</span><span class="p">),</span> <span class="s">&quot;%lx-%lx&quot;</span><span class="p">,</span>
						<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">flex_array_put</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
					<span class="n">BUG</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_files</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">flex_array_get</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">proc_fill_cache</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">dirent</span><span class="p">,</span> <span class="n">filldir</span><span class="p">,</span>
					      <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
					      <span class="n">proc_map_files_instantiate</span><span class="p">,</span>
					      <span class="n">task</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="o">++</span><span class="p">;</span>
			<span class="n">fput</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_files</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * In case of error don&#39;t forget</span>
<span class="cm">			 * to put rest of file refs.</span>
<span class="cm">			 */</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">flex_array_get</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">fput</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fa</span><span class="p">)</span>
			<span class="n">flex_array_free</span><span class="p">(</span><span class="n">fa</span><span class="p">);</span>
		<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out_put_task:</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_map_files_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">generic_read_dir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readdir</span>	<span class="o">=</span> <span class="n">proc_map_files_readdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_CHECKPOINT_RESTORE */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * /proc/pid/fd needs a special permission handler so that a process can still</span>
<span class="cm"> * access /proc/self/fd after it has executed a setuid().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_fd_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="n">generic_permission</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task_pid</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">==</span> <span class="n">proc_pid</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * proc directories can do almost nothing..</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">proc_fd_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">lookup</span>		<span class="o">=</span> <span class="n">proc_lookupfd</span><span class="p">,</span>
	<span class="p">.</span><span class="n">permission</span>	<span class="o">=</span> <span class="n">proc_fd_permission</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">proc_setattr</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">proc_fdinfo_instantiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">fd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
 	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
 	<span class="k">struct</span> <span class="n">proc_inode</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">proc_pid_make_inode</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">ei</span> <span class="o">=</span> <span class="n">PROC_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="n">S_IRUSR</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">proc_fdinfo_file_operations</span><span class="p">;</span>
	<span class="n">d_set_d_op</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tid_fd_dentry_operations</span><span class="p">);</span>
	<span class="n">d_add</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="cm">/* Close the race of the process dying before we return the dentry */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tid_fd_revalidate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">proc_lookupfdinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">proc_lookupfd_common</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">proc_fdinfo_instantiate</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_readfdinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dirent</span><span class="p">,</span> <span class="n">filldir_t</span> <span class="n">filldir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">proc_readfd_common</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">dirent</span><span class="p">,</span> <span class="n">filldir</span><span class="p">,</span>
				  <span class="n">proc_fdinfo_instantiate</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_fdinfo_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">generic_read_dir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readdir</span>	<span class="o">=</span> <span class="n">proc_readfdinfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * proc directories can do almost nothing..</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">proc_fdinfo_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">lookup</span>		<span class="o">=</span> <span class="n">proc_lookupfdinfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">proc_setattr</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">proc_pident_instantiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pid_entry</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_inode</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">proc_pid_make_inode</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ei</span> <span class="o">=</span> <span class="n">PROC_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>	<span class="cm">/* Use getattr to fix if necessary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">iop</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">iop</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fop</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">fop</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">;</span>
	<span class="n">d_set_d_op</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pid_dentry_operations</span><span class="p">);</span>
	<span class="n">d_add</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="cm">/* Close the race of the process dying before we return the dentry */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid_revalidate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">proc_pident_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> 
					 <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">pid_entry</span> <span class="o">*</span><span class="n">ents</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pid_entry</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_task</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Yes, it does not scale. And it should not. Don&#39;t add</span>
<span class="cm">	 * new entries into /proc/&lt;tgid&gt;/ without very good reasons.</span>
<span class="cm">	 */</span>
	<span class="n">last</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ents</span><span class="p">[</span><span class="n">nents</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">ents</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">last</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">!=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">last</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">proc_pident_instantiate</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="nl">out_no_task:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_pident_fill_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dirent</span><span class="p">,</span>
	<span class="n">filldir_t</span> <span class="n">filldir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pid_entry</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">proc_fill_cache</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">dirent</span><span class="p">,</span> <span class="n">filldir</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				<span class="n">proc_pident_instantiate</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_pident_readdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">dirent</span><span class="p">,</span> <span class="n">filldir_t</span> <span class="n">filldir</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">pid_entry</span> <span class="o">*</span><span class="n">ents</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nents</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pid_entry</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">ino</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_task</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">ino</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="s">&quot;.&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">DT_DIR</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">ino</span> <span class="o">=</span> <span class="n">parent_ino</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="s">&quot;..&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">DT_DIR</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="nl">default:</span>
		<span class="n">i</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">nents</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">ents</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">last</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ents</span><span class="p">[</span><span class="n">nents</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;=</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">proc_pident_fill_cache</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">dirent</span><span class="p">,</span> <span class="n">filldir</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="o">++</span><span class="p">;</span>
			<span class="n">p</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="nl">out_no_task:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SECURITY</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">proc_pid_attr_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">length</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>

	<span class="n">length</span> <span class="o">=</span> <span class="n">security_getprocattr</span><span class="p">(</span><span class="n">task</span><span class="p">,</span>
				      <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">proc_pid_attr_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
				   <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">length</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">length</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_task</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

	<span class="cm">/* No partial writes. */</span>
	<span class="n">length</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ppos</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">length</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_TEMPORARY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">length</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="cm">/* Guard against adverse ptrace interaction */</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cred_guard_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">length</span> <span class="o">=</span> <span class="n">security_setprocattr</span><span class="p">(</span><span class="n">task</span><span class="p">,</span>
				      <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
				      <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">page</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cred_guard_mutex</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">page</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="nl">out_no_task:</span>
	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_pid_attr_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">proc_pid_attr_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">proc_pid_attr_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pid_entry</span> <span class="n">attr_dir_stuff</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;current&quot;</span><span class="p">,</span>    <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUGO</span><span class="p">,</span> <span class="n">proc_pid_attr_operations</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;prev&quot;</span><span class="p">,</span>       <span class="n">S_IRUGO</span><span class="p">,</span>	   <span class="n">proc_pid_attr_operations</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;exec&quot;</span><span class="p">,</span>       <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUGO</span><span class="p">,</span> <span class="n">proc_pid_attr_operations</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;fscreate&quot;</span><span class="p">,</span>   <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUGO</span><span class="p">,</span> <span class="n">proc_pid_attr_operations</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;keycreate&quot;</span><span class="p">,</span>  <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUGO</span><span class="p">,</span> <span class="n">proc_pid_attr_operations</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;sockcreate&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUGO</span><span class="p">,</span> <span class="n">proc_pid_attr_operations</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_attr_dir_readdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">filp</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="o">*</span> <span class="n">dirent</span><span class="p">,</span> <span class="n">filldir_t</span> <span class="n">filldir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">proc_pident_readdir</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span><span class="n">dirent</span><span class="p">,</span><span class="n">filldir</span><span class="p">,</span>
				   <span class="n">attr_dir_stuff</span><span class="p">,</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">attr_dir_stuff</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_attr_dir_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">generic_read_dir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readdir</span>	<span class="o">=</span> <span class="n">proc_attr_dir_readdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">proc_attr_dir_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">proc_pident_lookup</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span>
				  <span class="n">attr_dir_stuff</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">attr_dir_stuff</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">proc_attr_dir_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">lookup</span>		<span class="o">=</span> <span class="n">proc_attr_dir_lookup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getattr</span>	<span class="o">=</span> <span class="n">pid_getattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">proc_setattr</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_ELF_CORE</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">proc_coredump_filter_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
					 <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">PROC_NUMBUF</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mm</span> <span class="o">=</span> <span class="n">get_task_mm</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="s">&quot;%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">((</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MMF_DUMP_FILTER_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
				<span class="n">MMF_DUMP_FILTER_SHIFT</span><span class="p">));</span>
		<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">proc_coredump_filter_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
					  <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
					  <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
					  <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">PROC_NUMBUF</span><span class="p">],</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_no_task</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">simple_strtoul</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">end</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
		<span class="n">end</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">buffer</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_task</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_task</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">buffer</span><span class="p">;</span>
	<span class="n">mm</span> <span class="o">=</span> <span class="n">get_task_mm</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_mm</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MMF_DUMP_FILTER_BITS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">mask</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">MMF_DUMP_FILTER_SHIFT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">MMF_DUMP_FILTER_SHIFT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
 <span class="nl">out_no_mm:</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
 <span class="nl">out_no_task:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_coredump_filter_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">proc_coredump_filter_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">proc_coredump_filter_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * /proc/self:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_self_readlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">tgid</span> <span class="o">=</span> <span class="n">task_tgid_nr_ns</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">ns</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">tmp</span><span class="p">[</span><span class="n">PROC_NUMBUF</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tgid</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">tgid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">vfs_readlink</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span><span class="n">buffer</span><span class="p">,</span><span class="n">buflen</span><span class="p">,</span><span class="n">tmp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">proc_self_follow_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">tgid</span> <span class="o">=</span> <span class="n">task_tgid_nr_ns</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">ns</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tgid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">__getname</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span>
			<span class="n">name</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">tgid</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">nd_set_link</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">proc_self_put_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">nd_get_link</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
		<span class="n">__putname</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">proc_self_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readlink</span>	<span class="o">=</span> <span class="n">proc_self_readlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">follow_link</span>	<span class="o">=</span> <span class="n">proc_self_follow_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put_link</span>	<span class="o">=</span> <span class="n">proc_self_put_link</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * proc base</span>
<span class="cm"> *</span>
<span class="cm"> * These are the directory entries in the root directory of /proc</span>
<span class="cm"> * that properly belong to the /proc filesystem, as they describe</span>
<span class="cm"> * describe something that is process related.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pid_entry</span> <span class="n">proc_base_stuff</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">NOD</span><span class="p">(</span><span class="s">&quot;self&quot;</span><span class="p">,</span> <span class="n">S_IFLNK</span><span class="o">|</span><span class="n">S_IRWXUGO</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">proc_self_inode_operations</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">{}),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">proc_base_instantiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pid_entry</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">proc_inode</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">error</span><span class="p">;</span>

	<span class="cm">/* Allocate the inode */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">new_inode</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Initialize the inode */</span>
	<span class="n">ei</span> <span class="o">=</span> <span class="n">PROC_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">get_next_ino</span><span class="p">();</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * grab the reference to the task.</span>
<span class="cm">	 */</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">get_task_pid</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">PIDTYPE_PID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_iput</span><span class="p">;</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">iop</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">iop</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fop</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">fop</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">;</span>
	<span class="n">d_add</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_iput:</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">proc_base_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pid_entry</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_task</span><span class="p">;</span>

	<span class="cm">/* Lookup the directory entry */</span>
	<span class="n">last</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">proc_base_stuff</span><span class="p">[</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">proc_base_stuff</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">proc_base_stuff</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">last</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">!=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">last</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">proc_base_instantiate</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="nl">out_no_task:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_base_fill_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dirent</span><span class="p">,</span>
	<span class="n">filldir_t</span> <span class="n">filldir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pid_entry</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">proc_fill_cache</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">dirent</span><span class="p">,</span> <span class="n">filldir</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				<span class="n">proc_base_instantiate</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_TASK_IO_ACCOUNTING</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_io_accounting</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">whole</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_io_accounting</span> <span class="n">acct</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">ioac</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">mutex_lock_killable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cred_guard_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptrace_may_access</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">PTRACE_MODE_READ</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">whole</span> <span class="o">&amp;&amp;</span> <span class="n">lock_task_sighand</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">task</span><span class="p">;</span>

		<span class="n">task_io_accounting_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">acct</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">ioac</span><span class="p">);</span>
		<span class="n">while_each_thread</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
			<span class="n">task_io_accounting_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">acct</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ioac</span><span class="p">);</span>

		<span class="n">unlock_task_sighand</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span>
			<span class="s">&quot;rchar: %llu</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;wchar: %llu</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;syscr: %llu</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;syscw: %llu</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;read_bytes: %llu</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;write_bytes: %llu</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;cancelled_write_bytes: %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">acct</span><span class="p">.</span><span class="n">rchar</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">acct</span><span class="p">.</span><span class="n">wchar</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">acct</span><span class="p">.</span><span class="n">syscr</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">acct</span><span class="p">.</span><span class="n">syscw</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">acct</span><span class="p">.</span><span class="n">read_bytes</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">acct</span><span class="p">.</span><span class="n">write_bytes</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">acct</span><span class="p">.</span><span class="n">cancelled_write_bytes</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cred_guard_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_tid_io_accounting</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">do_io_accounting</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_tgid_io_accounting</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">do_io_accounting</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_TASK_IO_ACCOUNTING */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_USER_NS</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_id_map_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">seq_operations</span> <span class="o">*</span><span class="n">seq_ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">ns</span> <span class="o">=</span> <span class="n">get_user_ns</span><span class="p">(</span><span class="n">task_cred_xxx</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">user_ns</span><span class="p">));</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">seq_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_put_ns</span><span class="p">;</span>

	<span class="n">seq</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">ns</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err_put_ns:</span>
	<span class="n">put_user_ns</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
<span class="nl">err:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_id_map_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">put_user_ns</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">seq_release</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_uid_map_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">proc_id_map_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_uid_seq_operations</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_gid_map_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">proc_id_map_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_gid_seq_operations</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_uid_map_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">proc_uid_map_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">proc_uid_map_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">proc_id_map_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_gid_map_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">proc_gid_map_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">proc_gid_map_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">proc_id_map_release</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_USER_NS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_pid_personality</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">lock_trace</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">personality</span><span class="p">);</span>
		<span class="n">unlock_trace</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Thread groups</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_task_operations</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">proc_task_inode_operations</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pid_entry</span> <span class="n">tgid_base_stuff</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="kt">DIR</span><span class="p">(</span><span class="s">&quot;task&quot;</span><span class="p">,</span>       <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IXUGO</span><span class="p">,</span> <span class="n">proc_task_inode_operations</span><span class="p">,</span> <span class="n">proc_task_operations</span><span class="p">),</span>
	<span class="kt">DIR</span><span class="p">(</span><span class="s">&quot;fd&quot;</span><span class="p">,</span>         <span class="n">S_IRUSR</span><span class="o">|</span><span class="n">S_IXUSR</span><span class="p">,</span> <span class="n">proc_fd_inode_operations</span><span class="p">,</span> <span class="n">proc_fd_operations</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_CHECKPOINT_RESTORE</span>
	<span class="kt">DIR</span><span class="p">(</span><span class="s">&quot;map_files&quot;</span><span class="p">,</span>  <span class="n">S_IRUSR</span><span class="o">|</span><span class="n">S_IXUSR</span><span class="p">,</span> <span class="n">proc_map_files_inode_operations</span><span class="p">,</span> <span class="n">proc_map_files_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
	<span class="kt">DIR</span><span class="p">(</span><span class="s">&quot;fdinfo&quot;</span><span class="p">,</span>     <span class="n">S_IRUSR</span><span class="o">|</span><span class="n">S_IXUSR</span><span class="p">,</span> <span class="n">proc_fdinfo_inode_operations</span><span class="p">,</span> <span class="n">proc_fdinfo_operations</span><span class="p">),</span>
	<span class="kt">DIR</span><span class="p">(</span><span class="s">&quot;ns&quot;</span><span class="p">,</span>	  <span class="n">S_IRUSR</span><span class="o">|</span><span class="n">S_IXUGO</span><span class="p">,</span> <span class="n">proc_ns_dir_inode_operations</span><span class="p">,</span> <span class="n">proc_ns_dir_operations</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_NET</span>
	<span class="kt">DIR</span><span class="p">(</span><span class="s">&quot;net&quot;</span><span class="p">,</span>        <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IXUGO</span><span class="p">,</span> <span class="n">proc_net_inode_operations</span><span class="p">,</span> <span class="n">proc_net_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;environ&quot;</span><span class="p">,</span>    <span class="n">S_IRUSR</span><span class="p">,</span> <span class="n">proc_environ_operations</span><span class="p">),</span>
	<span class="n">INF</span><span class="p">(</span><span class="s">&quot;auxv&quot;</span><span class="p">,</span>       <span class="n">S_IRUSR</span><span class="p">,</span> <span class="n">proc_pid_auxv</span><span class="p">),</span>
	<span class="n">ONE</span><span class="p">(</span><span class="s">&quot;status&quot;</span><span class="p">,</span>     <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pid_status</span><span class="p">),</span>
	<span class="n">ONE</span><span class="p">(</span><span class="s">&quot;personality&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pid_personality</span><span class="p">),</span>
	<span class="n">INF</span><span class="p">(</span><span class="s">&quot;limits&quot;</span><span class="p">,</span>	  <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pid_limits</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_SCHED_DEBUG</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;sched&quot;</span><span class="p">,</span>      <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">proc_pid_sched_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SCHED_AUTOGROUP</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;autogroup&quot;</span><span class="p">,</span>  <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">proc_pid_sched_autogroup_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;comm&quot;</span><span class="p">,</span>      <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">proc_pid_set_comm_operations</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_HAVE_ARCH_TRACEHOOK</span>
	<span class="n">INF</span><span class="p">(</span><span class="s">&quot;syscall&quot;</span><span class="p">,</span>    <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pid_syscall</span><span class="p">),</span>
<span class="cp">#endif</span>
	<span class="n">INF</span><span class="p">(</span><span class="s">&quot;cmdline&quot;</span><span class="p">,</span>    <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pid_cmdline</span><span class="p">),</span>
	<span class="n">ONE</span><span class="p">(</span><span class="s">&quot;stat&quot;</span><span class="p">,</span>       <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_tgid_stat</span><span class="p">),</span>
	<span class="n">ONE</span><span class="p">(</span><span class="s">&quot;statm&quot;</span><span class="p">,</span>      <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pid_statm</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;maps&quot;</span><span class="p">,</span>       <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pid_maps_operations</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;numa_maps&quot;</span><span class="p">,</span>  <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pid_numa_maps_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;mem&quot;</span><span class="p">,</span>        <span class="n">S_IRUSR</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">proc_mem_operations</span><span class="p">),</span>
	<span class="n">LNK</span><span class="p">(</span><span class="s">&quot;cwd&quot;</span><span class="p">,</span>        <span class="n">proc_cwd_link</span><span class="p">),</span>
	<span class="n">LNK</span><span class="p">(</span><span class="s">&quot;root&quot;</span><span class="p">,</span>       <span class="n">proc_root_link</span><span class="p">),</span>
	<span class="n">LNK</span><span class="p">(</span><span class="s">&quot;exe&quot;</span><span class="p">,</span>        <span class="n">proc_exe_link</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;mounts&quot;</span><span class="p">,</span>     <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_mounts_operations</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;mountinfo&quot;</span><span class="p">,</span>  <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_mountinfo_operations</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;mountstats&quot;</span><span class="p">,</span> <span class="n">S_IRUSR</span><span class="p">,</span> <span class="n">proc_mountstats_operations</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_PROC_PAGE_MONITOR</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;clear_refs&quot;</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">proc_clear_refs_operations</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;smaps&quot;</span><span class="p">,</span>      <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pid_smaps_operations</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;pagemap&quot;</span><span class="p">,</span>    <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pagemap_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SECURITY</span>
	<span class="kt">DIR</span><span class="p">(</span><span class="s">&quot;attr&quot;</span><span class="p">,</span>       <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IXUGO</span><span class="p">,</span> <span class="n">proc_attr_dir_inode_operations</span><span class="p">,</span> <span class="n">proc_attr_dir_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_KALLSYMS</span>
	<span class="n">INF</span><span class="p">(</span><span class="s">&quot;wchan&quot;</span><span class="p">,</span>      <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pid_wchan</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_STACKTRACE</span>
	<span class="n">ONE</span><span class="p">(</span><span class="s">&quot;stack&quot;</span><span class="p">,</span>      <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pid_stack</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SCHEDSTATS</span>
	<span class="n">INF</span><span class="p">(</span><span class="s">&quot;schedstat&quot;</span><span class="p">,</span>  <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pid_schedstat</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_LATENCYTOP</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;latency&quot;</span><span class="p">,</span>  <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_lstats_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_PROC_PID_CPUSET</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;cpuset&quot;</span><span class="p">,</span>     <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_cpuset_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_CGROUPS</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;cgroup&quot;</span><span class="p">,</span>  <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_cgroup_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
	<span class="n">INF</span><span class="p">(</span><span class="s">&quot;oom_score&quot;</span><span class="p">,</span>  <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_oom_score</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;oom_adj&quot;</span><span class="p">,</span>    <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">proc_oom_adjust_operations</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;oom_score_adj&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">proc_oom_score_adj_operations</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_AUDITSYSCALL</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;loginuid&quot;</span><span class="p">,</span>   <span class="n">S_IWUSR</span><span class="o">|</span><span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_loginuid_operations</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;sessionid&quot;</span><span class="p">,</span>  <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_sessionid_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_FAULT_INJECTION</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;make-it-fail&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">proc_fault_inject_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_ELF_CORE</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;coredump_filter&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">proc_coredump_filter_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_TASK_IO_ACCOUNTING</span>
	<span class="n">INF</span><span class="p">(</span><span class="s">&quot;io&quot;</span><span class="p">,</span>	<span class="n">S_IRUSR</span><span class="p">,</span> <span class="n">proc_tgid_io_accounting</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_HARDWALL</span>
	<span class="n">INF</span><span class="p">(</span><span class="s">&quot;hardwall&quot;</span><span class="p">,</span>   <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pid_hardwall</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_USER_NS</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;uid_map&quot;</span><span class="p">,</span>    <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">proc_uid_map_operations</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;gid_map&quot;</span><span class="p">,</span>    <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">proc_gid_map_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_tgid_base_readdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">filp</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="o">*</span> <span class="n">dirent</span><span class="p">,</span> <span class="n">filldir_t</span> <span class="n">filldir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">proc_pident_readdir</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span><span class="n">dirent</span><span class="p">,</span><span class="n">filldir</span><span class="p">,</span>
				   <span class="n">tgid_base_stuff</span><span class="p">,</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">tgid_base_stuff</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_tgid_base_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">generic_read_dir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readdir</span>	<span class="o">=</span> <span class="n">proc_tgid_base_readdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">proc_tgid_base_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">){</span>
	<span class="k">return</span> <span class="n">proc_pident_lookup</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span>
				  <span class="n">tgid_base_stuff</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">tgid_base_stuff</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">proc_tgid_base_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">lookup</span>		<span class="o">=</span> <span class="n">proc_tgid_base_lookup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getattr</span>	<span class="o">=</span> <span class="n">pid_getattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">proc_setattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">permission</span>	<span class="o">=</span> <span class="n">proc_pid_permission</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">proc_flush_task_mnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="n">pid_t</span> <span class="n">tgid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="o">*</span><span class="n">leader</span><span class="p">,</span> <span class="o">*</span><span class="n">dir</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">PROC_NUMBUF</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">name</span><span class="p">;</span>

	<span class="n">name</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">name</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
	<span class="n">dentry</span> <span class="o">=</span> <span class="n">d_hash_and_lookup</span><span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shrink_dcache_parent</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">name</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">name</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">tgid</span><span class="p">);</span>
	<span class="n">leader</span> <span class="o">=</span> <span class="n">d_hash_and_lookup</span><span class="p">(</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">leader</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">name</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;task&quot;</span><span class="p">;</span>
	<span class="n">name</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="n">dir</span> <span class="o">=</span> <span class="n">d_hash_and_lookup</span><span class="p">(</span><span class="n">leader</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put_leader</span><span class="p">;</span>

	<span class="n">name</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">name</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
	<span class="n">dentry</span> <span class="o">=</span> <span class="n">d_hash_and_lookup</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shrink_dcache_parent</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dput</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
<span class="nl">out_put_leader:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">leader</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * proc_flush_task -  Remove dcache entries for @task from the /proc dcache.</span>
<span class="cm"> * @task: task that should be flushed.</span>
<span class="cm"> *</span>
<span class="cm"> * When flushing dentries from proc, one needs to flush them from global</span>
<span class="cm"> * proc (proc_mnt) and from all the namespaces&#39; procs this task was seen</span>
<span class="cm"> * in. This call is supposed to do all of this job.</span>
<span class="cm"> *</span>
<span class="cm"> * Looks in the dcache for</span>
<span class="cm"> * /proc/@pid</span>
<span class="cm"> * /proc/@tgid/task/@pid</span>
<span class="cm"> * if either directory is present flushes it and all of it&#39;ts children</span>
<span class="cm"> * from the dcache.</span>
<span class="cm"> *</span>
<span class="cm"> * It is safe and reasonable to cache /proc entries for a task until</span>
<span class="cm"> * that task exits.  After that they just clog up the dcache with</span>
<span class="cm"> * useless entries, possibly causing useful dcache entries to be</span>
<span class="cm"> * flushed instead.  This routine is proved to flush those useless</span>
<span class="cm"> * dcache entries at process exit time.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: This routine is just an optimization so it does not guarantee</span>
<span class="cm"> *       that no dcache entries will exist at process exit time it</span>
<span class="cm"> *       just makes it very unlikely that any will persist.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">proc_flush_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">,</span> <span class="o">*</span><span class="n">tgid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">upid</span> <span class="o">*</span><span class="n">upid</span><span class="p">;</span>

	<span class="n">pid</span> <span class="o">=</span> <span class="n">task_pid</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">tgid</span> <span class="o">=</span> <span class="n">task_tgid</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">pid</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">upid</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pid</span><span class="o">-&gt;</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">proc_flush_task_mnt</span><span class="p">(</span><span class="n">upid</span><span class="o">-&gt;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">proc_mnt</span><span class="p">,</span> <span class="n">upid</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">,</span>
					<span class="n">tgid</span><span class="o">-&gt;</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">upid</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pid</span><span class="o">-&gt;</span><span class="n">numbers</span><span class="p">[</span><span class="n">pid</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">upid</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">pid_ns_release_proc</span><span class="p">(</span><span class="n">upid</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">proc_pid_instantiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">proc_pid_make_inode</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">S_IFDIR</span><span class="o">|</span><span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IXUGO</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">proc_tgid_base_inode_operations</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">proc_tgid_base_operations</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="o">|=</span><span class="n">S_IMMUTABLE</span><span class="p">;</span>

	<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">pid_entry_count_dirs</span><span class="p">(</span><span class="n">tgid_base_stuff</span><span class="p">,</span>
						  <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">tgid_base_stuff</span><span class="p">)));</span>

	<span class="n">d_set_d_op</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pid_dentry_operations</span><span class="p">);</span>

	<span class="n">d_add</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="cm">/* Close the race of the process dying before we return the dentry */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid_revalidate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">proc_pid_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">tgid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">proc_base_lookup</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">||</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">tgid</span> <span class="o">=</span> <span class="n">name_to_int</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tgid</span> <span class="o">==</span> <span class="o">~</span><span class="mi">0U</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ns</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">task</span> <span class="o">=</span> <span class="n">find_task_by_pid_ns</span><span class="p">(</span><span class="n">tgid</span><span class="p">,</span> <span class="n">ns</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">)</span>
		<span class="n">get_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">proc_pid_instantiate</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the first task with tgid &gt;= tgid</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tgid_iter</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tgid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tgid_iter</span> <span class="nf">next_tgid</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tgid_iter</span> <span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">task</span><span class="p">)</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">task</span><span class="p">);</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="nl">retry:</span>
	<span class="n">iter</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pid</span> <span class="o">=</span> <span class="n">find_ge_pid</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">tgid</span><span class="p">,</span> <span class="n">ns</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iter</span><span class="p">.</span><span class="n">tgid</span> <span class="o">=</span> <span class="n">pid_nr_ns</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">ns</span><span class="p">);</span>
		<span class="n">iter</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="n">pid_task</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">PIDTYPE_PID</span><span class="p">);</span>
		<span class="cm">/* What we to know is if the pid we have find is the</span>
<span class="cm">		 * pid of a thread_group_leader.  Testing for task</span>
<span class="cm">		 * being a thread_group_leader is the obvious thing</span>
<span class="cm">		 * todo but there is a window when it fails, due to</span>
<span class="cm">		 * the pid transfer logic in de_thread.</span>
<span class="cm">		 *</span>
<span class="cm">		 * So we perform the straight forward test of seeing</span>
<span class="cm">		 * if the pid we have found is the pid of a thread</span>
<span class="cm">		 * group leader, and don&#39;t worry if the task we have</span>
<span class="cm">		 * found doesn&#39;t happen to be a thread group leader.</span>
<span class="cm">		 * As we don&#39;t care in the case of readdir.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iter</span><span class="p">.</span><span class="n">task</span> <span class="o">||</span> <span class="o">!</span><span class="n">has_group_leader_pid</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">iter</span><span class="p">.</span><span class="n">tgid</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">get_task_struct</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">iter</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define TGID_OFFSET (FIRST_PROCESS_ENTRY + ARRAY_SIZE(proc_base_stuff))</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_pid_fill_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dirent</span><span class="p">,</span> <span class="n">filldir_t</span> <span class="n">filldir</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">tgid_iter</span> <span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">PROC_NUMBUF</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">iter</span><span class="p">.</span><span class="n">tgid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">proc_fill_cache</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">dirent</span><span class="p">,</span> <span class="n">filldir</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
				<span class="n">proc_pid_instantiate</span><span class="p">,</span> <span class="n">iter</span><span class="p">.</span><span class="n">task</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fake_filldir</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ino</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">d_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* for the /proc/ directory itself, after non-process stuff has been done */</span>
<span class="kt">int</span> <span class="nf">proc_pid_readdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">dirent</span><span class="p">,</span> <span class="n">filldir_t</span> <span class="n">filldir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">reaper</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tgid_iter</span> <span class="n">iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">;</span>
	<span class="n">filldir_t</span> <span class="n">__filldir</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">&gt;=</span> <span class="n">PID_MAX_LIMIT</span> <span class="o">+</span> <span class="n">TGID_OFFSET</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_task</span><span class="p">;</span>
	<span class="n">nr</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">-</span> <span class="n">FIRST_PROCESS_ENTRY</span><span class="p">;</span>

	<span class="n">reaper</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reaper</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_task</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">nr</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">proc_base_stuff</span><span class="p">);</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="o">++</span><span class="p">,</span> <span class="n">nr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">pid_entry</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">proc_base_stuff</span><span class="p">[</span><span class="n">nr</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">proc_base_fill_cache</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">dirent</span><span class="p">,</span> <span class="n">filldir</span><span class="p">,</span> <span class="n">reaper</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ns</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="n">iter</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">iter</span><span class="p">.</span><span class="n">tgid</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">-</span> <span class="n">TGID_OFFSET</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">iter</span> <span class="o">=</span> <span class="n">next_tgid</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>
	     <span class="n">iter</span><span class="p">.</span><span class="n">task</span><span class="p">;</span>
	     <span class="n">iter</span><span class="p">.</span><span class="n">tgid</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">next_tgid</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">iter</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">has_pid_permissions</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">iter</span><span class="p">.</span><span class="n">task</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
			<span class="n">__filldir</span> <span class="o">=</span> <span class="n">filldir</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">__filldir</span> <span class="o">=</span> <span class="n">fake_filldir</span><span class="p">;</span>

		<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">iter</span><span class="p">.</span><span class="n">tgid</span> <span class="o">+</span> <span class="n">TGID_OFFSET</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">proc_pid_fill_cache</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">dirent</span><span class="p">,</span> <span class="n">__filldir</span><span class="p">,</span> <span class="n">iter</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">put_task_struct</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">task</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">PID_MAX_LIMIT</span> <span class="o">+</span> <span class="n">TGID_OFFSET</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">reaper</span><span class="p">);</span>
<span class="nl">out_no_task:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Tasks</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pid_entry</span> <span class="n">tid_base_stuff</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="kt">DIR</span><span class="p">(</span><span class="s">&quot;fd&quot;</span><span class="p">,</span>        <span class="n">S_IRUSR</span><span class="o">|</span><span class="n">S_IXUSR</span><span class="p">,</span> <span class="n">proc_fd_inode_operations</span><span class="p">,</span> <span class="n">proc_fd_operations</span><span class="p">),</span>
	<span class="kt">DIR</span><span class="p">(</span><span class="s">&quot;fdinfo&quot;</span><span class="p">,</span>    <span class="n">S_IRUSR</span><span class="o">|</span><span class="n">S_IXUSR</span><span class="p">,</span> <span class="n">proc_fdinfo_inode_operations</span><span class="p">,</span> <span class="n">proc_fdinfo_operations</span><span class="p">),</span>
	<span class="kt">DIR</span><span class="p">(</span><span class="s">&quot;ns&quot;</span><span class="p">,</span>	 <span class="n">S_IRUSR</span><span class="o">|</span><span class="n">S_IXUGO</span><span class="p">,</span> <span class="n">proc_ns_dir_inode_operations</span><span class="p">,</span> <span class="n">proc_ns_dir_operations</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;environ&quot;</span><span class="p">,</span>   <span class="n">S_IRUSR</span><span class="p">,</span> <span class="n">proc_environ_operations</span><span class="p">),</span>
	<span class="n">INF</span><span class="p">(</span><span class="s">&quot;auxv&quot;</span><span class="p">,</span>      <span class="n">S_IRUSR</span><span class="p">,</span> <span class="n">proc_pid_auxv</span><span class="p">),</span>
	<span class="n">ONE</span><span class="p">(</span><span class="s">&quot;status&quot;</span><span class="p">,</span>    <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pid_status</span><span class="p">),</span>
	<span class="n">ONE</span><span class="p">(</span><span class="s">&quot;personality&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pid_personality</span><span class="p">),</span>
	<span class="n">INF</span><span class="p">(</span><span class="s">&quot;limits&quot;</span><span class="p">,</span>	 <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pid_limits</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_SCHED_DEBUG</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;sched&quot;</span><span class="p">,</span>     <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">proc_pid_sched_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;comm&quot;</span><span class="p">,</span>      <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">proc_pid_set_comm_operations</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_HAVE_ARCH_TRACEHOOK</span>
	<span class="n">INF</span><span class="p">(</span><span class="s">&quot;syscall&quot;</span><span class="p">,</span>   <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pid_syscall</span><span class="p">),</span>
<span class="cp">#endif</span>
	<span class="n">INF</span><span class="p">(</span><span class="s">&quot;cmdline&quot;</span><span class="p">,</span>   <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pid_cmdline</span><span class="p">),</span>
	<span class="n">ONE</span><span class="p">(</span><span class="s">&quot;stat&quot;</span><span class="p">,</span>      <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_tid_stat</span><span class="p">),</span>
	<span class="n">ONE</span><span class="p">(</span><span class="s">&quot;statm&quot;</span><span class="p">,</span>     <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pid_statm</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;maps&quot;</span><span class="p">,</span>      <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_tid_maps_operations</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_CHECKPOINT_RESTORE</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;children&quot;</span><span class="p">,</span>  <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_tid_children_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;numa_maps&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_tid_numa_maps_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;mem&quot;</span><span class="p">,</span>       <span class="n">S_IRUSR</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">proc_mem_operations</span><span class="p">),</span>
	<span class="n">LNK</span><span class="p">(</span><span class="s">&quot;cwd&quot;</span><span class="p">,</span>       <span class="n">proc_cwd_link</span><span class="p">),</span>
	<span class="n">LNK</span><span class="p">(</span><span class="s">&quot;root&quot;</span><span class="p">,</span>      <span class="n">proc_root_link</span><span class="p">),</span>
	<span class="n">LNK</span><span class="p">(</span><span class="s">&quot;exe&quot;</span><span class="p">,</span>       <span class="n">proc_exe_link</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;mounts&quot;</span><span class="p">,</span>    <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_mounts_operations</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;mountinfo&quot;</span><span class="p">,</span>  <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_mountinfo_operations</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_PROC_PAGE_MONITOR</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;clear_refs&quot;</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">proc_clear_refs_operations</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;smaps&quot;</span><span class="p">,</span>     <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_tid_smaps_operations</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;pagemap&quot;</span><span class="p">,</span>    <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pagemap_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SECURITY</span>
	<span class="kt">DIR</span><span class="p">(</span><span class="s">&quot;attr&quot;</span><span class="p">,</span>      <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IXUGO</span><span class="p">,</span> <span class="n">proc_attr_dir_inode_operations</span><span class="p">,</span> <span class="n">proc_attr_dir_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_KALLSYMS</span>
	<span class="n">INF</span><span class="p">(</span><span class="s">&quot;wchan&quot;</span><span class="p">,</span>     <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pid_wchan</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_STACKTRACE</span>
	<span class="n">ONE</span><span class="p">(</span><span class="s">&quot;stack&quot;</span><span class="p">,</span>      <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pid_stack</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SCHEDSTATS</span>
	<span class="n">INF</span><span class="p">(</span><span class="s">&quot;schedstat&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pid_schedstat</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_LATENCYTOP</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;latency&quot;</span><span class="p">,</span>  <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_lstats_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_PROC_PID_CPUSET</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;cpuset&quot;</span><span class="p">,</span>    <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_cpuset_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_CGROUPS</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;cgroup&quot;</span><span class="p">,</span>  <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_cgroup_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
	<span class="n">INF</span><span class="p">(</span><span class="s">&quot;oom_score&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_oom_score</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;oom_adj&quot;</span><span class="p">,</span>   <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">proc_oom_adjust_operations</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;oom_score_adj&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">proc_oom_score_adj_operations</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_AUDITSYSCALL</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;loginuid&quot;</span><span class="p">,</span>  <span class="n">S_IWUSR</span><span class="o">|</span><span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_loginuid_operations</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;sessionid&quot;</span><span class="p">,</span>  <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_sessionid_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_FAULT_INJECTION</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;make-it-fail&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">proc_fault_inject_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_TASK_IO_ACCOUNTING</span>
	<span class="n">INF</span><span class="p">(</span><span class="s">&quot;io&quot;</span><span class="p">,</span>	<span class="n">S_IRUSR</span><span class="p">,</span> <span class="n">proc_tid_io_accounting</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_HARDWALL</span>
	<span class="n">INF</span><span class="p">(</span><span class="s">&quot;hardwall&quot;</span><span class="p">,</span>   <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">proc_pid_hardwall</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_USER_NS</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;uid_map&quot;</span><span class="p">,</span>    <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">proc_uid_map_operations</span><span class="p">),</span>
	<span class="n">REG</span><span class="p">(</span><span class="s">&quot;gid_map&quot;</span><span class="p">,</span>    <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">proc_gid_map_operations</span><span class="p">),</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_tid_base_readdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">filp</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="o">*</span> <span class="n">dirent</span><span class="p">,</span> <span class="n">filldir_t</span> <span class="n">filldir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">proc_pident_readdir</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span><span class="n">dirent</span><span class="p">,</span><span class="n">filldir</span><span class="p">,</span>
				   <span class="n">tid_base_stuff</span><span class="p">,</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">tid_base_stuff</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">proc_tid_base_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">){</span>
	<span class="k">return</span> <span class="n">proc_pident_lookup</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span>
				  <span class="n">tid_base_stuff</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">tid_base_stuff</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_tid_base_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">generic_read_dir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readdir</span>	<span class="o">=</span> <span class="n">proc_tid_base_readdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">proc_tid_base_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">lookup</span>		<span class="o">=</span> <span class="n">proc_tid_base_lookup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getattr</span>	<span class="o">=</span> <span class="n">pid_getattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">proc_setattr</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">proc_task_instantiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">proc_pid_make_inode</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">S_IFDIR</span><span class="o">|</span><span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IXUGO</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">proc_tid_base_inode_operations</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">proc_tid_base_operations</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="o">|=</span><span class="n">S_IMMUTABLE</span><span class="p">;</span>

	<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">pid_entry_count_dirs</span><span class="p">(</span><span class="n">tid_base_stuff</span><span class="p">,</span>
						  <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">tid_base_stuff</span><span class="p">)));</span>

	<span class="n">d_set_d_op</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pid_dentry_operations</span><span class="p">);</span>

	<span class="n">d_add</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="cm">/* Close the race of the process dying before we return the dentry */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid_revalidate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">proc_task_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">leader</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">tid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">leader</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_task</span><span class="p">;</span>

	<span class="n">tid</span> <span class="o">=</span> <span class="n">name_to_int</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">==</span> <span class="o">~</span><span class="mi">0U</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ns</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">task</span> <span class="o">=</span> <span class="n">find_task_by_pid_ns</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ns</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">)</span>
		<span class="n">get_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">same_thread_group</span><span class="p">(</span><span class="n">leader</span><span class="p">,</span> <span class="n">task</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_drop_task</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">proc_task_instantiate</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="nl">out_drop_task:</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">leader</span><span class="p">);</span>
<span class="nl">out_no_task:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the first tid of a thread group to return to user space.</span>
<span class="cm"> *</span>
<span class="cm"> * Usually this is just the thread group leader, but if the users</span>
<span class="cm"> * buffer was too small or there was a seek into the middle of the</span>
<span class="cm"> * directory we have more work todo.</span>
<span class="cm"> *</span>
<span class="cm"> * In the case of a short read we start with find_task_by_pid.</span>
<span class="cm"> *</span>
<span class="cm"> * In the case of a seek we start with the leader and walk nr</span>
<span class="cm"> * threads past it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">first_tid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">leader</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">tid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="cm">/* Attempt to start with the pid of a thread */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">find_task_by_pid_ns</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="n">ns</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">group_leader</span> <span class="o">==</span> <span class="n">leader</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If nr exceeds the number of threads there is nothing todo */</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&amp;&amp;</span> <span class="n">nr</span> <span class="o">&gt;=</span> <span class="n">get_nr_threads</span><span class="p">(</span><span class="n">leader</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* If we haven&#39;t found our starting place yet start</span>
<span class="cm">	 * with the leader and walk nr threads forward.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="n">leader</span><span class="p">;</span> <span class="n">nr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">next_thread</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="n">leader</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pos</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">found:</span>
	<span class="n">get_task_struct</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the next thread in the thread list.</span>
<span class="cm"> * Return NULL if there is an error or no next thread.</span>
<span class="cm"> *</span>
<span class="cm"> * The reference to the input task_struct is released.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">next_tid</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid_alive</span><span class="p">(</span><span class="n">start</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">next_thread</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">thread_group_leader</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span>
			<span class="n">pos</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">get_task_struct</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_task_fill_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dirent</span><span class="p">,</span> <span class="n">filldir_t</span> <span class="n">filldir</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">PROC_NUMBUF</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">proc_fill_cache</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">dirent</span><span class="p">,</span> <span class="n">filldir</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
				<span class="n">proc_task_instantiate</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* for the /proc/TGID/task/ directories */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_task_readdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">dirent</span><span class="p">,</span> <span class="n">filldir_t</span> <span class="n">filldir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">leader</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">ino</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">ns</span><span class="p">;</span>

	<span class="n">task</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_task</span><span class="p">;</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pid_alive</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">leader</span> <span class="o">=</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">;</span>
		<span class="n">get_task_struct</span><span class="p">(</span><span class="n">leader</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">leader</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_task</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">ino</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="s">&quot;.&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">DT_DIR</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">ino</span> <span class="o">=</span> <span class="n">parent_ino</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="s">&quot;..&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">DT_DIR</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="p">}</span>

	<span class="cm">/* f_version caches the tgid value that the last readdir call couldn&#39;t</span>
<span class="cm">	 * return. lseek aka telldir automagically resets f_version to 0.</span>
<span class="cm">	 */</span>
	<span class="n">ns</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="n">tid</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_version</span><span class="p">;</span>
	<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">task</span> <span class="o">=</span> <span class="n">first_tid</span><span class="p">(</span><span class="n">leader</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ns</span><span class="p">);</span>
	     <span class="n">task</span><span class="p">;</span>
	     <span class="n">task</span> <span class="o">=</span> <span class="n">next_tid</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tid</span> <span class="o">=</span> <span class="n">task_pid_nr_ns</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">ns</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">proc_task_fill_cache</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">dirent</span><span class="p">,</span> <span class="n">filldir</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">tid</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* returning this tgid failed, save it as the first</span>
<span class="cm">			 * pid for the next readir call */</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_version</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">tid</span><span class="p">;</span>
			<span class="n">put_task_struct</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">put_task_struct</span><span class="p">(</span><span class="n">leader</span><span class="p">);</span>
<span class="nl">out_no_task:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proc_task_getattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstat</span> <span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">get_proc_task</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">generic_fillattr</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">nlink</span> <span class="o">+=</span> <span class="n">get_nr_threads</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">proc_task_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">lookup</span>		<span class="o">=</span> <span class="n">proc_task_lookup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getattr</span>	<span class="o">=</span> <span class="n">proc_task_getattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">proc_setattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">permission</span>	<span class="o">=</span> <span class="n">proc_pid_permission</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_task_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">generic_read_dir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readdir</span>	<span class="o">=</span> <span class="n">proc_task_readdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">default_llseek</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
