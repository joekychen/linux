<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › file_table.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>file_table.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/fs/file_table.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> *  Copyright (C) 1997 David S. Miller (davem@caip.rutgers.edu)</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/fdtable.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/eventpoll.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/cdev.h&gt;</span>
<span class="cp">#include &lt;linux/fsnotify.h&gt;</span>
<span class="cp">#include &lt;linux/sysctl.h&gt;</span>
<span class="cp">#include &lt;linux/lglock.h&gt;</span>
<span class="cp">#include &lt;linux/percpu_counter.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/ima.h&gt;</span>

<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cm">/* sysctl tunables... */</span>
<span class="k">struct</span> <span class="n">files_stat_struct</span> <span class="n">files_stat</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">max_files</span> <span class="o">=</span> <span class="n">NR_FILE</span>
<span class="p">};</span>

<span class="n">DEFINE_LGLOCK</span><span class="p">(</span><span class="n">files_lglock</span><span class="p">);</span>

<span class="cm">/* SLAB cache for file structures */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">filp_cachep</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">percpu_counter</span> <span class="n">nr_files</span> <span class="n">__cacheline_aligned_in_smp</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">file_free_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span><span class="p">,</span> <span class="n">f_u</span><span class="p">.</span><span class="n">fu_rcuhead</span><span class="p">);</span>

	<span class="n">put_cred</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_cred</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">filp_cachep</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">file_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">percpu_counter_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_files</span><span class="p">);</span>
	<span class="n">file_check_state</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_u</span><span class="p">.</span><span class="n">fu_rcuhead</span><span class="p">,</span> <span class="n">file_free_rcu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the total number of open files in the system</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">get_nr_files</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">percpu_counter_read_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_files</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the maximum number of open files in the system</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_max_files</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">files_stat</span><span class="p">.</span><span class="n">max_files</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">get_max_files</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Handle nr_files sysctl</span>
<span class="cm"> */</span>
<span class="cp">#if defined(CONFIG_SYSCTL) &amp;&amp; defined(CONFIG_PROC_FS)</span>
<span class="kt">int</span> <span class="nf">proc_nr_files</span><span class="p">(</span><span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
                     <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">files_stat</span><span class="p">.</span><span class="n">nr_files</span> <span class="o">=</span> <span class="n">get_nr_files</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">proc_doulongvec_minmax</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">lenp</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="kt">int</span> <span class="nf">proc_nr_files</span><span class="p">(</span><span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
                     <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Find an unused file structure and return a pointer to it.</span>
<span class="cm"> * Returns NULL, if there are no more free file structures or</span>
<span class="cm"> * we run out of memory.</span>
<span class="cm"> *</span>
<span class="cm"> * Be very careful using this.  You are responsible for</span>
<span class="cm"> * getting write access to any mount that you might assign</span>
<span class="cm"> * to this filp, if it is opened for write.  If this is not</span>
<span class="cm"> * done, you will imbalance int the mount&#39;s writer count</span>
<span class="cm"> * and a warning at __fput() time.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="nf">get_empty_filp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="k">static</span> <span class="kt">long</span> <span class="n">old_max</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">f</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Privileged users can go above max_files</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_nr_files</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">files_stat</span><span class="p">.</span><span class="n">max_files</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * percpu_counters are inaccurate.  Do an expensive check before</span>
<span class="cm">		 * we go and fail.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">percpu_counter_sum_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_files</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">files_stat</span><span class="p">.</span><span class="n">max_files</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">over</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">f</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">filp_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">percpu_counter_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_files</span><span class="p">);</span>
	<span class="n">f</span><span class="o">-&gt;</span><span class="n">f_cred</span> <span class="o">=</span> <span class="n">get_cred</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">security_file_alloc</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_sec</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_u</span><span class="p">.</span><span class="n">fu_list</span><span class="p">);</span>
	<span class="n">atomic_long_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_owner</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
	<span class="n">eventpoll_init_file</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
	<span class="cm">/* f-&gt;f_version: 0 */</span>
	<span class="k">return</span> <span class="n">f</span><span class="p">;</span>

<span class="nl">over:</span>
	<span class="cm">/* Ran out of filps - report that */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_nr_files</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">old_max</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;VFS: file-max limit %lu reached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">get_max_files</span><span class="p">());</span>
		<span class="n">old_max</span> <span class="o">=</span> <span class="n">get_nr_files</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

<span class="nl">fail_sec:</span>
	<span class="n">file_free</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="nl">fail:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * alloc_file - allocate and initialize a &#39;struct file&#39;</span>
<span class="cm"> * @mnt: the vfsmount on which the file will reside</span>
<span class="cm"> * @dentry: the dentry representing the new file</span>
<span class="cm"> * @mode: the mode with which the new file will be opened</span>
<span class="cm"> * @fop: the &#39;struct file_operations&#39; for the new file</span>
<span class="cm"> *</span>
<span class="cm"> * Use this instead of get_empty_filp() to get a new</span>
<span class="cm"> * &#39;struct file&#39;.  Do so because of the same initialization</span>
<span class="cm"> * pitfalls reasons listed for init_file().  This is a</span>
<span class="cm"> * preferred interface to using init_file().</span>
<span class="cm"> *</span>
<span class="cm"> * If all the callers of init_file() are eliminated, its</span>
<span class="cm"> * code should be moved into this function.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="nf">alloc_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">fop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">get_empty_filp</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span> <span class="o">=</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">=</span> <span class="n">fop</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * These mounts don&#39;t really matter in practice</span>
<span class="cm">	 * for r/o bind mounts.  They aren&#39;t userspace-</span>
<span class="cm">	 * visible.  We do this for consistency, and so</span>
<span class="cm">	 * that we can do debugging checks at __fput()</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">special_file</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">file_take_write</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">mnt_clone_write</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FMODE_READ</span> <span class="o">|</span> <span class="n">FMODE_WRITE</span><span class="p">))</span> <span class="o">==</span> <span class="n">FMODE_READ</span><span class="p">)</span>
		<span class="n">i_readcount_inc</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">file</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">alloc_file</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * drop_file_write_access - give up ability to write to a file</span>
<span class="cm"> * @file: the file to which we will stop writing</span>
<span class="cm"> *</span>
<span class="cm"> * This is a central place which will give up the ability</span>
<span class="cm"> * to write to @file, along with access to write through</span>
<span class="cm"> * its vfsmount.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">drop_file_write_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">mnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="n">put_write_access</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">special_file</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file_check_writeable</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">mnt_drop_write</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
	<span class="n">file_release_write</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* the real guts of fput() - releasing the last reference to file</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__fput</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">mnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="n">fsnotify_close</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The function eventpoll_release() should be the first called</span>
<span class="cm">	 * in the file cleanup chain.</span>
<span class="cm">	 */</span>
	<span class="n">eventpoll_release</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="n">locks_remove_flock</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">FASYNC</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">&amp;&amp;</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">fasync</span><span class="p">)</span>
			<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">fasync</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">&amp;&amp;</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">)</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
	<span class="n">security_file_free</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="n">ima_file_free</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_cdev</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
		     <span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_PATH</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">cdev_put</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_cdev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">fops_put</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="p">);</span>
	<span class="n">put_pid</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_owner</span><span class="p">.</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">file_sb_list_del</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FMODE_READ</span> <span class="o">|</span> <span class="n">FMODE_WRITE</span><span class="p">))</span> <span class="o">==</span> <span class="n">FMODE_READ</span><span class="p">)</span>
		<span class="n">i_readcount_dec</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span>
		<span class="n">drop_file_write_access</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">file_free</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">mntput</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">fput</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_long_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_count</span><span class="p">))</span>
		<span class="n">__fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fput</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="nf">fget</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">files</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">file</span> <span class="o">=</span> <span class="n">fcheck_files</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* File object ref couldn&#39;t be taken */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_PATH</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">atomic_long_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_count</span><span class="p">))</span>
			<span class="n">file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">file</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fget</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="nf">fget_raw</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">files</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">file</span> <span class="o">=</span> <span class="n">fcheck_files</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* File object ref couldn&#39;t be taken */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_long_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_count</span><span class="p">))</span>
			<span class="n">file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">file</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fget_raw</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Lightweight file lookup - no refcnt increment if fd table isn&#39;t shared.</span>
<span class="cm"> *</span>
<span class="cm"> * You can use this instead of fget if you satisfy all of the following</span>
<span class="cm"> * conditions:</span>
<span class="cm"> * 1) You must call fput_light before exiting the syscall and returning control</span>
<span class="cm"> *    to userspace (i.e. you cannot remember the returned struct file * after</span>
<span class="cm"> *    returning to userspace).</span>
<span class="cm"> * 2) You must not call filp_close on the returned struct file * in between</span>
<span class="cm"> *    calls to fget_light and fput_light.</span>
<span class="cm"> * 3) You must not clone the current task in between the calls to fget_light</span>
<span class="cm"> *    and fput_light.</span>
<span class="cm"> *</span>
<span class="cm"> * The fput_needed flag returned by fget_light should be passed to the</span>
<span class="cm"> * corresponding fput_light.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="nf">fget_light</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">fput_needed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">files</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">;</span>

	<span class="o">*</span><span class="n">fput_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">file</span> <span class="o">=</span> <span class="n">fcheck_files</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_PATH</span><span class="p">))</span>
			<span class="n">file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">file</span> <span class="o">=</span> <span class="n">fcheck_files</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_PATH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">atomic_long_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_count</span><span class="p">))</span>
				<span class="o">*</span><span class="n">fput_needed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="cm">/* Didn&#39;t get the reference, someone&#39;s freed */</span>
				<span class="n">file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">file</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="nf">fget_raw_light</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">fput_needed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">files</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">;</span>

	<span class="o">*</span><span class="n">fput_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">file</span> <span class="o">=</span> <span class="n">fcheck_files</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">file</span> <span class="o">=</span> <span class="n">fcheck_files</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">atomic_long_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_count</span><span class="p">))</span>
				<span class="o">*</span><span class="n">fput_needed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="cm">/* Didn&#39;t get the reference, someone&#39;s freed */</span>
				<span class="n">file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">file</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">put_filp</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_long_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">security_file_free</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
		<span class="n">file_sb_list_del</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
		<span class="n">file_free</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">file_list_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">return</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_sb_list_cpu</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">smp_processor_id</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* helper for file_sb_list_add to reduce ifdefs */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__file_sb_list_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_sb_list_cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">list</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_files</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_files</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_u</span><span class="p">.</span><span class="n">fu_list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * file_sb_list_add - add a file to the sb&#39;s file list</span>
<span class="cm"> * @file: file to add</span>
<span class="cm"> * @sb: sb to add it to</span>
<span class="cm"> *</span>
<span class="cm"> * Use this function to associate a file with the superblock of the inode it</span>
<span class="cm"> * refers to.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">file_sb_list_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lg_local_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files_lglock</span><span class="p">);</span>
	<span class="n">__file_sb_list_add</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">sb</span><span class="p">);</span>
	<span class="n">lg_local_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files_lglock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * file_sb_list_del - remove a file from the sb&#39;s file list</span>
<span class="cm"> * @file: file to remove</span>
<span class="cm"> * @sb: sb to remove it from</span>
<span class="cm"> *</span>
<span class="cm"> * Use this function to remove a file from its superblock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">file_sb_list_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_u</span><span class="p">.</span><span class="n">fu_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lg_local_lock_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files_lglock</span><span class="p">,</span> <span class="n">file_list_cpu</span><span class="p">(</span><span class="n">file</span><span class="p">));</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_u</span><span class="p">.</span><span class="n">fu_list</span><span class="p">);</span>
		<span class="n">lg_local_unlock_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files_lglock</span><span class="p">,</span> <span class="n">file_list_cpu</span><span class="p">(</span><span class="n">file</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>

<span class="cm">/*</span>
<span class="cm"> * These macros iterate all files on all CPUs for a given superblock.</span>
<span class="cm"> * files_lglock must be held globally.</span>
<span class="cm"> */</span>
<span class="cp">#define do_file_list_for_each_entry(__sb, __file)		\</span>
<span class="cp">{								\</span>
<span class="cp">	int i;							\</span>
<span class="cp">	for_each_possible_cpu(i) {				\</span>
<span class="cp">		struct list_head *list;				\</span>
<span class="cp">		list = per_cpu_ptr((__sb)-&gt;s_files, i);		\</span>
<span class="cp">		list_for_each_entry((__file), list, f_u.fu_list)</span>

<span class="cp">#define while_file_list_for_each_entry				\</span>
<span class="cp">	}							\</span>
<span class="cp">}</span>

<span class="cp">#else</span>

<span class="cp">#define do_file_list_for_each_entry(__sb, __file)		\</span>
<span class="cp">{								\</span>
<span class="cp">	struct list_head *list;					\</span>
<span class="cp">	list = &amp;(sb)-&gt;s_files;					\</span>
<span class="cp">	list_for_each_entry((__file), list, f_u.fu_list)</span>

<span class="cp">#define while_file_list_for_each_entry				\</span>
<span class="cp">}</span>

<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> *	mark_files_ro - mark all files read-only</span>
<span class="cm"> *	@sb: superblock in question</span>
<span class="cm"> *</span>
<span class="cm"> *	All files are marked read-only.  We don&#39;t care about pending</span>
<span class="cm"> *	delete files so this should be used in &#39;force&#39; mode only.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">mark_files_ro</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">lg_global_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files_lglock</span><span class="p">);</span>
	<span class="n">do_file_list_for_each_entry</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		       <span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file_count</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
		<span class="n">f</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FMODE_WRITE</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file_check_writeable</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">file_release_write</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
		<span class="n">mnt</span> <span class="o">=</span> <span class="n">mntget</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
		<span class="cm">/* This can sleep, so we can&#39;t hold the spinlock. */</span>
		<span class="n">lg_global_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files_lglock</span><span class="p">);</span>
		<span class="n">mnt_drop_write</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
		<span class="n">mntput</span><span class="p">(</span><span class="n">mnt</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">while_file_list_for_each_entry</span><span class="p">;</span>
	<span class="n">lg_global_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files_lglock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">files_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mempages</span><span class="p">)</span>
<span class="p">{</span> 
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">filp_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;filp&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">SLAB_HWCACHE_ALIGN</span> <span class="o">|</span> <span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * One file with associated inode and dcache is very roughly 1K.</span>
<span class="cm">	 * Per default don&#39;t use more than 10% of our memory for files. </span>
<span class="cm">	 */</span> 

	<span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">mempages</span> <span class="o">*</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">1024</span><span class="p">))</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">files_stat</span><span class="p">.</span><span class="n">max_files</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">NR_FILE</span><span class="p">);</span>
	<span class="n">files_defer_init</span><span class="p">();</span>
	<span class="n">lg_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files_lglock</span><span class="p">,</span> <span class="s">&quot;files_lglock&quot;</span><span class="p">);</span>
	<span class="n">percpu_counter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_files</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span> 

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
