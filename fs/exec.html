<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › exec.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>exec.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/fs/exec.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * #!-checking implemented by tytso.</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * Demand-loading implemented 01.12.91 - no need to read anything but</span>
<span class="cm"> * the header into memory. The inode of the executable is put into</span>
<span class="cm"> * &quot;current-&gt;executable&quot;, and page faults do the actual loading. Clean.</span>
<span class="cm"> *</span>
<span class="cm"> * Once more I can proudly say that linux stood up to being changed: it</span>
<span class="cm"> * was less than 2 hours work to get demand-loading completely implemented.</span>
<span class="cm"> *</span>
<span class="cm"> * Demand loading changed July 1993 by Eric Youngdale.   Use mmap instead,</span>
<span class="cm"> * current-&gt;executable is only used by the procfs.  This allows a dispatch</span>
<span class="cm"> * table to check for several different types  of binary formats.  We keep</span>
<span class="cm"> * trying until we recognize the file or we run out of supported binary</span>
<span class="cm"> * formats. </span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/fdtable.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/perf_event.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/key.h&gt;</span>
<span class="cp">#include &lt;linux/personality.h&gt;</span>
<span class="cp">#include &lt;linux/binfmts.h&gt;</span>
<span class="cp">#include &lt;linux/utsname.h&gt;</span>
<span class="cp">#include &lt;linux/pid_namespace.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/tsacct_kern.h&gt;</span>
<span class="cp">#include &lt;linux/cn_proc.h&gt;</span>
<span class="cp">#include &lt;linux/audit.h&gt;</span>
<span class="cp">#include &lt;linux/tracehook.h&gt;</span>
<span class="cp">#include &lt;linux/kmod.h&gt;</span>
<span class="cp">#include &lt;linux/fsnotify.h&gt;</span>
<span class="cp">#include &lt;linux/fs_struct.h&gt;</span>
<span class="cp">#include &lt;linux/pipe_fs_i.h&gt;</span>
<span class="cp">#include &lt;linux/oom.h&gt;</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &lt;asm/tlb.h&gt;</span>
<span class="cp">#include &lt;asm/exec.h&gt;</span>

<span class="cp">#include &lt;trace/events/task.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cp">#include &lt;trace/events/sched.h&gt;</span>

<span class="kt">int</span> <span class="n">core_uses_pid</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">core_pattern</span><span class="p">[</span><span class="n">CORENAME_MAX_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;core&quot;</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">core_pipe_limit</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">suid_dumpable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">core_name</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">corename</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">used</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">call_count</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="cm">/* The maximal length of core_pattern is also specified in sysctl.c */</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">formats</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">binfmt_lock</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">__register_binfmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binfmt</span> <span class="o">*</span> <span class="n">fmt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">insert</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">fmt</span><span class="p">);</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binfmt_lock</span><span class="p">);</span>
	<span class="n">insert</span> <span class="o">?</span> <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">lh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">formats</span><span class="p">)</span> <span class="o">:</span>
		 <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">lh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">formats</span><span class="p">);</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binfmt_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__register_binfmt</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">unregister_binfmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binfmt</span> <span class="o">*</span> <span class="n">fmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binfmt_lock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">lh</span><span class="p">);</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binfmt_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unregister_binfmt</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_binfmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binfmt</span> <span class="o">*</span> <span class="n">fmt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Note that a shared library must be both readable and executable due to</span>
<span class="cm"> * security reasons.</span>
<span class="cm"> *</span>
<span class="cm"> * Also note that we take the address to load from from the file itself.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">uselib</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">library</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">getname</span><span class="p">(</span><span class="n">library</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">open_flags</span> <span class="n">uselib_flags</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">open_flag</span> <span class="o">=</span> <span class="n">O_LARGEFILE</span> <span class="o">|</span> <span class="n">O_RDONLY</span> <span class="o">|</span> <span class="n">__FMODE_EXEC</span><span class="p">,</span>
		<span class="p">.</span><span class="n">acc_mode</span> <span class="o">=</span> <span class="n">MAY_READ</span> <span class="o">|</span> <span class="n">MAY_EXEC</span> <span class="o">|</span> <span class="n">MAY_OPEN</span><span class="p">,</span>
		<span class="p">.</span><span class="n">intent</span> <span class="o">=</span> <span class="n">LOOKUP_OPEN</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">do_filp_open</span><span class="p">(</span><span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uselib_flags</span><span class="p">,</span> <span class="n">LOOKUP_FOLLOW</span><span class="p">);</span>
	<span class="n">putname</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="n">MNT_NOEXEC</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">fsnotify_open</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">linux_binfmt</span> <span class="o">*</span> <span class="n">fmt</span><span class="p">;</span>

		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binfmt_lock</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">formats</span><span class="p">,</span> <span class="n">lh</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">load_shlib</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binfmt_lock</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">load_shlib</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
			<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binfmt_lock</span><span class="p">);</span>
			<span class="n">put_binfmt</span><span class="p">(</span><span class="n">fmt</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binfmt_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">exit:</span>
	<span class="n">fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="nl">out:</span>
  	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MMU</span>
<span class="cm">/*</span>
<span class="cm"> * The nascent bprm-&gt;mm is not visible until exec_mmap() but it can</span>
<span class="cm"> * use a lot of memory, account these pages in current-&gt;mm temporary</span>
<span class="cm"> * for oom_badness()-&gt;get_mm_rss(). Once exec succeeds or fails, we</span>
<span class="cm"> * change the counter back via acct_arg_size(0).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">acct_arg_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)(</span><span class="n">pages</span> <span class="o">-</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">vma_pages</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span> <span class="o">||</span> <span class="o">!</span><span class="n">diff</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">vma_pages</span> <span class="o">=</span> <span class="n">pages</span><span class="p">;</span>
	<span class="n">add_mm_counter</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_ANONPAGES</span><span class="p">,</span> <span class="n">diff</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">get_arg_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pos</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_STACK_GROWSUP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">expand_downwards</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">vma</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">get_user_pages</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
			<span class="mi">1</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">rlimit</span> <span class="o">*</span><span class="n">rlim</span><span class="p">;</span>

		<span class="n">acct_arg_size</span><span class="p">(</span><span class="n">bprm</span><span class="p">,</span> <span class="n">size</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We&#39;ve historically supported up to 32 pages (ARG_MAX)</span>
<span class="cm">		 * of argument strings even with small stacks</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">ARG_MAX</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">page</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Limit to 1/4-th the stack size for the argv+env strings.</span>
<span class="cm">		 * This ensures that:</span>
<span class="cm">		 *  - the remaining binfmt code will not run out of stack space,</span>
<span class="cm">		 *  - the program will have a reasonable amount of stack left</span>
<span class="cm">		 *    to work from.</span>
<span class="cm">		 */</span>
		<span class="n">rlim</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">rlim</span><span class="p">[</span><span class="n">RLIMIT_STACK</span><span class="p">].</span><span class="n">rlim_cur</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">put_arg_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">free_arg_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">free_arg_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">flush_arg_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pos</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">flush_cache_page</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">vma</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__bprm_mm_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>

	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span> <span class="o">=</span> <span class="n">mm</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Place the stack at the largest stack address the architecture</span>
<span class="cm">	 * supports. Later, we&#39;ll move this to an appropriate place. We don&#39;t</span>
<span class="cm">	 * use STACK_TOP because that can depend on attributes which aren&#39;t</span>
<span class="cm">	 * configured yet.</span>
<span class="cm">	 */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">VM_STACK_FLAGS</span> <span class="o">&amp;</span> <span class="n">VM_STACK_INCOMPLETE_SETUP</span><span class="p">);</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">STACK_TOP_MAX</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">=</span> <span class="n">VM_STACK_FLAGS</span> <span class="o">|</span> <span class="n">VM_STACK_INCOMPLETE_SETUP</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span> <span class="o">=</span> <span class="n">vm_get_page_prot</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma_chain</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">insert_vm_struct</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">stack_vm</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">total_vm</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">valid_arg_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">MAX_ARG_STRLEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">acct_arg_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">get_arg_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pos</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">[</span><span class="n">pos</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="n">write</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_HIGHUSER</span><span class="o">|</span><span class="n">__GFP_ZERO</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">[</span><span class="n">pos</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">put_arg_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">free_arg_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">free_arg_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_ARG_PAGES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">free_arg_page</span><span class="p">(</span><span class="n">bprm</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">flush_arg_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pos</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__bprm_mm_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="n">MAX_ARG_PAGES</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">valid_arg_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_MMU */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Create a new mm_struct and populate it with a temporary stack</span>
<span class="cm"> * vm_area_struct.  We don&#39;t have enough context at this point to set the stack</span>
<span class="cm"> * flags, permissions, and offset, so we use temporary values.  We&#39;ll update</span>
<span class="cm"> * them later in setup_arg_pages().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">bprm_mm_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">=</span> <span class="n">mm</span> <span class="o">=</span> <span class="n">mm_alloc</span><span class="p">();</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">init_new_context</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">mm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">__bprm_mm_init</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">mmdrop</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">user_arg_ptr</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="n">bool</span> <span class="n">is_compat</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="k">const</span> <span class="n">__user</span> <span class="o">*</span><span class="n">native</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
		<span class="n">compat_uptr_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">compat</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="nf">get_user_arg_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">user_arg_ptr</span> <span class="n">argv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">native</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">argv</span><span class="p">.</span><span class="n">is_compat</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">compat_uptr_t</span> <span class="n">compat</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">compat</span><span class="p">,</span> <span class="n">argv</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">compat</span> <span class="o">+</span> <span class="n">nr</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">compat</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">native</span><span class="p">,</span> <span class="n">argv</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">native</span> <span class="o">+</span> <span class="n">nr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">native</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * count() counts the number of strings in array ARGV.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">count</span><span class="p">(</span><span class="k">struct</span> <span class="n">user_arg_ptr</span> <span class="n">argv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">argv</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">native</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">get_user_arg_ptr</span><span class="p">(</span><span class="n">argv</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">fatal_signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ERESTARTNOHAND</span><span class="p">;</span>
			<span class="n">cond_resched</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * &#39;copy_strings()&#39; copies argument/environment strings from the old</span>
<span class="cm"> * processes&#39;s memory to the new process&#39;s stack.  The call to get_user_pages()</span>
<span class="cm"> * ensures the destination page is created and not swapped out.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">copy_strings</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">user_arg_ptr</span> <span class="n">argv</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">kmapped_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kpos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">argc</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pos</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">str</span> <span class="o">=</span> <span class="n">get_user_arg_ptr</span><span class="p">(</span><span class="n">argv</span><span class="p">,</span> <span class="n">argc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">str</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">strnlen_user</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">MAX_ARG_STRLEN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_arg_len</span><span class="p">(</span><span class="n">bprm</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* We&#39;re going to work our way backwords. */</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
		<span class="n">str</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">bytes_to_copy</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">fatal_signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTNOHAND</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">cond_resched</span><span class="p">();</span>

			<span class="n">offset</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">offset</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

			<span class="n">bytes_to_copy</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bytes_to_copy</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
				<span class="n">bytes_to_copy</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

			<span class="n">offset</span> <span class="o">-=</span> <span class="n">bytes_to_copy</span><span class="p">;</span>
			<span class="n">pos</span> <span class="o">-=</span> <span class="n">bytes_to_copy</span><span class="p">;</span>
			<span class="n">str</span> <span class="o">-=</span> <span class="n">bytes_to_copy</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">-=</span> <span class="n">bytes_to_copy</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kmapped_page</span> <span class="o">||</span> <span class="n">kpos</span> <span class="o">!=</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

				<span class="n">page</span> <span class="o">=</span> <span class="n">get_arg_page</span><span class="p">(</span><span class="n">bprm</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">kmapped_page</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">flush_kernel_dcache_page</span><span class="p">(</span><span class="n">kmapped_page</span><span class="p">);</span>
					<span class="n">kunmap</span><span class="p">(</span><span class="n">kmapped_page</span><span class="p">);</span>
					<span class="n">put_arg_page</span><span class="p">(</span><span class="n">kmapped_page</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">kmapped_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
				<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">kmapped_page</span><span class="p">);</span>
				<span class="n">kpos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
				<span class="n">flush_arg_page</span><span class="p">(</span><span class="n">bprm</span><span class="p">,</span> <span class="n">kpos</span><span class="p">,</span> <span class="n">kmapped_page</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">kaddr</span><span class="o">+</span><span class="n">offset</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">bytes_to_copy</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kmapped_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flush_kernel_dcache_page</span><span class="p">(</span><span class="n">kmapped_page</span><span class="p">);</span>
		<span class="n">kunmap</span><span class="p">(</span><span class="n">kmapped_page</span><span class="p">);</span>
		<span class="n">put_arg_page</span><span class="p">(</span><span class="n">kmapped_page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Like copy_strings, but get argv and its values from kernel memory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">copy_strings_kernel</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="o">*</span><span class="n">__argv</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">mm_segment_t</span> <span class="n">oldfs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">user_arg_ptr</span> <span class="n">argv</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">native</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="k">const</span>  <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">__argv</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">copy_strings</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">bprm</span><span class="p">);</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">oldfs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">copy_strings_kernel</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_MMU</span>

<span class="cm">/*</span>
<span class="cm"> * During bprm_mm_init(), we create a temporary stack at STACK_TOP_MAX.  Once</span>
<span class="cm"> * the binfmt code determines where the new stack should reside, we shift it to</span>
<span class="cm"> * its final location.  The process proceeds as follows:</span>
<span class="cm"> *</span>
<span class="cm"> * 1) Use shift to calculate the new vma endpoints.</span>
<span class="cm"> * 2) Extend vma to cover both the old and new ranges.  This ensures the</span>
<span class="cm"> *    arguments passed to subsequent functions are consistent.</span>
<span class="cm"> * 3) Move vma&#39;s page tables to the new range.</span>
<span class="cm"> * 4) Free up any cleared pgd range.</span>
<span class="cm"> * 5) Shrink the vma to cover only the new range.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">shift_arg_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_start</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_end</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span> <span class="o">=</span> <span class="n">old_end</span> <span class="o">-</span> <span class="n">old_start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_start</span> <span class="o">=</span> <span class="n">old_start</span> <span class="o">-</span> <span class="n">shift</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_end</span> <span class="o">=</span> <span class="n">old_end</span> <span class="o">-</span> <span class="n">shift</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mmu_gather</span> <span class="n">tlb</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">new_start</span> <span class="o">&gt;</span> <span class="n">new_end</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * ensure there are no vmas between where we want to go</span>
<span class="cm">	 * and where we are</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span> <span class="o">!=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">new_start</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * cover the whole range: [new_start, old_end)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma_adjust</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">new_start</span><span class="p">,</span> <span class="n">old_end</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * move the page tables downwards, on failure we rely on</span>
<span class="cm">	 * process cleanup to remove whatever mess we made.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">!=</span> <span class="n">move_page_tables</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">old_start</span><span class="p">,</span>
				       <span class="n">vma</span><span class="p">,</span> <span class="n">new_start</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">lru_add_drain</span><span class="p">();</span>
	<span class="n">tlb_gather_mmu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_end</span> <span class="o">&gt;</span> <span class="n">old_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * when the old and new regions overlap clear from new_end.</span>
<span class="cm">		 */</span>
		<span class="n">free_pgd_range</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="p">,</span> <span class="n">new_end</span><span class="p">,</span> <span class="n">old_end</span><span class="p">,</span> <span class="n">new_end</span><span class="p">,</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span> <span class="o">?</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * otherwise, clean from old_start; this is done to not touch</span>
<span class="cm">		 * the address space in [new_end, old_start) some architectures</span>
<span class="cm">		 * have constraints on va-space that make this illegal (IA64) -</span>
<span class="cm">		 * for the others its just a little faster.</span>
<span class="cm">		 */</span>
		<span class="n">free_pgd_range</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="p">,</span> <span class="n">old_start</span><span class="p">,</span> <span class="n">old_end</span><span class="p">,</span> <span class="n">new_end</span><span class="p">,</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span> <span class="o">?</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">tlb_finish_mmu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="p">,</span> <span class="n">new_end</span><span class="p">,</span> <span class="n">old_end</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Shrink the vma to just the new range.  Always succeeds.</span>
<span class="cm">	 */</span>
	<span class="n">vma_adjust</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">new_start</span><span class="p">,</span> <span class="n">new_end</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Finalizes the stack vm_area_struct. The flags and permissions are updated,</span>
<span class="cm"> * the stack is optionally relocated, and some extra space is added.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">setup_arg_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_top</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">executable_stack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_shift</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_expand</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rlim_stack</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_STACK_GROWSUP</span>
	<span class="cm">/* Limit stack size to 1GB */</span>
	<span class="n">stack_base</span> <span class="o">=</span> <span class="n">rlimit_max</span><span class="p">(</span><span class="n">RLIMIT_STACK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stack_base</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">))</span>
		<span class="n">stack_base</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">;</span>

	<span class="cm">/* Make sure we didn&#39;t let the argument array grow too large. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&gt;</span> <span class="n">stack_base</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">stack_base</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">stack_top</span> <span class="o">-</span> <span class="n">stack_base</span><span class="p">);</span>

	<span class="n">stack_shift</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">-</span> <span class="n">stack_base</span><span class="p">;</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">arg_start</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">-</span> <span class="n">stack_shift</span><span class="p">;</span>
	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">stack_shift</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">stack_top</span> <span class="o">=</span> <span class="n">arch_align_stack</span><span class="p">(</span><span class="n">stack_top</span><span class="p">);</span>
	<span class="n">stack_top</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">stack_top</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">stack_top</span> <span class="o">&lt;</span> <span class="n">mmap_min_addr</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">unlikely</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&gt;=</span> <span class="n">stack_top</span> <span class="o">-</span> <span class="n">mmap_min_addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">stack_shift</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">stack_top</span><span class="p">;</span>

	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">-=</span> <span class="n">stack_shift</span><span class="p">;</span>
	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">arg_start</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">loader</span><span class="p">)</span>
		<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">loader</span> <span class="o">-=</span> <span class="n">stack_shift</span><span class="p">;</span>
	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">exec</span> <span class="o">-=</span> <span class="n">stack_shift</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">vm_flags</span> <span class="o">=</span> <span class="n">VM_STACK_FLAGS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Adjust stack execute permissions; explicitly enable for</span>
<span class="cm">	 * EXSTACK_ENABLE_X, disable for EXSTACK_DISABLE_X and leave alone</span>
<span class="cm">	 * (arch default) otherwise.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">executable_stack</span> <span class="o">==</span> <span class="n">EXSTACK_ENABLE_X</span><span class="p">))</span>
		<span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_EXEC</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">executable_stack</span> <span class="o">==</span> <span class="n">EXSTACK_DISABLE_X</span><span class="p">)</span>
		<span class="n">vm_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VM_EXEC</span><span class="p">;</span>
	<span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">def_flags</span><span class="p">;</span>
	<span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_STACK_INCOMPLETE_SETUP</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mprotect_fixup</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prev</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">,</span>
			<span class="n">vm_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">vma</span><span class="p">);</span>

	<span class="cm">/* Move stack pages down in memory. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stack_shift</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">shift_arg_pages</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">stack_shift</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* mprotect_fixup is overkill to remove the temporary stack flags */</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VM_STACK_INCOMPLETE_SETUP</span><span class="p">;</span>

	<span class="n">stack_expand</span> <span class="o">=</span> <span class="mi">131072UL</span><span class="p">;</span> <span class="cm">/* randomly 32*4k (or 2*64k) pages */</span>
	<span class="n">stack_size</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Align this down to a page boundary as expand_stack</span>
<span class="cm">	 * will align it up.</span>
<span class="cm">	 */</span>
	<span class="n">rlim_stack</span> <span class="o">=</span> <span class="n">rlimit</span><span class="p">(</span><span class="n">RLIMIT_STACK</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_STACK_GROWSUP</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stack_size</span> <span class="o">+</span> <span class="n">stack_expand</span> <span class="o">&gt;</span> <span class="n">rlim_stack</span><span class="p">)</span>
		<span class="n">stack_base</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">+</span> <span class="n">rlim_stack</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">stack_base</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">+</span> <span class="n">stack_expand</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stack_size</span> <span class="o">+</span> <span class="n">stack_expand</span> <span class="o">&gt;</span> <span class="n">rlim_stack</span><span class="p">)</span>
		<span class="n">stack_base</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">rlim_stack</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">stack_base</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">-</span> <span class="n">stack_expand</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_stack</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">expand_stack</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">stack_base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">setup_arg_pages</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_MMU */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="nf">open_exec</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">open_flags</span> <span class="n">open_exec_flags</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">open_flag</span> <span class="o">=</span> <span class="n">O_LARGEFILE</span> <span class="o">|</span> <span class="n">O_RDONLY</span> <span class="o">|</span> <span class="n">__FMODE_EXEC</span><span class="p">,</span>
		<span class="p">.</span><span class="n">acc_mode</span> <span class="o">=</span> <span class="n">MAY_EXEC</span> <span class="o">|</span> <span class="n">MAY_OPEN</span><span class="p">,</span>
		<span class="p">.</span><span class="n">intent</span> <span class="o">=</span> <span class="n">LOOKUP_OPEN</span>
	<span class="p">};</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">do_filp_open</span><span class="p">(</span><span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">open_exec_flags</span><span class="p">,</span> <span class="n">LOOKUP_FOLLOW</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="n">MNT_NOEXEC</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">fsnotify_open</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">deny_write_access</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">file</span><span class="p">;</span>

<span class="nl">exit:</span>
	<span class="n">fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">open_exec</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kernel_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mm_segment_t</span> <span class="n">old_fs</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">old_fs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">get_ds</span><span class="p">());</span>
	<span class="cm">/* The cast to a user pointer is valid due to the set_fs() */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">vfs_read</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">);</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">old_fs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kernel_read</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">exec_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span> <span class="n">old_mm</span><span class="p">,</span> <span class="o">*</span><span class="n">active_mm</span><span class="p">;</span>

	<span class="cm">/* Notify parent that we&#39;re no longer interested in the old VM */</span>
	<span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="n">old_mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="n">mm_release</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">old_mm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_mm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sync_mm_rss</span><span class="p">(</span><span class="n">old_mm</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Make sure that if there is a core dump in progress</span>
<span class="cm">		 * for the old mm, we get out and die instead of going</span>
<span class="cm">		 * through with the exec.  We must hold mmap_sem around</span>
<span class="cm">		 * checking core_state and changing tsk-&gt;mm.</span>
<span class="cm">		 */</span>
		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">old_mm</span><span class="o">-&gt;</span><span class="n">core_state</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">task_lock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">active_mm</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">=</span> <span class="n">mm</span><span class="p">;</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="n">mm</span><span class="p">;</span>
	<span class="n">activate_mm</span><span class="p">(</span><span class="n">active_mm</span><span class="p">,</span> <span class="n">mm</span><span class="p">);</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">arch_pick_mmap_layout</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_mm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">active_mm</span> <span class="o">!=</span> <span class="n">old_mm</span><span class="p">);</span>
		<span class="n">setmax_mm_hiwater_rss</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">maxrss</span><span class="p">,</span> <span class="n">old_mm</span><span class="p">);</span>
		<span class="n">mm_update_next_owner</span><span class="p">(</span><span class="n">old_mm</span><span class="p">);</span>
		<span class="n">mmput</span><span class="p">(</span><span class="n">old_mm</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mmdrop</span><span class="p">(</span><span class="n">active_mm</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function makes sure the current process has its own signal table,</span>
<span class="cm"> * so that flush_signal_handlers can later reset the handlers without</span>
<span class="cm"> * disturbing other processes.  (Other processes might share the signal</span>
<span class="cm"> * table via the CLONE_SIGHAND option to clone().)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">de_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">sig</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sighand_struct</span> <span class="o">*</span><span class="n">oldsighand</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">oldsighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">thread_group_empty</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">no_thread_group</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Kill all other threads in the thread group.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">signal_group_exit</span><span class="p">(</span><span class="n">sig</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Another group action in progress, just</span>
<span class="cm">		 * return so that the signal is processed.</span>
<span class="cm">		 */</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sig</span><span class="o">-&gt;</span><span class="n">group_exit_task</span> <span class="o">=</span> <span class="n">tsk</span><span class="p">;</span>
	<span class="n">sig</span><span class="o">-&gt;</span><span class="n">notify_count</span> <span class="o">=</span> <span class="n">zap_other_threads</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">thread_group_leader</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span>
		<span class="n">sig</span><span class="o">-&gt;</span><span class="n">notify_count</span><span class="o">--</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">sig</span><span class="o">-&gt;</span><span class="n">notify_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this point all other threads have exited, all we have to</span>
<span class="cm">	 * do is to wait for the thread group leader to become inactive,</span>
<span class="cm">	 * and to assume its PID:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">thread_group_leader</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">leader</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">;</span>

		<span class="n">sig</span><span class="o">-&gt;</span><span class="n">notify_count</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* for exit_notify() */</span>
		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
			<span class="n">write_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">leader</span><span class="o">-&gt;</span><span class="n">exit_state</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
			<span class="n">schedule</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * The only record we have of the real-time age of a</span>
<span class="cm">		 * process, regardless of execs it&#39;s done, is start_time.</span>
<span class="cm">		 * All the past CPU time is accumulated in signal_struct</span>
<span class="cm">		 * from sister threads now dead.  But in this non-leader</span>
<span class="cm">		 * exec, nothing survives from the original leader thread,</span>
<span class="cm">		 * whose birth marks the true age of this process now.</span>
<span class="cm">		 * When we take on its identity by switching to its PID, we</span>
<span class="cm">		 * also take its birthdate (always earlier than our own).</span>
<span class="cm">		 */</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">leader</span><span class="o">-&gt;</span><span class="n">start_time</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">same_thread_group</span><span class="p">(</span><span class="n">leader</span><span class="p">,</span> <span class="n">tsk</span><span class="p">));</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">has_group_leader_pid</span><span class="p">(</span><span class="n">tsk</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * An exec() starts a new thread group with the</span>
<span class="cm">		 * TGID of the previous thread group. Rehash the</span>
<span class="cm">		 * two threads with a switched PID, and release</span>
<span class="cm">		 * the former thread group leader:</span>
<span class="cm">		 */</span>

		<span class="cm">/* Become a process group leader with the old leader&#39;s pid.</span>
<span class="cm">		 * The old leader becomes a thread of the this thread group.</span>
<span class="cm">		 * Note: The old leader also uses this pid until release_task</span>
<span class="cm">		 *       is called.  Odd but simple and correct.</span>
<span class="cm">		 */</span>
		<span class="n">detach_pid</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">PIDTYPE_PID</span><span class="p">);</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">leader</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
		<span class="n">attach_pid</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">PIDTYPE_PID</span><span class="p">,</span>  <span class="n">task_pid</span><span class="p">(</span><span class="n">leader</span><span class="p">));</span>
		<span class="n">transfer_pid</span><span class="p">(</span><span class="n">leader</span><span class="p">,</span> <span class="n">tsk</span><span class="p">,</span> <span class="n">PIDTYPE_PGID</span><span class="p">);</span>
		<span class="n">transfer_pid</span><span class="p">(</span><span class="n">leader</span><span class="p">,</span> <span class="n">tsk</span><span class="p">,</span> <span class="n">PIDTYPE_SID</span><span class="p">);</span>

		<span class="n">list_replace_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leader</span><span class="o">-&gt;</span><span class="n">tasks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">tasks</span><span class="p">);</span>
		<span class="n">list_replace_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leader</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">);</span>

		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">group_leader</span> <span class="o">=</span> <span class="n">tsk</span><span class="p">;</span>
		<span class="n">leader</span><span class="o">-&gt;</span><span class="n">group_leader</span> <span class="o">=</span> <span class="n">tsk</span><span class="p">;</span>

		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">exit_signal</span> <span class="o">=</span> <span class="n">SIGCHLD</span><span class="p">;</span>
		<span class="n">leader</span><span class="o">-&gt;</span><span class="n">exit_signal</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">leader</span><span class="o">-&gt;</span><span class="n">exit_state</span> <span class="o">!=</span> <span class="n">EXIT_ZOMBIE</span><span class="p">);</span>
		<span class="n">leader</span><span class="o">-&gt;</span><span class="n">exit_state</span> <span class="o">=</span> <span class="n">EXIT_DEAD</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We are going to release_task()-&gt;ptrace_unlink() silently,</span>
<span class="cm">		 * the tracer can sleep in do_wait(). EXIT_DEAD guarantees</span>
<span class="cm">		 * the tracer wont&#39;t block again waiting for this thread.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">leader</span><span class="o">-&gt;</span><span class="n">ptrace</span><span class="p">))</span>
			<span class="n">__wake_up_parent</span><span class="p">(</span><span class="n">leader</span><span class="p">,</span> <span class="n">leader</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
		<span class="n">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

		<span class="n">release_task</span><span class="p">(</span><span class="n">leader</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sig</span><span class="o">-&gt;</span><span class="n">group_exit_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sig</span><span class="o">-&gt;</span><span class="n">notify_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">no_thread_group:</span>
	<span class="cm">/* we have changed execution domain */</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">exit_signal</span> <span class="o">=</span> <span class="n">SIGCHLD</span><span class="p">;</span>

	<span class="n">exit_itimers</span><span class="p">(</span><span class="n">sig</span><span class="p">);</span>
	<span class="n">flush_itimer_signals</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldsighand</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sighand_struct</span> <span class="o">*</span><span class="n">newsighand</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * This -&gt;sighand is shared with the CLONE_SIGHAND</span>
<span class="cm">		 * but not CLONE_THREAD task, switch to the new one.</span>
<span class="cm">		 */</span>
		<span class="n">newsighand</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">sighand_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newsighand</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newsighand</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">newsighand</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">,</span> <span class="n">oldsighand</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">newsighand</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">));</span>

		<span class="n">write_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldsighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="p">,</span> <span class="n">newsighand</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldsighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
		<span class="n">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

		<span class="n">__cleanup_sighand</span><span class="p">(</span><span class="n">oldsighand</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">thread_group_leader</span><span class="p">(</span><span class="n">tsk</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These functions flushes out all traces of the currently running executable</span>
<span class="cm"> * so that a new one can be started</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_old_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span> <span class="n">files</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fdtable</span> <span class="o">*</span><span class="n">fdt</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">file_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">set</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">j</span><span class="o">++</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">*</span> <span class="n">__NFDBITS</span><span class="p">;</span>
		<span class="n">fdt</span> <span class="o">=</span> <span class="n">files_fdtable</span><span class="p">(</span><span class="n">files</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">fdt</span><span class="o">-&gt;</span><span class="n">max_fds</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">set</span> <span class="o">=</span> <span class="n">fdt</span><span class="o">-&gt;</span><span class="n">close_on_exec</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">set</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">fdt</span><span class="o">-&gt;</span><span class="n">close_on_exec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">file_lock</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">set</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="n">set</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">set</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sys_close</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">file_lock</span><span class="p">);</span>

	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">file_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">get_task_comm</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* buf must be at least sizeof(tsk-&gt;comm) in size */</span>
	<span class="n">task_lock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">));</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">get_task_comm</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">set_task_comm</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">task_lock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="n">trace_task_rename</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Threads may access current-&gt;comm without holding</span>
<span class="cm">	 * the task lock, so write the string carefully.</span>
<span class="cm">	 * Readers without a lock may see incomplete new</span>
<span class="cm">	 * names but are safe from non-terminating string reads.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">TASK_COMM_LEN</span><span class="p">);</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">));</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">perf_event_comm</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">filename_to_taskname</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">tcomm</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ch</span><span class="p">;</span>

	<span class="cm">/* Copies the binary name from after last slash */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">ch</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">fn</span><span class="o">++</span><span class="p">))</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* overwrite what we wrote */</span>
		<span class="k">else</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">tcomm</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tcomm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">flush_old_exec</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span> <span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure we have a private signal table and that</span>
<span class="cm">	 * we are unassociated from the previous thread group.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">de_thread</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">set_mm_exe_file</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">);</span>

	<span class="n">filename_to_taskname</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">tcomm</span><span class="p">,</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">tcomm</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * Release all of the old mmap stuff</span>
<span class="cm">	 */</span>
	<span class="n">acct_arg_size</span><span class="p">(</span><span class="n">bprm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">exec_mmap</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>		<span class="cm">/* We&#39;re using it now */</span>

	<span class="n">set_fs</span><span class="p">(</span><span class="n">USER_DS</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PF_RANDOMIZE</span> <span class="o">|</span> <span class="n">PF_FORKNOEXEC</span> <span class="o">|</span> <span class="n">PF_KTHREAD</span><span class="p">);</span>
	<span class="n">flush_thread</span><span class="p">();</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">personality</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">per_clear</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">flush_old_exec</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">would_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode_permission</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">MAY_READ</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">interp_flags</span> <span class="o">|=</span> <span class="n">BINPRM_FLAGS_ENFORCE_NONDUMP</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">would_dump</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">setup_new_exec</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span> <span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">arch_pick_mmap_layout</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>

	<span class="cm">/* This is the point of no return */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">sas_ss_sp</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">sas_ss_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">current_euid</span><span class="p">(),</span> <span class="n">current_uid</span><span class="p">())</span> <span class="o">&amp;&amp;</span> <span class="n">gid_eq</span><span class="p">(</span><span class="n">current_egid</span><span class="p">(),</span> <span class="n">current_gid</span><span class="p">()))</span>
		<span class="n">set_dumpable</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">set_dumpable</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">suid_dumpable</span><span class="p">);</span>

	<span class="n">set_task_comm</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">tcomm</span><span class="p">);</span>

	<span class="cm">/* Set the new mm task size. We have to do that late because it may</span>
<span class="cm">	 * depend on TIF_32BIT which is only updated in flush_thread() on</span>
<span class="cm">	 * some architectures like powerpc</span>
<span class="cm">	 */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">task_size</span> <span class="o">=</span> <span class="n">TASK_SIZE</span><span class="p">;</span>

	<span class="cm">/* install the new credentials */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">,</span> <span class="n">current_euid</span><span class="p">())</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">gid_eq</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">,</span> <span class="n">current_egid</span><span class="p">()))</span> <span class="p">{</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">pdeath_signal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">would_dump</span><span class="p">(</span><span class="n">bprm</span><span class="p">,</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">interp_flags</span> <span class="o">&amp;</span> <span class="n">BINPRM_FLAGS_ENFORCE_NONDUMP</span><span class="p">)</span>
			<span class="n">set_dumpable</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">suid_dumpable</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Flush performance counters when crossing a</span>
<span class="cm">	 * security domain:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_dumpable</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">))</span>
		<span class="n">perf_event_exit_task</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>

	<span class="cm">/* An exec changes our domain. We are no longer part of the thread</span>
<span class="cm">	   group */</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">self_exec_id</span><span class="o">++</span><span class="p">;</span>
			
	<span class="n">flush_signal_handlers</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">flush_old_files</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">setup_new_exec</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Prepare credentials and lock -&gt;cred_guard_mutex.</span>
<span class="cm"> * install_exec_creds() commits the new creds and drops the lock.</span>
<span class="cm"> * Or, if exec fails before, free_bprm() should release -&gt;cred and</span>
<span class="cm"> * and unlock.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">prepare_bprm_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cred_guard_mutex</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERESTARTNOINTR</span><span class="p">;</span>

	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span> <span class="o">=</span> <span class="n">prepare_exec_creds</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cred_guard_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_bprm</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_arg_pages</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cred_guard_mutex</span><span class="p">);</span>
		<span class="n">abort_creds</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * install the new credentials for this executable</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">install_exec_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">security_bprm_committing_creds</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>

	<span class="n">commit_creds</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">);</span>
	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * cred_guard_mutex must be held at least to this point to prevent</span>
<span class="cm">	 * ptrace_attach() from altering our determination of the task&#39;s</span>
<span class="cm">	 * credentials; any time after this it may be unlocked.</span>
<span class="cm">	 */</span>
	<span class="n">security_bprm_committed_creds</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cred_guard_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">install_exec_creds</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * determine how safe it is to execute the proposed program</span>
<span class="cm"> * - the caller must hold -&gt;cred_guard_mutex to protect against</span>
<span class="cm"> *   PTRACE_ATTACH</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_unsafe_exec</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">n_fs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ptrace</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">&amp;</span> <span class="n">PT_PTRACE_CAP</span><span class="p">)</span>
			<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">unsafe</span> <span class="o">|=</span> <span class="n">LSM_UNSAFE_PTRACE_CAP</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">unsafe</span> <span class="o">|=</span> <span class="n">LSM_UNSAFE_PTRACE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This isn&#39;t strictly necessary, but it makes it harder for LSMs to</span>
<span class="cm">	 * mess up.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">no_new_privs</span><span class="p">)</span>
		<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">unsafe</span> <span class="o">|=</span> <span class="n">LSM_UNSAFE_NO_NEW_PRIVS</span><span class="p">;</span>

	<span class="n">n_fs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">t</span> <span class="o">=</span> <span class="n">next_thread</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">p</span><span class="p">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">next_thread</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">fs</span> <span class="o">==</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">)</span>
			<span class="n">n_fs</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">users</span> <span class="o">&gt;</span> <span class="n">n_fs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">unsafe</span> <span class="o">|=</span> <span class="n">LSM_UNSAFE_SHARE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">in_exec</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">in_exec</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* </span>
<span class="cm"> * Fill the binprm structure from the inode. </span>
<span class="cm"> * Check permissions, then read the first 128 (BINPRM_BUF_SIZE) bytes</span>
<span class="cm"> *</span>
<span class="cm"> * This may be called multiple times for binary chains (scripts for example).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">prepare_binprm</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">umode_t</span> <span class="n">mode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">mode</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="cm">/* clear any previous set[ug]id data from a previous binary */</span>
	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span> <span class="o">=</span> <span class="n">current_euid</span><span class="p">();</span>
	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">egid</span> <span class="o">=</span> <span class="n">current_egid</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="n">MNT_NOSUID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">no_new_privs</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set-uid? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_ISUID</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kuid_has_mapping</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">per_clear</span> <span class="o">|=</span> <span class="n">PER_CLEAR_ON_SETID</span><span class="p">;</span>
			<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">;</span>

		<span class="p">}</span>

		<span class="cm">/* Set-gid? */</span>
		<span class="cm">/*</span>
<span class="cm">		 * If setgid is set but no group execute bit then this</span>
<span class="cm">		 * is a candidate for mandatory locking, not a setgid</span>
<span class="cm">		 * executable.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">S_ISGID</span> <span class="o">|</span> <span class="n">S_IXGRP</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="n">S_ISGID</span> <span class="o">|</span> <span class="n">S_IXGRP</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kgid_has_mapping</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">per_clear</span> <span class="o">|=</span> <span class="n">PER_CLEAR_ON_SETID</span><span class="p">;</span>
			<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">egid</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* fill in binprm security blob */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">security_bprm_set_creds</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred_prepared</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">BINPRM_BUF_SIZE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">kernel_read</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">BINPRM_BUF_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">prepare_binprm</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Arguments are &#39;\0&#39; separated strings found at the location bprm-&gt;p</span>
<span class="cm"> * points to; chop off the first by relocating brpm-&gt;p to right after</span>
<span class="cm"> * the first &#39;\0&#39; encountered.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">remove_arg_zero</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">argc</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">get_arg_page</span><span class="p">(</span><span class="n">bprm</span><span class="p">,</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span> <span class="o">&amp;&amp;</span> <span class="n">kaddr</span><span class="p">[</span><span class="n">offset</span><span class="p">];</span>
				<span class="n">offset</span><span class="o">++</span><span class="p">,</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">++</span><span class="p">)</span>
			<span class="p">;</span>

		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
		<span class="n">put_arg_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
			<span class="n">free_arg_page</span><span class="p">(</span><span class="n">bprm</span><span class="p">,</span> <span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">++</span><span class="p">;</span>
	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">argc</span><span class="o">--</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">remove_arg_zero</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * cycle the list of binary formats handler, until one recognizes the image</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">search_binary_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">recursion_depth</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">try</span><span class="p">,</span><span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">linux_binfmt</span> <span class="o">*</span><span class="n">fmt</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">old_pid</span><span class="p">,</span> <span class="n">old_vpid</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">security_bprm_check</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">audit_bprm</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* Need to fetch pid before load_binary changes it */</span>
	<span class="n">old_pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">old_vpid</span> <span class="o">=</span> <span class="n">task_pid_nr_ns</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">task_active_pid_ns</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">));</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">try</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">try</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span> <span class="n">try</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binfmt_lock</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">formats</span><span class="p">,</span> <span class="n">lh</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">-&gt;</span><span class="n">load_binary</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fn</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">fmt</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binfmt_lock</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">bprm</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Restore the depth counter to its starting value</span>
<span class="cm">			 * in this call, so we don&#39;t have to rely on every</span>
<span class="cm">			 * load_binary function to restore it on return.</span>
<span class="cm">			 */</span>
			<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">recursion_depth</span> <span class="o">=</span> <span class="n">depth</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">trace_sched_process_exec</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">old_pid</span><span class="p">,</span> <span class="n">bprm</span><span class="p">);</span>
					<span class="n">ptrace_event</span><span class="p">(</span><span class="n">PTRACE_EVENT_EXEC</span><span class="p">,</span> <span class="n">old_vpid</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">put_binfmt</span><span class="p">(</span><span class="n">fmt</span><span class="p">);</span>
				<span class="n">allow_write_access</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">)</span>
					<span class="n">fput</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">);</span>
				<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">did_exec</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">proc_exec_connector</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binfmt_lock</span><span class="p">);</span>
			<span class="n">put_binfmt</span><span class="p">(</span><span class="n">fmt</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOEXEC</span> <span class="o">||</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binfmt_lock</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binfmt_lock</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_MODULES</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOEXEC</span> <span class="o">||</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#define printable(c) (((c)==&#39;\t&#39;) || ((c)==&#39;\n&#39;) || (0x20&lt;=(c) &amp;&amp; (c)&lt;=0x7e))</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">printable</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
			    <span class="n">printable</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
			    <span class="n">printable</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
			    <span class="n">printable</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
				<span class="k">break</span><span class="p">;</span> <span class="cm">/* -ENOEXEC */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">try</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span> <span class="cm">/* -ENOEXEC */</span>
			<span class="n">request_module</span><span class="p">(</span><span class="s">&quot;binfmt-%04x&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
		<span class="p">}</span>
<span class="cp">#else</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">search_binary_handler</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * sys_execve() executes a new program.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_execve_common</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">user_arg_ptr</span> <span class="n">argv</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">user_arg_ptr</span> <span class="n">envp</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">displaced</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">clear_in_exec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * We move the actual failure in case of RLIMIT_NPROC excess from</span>
<span class="cm">	 * set*uid() to execve() because too many poorly written programs</span>
<span class="cm">	 * don&#39;t check setuid() return code.  Here we additionally recheck</span>
<span class="cm">	 * whether NPROC limit is still exceeded.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_NPROC_EXCEEDED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">processes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">rlimit</span><span class="p">(</span><span class="n">RLIMIT_NPROC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We&#39;re below the limit (still or again), so we don&#39;t want to make</span>
<span class="cm">	 * further execve() calls fail. */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PF_NPROC_EXCEEDED</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">unshare_files</span><span class="p">(</span><span class="o">&amp;</span><span class="n">displaced</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ret</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">bprm</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bprm</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bprm</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_files</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">prepare_bprm_creds</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">check_unsafe_exec</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="n">clear_in_exec</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">in_execve</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">open_exec</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unmark</span><span class="p">;</span>

	<span class="n">sched_exec</span><span class="p">();</span>

	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span><span class="p">;</span>
	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">interp</span> <span class="o">=</span> <span class="n">filename</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">bprm_mm_init</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_file</span><span class="p">;</span>

	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">=</span> <span class="n">count</span><span class="p">(</span><span class="n">argv</span><span class="p">,</span> <span class="n">MAX_ARG_STRINGS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">argc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">envc</span> <span class="o">=</span> <span class="n">count</span><span class="p">(</span><span class="n">envp</span><span class="p">,</span> <span class="n">MAX_ARG_STRINGS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">envc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">prepare_binprm</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">copy_strings_kernel</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">,</span> <span class="n">bprm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">exec</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">copy_strings</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">envc</span><span class="p">,</span> <span class="n">envp</span><span class="p">,</span> <span class="n">bprm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">copy_strings</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">bprm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">search_binary_handler</span><span class="p">(</span><span class="n">bprm</span><span class="p">,</span><span class="n">regs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* execve succeeded */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">in_exec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">in_execve</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">acct_update_integrals</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">free_bprm</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">displaced</span><span class="p">)</span>
		<span class="n">put_files_struct</span><span class="p">(</span><span class="n">displaced</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">acct_arg_size</span><span class="p">(</span><span class="n">bprm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">mmput</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out_file:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">allow_write_access</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">);</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out_unmark:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clear_in_exec</span><span class="p">)</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">fs</span><span class="o">-&gt;</span><span class="n">in_exec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">in_execve</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">free_bprm</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>

<span class="nl">out_files:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">displaced</span><span class="p">)</span>
		<span class="n">reset_files_struct</span><span class="p">(</span><span class="n">displaced</span><span class="p">);</span>
<span class="nl">out_ret:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">do_execve</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="k">const</span> <span class="n">__user</span> <span class="o">*</span><span class="n">__argv</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="k">const</span> <span class="n">__user</span> <span class="o">*</span><span class="n">__envp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">user_arg_ptr</span> <span class="n">argv</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">native</span> <span class="o">=</span> <span class="n">__argv</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">user_arg_ptr</span> <span class="n">envp</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">native</span> <span class="o">=</span> <span class="n">__envp</span> <span class="p">};</span>
	<span class="k">return</span> <span class="n">do_execve_common</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="kt">int</span> <span class="nf">compat_do_execve</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span>
	<span class="n">compat_uptr_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">__argv</span><span class="p">,</span>
	<span class="n">compat_uptr_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">__envp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">user_arg_ptr</span> <span class="n">argv</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">is_compat</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">compat</span> <span class="o">=</span> <span class="n">__argv</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">user_arg_ptr</span> <span class="n">envp</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">is_compat</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">compat</span> <span class="o">=</span> <span class="n">__envp</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">return</span> <span class="n">do_execve_common</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="nf">set_binfmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binfmt</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">binfmt</span><span class="p">)</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">binfmt</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">);</span>

	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">binfmt</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">)</span>
		<span class="n">__module_get</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">module</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_binfmt</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">expand_corename</span><span class="p">(</span><span class="k">struct</span> <span class="n">core_name</span> <span class="o">*</span><span class="n">cn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">old_corename</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">corename</span><span class="p">;</span>

	<span class="n">cn</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">CORENAME_MAX_SIZE</span> <span class="o">*</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">call_count</span><span class="p">);</span>
	<span class="n">cn</span><span class="o">-&gt;</span><span class="n">corename</span> <span class="o">=</span> <span class="n">krealloc</span><span class="p">(</span><span class="n">old_corename</span><span class="p">,</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">corename</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">old_corename</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cn_printf</span><span class="p">(</span><span class="k">struct</span> <span class="n">core_name</span> <span class="o">*</span><span class="n">cn</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">need</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">arg</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">need</span> <span class="o">=</span> <span class="n">vsnprintf</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">need</span> <span class="o">&lt;</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_printf</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">expand_corename</span><span class="p">(</span><span class="n">cn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">expand_fail</span><span class="p">;</span>

<span class="nl">out_printf:</span>
	<span class="n">cur</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">corename</span> <span class="o">+</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">;</span>
	<span class="n">va_start</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">vsnprintf</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">need</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
	<span class="n">cn</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">+=</span> <span class="n">need</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">expand_fail:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cn_escape</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span> <span class="n">str</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span>
			<span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="sc">&#39;!&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cn_print_exe_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">core_name</span> <span class="o">*</span><span class="n">cn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">exe_file</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">pathbuf</span><span class="p">,</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">exe_file</span> <span class="o">=</span> <span class="n">get_mm_exe_file</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exe_file</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">commstart</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">corename</span> <span class="o">+</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cn_printf</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="s">&quot;%s (path unknown)&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
		<span class="n">cn_escape</span><span class="p">(</span><span class="n">commstart</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pathbuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">PATH_MAX</span><span class="p">,</span> <span class="n">GFP_TEMPORARY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pathbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">put_exe_file</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">d_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exe_file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">,</span> <span class="n">pathbuf</span><span class="p">,</span> <span class="n">PATH_MAX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">path</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_buf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cn_escape</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">cn_printf</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>

<span class="nl">free_buf:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pathbuf</span><span class="p">);</span>
<span class="nl">put_exe_file:</span>
	<span class="n">fput</span><span class="p">(</span><span class="n">exe_file</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* format_corename will inspect the pattern parameter, and output a</span>
<span class="cm"> * name into corename, which must have space for at least</span>
<span class="cm"> * CORENAME_MAX_SIZE bytes plus one byte for the zero terminator.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">format_corename</span><span class="p">(</span><span class="k">struct</span> <span class="n">core_name</span> <span class="o">*</span><span class="n">cn</span><span class="p">,</span> <span class="kt">long</span> <span class="n">signr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pat_ptr</span> <span class="o">=</span> <span class="n">core_pattern</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ispipe</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">pat_ptr</span> <span class="o">==</span> <span class="sc">&#39;|&#39;</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">pid_in_pattern</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cn</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">CORENAME_MAX_SIZE</span> <span class="o">*</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">call_count</span><span class="p">);</span>
	<span class="n">cn</span><span class="o">-&gt;</span><span class="n">corename</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">cn</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">corename</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Repeat as long as we have more pattern to process and more output</span>
<span class="cm">	   space */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">pat_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pat_ptr</span> <span class="o">!=</span> <span class="sc">&#39;%&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pat_ptr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">cn_printf</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">pat_ptr</span><span class="o">++</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="o">*++</span><span class="n">pat_ptr</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* single % at the end, drop that */</span>
			<span class="k">case</span> <span class="mi">0</span>:
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="cm">/* Double percent, output one percent */</span>
			<span class="k">case</span> <span class="sc">&#39;%&#39;</span>:
				<span class="n">err</span> <span class="o">=</span> <span class="n">cn_printf</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="sc">&#39;%&#39;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* pid */</span>
			<span class="k">case</span> <span class="sc">&#39;p&#39;</span>:
				<span class="n">pid_in_pattern</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">cn_printf</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span>
					      <span class="n">task_tgid_vnr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* uid */</span>
			<span class="k">case</span> <span class="sc">&#39;u&#39;</span>:
				<span class="n">err</span> <span class="o">=</span> <span class="n">cn_printf</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* gid */</span>
			<span class="k">case</span> <span class="sc">&#39;g&#39;</span>:
				<span class="n">err</span> <span class="o">=</span> <span class="n">cn_printf</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* signal that caused the coredump */</span>
			<span class="k">case</span> <span class="sc">&#39;s&#39;</span>:
				<span class="n">err</span> <span class="o">=</span> <span class="n">cn_printf</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="s">&quot;%ld&quot;</span><span class="p">,</span> <span class="n">signr</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* UNIX time of coredump */</span>
			<span class="k">case</span> <span class="sc">&#39;t&#39;</span>: <span class="p">{</span>
				<span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>
				<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">cn_printf</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="s">&quot;%lu&quot;</span><span class="p">,</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* hostname */</span>
			<span class="k">case</span> <span class="sc">&#39;h&#39;</span>: <span class="p">{</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">namestart</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">corename</span> <span class="o">+</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">;</span>
				<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uts_sem</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">cn_printf</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span>
					      <span class="n">utsname</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">nodename</span><span class="p">);</span>
				<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uts_sem</span><span class="p">);</span>
				<span class="n">cn_escape</span><span class="p">(</span><span class="n">namestart</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* executable */</span>
			<span class="k">case</span> <span class="sc">&#39;e&#39;</span>: <span class="p">{</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">commstart</span> <span class="o">=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">corename</span> <span class="o">+</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">;</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">cn_printf</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
				<span class="n">cn_escape</span><span class="p">(</span><span class="n">commstart</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">case</span> <span class="sc">&#39;E&#39;</span>:
				<span class="n">err</span> <span class="o">=</span> <span class="n">cn_print_exe_file</span><span class="p">(</span><span class="n">cn</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* core limit size */</span>
			<span class="k">case</span> <span class="sc">&#39;c&#39;</span>:
				<span class="n">err</span> <span class="o">=</span> <span class="n">cn_printf</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="s">&quot;%lu&quot;</span><span class="p">,</span>
					      <span class="n">rlimit</span><span class="p">(</span><span class="n">RLIMIT_CORE</span><span class="p">));</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="o">++</span><span class="n">pat_ptr</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Backward compatibility with core_uses_pid:</span>
<span class="cm">	 *</span>
<span class="cm">	 * If core_pattern does not include a %p (as is the default)</span>
<span class="cm">	 * and core_uses_pid is set, then .%pid will be appended to</span>
<span class="cm">	 * the filename. Do not do this for piped commands. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ispipe</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pid_in_pattern</span> <span class="o">&amp;&amp;</span> <span class="n">core_uses_pid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">cn_printf</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="s">&quot;.%d&quot;</span><span class="p">,</span> <span class="n">task_tgid_vnr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ispipe</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">zap_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exit_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">start</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">SIGNAL_GROUP_EXIT</span><span class="p">;</span>
	<span class="n">start</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">group_exit_code</span> <span class="o">=</span> <span class="n">exit_code</span><span class="p">;</span>
	<span class="n">start</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">group_stop_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">task_clear_jobctl_pending</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">JOBCTL_PENDING_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">current</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">.</span><span class="n">signal</span><span class="p">,</span> <span class="n">SIGKILL</span><span class="p">);</span>
			<span class="n">signal_wake_up</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">nr</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">zap_threads</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">core_state</span> <span class="o">*</span><span class="n">core_state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exit_code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">g</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">signal_group_exit</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">core_state</span> <span class="o">=</span> <span class="n">core_state</span><span class="p">;</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">zap_process</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">exit_code</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">nr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">nr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">)</span> <span class="o">==</span> <span class="n">nr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We should find and kill all tasks which use this mm, and we should</span>
<span class="cm">	 * count them correctly into -&gt;nr_threads. We don&#39;t take tasklist</span>
<span class="cm">	 * lock, but this is safe wrt:</span>
<span class="cm">	 *</span>
<span class="cm">	 * fork:</span>
<span class="cm">	 *	None of sub-threads can fork after zap_process(leader). All</span>
<span class="cm">	 *	processes which were created before this point should be</span>
<span class="cm">	 *	visible to zap_threads() because copy_process() adds the new</span>
<span class="cm">	 *	process to the tail of init_task.tasks list, and lock/unlock</span>
<span class="cm">	 *	of -&gt;siglock provides a memory barrier.</span>
<span class="cm">	 *</span>
<span class="cm">	 * do_exit:</span>
<span class="cm">	 *	The caller holds mm-&gt;mmap_sem. This means that the task which</span>
<span class="cm">	 *	uses this mm can&#39;t pass exit_mm(), so it can&#39;t exit or clear</span>
<span class="cm">	 *	its -&gt;mm.</span>
<span class="cm">	 *</span>
<span class="cm">	 * de_thread:</span>
<span class="cm">	 *	It does list_replace_rcu(&amp;leader-&gt;tasks, &amp;current-&gt;tasks),</span>
<span class="cm">	 *	we must see either old or new leader, this does not matter.</span>
<span class="cm">	 *	However, it can change p-&gt;sighand, so lock_task_sighand(p)</span>
<span class="cm">	 *	must be used. Since p-&gt;mm != NULL and we hold -&gt;mmap_sem</span>
<span class="cm">	 *	it can&#39;t fail.</span>
<span class="cm">	 *</span>
<span class="cm">	 *	Note also that &quot;g&quot; can be the old leader with -&gt;mm == NULL</span>
<span class="cm">	 *	and already unhashed and thus removed from -&gt;thread_group.</span>
<span class="cm">	 *	This is OK, __unhash_process()-&gt;list_del_rcu() does not</span>
<span class="cm">	 *	clear the -&gt;next pointer, we will find the new leader via</span>
<span class="cm">	 *	next_thread().</span>
<span class="cm">	 */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">for_each_process</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">g</span> <span class="o">==</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_KTHREAD</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">g</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">==</span> <span class="n">mm</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">lock_task_sighand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
					<span class="n">nr</span> <span class="o">+=</span> <span class="n">zap_process</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">exit_code</span><span class="p">);</span>
					<span class="n">unlock_task_sighand</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="nl">done:</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_state</span><span class="o">-&gt;</span><span class="n">nr_threads</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">coredump_wait</span><span class="p">(</span><span class="kt">int</span> <span class="n">exit_code</span><span class="p">,</span> <span class="k">struct</span> <span class="n">core_state</span> <span class="o">*</span><span class="n">core_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">core_waiters</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_state</span><span class="o">-&gt;</span><span class="n">startup</span><span class="p">);</span>
	<span class="n">core_state</span><span class="o">-&gt;</span><span class="n">dumper</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="n">tsk</span><span class="p">;</span>
	<span class="n">core_state</span><span class="o">-&gt;</span><span class="n">dumper</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">core_state</span><span class="p">)</span>
		<span class="n">core_waiters</span> <span class="o">=</span> <span class="n">zap_threads</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">core_state</span><span class="p">,</span> <span class="n">exit_code</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">core_waiters</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">core_thread</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_state</span><span class="o">-&gt;</span><span class="n">startup</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Wait for all the threads to become inactive, so that</span>
<span class="cm">		 * all the thread context (extended register state, like</span>
<span class="cm">		 * fpu etc) gets copied to the memory.</span>
<span class="cm">		 */</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">core_state</span><span class="o">-&gt;</span><span class="n">dumper</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wait_task_inactive</span><span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">core_waiters</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">coredump_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">core_thread</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>

	<span class="n">next</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">core_state</span><span class="o">-&gt;</span><span class="n">dumper</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">curr</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">task</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * see exit_mm(), curr-&gt;task must not see</span>
<span class="cm">		 * -&gt;task == NULL before we read -&gt;next.</span>
<span class="cm">		 */</span>
		<span class="n">smp_mb</span><span class="p">();</span>
		<span class="n">curr</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">core_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * set_dumpable converts traditional three-value dumpable to two flags and</span>
<span class="cm"> * stores them into mm-&gt;flags.  It modifies lower two bits of mm-&gt;flags, but</span>
<span class="cm"> * these bits are not changed atomically.  So get_dumpable can observe the</span>
<span class="cm"> * intermediate state.  To avoid doing unexpected behavior, get get_dumpable</span>
<span class="cm"> * return either old dumpable or new one by paying attention to the order of</span>
<span class="cm"> * modifying the bits.</span>
<span class="cm"> *</span>
<span class="cm"> * dumpable |   mm-&gt;flags (binary)</span>
<span class="cm"> * old  new | initial interim  final</span>
<span class="cm"> * ---------+-----------------------</span>
<span class="cm"> *  0    1  |   00      01      01</span>
<span class="cm"> *  0    2  |   00      10(*)   11</span>
<span class="cm"> *  1    0  |   01      00      00</span>
<span class="cm"> *  1    2  |   01      11      11</span>
<span class="cm"> *  2    0  |   11      10(*)   00</span>
<span class="cm"> *  2    1  |   11      11      01</span>
<span class="cm"> *</span>
<span class="cm"> * (*) get_dumpable regards interim value of 10 as 11.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">set_dumpable</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">MMF_DUMPABLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">smp_wmb</span><span class="p">();</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">MMF_DUMP_SECURELY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">set_bit</span><span class="p">(</span><span class="n">MMF_DUMPABLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">smp_wmb</span><span class="p">();</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">MMF_DUMP_SECURELY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">set_bit</span><span class="p">(</span><span class="n">MMF_DUMP_SECURELY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">smp_wmb</span><span class="p">();</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">MMF_DUMPABLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__get_dumpable</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mm_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mm_flags</span> <span class="o">&amp;</span> <span class="n">MMF_DUMPABLE_MASK</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">get_dumpable</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__get_dumpable</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wait_for_dump_helpers</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">;</span>

	<span class="n">pipe</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_pipe</span><span class="p">;</span>

	<span class="n">pipe_lock</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">readers</span><span class="o">++</span><span class="p">;</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">writers</span><span class="o">--</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">readers</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">wake_up_interruptible_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
		<span class="n">kill_fasync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pipe</span><span class="o">-&gt;</span><span class="n">fasync_readers</span><span class="p">,</span> <span class="n">SIGIO</span><span class="p">,</span> <span class="n">POLL_IN</span><span class="p">);</span>
		<span class="n">pipe_wait</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">readers</span><span class="o">--</span><span class="p">;</span>
	<span class="n">pipe</span><span class="o">-&gt;</span><span class="n">writers</span><span class="o">++</span><span class="p">;</span>
	<span class="n">pipe_unlock</span><span class="p">(</span><span class="n">pipe</span><span class="p">);</span>

<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * umh_pipe_setup</span>
<span class="cm"> * helper function to customize the process used</span>
<span class="cm"> * to collect the core in userspace.  Specifically</span>
<span class="cm"> * it sets up a pipe and installs it as fd 0 (stdin)</span>
<span class="cm"> * for the process.  Returns 0 on success, or</span>
<span class="cm"> * PTR_ERR on failure.</span>
<span class="cm"> * Note that it also sets the core limit to 1.  This</span>
<span class="cm"> * is a special value that we use to trap recursive</span>
<span class="cm"> * core dumps</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">umh_pipe_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">subprocess_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">rp</span><span class="p">,</span> <span class="o">*</span><span class="n">wp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fdtable</span> <span class="o">*</span><span class="n">fdt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">coredump_params</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">coredump_params</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">cf</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">;</span>

	<span class="n">wp</span> <span class="o">=</span> <span class="n">create_write_pipe</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">wp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">wp</span><span class="p">);</span>

	<span class="n">rp</span> <span class="o">=</span> <span class="n">create_read_pipe</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">free_write_pipe</span><span class="p">(</span><span class="n">wp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">rp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">=</span> <span class="n">wp</span><span class="p">;</span>

	<span class="n">sys_close</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">fd_install</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">rp</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">file_lock</span><span class="p">);</span>
	<span class="n">fdt</span> <span class="o">=</span> <span class="n">files_fdtable</span><span class="p">(</span><span class="n">cf</span><span class="p">);</span>
	<span class="n">__set_open_fd</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fdt</span><span class="p">);</span>
	<span class="n">__clear_close_on_exec</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fdt</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">file_lock</span><span class="p">);</span>

	<span class="cm">/* and disallow core files too */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">rlim</span><span class="p">[</span><span class="n">RLIMIT_CORE</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rlimit</span><span class="p">){</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">do_coredump</span><span class="p">(</span><span class="kt">long</span> <span class="n">signr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exit_code</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">core_state</span> <span class="n">core_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">core_name</span> <span class="n">cn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">linux_binfmt</span> <span class="o">*</span> <span class="n">binfmt</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old_cred</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ispipe</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">core_dump_count</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">coredump_params</span> <span class="n">cprm</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">signr</span> <span class="o">=</span> <span class="n">signr</span><span class="p">,</span>
		<span class="p">.</span><span class="n">regs</span> <span class="o">=</span> <span class="n">regs</span><span class="p">,</span>
		<span class="p">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">rlimit</span><span class="p">(</span><span class="n">RLIMIT_CORE</span><span class="p">),</span>
		<span class="cm">/*</span>
<span class="cm">		 * We must use the same mm-&gt;flags while dumping core to avoid</span>
<span class="cm">		 * inconsistency of bit flags, since this flag is not protected</span>
<span class="cm">		 * by any locks.</span>
<span class="cm">		 */</span>
		<span class="p">.</span><span class="n">mm_flags</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">audit_core_dumps</span><span class="p">(</span><span class="n">signr</span><span class="p">);</span>

	<span class="n">binfmt</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">binfmt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">binfmt</span> <span class="o">||</span> <span class="o">!</span><span class="n">binfmt</span><span class="o">-&gt;</span><span class="n">core_dump</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__get_dumpable</span><span class="p">(</span><span class="n">cprm</span><span class="p">.</span><span class="n">mm_flags</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">cred</span> <span class="o">=</span> <span class="n">prepare_creds</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cred</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *	We cannot trust fsuid as being the &quot;true&quot; uid of the</span>
<span class="cm">	 *	process nor do we know its entire history. We only know it</span>
<span class="cm">	 *	was tainted so we dump it as root in mode 2.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__get_dumpable</span><span class="p">(</span><span class="n">cprm</span><span class="p">.</span><span class="n">mm_flags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Setuid core dump mode */</span>
		<span class="n">flag</span> <span class="o">=</span> <span class="n">O_EXCL</span><span class="p">;</span>		<span class="cm">/* Stop rewrite attacks */</span>
		<span class="n">cred</span><span class="o">-&gt;</span><span class="n">fsuid</span> <span class="o">=</span> <span class="n">GLOBAL_ROOT_UID</span><span class="p">;</span>	<span class="cm">/* Dump root private */</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">coredump_wait</span><span class="p">(</span><span class="n">exit_code</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">core_state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_creds</span><span class="p">;</span>

	<span class="n">old_cred</span> <span class="o">=</span> <span class="n">override_creds</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear any false indication of pending signals that might</span>
<span class="cm">	 * be seen by the filesystem code called to write the core file.</span>
<span class="cm">	 */</span>
	<span class="n">clear_thread_flag</span><span class="p">(</span><span class="n">TIF_SIGPENDING</span><span class="p">);</span>

	<span class="n">ispipe</span> <span class="o">=</span> <span class="n">format_corename</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cn</span><span class="p">,</span> <span class="n">signr</span><span class="p">);</span>

 	<span class="k">if</span> <span class="p">(</span><span class="n">ispipe</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">dump_count</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">**</span><span class="n">helper_argv</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ispipe</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;format_corename failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Aborting core</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail_corename</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cprm</span><span class="p">.</span><span class="n">limit</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Normally core limits are irrelevant to pipes, since</span>
<span class="cm">			 * we&#39;re not writing to the file system, but we use</span>
<span class="cm">			 * cprm.limit of 1 here as a speacial value. Any</span>
<span class="cm">			 * non-1 limit gets set to RLIM_INFINITY below, but</span>
<span class="cm">			 * a limit of 0 skips the dump.  This is a consistent</span>
<span class="cm">			 * way to catch recursive crashes.  We can still crash</span>
<span class="cm">			 * if the core_pattern binary sets RLIM_CORE =  !1</span>
<span class="cm">			 * but it runs as root, and can do lots of stupid things</span>
<span class="cm">			 * Note that we use task_tgid_vnr here to grab the pid</span>
<span class="cm">			 * of the process group leader.  That way we get the</span>
<span class="cm">			 * right pid if a thread in a multi-threaded</span>
<span class="cm">			 * core_pattern process dies.</span>
<span class="cm">			 */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;Process %d(%s) has RLIMIT_CORE set to 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">task_tgid_vnr</span><span class="p">(</span><span class="n">current</span><span class="p">),</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Aborting core</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail_unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cprm</span><span class="p">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">RLIM_INFINITY</span><span class="p">;</span>

		<span class="n">dump_count</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_dump_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">core_pipe_limit</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">core_pipe_limit</span> <span class="o">&lt;</span> <span class="n">dump_count</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Pid %d(%s) over core_pipe_limit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">task_tgid_vnr</span><span class="p">(</span><span class="n">current</span><span class="p">),</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Skipping core dump</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail_dropcount</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">helper_argv</span> <span class="o">=</span> <span class="n">argv_split</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">cn</span><span class="p">.</span><span class="n">corename</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">helper_argv</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s failed to allocate memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail_dropcount</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">call_usermodehelper_fns</span><span class="p">(</span><span class="n">helper_argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">helper_argv</span><span class="p">,</span>
					<span class="nb">NULL</span><span class="p">,</span> <span class="n">UMH_WAIT_EXEC</span><span class="p">,</span> <span class="n">umh_pipe_setup</span><span class="p">,</span>
					<span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cprm</span><span class="p">);</span>
		<span class="n">argv_free</span><span class="p">(</span><span class="n">helper_argv</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
 			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Core dump to %s pipe failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">cn</span><span class="p">.</span><span class="n">corename</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">close_fail</span><span class="p">;</span>
 		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cprm</span><span class="p">.</span><span class="n">limit</span> <span class="o">&lt;</span> <span class="n">binfmt</span><span class="o">-&gt;</span><span class="n">min_coredump</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail_unlock</span><span class="p">;</span>

		<span class="n">cprm</span><span class="p">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">filp_open</span><span class="p">(</span><span class="n">cn</span><span class="p">.</span><span class="n">corename</span><span class="p">,</span>
				 <span class="n">O_CREAT</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="n">O_NOFOLLOW</span> <span class="o">|</span> <span class="n">O_LARGEFILE</span> <span class="o">|</span> <span class="n">flag</span><span class="p">,</span>
				 <span class="mo">0600</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">cprm</span><span class="p">.</span><span class="n">file</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">fail_unlock</span><span class="p">;</span>

		<span class="n">inode</span> <span class="o">=</span> <span class="n">cprm</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">close_fail</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d_unhashed</span><span class="p">(</span><span class="n">cprm</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">close_fail</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * AK: actually i see no reason to not allow this for named</span>
<span class="cm">		 * pipes etc, but keep the previous behaviour for now.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">close_fail</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Dont allow local users get cute and trick others to coredump</span>
<span class="cm">		 * into their pre-created files.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">,</span> <span class="n">current_fsuid</span><span class="p">()))</span>
			<span class="k">goto</span> <span class="n">close_fail</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cprm</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">||</span> <span class="o">!</span><span class="n">cprm</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">close_fail</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">do_truncate</span><span class="p">(</span><span class="n">cprm</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cprm</span><span class="p">.</span><span class="n">file</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">close_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">binfmt</span><span class="o">-&gt;</span><span class="n">core_dump</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cprm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">group_exit_code</span> <span class="o">|=</span> <span class="mh">0x80</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ispipe</span> <span class="o">&amp;&amp;</span> <span class="n">core_pipe_limit</span><span class="p">)</span>
		<span class="n">wait_for_dump_helpers</span><span class="p">(</span><span class="n">cprm</span><span class="p">.</span><span class="n">file</span><span class="p">);</span>
<span class="nl">close_fail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cprm</span><span class="p">.</span><span class="n">file</span><span class="p">)</span>
		<span class="n">filp_close</span><span class="p">(</span><span class="n">cprm</span><span class="p">.</span><span class="n">file</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="nl">fail_dropcount:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ispipe</span><span class="p">)</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">core_dump_count</span><span class="p">);</span>
<span class="nl">fail_unlock:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cn</span><span class="p">.</span><span class="n">corename</span><span class="p">);</span>
<span class="nl">fail_corename:</span>
	<span class="n">coredump_finish</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">revert_creds</span><span class="p">(</span><span class="n">old_cred</span><span class="p">);</span>
<span class="nl">fail_creds:</span>
	<span class="n">put_cred</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>
<span class="nl">fail:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Core dumping helper functions.  These are the only things you should</span>
<span class="cm"> * do on a core-file: use only these functions to write out all the</span>
<span class="cm"> * necessary info.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dump_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">nr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">)</span> <span class="o">==</span> <span class="n">nr</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dump_write</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">dump_seek</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">llseek</span> <span class="o">&amp;&amp;</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">llseek</span> <span class="o">!=</span> <span class="n">no_llseek</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">llseek</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">SEEK_CUR</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">get_zeroed_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">off</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span> <span class="o">=</span> <span class="n">off</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
				<span class="n">n</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dump_write</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">off</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dump_seek</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
