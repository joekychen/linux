<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › seq_file.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>seq_file.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/fs/seq_file.c</span>
<span class="cm"> *</span>
<span class="cm"> * helper functions for making synthetic files from sequences of records.</span>
<span class="cm"> * initial implementation -- AV, Oct 2001.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>


<span class="cm">/*</span>
<span class="cm"> * seq_files have a buffer which can may overflow. When this happens a larger</span>
<span class="cm"> * buffer is reallocated and all the data will be printed again.</span>
<span class="cm"> * The overflow state is true when m-&gt;count == m-&gt;size.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">seq_overflow</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">seq_set_overflow</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	seq_open -	initialize sequential file</span>
<span class="cm"> *	@file: file we initialize</span>
<span class="cm"> *	@op: method table describing the sequence</span>
<span class="cm"> *</span>
<span class="cm"> *	seq_open() sets @file, associating it with a sequence described</span>
<span class="cm"> *	by @op.  @op-&gt;start() sets the iterator up and returns the first</span>
<span class="cm"> *	element of sequence. @op-&gt;stop() shuts it down.  @op-&gt;next()</span>
<span class="cm"> *	returns the next element of sequence.  @op-&gt;show() prints element</span>
<span class="cm"> *	into the buffer.  In case of error -&gt;start() and -&gt;next() return</span>
<span class="cm"> *	ERR_PTR(error).  In the end of sequence they return %NULL. -&gt;show()</span>
<span class="cm"> *	returns 0 in case of success and negative number in case of error.</span>
<span class="cm"> *	Returning SEQ_SKIP means &quot;discard this element and move on&quot;.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">seq_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">));</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wrappers around seq_open(e.g. swaps_open) need to be</span>
<span class="cm">	 * aware of this. If they set f_version themselves, they</span>
<span class="cm">	 * should call seq_open first and then set f_version.</span>
<span class="cm">	 */</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * seq_files support lseek() and pread().  They do not implement</span>
<span class="cm">	 * write() at all, but we clear FMODE_PWRITE here for historical</span>
<span class="cm">	 * reasons.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If a client of seq_files a) implements file.write() and b) wishes to</span>
<span class="cm">	 * support pwrite() then that client will need to implement its own</span>
<span class="cm">	 * file.open() which calls seq_open() and then sets FMODE_PWRITE.</span>
<span class="cm">	 */</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FMODE_PWRITE</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_open</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">traverse</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">m</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">from</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">seq_overflow</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">Eoverflow</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">from</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">pos</span><span class="p">;</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">from</span><span class="p">;</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">index</span><span class="o">++</span><span class="p">;</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

<span class="nl">Eoverflow:</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">?</span> <span class="o">-</span><span class="n">ENOMEM</span> <span class="o">:</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	seq_read -	-&gt;read() method for sequential files.</span>
<span class="cm"> *	@file: the file to read from</span>
<span class="cm"> *	@buf: the buffer to read to</span>
<span class="cm"> *	@size: the maximum number of bytes to read</span>
<span class="cm"> *	@ppos: the current position in the file</span>
<span class="cm"> *</span>
<span class="cm"> *	Ready-made -&gt;f_op-&gt;read()</span>
<span class="cm"> */</span>
<span class="kt">ssize_t</span> <span class="nf">seq_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">pos</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * seq_file-&gt;op-&gt;..m_start/m_stop/m_next may do special actions</span>
<span class="cm">	 * or optimisations based on the file-&gt;f_version, so we want to</span>
<span class="cm">	 * pass the file-&gt;f_version to those methods.</span>
<span class="cm">	 *</span>
<span class="cm">	 * seq_file-&gt;version is just copy of f_version, and seq_file</span>
<span class="cm">	 * methods can treat it simply as file version.</span>
<span class="cm">	 * It is copied in first and copied out after all operations.</span>
<span class="cm">	 * It is convenient to have it as  part of structure to avoid the</span>
<span class="cm">	 * need of passing another argument to all the seq_file methods.</span>
<span class="cm">	 */</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_version</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t assume *ppos is where we left it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">*</span><span class="n">ppos</span> <span class="o">!=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">read_pos</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">traverse</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">ppos</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
			<span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* With prejudice... */</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">read_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">Done</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">read_pos</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppos</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* grab buffer if we didn&#39;t have one */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">Enomem</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* if not empty - flush it first */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">from</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">Efault</span><span class="p">;</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">from</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">copied</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">Done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* we need at least one record in buffer */</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span> <span class="o">||</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">);</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">Fill</span><span class="p">;</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">Enomem</span><span class="p">;</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">Done</span><span class="p">;</span>
<span class="nl">Fill:</span>
	<span class="cm">/* they want more? let&#39;s try to get some more */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">offs</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
		<span class="n">loff_t</span> <span class="n">next</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span> <span class="o">||</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">seq_overflow</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">||</span> <span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">offs</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">Efault</span><span class="p">;</span>
	<span class="n">copied</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">from</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pos</span><span class="o">++</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
<span class="nl">Done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copied</span><span class="p">)</span>
		<span class="n">copied</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ppos</span> <span class="o">+=</span> <span class="n">copied</span><span class="p">;</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">read_pos</span> <span class="o">+=</span> <span class="n">copied</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_version</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">copied</span><span class="p">;</span>
<span class="nl">Enomem:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">Done</span><span class="p">;</span>
<span class="nl">Efault:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">Done</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_read</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	seq_lseek -	-&gt;llseek() method for sequential files.</span>
<span class="cm"> *	@file: the file in question</span>
<span class="cm"> *	@offset: new position</span>
<span class="cm"> *	@origin: 0 for absolute, 1 for relative position</span>
<span class="cm"> *</span>
<span class="cm"> *	Ready-made -&gt;f_op-&gt;llseek()</span>
<span class="cm"> */</span>
<span class="n">loff_t</span> <span class="nf">seq_lseek</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_version</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">origin</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">!=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">read_pos</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">while</span> <span class="p">((</span><span class="n">retval</span><span class="o">=</span><span class="n">traverse</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
					<span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* with extreme prejudice... */</span>
					<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">m</span><span class="o">-&gt;</span><span class="n">read_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">m</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">m</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">m</span><span class="o">-&gt;</span><span class="n">read_pos</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
					<span class="n">retval</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_version</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_lseek</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	seq_release -	free the structures associated with sequential file.</span>
<span class="cm"> *	@file: file in question</span>
<span class="cm"> *	@inode: file-&gt;f_path.dentry-&gt;d_inode</span>
<span class="cm"> *</span>
<span class="cm"> *	Frees the structures associated with sequential file; can be used</span>
<span class="cm"> *	as -&gt;f_op-&gt;release() if you don&#39;t have private data to destroy.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">seq_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_release</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	seq_escape -	print string into buffer, escaping some characters</span>
<span class="cm"> *	@m:	target buffer</span>
<span class="cm"> *	@s:	string</span>
<span class="cm"> *	@esc:	set of characters that need escaping</span>
<span class="cm"> *</span>
<span class="cm"> *	Puts string into buffer, replacing each occurrence of character from</span>
<span class="cm"> *	@esc with usual octal escape.  Returns 0 in case of success, -1 - in</span>
<span class="cm"> *	case of overflow.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">seq_escape</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">esc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">c</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strchr</span><span class="p">(</span><span class="n">esc</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;\\&#39;</span><span class="p">;</span>
			<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="p">((</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mo">0300</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">);</span>
			<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="p">((</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mo">070</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
			<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mo">07</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">seq_set_overflow</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_escape</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">seq_printf</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">vsnprintf</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
		<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">seq_set_overflow</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_printf</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	mangle_path -	mangle and copy path to buffer beginning</span>
<span class="cm"> *	@s: buffer start</span>
<span class="cm"> *	@p: beginning of path in above buffer</span>
<span class="cm"> *	@esc: set of characters that need escaping</span>
<span class="cm"> *</span>
<span class="cm"> *      Copy the path from @p to @s, replacing each occurrence of character from</span>
<span class="cm"> *      @esc with usual octal escape.</span>
<span class="cm"> *      Returns pointer past last written character in @s, or NULL in case of</span>
<span class="cm"> *      failure.</span>
<span class="cm"> */</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">mangle_path</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">esc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strchr</span><span class="p">(</span><span class="n">esc</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;\\&#39;</span><span class="p">;</span>
			<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="p">((</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mo">0300</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">);</span>
			<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="p">((</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mo">070</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
			<span class="o">*</span><span class="n">s</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mo">07</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mangle_path</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * seq_path - seq_file interface to print a pathname</span>
<span class="cm"> * @m: the seq_file handle</span>
<span class="cm"> * @path: the struct path to print</span>
<span class="cm"> * @esc: set of characters to escape in the output</span>
<span class="cm"> *</span>
<span class="cm"> * return the absolute path of &#39;path&#39;, as represented by the</span>
<span class="cm"> * dentry / mnt pair in the path parameter.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">seq_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">esc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">seq_get_buf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">d_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">mangle_path</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">esc</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">end</span><span class="p">)</span>
				<span class="n">res</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">seq_commit</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_path</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Same as seq_path, but relative to supplied root.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">seq_path_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
		  <span class="k">const</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">esc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">seq_get_buf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

		<span class="n">p</span> <span class="o">=</span> <span class="n">__d_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">SEQ_SKIP</span><span class="p">;</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">mangle_path</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">esc</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">end</span><span class="p">)</span>
				<span class="n">res</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">seq_commit</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">res</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span> <span class="o">?</span> <span class="n">res</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * returns the path of the &#39;dentry&#39; from the root of its filesystem.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">seq_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">esc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">seq_get_buf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">dentry_path</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">mangle_path</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">esc</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">end</span><span class="p">)</span>
				<span class="n">res</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">seq_commit</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">seq_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bits</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">bitmap_scnprintf</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span>
				<span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="n">nr_bits</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">seq_set_overflow</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_bitmap</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">seq_bitmap_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bits</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">bitmap_scnlistprintf</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span>
				<span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="n">nr_bits</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">seq_set_overflow</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_bitmap_list</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">single_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">single_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">++*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">single_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">single_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">seq_operations</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">op</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">single_start</span><span class="p">;</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">single_next</span><span class="p">;</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">=</span> <span class="n">single_stop</span><span class="p">;</span>
		<span class="n">op</span><span class="o">-&gt;</span><span class="n">show</span> <span class="o">=</span> <span class="n">show</span><span class="p">;</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span>
			<span class="p">((</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="p">)</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">single_open</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">single_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="p">)</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">seq_release</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">single_release</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">seq_release_private</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>
	<span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">seq_release</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_release_private</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">__seq_open_private</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">psize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>

	<span class="n">private</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">psize</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">private</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">seq</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">private</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">private</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">private</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__seq_open_private</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">seq_open_private</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">psize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__seq_open_private</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">ops</span><span class="p">,</span> <span class="n">psize</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_open_private</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">seq_putc</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_putc</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">seq_puts</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">seq_set_overflow</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_puts</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * A helper routine for putting decimal numbers without rich format of printf().</span>
<span class="cm"> * only &#39;unsigned long long&#39; is supported.</span>
<span class="cm"> * This routine will put one byte delimiter + number into seq_file.</span>
<span class="cm"> * This routine is very quick when you show lots of numbers.</span>
<span class="cm"> * In usual cases, it will be better to use seq_printf(). It&#39;s easier to read.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">seq_put_decimal_ull</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">char</span> <span class="n">delimiter</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="cm">/* we&#39;ll write 2 bytes at least */</span>
		<span class="k">goto</span> <span class="n">overflow</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">delimiter</span><span class="p">)</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">delimiter</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span> <span class="o">+</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">num_to_str</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">overflow</span><span class="p">;</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">overflow:</span>
	<span class="n">seq_set_overflow</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_put_decimal_ull</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">seq_put_decimal_ll</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">char</span> <span class="n">delimiter</span><span class="p">,</span>
			<span class="kt">long</span> <span class="kt">long</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">seq_set_overflow</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delimiter</span><span class="p">)</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">delimiter</span><span class="p">;</span>
		<span class="n">num</span> <span class="o">=</span> <span class="o">-</span><span class="n">num</span><span class="p">;</span>
		<span class="n">delimiter</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">seq_put_decimal_ull</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">delimiter</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_put_decimal_ll</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * seq_write - write arbitrary data to buffer</span>
<span class="cm"> * @seq: seq_file identifying the buffer to which data should be written</span>
<span class="cm"> * @data: data address</span>
<span class="cm"> * @len: number of bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success, non-zero otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">seq_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">seq</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">seq_set_overflow</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_write</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="nf">seq_list_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lh</span><span class="p">;</span>

	<span class="n">list_for_each</span><span class="p">(</span><span class="n">lh</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="o">--</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">lh</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_list_start</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="nf">seq_list_start_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">head</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">seq_list_start</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_list_start_head</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="nf">seq_list_next</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lh</span><span class="p">;</span>

	<span class="n">lh</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">)</span><span class="n">v</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="o">++*</span><span class="n">ppos</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">lh</span> <span class="o">==</span> <span class="n">head</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">lh</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_list_next</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * seq_hlist_start - start an iteration of a hlist</span>
<span class="cm"> * @head: the head of the hlist</span>
<span class="cm"> * @pos:  the start position of the sequence</span>
<span class="cm"> *</span>
<span class="cm"> * Called at seq_file-&gt;op-&gt;start().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="nf">seq_hlist_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">hlist_for_each</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="o">--</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_hlist_start</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * seq_hlist_start_head - start an iteration of a hlist</span>
<span class="cm"> * @head: the head of the hlist</span>
<span class="cm"> * @pos:  the start position of the sequence</span>
<span class="cm"> *</span>
<span class="cm"> * Called at seq_file-&gt;op-&gt;start(). Call this function if you want to</span>
<span class="cm"> * print a header at the top of the output.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="nf">seq_hlist_start_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SEQ_START_TOKEN</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">seq_hlist_start</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_hlist_start_head</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * seq_hlist_next - move to the next position of the hlist</span>
<span class="cm"> * @v:    the current iterator</span>
<span class="cm"> * @head: the head of the hlist</span>
<span class="cm"> * @ppos: the current position</span>
<span class="cm"> *</span>
<span class="cm"> * Called at seq_file-&gt;op-&gt;next().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="nf">seq_hlist_next</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
				  <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

	<span class="o">++*</span><span class="n">ppos</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">SEQ_START_TOKEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_hlist_next</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * seq_hlist_start_rcu - start an iteration of a hlist protected by RCU</span>
<span class="cm"> * @head: the head of the hlist</span>
<span class="cm"> * @pos:  the start position of the sequence</span>
<span class="cm"> *</span>
<span class="cm"> * Called at seq_file-&gt;op-&gt;start().</span>
<span class="cm"> *</span>
<span class="cm"> * This list-traversal primitive may safely run concurrently with</span>
<span class="cm"> * the _rcu list-mutation primitives such as hlist_add_head_rcu()</span>
<span class="cm"> * as long as the traversal is guarded by rcu_read_lock().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="nf">seq_hlist_start_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
				       <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">__hlist_for_each_rcu</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="o">--</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_hlist_start_rcu</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * seq_hlist_start_head_rcu - start an iteration of a hlist protected by RCU</span>
<span class="cm"> * @head: the head of the hlist</span>
<span class="cm"> * @pos:  the start position of the sequence</span>
<span class="cm"> *</span>
<span class="cm"> * Called at seq_file-&gt;op-&gt;start(). Call this function if you want to</span>
<span class="cm"> * print a header at the top of the output.</span>
<span class="cm"> *</span>
<span class="cm"> * This list-traversal primitive may safely run concurrently with</span>
<span class="cm"> * the _rcu list-mutation primitives such as hlist_add_head_rcu()</span>
<span class="cm"> * as long as the traversal is guarded by rcu_read_lock().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="nf">seq_hlist_start_head_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
					    <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SEQ_START_TOKEN</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">seq_hlist_start_rcu</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_hlist_start_head_rcu</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * seq_hlist_next_rcu - move to the next position of the hlist protected by RCU</span>
<span class="cm"> * @v:    the current iterator</span>
<span class="cm"> * @head: the head of the hlist</span>
<span class="cm"> * @ppos: the current position</span>
<span class="cm"> *</span>
<span class="cm"> * Called at seq_file-&gt;op-&gt;next().</span>
<span class="cm"> *</span>
<span class="cm"> * This list-traversal primitive may safely run concurrently with</span>
<span class="cm"> * the _rcu list-mutation primitives such as hlist_add_head_rcu()</span>
<span class="cm"> * as long as the traversal is guarded by rcu_read_lock().</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="nf">seq_hlist_next_rcu</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
				      <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

	<span class="o">++*</span><span class="n">ppos</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">SEQ_START_TOKEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">seq_hlist_next_rcu</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
