<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › logfs › logfs.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>logfs.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * fs/logfs/logfs.h</span>
<span class="cm"> *</span>
<span class="cm"> * As should be obvious for Linux kernel code, license is GPLv2</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2005-2008 Joern Engel &lt;joern@logfs.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Private header for logfs.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef FS_LOGFS_LOGFS_H</span>
<span class="cp">#define FS_LOGFS_LOGFS_H</span>

<span class="cp">#undef __CHECK_ENDIAN__</span>
<span class="cp">#define __CHECK_ENDIAN__</span>

<span class="cp">#include &lt;linux/btree.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mempool.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/mtd.h&gt;</span>
<span class="cp">#include &quot;logfs_abi.h&quot;</span>

<span class="cp">#define LOGFS_DEBUG_SUPER	(0x0001)</span>
<span class="cp">#define LOGFS_DEBUG_SEGMENT	(0x0002)</span>
<span class="cp">#define LOGFS_DEBUG_JOURNAL	(0x0004)</span>
<span class="cp">#define LOGFS_DEBUG_DIR		(0x0008)</span>
<span class="cp">#define LOGFS_DEBUG_FILE	(0x0010)</span>
<span class="cp">#define LOGFS_DEBUG_INODE	(0x0020)</span>
<span class="cp">#define LOGFS_DEBUG_READWRITE	(0x0040)</span>
<span class="cp">#define LOGFS_DEBUG_GC		(0x0080)</span>
<span class="cp">#define LOGFS_DEBUG_GC_NOISY	(0x0100)</span>
<span class="cp">#define LOGFS_DEBUG_ALIASES	(0x0200)</span>
<span class="cp">#define LOGFS_DEBUG_BLOCKMOVE	(0x0400)</span>
<span class="cp">#define LOGFS_DEBUG_ALL		(0xffffffff)</span>

<span class="cp">#define LOGFS_DEBUG		(0x01)</span>
<span class="cm">/*</span>
<span class="cm"> * To enable specific log messages, simply define LOGFS_DEBUG to match any</span>
<span class="cm"> * or all of the above.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef LOGFS_DEBUG</span>
<span class="cp">#define LOGFS_DEBUG		(0)</span>
<span class="cp">#endif</span>

<span class="cp">#define log_cond(cond, fmt, arg...) do {	\</span>
<span class="cp">	if (cond)				\</span>
<span class="cp">		printk(KERN_DEBUG fmt, ##arg);	\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define log_super(fmt, arg...) \</span>
<span class="cp">	log_cond(LOGFS_DEBUG &amp; LOGFS_DEBUG_SUPER, fmt, ##arg)</span>
<span class="cp">#define log_segment(fmt, arg...) \</span>
<span class="cp">	log_cond(LOGFS_DEBUG &amp; LOGFS_DEBUG_SEGMENT, fmt, ##arg)</span>
<span class="cp">#define log_journal(fmt, arg...) \</span>
<span class="cp">	log_cond(LOGFS_DEBUG &amp; LOGFS_DEBUG_JOURNAL, fmt, ##arg)</span>
<span class="cp">#define log_dir(fmt, arg...) \</span>
<span class="cp">	log_cond(LOGFS_DEBUG &amp; LOGFS_DEBUG_DIR, fmt, ##arg)</span>
<span class="cp">#define log_file(fmt, arg...) \</span>
<span class="cp">	log_cond(LOGFS_DEBUG &amp; LOGFS_DEBUG_FILE, fmt, ##arg)</span>
<span class="cp">#define log_inode(fmt, arg...) \</span>
<span class="cp">	log_cond(LOGFS_DEBUG &amp; LOGFS_DEBUG_INODE, fmt, ##arg)</span>
<span class="cp">#define log_readwrite(fmt, arg...) \</span>
<span class="cp">	log_cond(LOGFS_DEBUG &amp; LOGFS_DEBUG_READWRITE, fmt, ##arg)</span>
<span class="cp">#define log_gc(fmt, arg...) \</span>
<span class="cp">	log_cond(LOGFS_DEBUG &amp; LOGFS_DEBUG_GC, fmt, ##arg)</span>
<span class="cp">#define log_gc_noisy(fmt, arg...) \</span>
<span class="cp">	log_cond(LOGFS_DEBUG &amp; LOGFS_DEBUG_GC_NOISY, fmt, ##arg)</span>
<span class="cp">#define log_aliases(fmt, arg...) \</span>
<span class="cp">	log_cond(LOGFS_DEBUG &amp; LOGFS_DEBUG_ALIASES, fmt, ##arg)</span>
<span class="cp">#define log_blockmove(fmt, arg...) \</span>
<span class="cp">	log_cond(LOGFS_DEBUG &amp; LOGFS_DEBUG_BLOCKMOVE, fmt, ##arg)</span>

<span class="cp">#define PG_pre_locked		PG_owner_priv_1</span>
<span class="cp">#define PagePreLocked(page)	test_bit(PG_pre_locked, &amp;(page)-&gt;flags)</span>
<span class="cp">#define SetPagePreLocked(page)	set_bit(PG_pre_locked, &amp;(page)-&gt;flags)</span>
<span class="cp">#define ClearPagePreLocked(page) clear_bit(PG_pre_locked, &amp;(page)-&gt;flags)</span>

<span class="cm">/* FIXME: This should really be somewhere in the 64bit area. */</span>
<span class="cp">#define LOGFS_LINK_MAX		(1&lt;&lt;30)</span>

<span class="cm">/* Read-only filesystem */</span>
<span class="cp">#define LOGFS_SB_FLAG_RO	0x0001</span>
<span class="cp">#define LOGFS_SB_FLAG_DIRTY	0x0002</span>
<span class="cp">#define LOGFS_SB_FLAG_OBJ_ALIAS	0x0004</span>
<span class="cp">#define LOGFS_SB_FLAG_SHUTDOWN	0x0008</span>

<span class="cm">/* Write Control Flags */</span>
<span class="cp">#define WF_LOCK			0x01 </span><span class="cm">/* take write lock */</span><span class="cp"></span>
<span class="cp">#define WF_WRITE		0x02 </span><span class="cm">/* write block */</span><span class="cp"></span>
<span class="cp">#define WF_DELETE		0x04 </span><span class="cm">/* delete old block */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="n">u8</span> <span class="n">__bitwise</span> <span class="n">level_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">u8</span> <span class="n">__bitwise</span> <span class="n">gc_level_t</span><span class="p">;</span>

<span class="cp">#define LEVEL(level) ((__force level_t)(level))</span>
<span class="cp">#define GC_LEVEL(gc_level) ((__force gc_level_t)(gc_level))</span>

<span class="cp">#define SUBLEVEL(level) ( (void)((level) == LEVEL(1)),	\</span>
<span class="cp">		(__force level_t)((__force u8)(level) - 1) )</span>

<span class="cm">/**</span>
<span class="cm"> * struct logfs_area - area management information</span>
<span class="cm"> *</span>
<span class="cm"> * @a_sb:			the superblock this area belongs to</span>
<span class="cm"> * @a_is_open:			1 if the area is currently open, else 0</span>
<span class="cm"> * @a_segno:			segment number of area</span>
<span class="cm"> * @a_written_bytes:		number of bytes already written back</span>
<span class="cm"> * @a_used_bytes:		number of used bytes</span>
<span class="cm"> * @a_ops:			area operations (either journal or ostore)</span>
<span class="cm"> * @a_erase_count:		erase count</span>
<span class="cm"> * @a_level:			GC level</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">logfs_area</span> <span class="p">{</span> <span class="cm">/* a segment open for writing */</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">a_sb</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">a_is_open</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">a_segno</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">a_written_bytes</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">a_used_bytes</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">logfs_area_ops</span> <span class="o">*</span><span class="n">a_ops</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">a_erase_count</span><span class="p">;</span>
	<span class="n">gc_level_t</span> <span class="n">a_level</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct logfs_area_ops - area operations</span>
<span class="cm"> *</span>
<span class="cm"> * @get_free_segment:		fill area-&gt;ofs with the offset of a free segment</span>
<span class="cm"> * @get_erase_count:		fill area-&gt;erase_count (needs area-&gt;ofs)</span>
<span class="cm"> * @erase_segment:		erase and setup segment</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">logfs_area_ops</span> <span class="p">{</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_free_segment</span><span class="p">)(</span><span class="k">struct</span> <span class="n">logfs_area</span> <span class="o">*</span><span class="n">area</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">get_erase_count</span><span class="p">)(</span><span class="k">struct</span> <span class="n">logfs_area</span> <span class="o">*</span><span class="n">area</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">erase_segment</span><span class="p">)(</span><span class="k">struct</span> <span class="n">logfs_area</span> <span class="o">*</span><span class="n">area</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">logfs_super</span><span class="p">;</span>	<span class="cm">/* forward */</span>
<span class="cm">/**</span>
<span class="cm"> * struct logfs_device_ops - device access operations</span>
<span class="cm"> *</span>
<span class="cm"> * @readpage:			read one page (mm page)</span>
<span class="cm"> * @writeseg:			write one segment.  may be a partial segment</span>
<span class="cm"> * @erase:			erase one segment</span>
<span class="cm"> * @read:			read from the device</span>
<span class="cm"> * @erase:			erase part of the device</span>
<span class="cm"> * @can_write_buf:		decide whether wbuf can be written to ofs</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">logfs_device_ops</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">find_first_sb</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">ofs</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">find_last_sb</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">ofs</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_sb</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">readpage</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">_sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">writeseg</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">erase</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">ensure_write</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">can_write_buf</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ofs</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sync</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">put_device</span><span class="p">)(</span><span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct candidate_list - list of similar candidates</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">candidate_list</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">rb_tree</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maxcount</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sort_by_ec</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct gc_candidate - &quot;candidate&quot; segment to be garbage collected next</span>
<span class="cm"> *</span>
<span class="cm"> * @list:			list (either free of low)</span>
<span class="cm"> * @segno:			segment number</span>
<span class="cm"> * @valid:			number of valid bytes</span>
<span class="cm"> * @erase_count:		erase count of segment</span>
<span class="cm"> * @dist:			distance from tree root</span>
<span class="cm"> *</span>
<span class="cm"> * Candidates can be on two lists.  The free list contains electees rather</span>
<span class="cm"> * than candidates - segments that no longer contain any valid data.  The</span>
<span class="cm"> * low list contains candidates to be picked for GC.  It should be kept</span>
<span class="cm"> * short.  It is not required to always pick a perfect candidate.  In the</span>
<span class="cm"> * worst case GC will have to move more data than absolutely necessary.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">gc_candidate</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">candidate_list</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">segno</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">valid</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">erase_count</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">dist</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct logfs_journal_entry - temporary structure used during journal scan</span>
<span class="cm"> *</span>
<span class="cm"> * @used:</span>
<span class="cm"> * @version:			normalized version</span>
<span class="cm"> * @len:			length</span>
<span class="cm"> * @offset:			offset</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">logfs_journal_entry</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">used</span><span class="p">;</span>
	<span class="n">s16</span> <span class="n">version</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">datalen</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">transaction_state</span> <span class="p">{</span>
	<span class="n">CREATE_1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">CREATE_2</span><span class="p">,</span>
	<span class="n">UNLINK_1</span><span class="p">,</span>
	<span class="n">UNLINK_2</span><span class="p">,</span>
	<span class="n">CROSS_RENAME_1</span><span class="p">,</span>
	<span class="n">CROSS_RENAME_2</span><span class="p">,</span>
	<span class="n">TARGET_RENAME_1</span><span class="p">,</span>
	<span class="n">TARGET_RENAME_2</span><span class="p">,</span>
	<span class="n">TARGET_RENAME_3</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct logfs_transaction - essential fields to support atomic dirops</span>
<span class="cm"> *</span>
<span class="cm"> * @ino:			target inode</span>
<span class="cm"> * @dir:			inode of directory containing dentry</span>
<span class="cm"> * @pos:			pos of dentry in directory</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">logfs_transaction</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">transaction_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">u64</span>	 <span class="n">ino</span><span class="p">;</span>
	<span class="n">u64</span>	 <span class="n">dir</span><span class="p">;</span>
	<span class="n">u64</span>	 <span class="n">pos</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct logfs_shadow - old block in the shadow of a not-yet-committed new one</span>
<span class="cm"> * @old_ofs:			offset of old block on medium</span>
<span class="cm"> * @new_ofs:			offset of new block on medium</span>
<span class="cm"> * @ino:			inode number</span>
<span class="cm"> * @bix:			block index</span>
<span class="cm"> * @old_len:			size of old block, including header</span>
<span class="cm"> * @new_len:			size of new block, including header</span>
<span class="cm"> * @level:			block level</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">logfs_shadow</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">old_ofs</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">new_ofs</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ino</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">bix</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new_len</span><span class="p">;</span>
	<span class="n">gc_level_t</span> <span class="n">gc_level</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct shadow_tree</span>
<span class="cm"> * @new:			shadows where old_ofs==0, indexed by new_ofs</span>
<span class="cm"> * @old:			shadows where old_ofs!=0, indexed by old_ofs</span>
<span class="cm"> * @segment_map:		bitfield of segments containing shadows</span>
<span class="cm"> * @no_shadowed_segment:	number of segments containing shadows</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">shadow_tree</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">btree_head64</span> <span class="n">new</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btree_head64</span> <span class="n">old</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btree_head32</span> <span class="n">segment_map</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">no_shadowed_segments</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">object_alias_item</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">__be64</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">child_no</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct logfs_block - contains any block state</span>
<span class="cm"> * @type:			indirect block or inode</span>
<span class="cm"> * @full:			number of fully populated children</span>
<span class="cm"> * @partial:			number of partially populated children</span>
<span class="cm"> *</span>
<span class="cm"> * Most blocks are directly represented by page cache pages.  But when a block</span>
<span class="cm"> * becomes dirty, is part of a transaction, contains aliases or is otherwise</span>
<span class="cm"> * special, a struct logfs_block is allocated to track the additional state.</span>
<span class="cm"> * Inodes are very similar to indirect blocks, so they can also get one of</span>
<span class="cm"> * these structures added when appropriate.</span>
<span class="cm"> */</span>
<span class="cp">#define BLOCK_INDIRECT	1	</span><span class="cm">/* Indirect block */</span><span class="cp"></span>
<span class="cp">#define BLOCK_INODE	2	</span><span class="cm">/* Inode */</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">logfs_block_ops</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">logfs_block</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">alias_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">item_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ino</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">bix</span><span class="p">;</span>
	<span class="n">level_t</span> <span class="n">level</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">logfs_transaction</span> <span class="o">*</span><span class="n">ta</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">alias_map</span><span class="p">[</span><span class="n">LOGFS_BLOCK_FACTOR</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">logfs_block_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">full</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">partial</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reserved_bytes</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="n">write_alias_t</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ino</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bix</span><span class="p">,</span>
		<span class="n">level_t</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">child_no</span><span class="p">,</span> <span class="n">__be64</span> <span class="n">val</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">logfs_block_ops</span> <span class="p">{</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">write_block</span><span class="p">)(</span><span class="k">struct</span> <span class="n">logfs_block</span> <span class="o">*</span><span class="n">block</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="p">(</span><span class="o">*</span><span class="n">free_block</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">logfs_block</span><span class="o">*</span><span class="n">block</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="p">(</span><span class="o">*</span><span class="n">write_alias</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">logfs_block</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span>
			<span class="n">write_alias_t</span> <span class="o">*</span><span class="n">write_one_alias</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#define MAX_JOURNAL_ENTRIES 256</span>

<span class="k">struct</span> <span class="n">logfs_super</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mtd_info</span> <span class="o">*</span><span class="n">s_mtd</span><span class="p">;</span>			<span class="cm">/* underlying device */</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">s_bdev</span><span class="p">;</span>		<span class="cm">/* underlying device */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">logfs_device_ops</span> <span class="o">*</span><span class="n">s_devops</span><span class="p">;</span><span class="cm">/* device access */</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">s_master_inode</span><span class="p">;</span>	<span class="cm">/* inode file */</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">s_segfile_inode</span><span class="p">;</span>	<span class="cm">/* segment file */</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">s_mapping_inode</span><span class="p">;</span>		<span class="cm">/* device mapping */</span>
	<span class="n">atomic_t</span> <span class="n">s_pending_writes</span><span class="p">;</span>		<span class="cm">/* outstanting bios */</span>
	<span class="kt">long</span>	 <span class="n">s_flags</span><span class="p">;</span>
	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">s_btree_pool</span><span class="p">;</span>		<span class="cm">/* for btree nodes */</span>
	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">s_alias_pool</span><span class="p">;</span>		<span class="cm">/* aliases in segment.c */</span>
	<span class="n">u64</span>	 <span class="n">s_feature_incompat</span><span class="p">;</span>
	<span class="n">u64</span>	 <span class="n">s_feature_ro_compat</span><span class="p">;</span>
	<span class="n">u64</span>	 <span class="n">s_feature_compat</span><span class="p">;</span>
	<span class="n">u64</span>	 <span class="n">s_feature_flags</span><span class="p">;</span>
	<span class="n">u64</span>	 <span class="n">s_sb_ofs</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">s_erase_page</span><span class="p">;</span>		<span class="cm">/* for dev_bdev.c */</span>
	<span class="cm">/* alias.c fields */</span>
	<span class="k">struct</span> <span class="n">btree_head32</span> <span class="n">s_segment_alias</span><span class="p">;</span>	<span class="cm">/* remapped segments */</span>
	<span class="kt">int</span>	 <span class="n">s_no_object_aliases</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">s_object_alias</span><span class="p">;</span>	<span class="cm">/* remapped objects */</span>
	<span class="k">struct</span> <span class="n">btree_head128</span> <span class="n">s_object_alias_tree</span><span class="p">;</span> <span class="cm">/* remapped objects */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">s_object_alias_mutex</span><span class="p">;</span>
	<span class="cm">/* dir.c fields */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">s_dirop_mutex</span><span class="p">;</span>		<span class="cm">/* for creat/unlink/rename */</span>
	<span class="n">u64</span>	 <span class="n">s_victim_ino</span><span class="p">;</span>			<span class="cm">/* used for atomic dir-ops */</span>
	<span class="n">u64</span>	 <span class="n">s_rename_dir</span><span class="p">;</span>			<span class="cm">/* source directory ino */</span>
	<span class="n">u64</span>	 <span class="n">s_rename_pos</span><span class="p">;</span>			<span class="cm">/* position of source dd */</span>
	<span class="cm">/* gc.c fields */</span>
	<span class="kt">long</span>	 <span class="n">s_segsize</span><span class="p">;</span>			<span class="cm">/* size of a segment */</span>
	<span class="kt">int</span>	 <span class="n">s_segshift</span><span class="p">;</span>			<span class="cm">/* log2 of segment size */</span>
	<span class="kt">long</span>	 <span class="n">s_segmask</span><span class="p">;</span>			<span class="cm">/* 1 &lt;&lt; s_segshift - 1 */</span>
	<span class="kt">long</span>	 <span class="n">s_no_segs</span><span class="p">;</span>			<span class="cm">/* segments on device */</span>
	<span class="kt">long</span>	 <span class="n">s_no_journal_segs</span><span class="p">;</span>		<span class="cm">/* segments used for journal */</span>
	<span class="kt">long</span>	 <span class="n">s_no_blocks</span><span class="p">;</span>			<span class="cm">/* blocks per segment */</span>
	<span class="kt">long</span>	 <span class="n">s_writesize</span><span class="p">;</span>			<span class="cm">/* minimum write size */</span>
	<span class="kt">int</span>	 <span class="n">s_writeshift</span><span class="p">;</span>			<span class="cm">/* log2 of write size */</span>
	<span class="n">u64</span>	 <span class="n">s_size</span><span class="p">;</span>			<span class="cm">/* filesystem size */</span>
	<span class="k">struct</span> <span class="n">logfs_area</span> <span class="o">*</span><span class="n">s_area</span><span class="p">[</span><span class="n">LOGFS_NO_AREAS</span><span class="p">];</span>	<span class="cm">/* open segment array */</span>
	<span class="n">u64</span>	 <span class="n">s_gec</span><span class="p">;</span>				<span class="cm">/* global erase count */</span>
	<span class="n">u64</span>	 <span class="n">s_wl_gec_ostore</span><span class="p">;</span>		<span class="cm">/* time of last wl event */</span>
	<span class="n">u64</span>	 <span class="n">s_wl_gec_journal</span><span class="p">;</span>		<span class="cm">/* time of last wl event */</span>
	<span class="n">u64</span>	 <span class="n">s_sweeper</span><span class="p">;</span>			<span class="cm">/* current sweeper pos */</span>
	<span class="n">u8</span>	 <span class="n">s_ifile_levels</span><span class="p">;</span>		<span class="cm">/* max level of ifile */</span>
	<span class="n">u8</span>	 <span class="n">s_iblock_levels</span><span class="p">;</span>		<span class="cm">/* max level of regular files */</span>
	<span class="n">u8</span>	 <span class="n">s_data_levels</span><span class="p">;</span>			<span class="cm">/* # of segments to leaf block*/</span>
	<span class="n">u8</span>	 <span class="n">s_total_levels</span><span class="p">;</span>		<span class="cm">/* sum of above three */</span>
	<span class="k">struct</span> <span class="n">btree_head32</span> <span class="n">s_cand_tree</span><span class="p">;</span>	<span class="cm">/* all candidates */</span>
	<span class="k">struct</span> <span class="n">candidate_list</span> <span class="n">s_free_list</span><span class="p">;</span>	<span class="cm">/* 100% free segments */</span>
	<span class="k">struct</span> <span class="n">candidate_list</span> <span class="n">s_reserve_list</span><span class="p">;</span>	<span class="cm">/* Bad segment reserve */</span>
	<span class="k">struct</span> <span class="n">candidate_list</span> <span class="n">s_low_list</span><span class="p">[</span><span class="n">LOGFS_NO_AREAS</span><span class="p">];</span><span class="cm">/* good candidates */</span>
	<span class="k">struct</span> <span class="n">candidate_list</span> <span class="n">s_ec_list</span><span class="p">;</span>	<span class="cm">/* wear level candidates */</span>
	<span class="k">struct</span> <span class="n">btree_head32</span> <span class="n">s_reserved_segments</span><span class="p">;</span><span class="cm">/* sb, journal, bad, etc. */</span>
	<span class="cm">/* inode.c fields */</span>
	<span class="n">u64</span>	 <span class="n">s_last_ino</span><span class="p">;</span>			<span class="cm">/* highest ino used */</span>
	<span class="kt">long</span>	 <span class="n">s_inos_till_wrap</span><span class="p">;</span>
	<span class="n">u32</span>	 <span class="n">s_generation</span><span class="p">;</span>			<span class="cm">/* i_generation for new files */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">s_freeing_list</span><span class="p">;</span>	<span class="cm">/* inodes being freed */</span>
	<span class="cm">/* journal.c fields */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">s_journal_mutex</span><span class="p">;</span>
	<span class="kt">void</span>	<span class="o">*</span><span class="n">s_je</span><span class="p">;</span>				<span class="cm">/* journal entry to compress */</span>
	<span class="kt">void</span>	<span class="o">*</span><span class="n">s_compressed_je</span><span class="p">;</span>		<span class="cm">/* block to write to journal */</span>
	<span class="n">u32</span>	 <span class="n">s_journal_seg</span><span class="p">[</span><span class="n">LOGFS_JOURNAL_SEGS</span><span class="p">];</span> <span class="cm">/* journal segments */</span>
	<span class="n">u32</span>	 <span class="n">s_journal_ec</span><span class="p">[</span><span class="n">LOGFS_JOURNAL_SEGS</span><span class="p">];</span> <span class="cm">/* journal erasecounts */</span>
	<span class="n">u64</span>	 <span class="n">s_last_version</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">logfs_area</span> <span class="o">*</span><span class="n">s_journal_area</span><span class="p">;</span>	<span class="cm">/* open journal segment */</span>
	<span class="n">__be64</span>	<span class="n">s_je_array</span><span class="p">[</span><span class="n">MAX_JOURNAL_ENTRIES</span><span class="p">];</span>
	<span class="kt">int</span>	<span class="n">s_no_je</span><span class="p">;</span>

	<span class="kt">int</span>	 <span class="n">s_sum_index</span><span class="p">;</span>			<span class="cm">/* for the 12 summaries */</span>
	<span class="k">struct</span> <span class="n">shadow_tree</span> <span class="n">s_shadow_tree</span><span class="p">;</span>
	<span class="kt">int</span>	 <span class="n">s_je_fill</span><span class="p">;</span>			<span class="cm">/* index of current je */</span>
	<span class="cm">/* readwrite.c fields */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">s_write_mutex</span><span class="p">;</span>
	<span class="kt">int</span>	 <span class="n">s_lock_count</span><span class="p">;</span>
	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">s_block_pool</span><span class="p">;</span>		<span class="cm">/* struct logfs_block pool */</span>
	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">s_shadow_pool</span><span class="p">;</span>		<span class="cm">/* struct logfs_shadow pool */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">s_writeback_list</span><span class="p">;</span>	<span class="cm">/* writeback pages */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Space accounting:</span>
<span class="cm">	 * - s_used_bytes specifies space used to store valid data objects.</span>
<span class="cm">	 * - s_dirty_used_bytes is space used to store non-committed data</span>
<span class="cm">	 *   objects.  Those objects have already been written themselves,</span>
<span class="cm">	 *   but they don&#39;t become valid until all indirect blocks up to the</span>
<span class="cm">	 *   journal have been written as well.</span>
<span class="cm">	 * - s_dirty_free_bytes is space used to store the old copy of a</span>
<span class="cm">	 *   replaced object, as long as the replacement is non-committed.</span>
<span class="cm">	 *   In other words, it is the amount of space freed when all dirty</span>
<span class="cm">	 *   blocks are written back.</span>
<span class="cm">	 * - s_free_bytes is the amount of free space available for any</span>
<span class="cm">	 *   purpose.</span>
<span class="cm">	 * - s_root_reserve is the amount of free space available only to</span>
<span class="cm">	 *   the root user.  Non-privileged users can no longer write once</span>
<span class="cm">	 *   this watermark has been reached.</span>
<span class="cm">	 * - s_speed_reserve is space which remains unused to speed up</span>
<span class="cm">	 *   garbage collection performance.</span>
<span class="cm">	 * - s_dirty_pages is the space reserved for currently dirty pages.</span>
<span class="cm">	 *   It is a pessimistic estimate, so some/most will get freed on</span>
<span class="cm">	 *   page writeback.</span>
<span class="cm">	 *</span>
<span class="cm">	 * s_used_bytes + s_free_bytes + s_speed_reserve = total usable size</span>
<span class="cm">	 */</span>
	<span class="n">u64</span>	 <span class="n">s_free_bytes</span><span class="p">;</span>
	<span class="n">u64</span>	 <span class="n">s_used_bytes</span><span class="p">;</span>
	<span class="n">u64</span>	 <span class="n">s_dirty_free_bytes</span><span class="p">;</span>
	<span class="n">u64</span>	 <span class="n">s_dirty_used_bytes</span><span class="p">;</span>
	<span class="n">u64</span>	 <span class="n">s_root_reserve</span><span class="p">;</span>
	<span class="n">u64</span>	 <span class="n">s_speed_reserve</span><span class="p">;</span>
	<span class="n">u64</span>	 <span class="n">s_dirty_pages</span><span class="p">;</span>
	<span class="cm">/* Bad block handling:</span>
<span class="cm">	 * - s_bad_seg_reserve is a number of segments usually kept</span>
<span class="cm">	 *   free.  When encountering bad blocks, the affected segment&#39;s data</span>
<span class="cm">	 *   is _temporarily_ moved to a reserved segment.</span>
<span class="cm">	 * - s_bad_segments is the number of known bad segments.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span>	 <span class="n">s_bad_seg_reserve</span><span class="p">;</span>
	<span class="n">u32</span>	 <span class="n">s_bad_segments</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct logfs_inode - in-memory inode</span>
<span class="cm"> *</span>
<span class="cm"> * @vfs_inode:			struct inode</span>
<span class="cm"> * @li_data:			data pointers</span>
<span class="cm"> * @li_used_bytes:		number of used bytes</span>
<span class="cm"> * @li_freeing_list:		used to track inodes currently being freed</span>
<span class="cm"> * @li_flags:			inode flags</span>
<span class="cm"> * @li_refcount:		number of internal (GC-induced) references</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">logfs_inode</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="n">vfs_inode</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">li_data</span><span class="p">[</span><span class="n">LOGFS_EMBEDDED_FIELDS</span><span class="p">];</span>
	<span class="n">u64</span>	<span class="n">li_used_bytes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">li_freeing_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">logfs_block</span> <span class="o">*</span><span class="n">li_block</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">li_flags</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">li_height</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">li_refcount</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define journal_for_each(__i) for (__i = 0; __i &lt; LOGFS_JOURNAL_SEGS; __i++)</span>
<span class="cp">#define for_each_area(__i) for (__i = 0; __i &lt; LOGFS_NO_AREAS; __i++)</span>
<span class="cp">#define for_each_area_down(__i) for (__i = LOGFS_NO_AREAS - 1; __i &gt;= 0; __i--)</span>

<span class="cm">/* compr.c */</span>
<span class="kt">int</span> <span class="n">logfs_compress</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">inlen</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">outlen</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_uncompress</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">inlen</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">outlen</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="n">logfs_compr_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_compr_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* dev_bdev.c */</span>
<span class="cp">#ifdef CONFIG_BLOCK</span>
<span class="kt">int</span> <span class="n">logfs_get_sb_bdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">devname</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">logfs_get_sb_bdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">devname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* dev_mtd.c */</span>
<span class="cp">#ifdef CONFIG_MTD</span>
<span class="kt">int</span> <span class="n">logfs_get_sb_mtd</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mtdnr</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">logfs_get_sb_mtd</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mtdnr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* dir.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">logfs_symlink_iops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">logfs_dir_iops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">logfs_dir_fops</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">logfs_replay_journal</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>

<span class="cm">/* file.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">logfs_reg_iops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">logfs_reg_fops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">logfs_reg_aops</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">logfs_readpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">long</span> <span class="n">logfs_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_fsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datasync</span><span class="p">);</span>

<span class="cm">/* gc.c */</span>
<span class="n">u32</span> <span class="n">get_best_cand</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">candidate_list</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ec</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_gc_pass</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_check_areas</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_init_gc</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_cleanup_gc</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>

<span class="cm">/* inode.c */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="n">logfs_super_operations</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">logfs_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">ino</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">logfs_safe_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">ino</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cookie</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_safe_iput</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cookie</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">logfs_new_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">logfs_new_meta_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ino</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">logfs_read_meta_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ino</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_init_inode_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_destroy_inode_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_set_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">no</span><span class="p">);</span>
<span class="cm">/* these logically belong into inode.c but actually reside in readwrite.c */</span>
<span class="kt">int</span> <span class="n">logfs_read_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__logfs_write_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_evict_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="cm">/* journal.c */</span>
<span class="kt">void</span> <span class="n">logfs_write_anchor</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_init_journal</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_cleanup_journal</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">write_alias_journal</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ino</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bix</span><span class="p">,</span>
		<span class="n">level_t</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">child_no</span><span class="p">,</span> <span class="n">__be64</span> <span class="n">val</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">do_logfs_journal_wl_pass</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>

<span class="cm">/* readwrite.c */</span>
<span class="n">pgoff_t</span> <span class="n">logfs_pack_index</span><span class="p">(</span><span class="n">u64</span> <span class="n">bix</span><span class="p">,</span> <span class="n">level_t</span> <span class="n">level</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_unpack_index</span><span class="p">(</span><span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">bix</span><span class="p">,</span> <span class="n">level_t</span> <span class="o">*</span><span class="n">level</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_inode_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="n">bix</span><span class="p">,</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">shadow_tree</span> <span class="o">*</span><span class="n">shadow_tree</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_readpage_nolock</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_write_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">shadow_tree</span> <span class="o">*</span><span class="n">shadow_tree</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_rewrite_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bix</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ofs</span><span class="p">,</span>
		<span class="n">gc_level_t</span> <span class="n">gc_level</span><span class="p">,</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_is_valid_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ino</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bix</span><span class="p">,</span>
		<span class="n">gc_level_t</span> <span class="n">gc_level</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">size</span><span class="p">);</span>
<span class="n">u64</span> <span class="n">logfs_seek_hole</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bix</span><span class="p">);</span>
<span class="n">u64</span> <span class="n">logfs_seek_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bix</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_open_segfile</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_init_rw</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_cleanup_rw</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_add_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">logfs_transaction</span> <span class="o">*</span><span class="n">ta</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_del_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">logfs_transaction</span> <span class="o">*</span><span class="n">ta</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_write_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_block</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_write_obj_aliases_pagecache</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_get_segment_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">segno</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">logfs_segment_entry</span> <span class="o">*</span><span class="n">se</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_set_segment_used</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">increment</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_set_segment_erased</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">segno</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ec</span><span class="p">,</span>
		<span class="n">gc_level_t</span> <span class="n">gc_level</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_set_segment_reserved</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">segno</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_set_segment_unreserved</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">segno</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ec</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">logfs_block</span> <span class="o">*</span><span class="n">__alloc_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
		<span class="n">u64</span> <span class="n">ino</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bix</span><span class="p">,</span> <span class="n">level_t</span> <span class="n">level</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__free_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">logfs_block</span> <span class="o">*</span><span class="n">block</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">btree_write_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_block</span> <span class="o">*</span><span class="n">block</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">initialize_block_counters</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">logfs_block</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span>
		<span class="n">__be64</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page_is_empty</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_exist_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bix</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">get_page_reserve</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_get_wblocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lock</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_put_wblocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lock</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">logfs_block_ops</span> <span class="n">indirect_block_ops</span><span class="p">;</span>

<span class="cm">/* segment.c */</span>
<span class="kt">int</span> <span class="n">logfs_erase_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ensure_erase</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">wbuf_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_segment_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bix</span><span class="p">,</span>
		<span class="n">level_t</span> <span class="n">level</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_segment_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">logfs_shadow</span> <span class="o">*</span><span class="n">shadow</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_segment_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">logfs_shadow</span> <span class="o">*</span><span class="n">shadow</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_load_object_aliases</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">logfs_obj_alias</span> <span class="o">*</span><span class="n">oa</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">move_page_to_btree</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_init_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_sync_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_area</span> <span class="o">*</span><span class="n">area</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_sync_segments</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">freeseg</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">segno</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">free_areas</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>

<span class="cm">/* area handling */</span>
<span class="kt">int</span> <span class="n">logfs_init_areas</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_cleanup_areas</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_open_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_area</span> <span class="o">*</span><span class="n">area</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__logfs_buf_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_area</span> <span class="o">*</span><span class="n">area</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">use_filler</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">logfs_buf_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_area</span> <span class="o">*</span><span class="n">area</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ofs</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__logfs_buf_write</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">logfs_buf_recover</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_area</span> <span class="o">*</span><span class="n">area</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ofs</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__logfs_buf_write</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* super.c */</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">emergency_read_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">index</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">emergency_read_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">logfs_crash_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_statfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstatfs</span> <span class="o">*</span><span class="n">stats</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_check_ds</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_disk_super</span> <span class="o">*</span><span class="n">ds</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">logfs_write_sb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="nf">logfs_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">logfs_inode</span> <span class="o">*</span><span class="nf">logfs_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">logfs_inode</span><span class="p">,</span> <span class="n">vfs_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">logfs_set_ro</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">LOGFS_SB_FLAG_RO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define LOGFS_BUG(sb) do {					\</span>
<span class="cp">	struct super_block *__sb = sb;				\</span>
<span class="cp">	logfs_crash_dump(__sb);					\</span>
<span class="cp">	logfs_super(__sb)-&gt;s_flags |= LOGFS_SB_FLAG_RO;		\</span>
<span class="cp">	BUG();							\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define LOGFS_BUG_ON(condition, sb) \</span>
<span class="cp">	do { if (unlikely(condition)) LOGFS_BUG((sb)); } while (0)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__be32</span> <span class="nf">logfs_crc32</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">skip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">crc32</span><span class="p">(</span><span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">+</span><span class="n">skip</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="n">skip</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">logfs_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pgoff_t</span> <span class="nf">logfs_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">dev_ofs</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">segno</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ofs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">segno</span> <span class="o">&lt;&lt;</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_segshift</span><span class="p">)</span> <span class="o">+</span> <span class="n">ofs</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">seg_no</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ofs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_segshift</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">seg_ofs</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ofs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ofs</span> <span class="o">&amp;</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_segmask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">seg_align</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ofs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ofs</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_segmask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">logfs_block</span> <span class="o">*</span><span class="nf">logfs_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">level_t</span> <span class="nf">shrink_level</span><span class="p">(</span><span class="n">gc_level_t</span> <span class="n">__level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">level</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u8</span><span class="p">)</span><span class="n">__level</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;=</span> <span class="n">LOGFS_MAX_LEVELS</span><span class="p">)</span>
		<span class="n">level</span> <span class="o">-=</span> <span class="n">LOGFS_MAX_LEVELS</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">__force</span> <span class="n">level_t</span><span class="p">)</span><span class="n">level</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">gc_level_t</span> <span class="nf">expand_level</span><span class="p">(</span><span class="n">u64</span> <span class="n">ino</span><span class="p">,</span> <span class="n">level_t</span> <span class="n">__level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">level</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u8</span><span class="p">)</span><span class="n">__level</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ino</span> <span class="o">==</span> <span class="n">LOGFS_INO_MASTER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* ifile has separate areas */</span>
		<span class="n">level</span> <span class="o">+=</span> <span class="n">LOGFS_MAX_LEVELS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">__force</span> <span class="n">gc_level_t</span><span class="p">)</span><span class="n">level</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">logfs_block_shift</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">level_t</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">level</span> <span class="o">=</span> <span class="n">shrink_level</span><span class="p">((</span><span class="n">__force</span> <span class="n">gc_level_t</span><span class="p">)</span><span class="n">level</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">__force</span> <span class="kt">int</span><span class="p">)</span><span class="n">level</span> <span class="o">*</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span> <span class="o">-</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">logfs_block_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">level_t</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">~</span><span class="mi">0ull</span> <span class="o">&lt;&lt;</span> <span class="n">logfs_block_shift</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">logfs_area</span> <span class="o">*</span><span class="nf">get_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
		<span class="n">gc_level_t</span> <span class="n">gc_level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_area</span><span class="p">[(</span><span class="n">__force</span> <span class="n">u8</span><span class="p">)</span><span class="n">gc_level</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">logfs_mempool_destroy</span><span class="p">(</span><span class="n">mempool_t</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pool</span><span class="p">)</span>
		<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
