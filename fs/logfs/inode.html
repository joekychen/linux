<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › logfs › inode.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>inode.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * fs/logfs/inode.c	- inode handling code</span>
<span class="cm"> *</span>
<span class="cm"> * As should be obvious for Linux kernel code, license is GPLv2</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2005-2008 Joern Engel &lt;joern@logfs.org&gt;</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;logfs.h&quot;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * How soon to reuse old inode numbers?  LogFS doesn&#39;t store deleted inodes</span>
<span class="cm"> * on the medium.  It therefore also lacks a method to store the previous</span>
<span class="cm"> * generation number for deleted inodes.  Instead a single generation number</span>
<span class="cm"> * is stored which will be used for new inodes.  Being just a 32bit counter,</span>
<span class="cm"> * this can obvious wrap relatively quickly.  So we only reuse inodes if we</span>
<span class="cm"> * know that a fair number of inodes can be created before we have to increment</span>
<span class="cm"> * the generation again - effectively adding some bits to the counter.</span>
<span class="cm"> * But being too aggressive here means we keep a very large and very sparse</span>
<span class="cm"> * inode file, wasting space on indirect blocks.</span>
<span class="cm"> * So what is a good value?  Beats me.  64k seems moderately bad on both</span>
<span class="cm"> * fronts, so let&#39;s use that for now...</span>
<span class="cm"> *</span>
<span class="cm"> * NFS sucks, as everyone already knows.</span>
<span class="cm"> */</span>
<span class="cp">#define INOS_PER_WRAP (0x10000)</span>

<span class="cm">/*</span>
<span class="cm"> * Logfs&#39; requirement to read inodes for garbage collection makes life a bit</span>
<span class="cm"> * harder.  GC may have to read inodes that are in I_FREEING state, when they</span>
<span class="cm"> * are being written out - and waiting for GC to make progress, naturally.</span>
<span class="cm"> *</span>
<span class="cm"> * So we cannot just call iget() or some variant of it, but first have to check</span>
<span class="cm"> * wether the inode in question might be in I_FREEING state.  Therefore we</span>
<span class="cm"> * maintain our own per-sb list of &quot;almost deleted&quot; inodes and check against</span>
<span class="cm"> * that list first.  Normally this should be at most 1-2 entries long.</span>
<span class="cm"> *</span>
<span class="cm"> * Also, inodes have logfs-specific reference counting on top of what the vfs</span>
<span class="cm"> * does.  When .destroy_inode is called, normally the reference count will drop</span>
<span class="cm"> * to zero and the inode gets deleted.  But if GC accessed the inode, its</span>
<span class="cm"> * refcount will remain nonzero and final deletion will have to wait.</span>
<span class="cm"> *</span>
<span class="cm"> * As a result we have two sets of functions to get/put inodes:</span>
<span class="cm"> * logfs_safe_iget/logfs_safe_iput	- safe to call from GC context</span>
<span class="cm"> * logfs_iget/iput			- normal version</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">logfs_inode_cache</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">logfs_inode_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">logfs_inode_setops</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">S_IFDIR</span>:
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">logfs_dir_iops</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">logfs_dir_fops</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">logfs_reg_aops</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFREG</span>:
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">logfs_reg_iops</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">logfs_reg_fops</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">logfs_reg_aops</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFLNK</span>:
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">logfs_symlink_iops</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">logfs_reg_aops</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFSOCK</span>:	<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">S_IFBLK</span>:	<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">S_IFCHR</span>:	<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">S_IFIFO</span>:
		<span class="n">init_special_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">__logfs_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">iget_locked</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_NEW</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">logfs_read_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* inode-&gt;i_nlink == 0 can be true when called from</span>
<span class="cm">		 * block validator */</span>
		<span class="cm">/* set i_nlink to 0 to prevent caching */</span>
		<span class="n">clear_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">logfs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">li_flags</span> <span class="o">|=</span> <span class="n">LOGFS_IF_ZOMBIE</span><span class="p">;</span>
		<span class="n">iget_failed</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">logfs_inode_setops</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">unlock_new_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">logfs_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ino</span> <span class="o">==</span> <span class="n">LOGFS_INO_MASTER</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ino</span> <span class="o">==</span> <span class="n">LOGFS_INO_SEGFILE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__logfs_iget</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * is_cached is set to 1 if we hand out a cached inode, 0 otherwise.</span>
<span class="cm"> * this allows logfs_iput to do the right thing later</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">logfs_safe_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">ino</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">is_cached</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">logfs_inode</span> <span class="o">*</span><span class="n">li</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ino</span> <span class="o">==</span> <span class="n">LOGFS_INO_MASTER</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_master_inode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ino</span> <span class="o">==</span> <span class="n">LOGFS_INO_SEGFILE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_segfile_inode</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logfs_inode_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_freeing_list</span><span class="p">,</span> <span class="n">li_freeing_list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_ino</span> <span class="o">==</span> <span class="n">ino</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">li</span><span class="o">-&gt;</span><span class="n">li_refcount</span><span class="o">++</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logfs_inode_lock</span><span class="p">);</span>
			<span class="o">*</span><span class="n">is_cached</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logfs_inode_lock</span><span class="p">);</span>

	<span class="o">*</span><span class="n">is_cached</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__logfs_iget</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">logfs_i_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span><span class="p">,</span> <span class="n">i_rcu</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">logfs_inode_cache</span><span class="p">,</span> <span class="n">logfs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__logfs_destroy_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_inode</span> <span class="o">*</span><span class="n">li</span> <span class="o">=</span> <span class="n">logfs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">li_block</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">li_freeing_list</span><span class="p">);</span>
	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rcu</span><span class="p">,</span> <span class="n">logfs_i_callback</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">logfs_destroy_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_inode</span> <span class="o">*</span><span class="n">li</span> <span class="o">=</span> <span class="n">logfs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">li_freeing_list</span><span class="p">));</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logfs_inode_lock</span><span class="p">);</span>
	<span class="n">li</span><span class="o">-&gt;</span><span class="n">li_refcount</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">li_refcount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">__logfs_destroy_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logfs_inode_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">logfs_safe_iput</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_cached</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">==</span> <span class="n">LOGFS_INO_MASTER</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">==</span> <span class="n">LOGFS_INO_SEGFILE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_cached</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">logfs_destroy_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">logfs_init_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_inode</span> <span class="o">*</span><span class="n">li</span> <span class="o">=</span> <span class="n">logfs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">li</span><span class="o">-&gt;</span><span class="n">li_flags</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">li</span><span class="o">-&gt;</span><span class="n">li_height</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">li</span><span class="o">-&gt;</span><span class="n">li_used_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">li</span><span class="o">-&gt;</span><span class="n">li_block</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span>	<span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span>	<span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
	<span class="n">li</span><span class="o">-&gt;</span><span class="n">li_refcount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">li_freeing_list</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LOGFS_EMBEDDED_FIELDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">li</span><span class="o">-&gt;</span><span class="n">li_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">logfs_alloc_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_inode</span> <span class="o">*</span><span class="n">li</span><span class="p">;</span>

	<span class="n">li</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">logfs_inode_cache</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">li</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">logfs_init_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * In logfs inodes are written to an inode file.  The inode file, like any</span>
<span class="cm"> * other file, is managed with a inode.  The inode file&#39;s inode, aka master</span>
<span class="cm"> * inode, requires special handling in several respects.  First, it cannot be</span>
<span class="cm"> * written to the inode file, so it is stored in the journal instead.</span>
<span class="cm"> *</span>
<span class="cm"> * Secondly, this inode cannot be written back and destroyed before all other</span>
<span class="cm"> * inodes have been written.  The ordering is important.  Linux&#39; VFS is happily</span>
<span class="cm"> * unaware of the ordering constraint and would ordinarily destroy the master</span>
<span class="cm"> * inode at umount time while other inodes are still in use and dirty.  Not</span>
<span class="cm"> * good.</span>
<span class="cm"> *</span>
<span class="cm"> * So logfs makes sure the master inode is not written until all other inodes</span>
<span class="cm"> * have been destroyed.  Sadly, this method has another side-effect.  The VFS</span>
<span class="cm"> * will notice one remaining inode and print a frightening warning message.</span>
<span class="cm"> * Worse, it is impossible to judge whether such a warning was caused by the</span>
<span class="cm"> * master inode or any other inodes have leaked as well.</span>
<span class="cm"> *</span>
<span class="cm"> * Our attempt of solving this is with logfs_new_meta_inode() below.  Its</span>
<span class="cm"> * purpose is to create a new inode that will not trigger the warning if such</span>
<span class="cm"> * an inode is still in use.  An ugly hack, no doubt.  Suggections for</span>
<span class="cm"> * improvement are welcome.</span>
<span class="cm"> *</span>
<span class="cm"> * AV: that&#39;s what -&gt;put_super() is for...</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">logfs_new_meta_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">new_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">S_IFREG</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">ino</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">.</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">logfs_reg_aops</span><span class="p">;</span>
	<span class="n">mapping_set_gfp_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">logfs_read_meta_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">logfs_new_meta_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">logfs_read_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">logfs_inode_setops</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">logfs_write_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">WF_LOCK</span><span class="p">;</span>

	<span class="cm">/* Can only happen if creat() failed.  Safe to skip. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">logfs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">li_flags</span> <span class="o">&amp;</span> <span class="n">LOGFS_IF_STILLBORN</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__logfs_write_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">LOGFS_BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* called with inode-&gt;i_lock held */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">logfs_drop_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">logfs_inode</span> <span class="o">*</span><span class="n">li</span> <span class="o">=</span> <span class="n">logfs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logfs_inode_lock</span><span class="p">);</span>
	<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">li_freeing_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_freeing_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logfs_inode_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">generic_drop_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">logfs_set_ino_generation</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">ino</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_mutex</span><span class="p">);</span>
	<span class="n">ino</span> <span class="o">=</span> <span class="n">logfs_seek_hole</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_master_inode</span><span class="p">,</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_last_ino</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_last_ino</span> <span class="o">=</span> <span class="n">ino</span><span class="p">;</span>
	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_inos_till_wrap</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_inos_till_wrap</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_last_ino</span> <span class="o">=</span> <span class="n">LOGFS_RESERVED_INOS</span><span class="p">;</span>
		<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_generation</span><span class="o">++</span><span class="p">;</span>
		<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_inos_till_wrap</span> <span class="o">=</span> <span class="n">INOS_PER_WRAP</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">ino</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_generation</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">logfs_new_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">new_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">logfs_init_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="cm">/* inherit parent flags */</span>
	<span class="n">logfs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">li_flags</span> <span class="o">|=</span>
		<span class="n">logfs_inode</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">li_flags</span> <span class="o">&amp;</span> <span class="n">LOGFS_FL_INHERITED</span><span class="p">;</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">logfs_set_ino_generation</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="n">inode_init_owner</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="n">logfs_inode_setops</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">insert_inode_hash</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">logfs_init_once</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">_li</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_inode</span> <span class="o">*</span><span class="n">li</span> <span class="o">=</span> <span class="n">_li</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">li</span><span class="o">-&gt;</span><span class="n">li_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">li</span><span class="o">-&gt;</span><span class="n">li_used_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">li</span><span class="o">-&gt;</span><span class="n">li_refcount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LOGFS_EMBEDDED_FIELDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">li</span><span class="o">-&gt;</span><span class="n">li_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">inode_init_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">logfs_sync_fs</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">logfs_get_wblocks</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">WF_LOCK</span><span class="p">);</span>
	<span class="n">logfs_write_anchor</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">logfs_put_wblocks</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">WF_LOCK</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">logfs_put_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="cm">/* kill the meta-inodes */</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_master_inode</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_segfile_inode</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_mapping_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="n">logfs_super_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">alloc_inode</span>	<span class="o">=</span> <span class="n">logfs_alloc_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">destroy_inode</span>	<span class="o">=</span> <span class="n">logfs_destroy_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">evict_inode</span>	<span class="o">=</span> <span class="n">logfs_evict_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">drop_inode</span>	<span class="o">=</span> <span class="n">logfs_drop_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put_super</span>	<span class="o">=</span> <span class="n">logfs_put_super</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_inode</span>	<span class="o">=</span> <span class="n">logfs_write_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">statfs</span>		<span class="o">=</span> <span class="n">logfs_statfs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync_fs</span>	<span class="o">=</span> <span class="n">logfs_sync_fs</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">logfs_init_inode_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">logfs_inode_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;logfs_inode_cache&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_inode</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="p">,</span>
			<span class="n">logfs_init_once</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">logfs_inode_cache</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">logfs_destroy_inode_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">logfs_inode_cache</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
