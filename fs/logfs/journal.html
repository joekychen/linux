<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › logfs › journal.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>journal.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * fs/logfs/journal.c	- journal handling code</span>
<span class="cm"> *</span>
<span class="cm"> * As should be obvious for Linux kernel code, license is GPLv2</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2005-2008 Joern Engel &lt;joern@logfs.org&gt;</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;logfs.h&quot;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">logfs_calc_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">reserve</span><span class="p">,</span> <span class="n">no_segs</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_no_segs</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">free</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* superblock segments */</span>
	<span class="n">no_segs</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_no_journal_segs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* journal */</span>
	<span class="n">journal_for_each</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_seg</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">no_segs</span><span class="o">--</span><span class="p">;</span>
			<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_no_journal_segs</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/* open segments plus one extra per level for GC */</span>
	<span class="n">no_segs</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_total_levels</span><span class="p">;</span>

	<span class="n">free</span> <span class="o">=</span> <span class="n">no_segs</span> <span class="o">*</span> <span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_segsize</span> <span class="o">-</span> <span class="n">LOGFS_SEGMENT_RESERVE</span><span class="p">);</span>
	<span class="n">free</span> <span class="o">-=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_used_bytes</span><span class="p">;</span>
	<span class="cm">/* just a bit extra */</span>
	<span class="n">free</span> <span class="o">-=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_total_levels</span> <span class="o">*</span> <span class="mi">4096</span><span class="p">;</span>

	<span class="cm">/* Bad blocks are &#39;paid&#39; for with speed reserve - the filesystem</span>
<span class="cm">	 * simply gets slower as bad blocks accumulate.  Until the bad blocks</span>
<span class="cm">	 * exceed the speed reserve - then the filesystem gets smaller.</span>
<span class="cm">	 */</span>
	<span class="n">reserve</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_bad_segments</span> <span class="o">+</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_bad_seg_reserve</span><span class="p">;</span>
	<span class="n">reserve</span> <span class="o">*=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_segsize</span> <span class="o">-</span> <span class="n">LOGFS_SEGMENT_RESERVE</span><span class="p">;</span>
	<span class="n">reserve</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">reserve</span><span class="p">,</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_speed_reserve</span><span class="p">);</span>
	<span class="n">free</span> <span class="o">-=</span> <span class="n">reserve</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_free_bytes</span> <span class="o">=</span> <span class="n">free</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reserve_sb_and_journal</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">btree_head32</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_reserved_segments</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">btree_insert32</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">seg_no</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_sb_ofs</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">,</span>
			<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">btree_insert32</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">seg_no</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_sb_ofs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">,</span>
			<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>

	<span class="n">journal_for_each</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_seg</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">btree_insert32</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_seg</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">,</span>
				<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">read_dynsb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">logfs_je_dynsb</span> <span class="o">*</span><span class="n">dynsb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_gec</span>		<span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">dynsb</span><span class="o">-&gt;</span><span class="n">ds_gec</span><span class="p">);</span>
	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_sweeper</span>	<span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">dynsb</span><span class="o">-&gt;</span><span class="n">ds_sweeper</span><span class="p">);</span>
	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_victim_ino</span>	<span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">dynsb</span><span class="o">-&gt;</span><span class="n">ds_victim_ino</span><span class="p">);</span>
	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_rename_dir</span>	<span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">dynsb</span><span class="o">-&gt;</span><span class="n">ds_rename_dir</span><span class="p">);</span>
	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_rename_pos</span>	<span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">dynsb</span><span class="o">-&gt;</span><span class="n">ds_rename_pos</span><span class="p">);</span>
	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_used_bytes</span>	<span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">dynsb</span><span class="o">-&gt;</span><span class="n">ds_used_bytes</span><span class="p">);</span>
	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_generation</span>	<span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">dynsb</span><span class="o">-&gt;</span><span class="n">ds_generation</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">read_anchor</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">logfs_je_anchor</span> <span class="o">*</span><span class="n">da</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_master_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">logfs_inode</span> <span class="o">*</span><span class="n">li</span> <span class="o">=</span> <span class="n">logfs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_last_ino</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">da</span><span class="o">-&gt;</span><span class="n">da_last_ino</span><span class="p">);</span>
	<span class="n">li</span><span class="o">-&gt;</span><span class="n">li_flags</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">li</span><span class="o">-&gt;</span><span class="n">li_height</span>	<span class="o">=</span> <span class="n">da</span><span class="o">-&gt;</span><span class="n">da_height</span><span class="p">;</span>
	<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">da</span><span class="o">-&gt;</span><span class="n">da_size</span><span class="p">));</span>
	<span class="n">li</span><span class="o">-&gt;</span><span class="n">li_used_bytes</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">da</span><span class="o">-&gt;</span><span class="n">da_used_bytes</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LOGFS_EMBEDDED_FIELDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">li</span><span class="o">-&gt;</span><span class="n">li_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">da</span><span class="o">-&gt;</span><span class="n">da_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">read_erasecount</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">logfs_je_journal_ec</span> <span class="o">*</span><span class="n">ec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">journal_for_each</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_ec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ec</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">logfs_je_area</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">logfs_area</span> <span class="o">*</span><span class="n">area</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_area</span><span class="p">[</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">gc_level</span><span class="p">];</span>
	<span class="n">u64</span> <span class="n">ofs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">writemask</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_writesize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">gc_level</span> <span class="o">&gt;=</span> <span class="n">LOGFS_NO_AREAS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">vim</span> <span class="o">!=</span> <span class="n">VIM_DEFAULT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span> <span class="cm">/* TODO: close area and continue */</span>

	<span class="n">area</span><span class="o">-&gt;</span><span class="n">a_used_bytes</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">used_bytes</span><span class="p">);</span>
	<span class="n">area</span><span class="o">-&gt;</span><span class="n">a_written_bytes</span> <span class="o">=</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">a_used_bytes</span> <span class="o">&amp;</span> <span class="n">writemask</span><span class="p">;</span>
	<span class="n">area</span><span class="o">-&gt;</span><span class="n">a_segno</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">segno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">a_segno</span><span class="p">)</span>
		<span class="n">area</span><span class="o">-&gt;</span><span class="n">a_is_open</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ofs</span> <span class="o">=</span> <span class="n">dev_ofs</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">a_segno</span><span class="p">,</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">a_written_bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_writesize</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">logfs_buf_recover</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_writesize</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">logfs_buf_recover</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">unpack</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_journal_header</span> <span class="o">*</span><span class="n">jh</span> <span class="o">=</span> <span class="n">from</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">from</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_journal_header</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">inlen</span><span class="p">,</span> <span class="n">outlen</span><span class="p">;</span>

	<span class="n">inlen</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_len</span><span class="p">);</span>
	<span class="n">outlen</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_datalen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_compr</span> <span class="o">==</span> <span class="n">COMPR_NONE</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">inlen</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">logfs_uncompress</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">inlen</span><span class="p">,</span> <span class="n">outlen</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">to</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__read_je_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ofs</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">logfs_journal_header</span> <span class="o">*</span><span class="n">jh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">bufsize</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">,</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_writesize</span><span class="p">)</span>
		<span class="o">+</span> <span class="n">MAX_JOURNAL_HEADER</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">type</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">datalen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* read header only */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">wbuf_read</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">jh</span><span class="p">),</span> <span class="n">jh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_type</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_len</span><span class="p">);</span>
	<span class="n">datalen</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_datalen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">type</span> <span class="o">&lt;</span> <span class="n">JE_FIRST</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">type</span> <span class="o">&gt;</span> <span class="n">JE_LAST</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">datalen</span> <span class="o">&gt;</span> <span class="n">bufsize</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__read_je_payload</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ofs</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">logfs_journal_header</span> <span class="o">*</span><span class="n">jh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_len</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">wbuf_read</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ofs</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">jh</span><span class="p">),</span> <span class="n">len</span><span class="p">,</span> <span class="n">jh</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_crc</span> <span class="o">!=</span> <span class="n">logfs_crc32</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">len</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">jh</span><span class="p">),</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Old code was confused.  It forgot about the header length</span>
<span class="cm">		 * and stopped calculating the crc 16 bytes before the end</span>
<span class="cm">		 * of data - ick!</span>
<span class="cm">		 * FIXME: Remove this hack once the old code is fixed.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_crc</span> <span class="o">==</span> <span class="n">logfs_crc32</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
			<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * jh needs to be large enough to hold the complete entry, not just the header</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__read_je</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ofs</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">logfs_journal_header</span> <span class="o">*</span><span class="n">jh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">__read_je_header</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">jh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__read_je_payload</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">jh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_je</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ofs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">logfs_journal_header</span> <span class="o">*</span><span class="n">jh</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_compressed_je</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">scratch</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_je</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">type</span><span class="p">,</span> <span class="n">datalen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">__read_je</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">jh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_type</span><span class="p">);</span>
	<span class="n">datalen</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_datalen</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">JE_DYNSB</span>:
		<span class="n">read_dynsb</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">unpack</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">scratch</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">JE_ANCHOR</span>:
		<span class="n">read_anchor</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">unpack</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">scratch</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">JE_ERASECOUNT</span>:
		<span class="n">read_erasecount</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">unpack</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">scratch</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">JE_AREA</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">read_area</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">unpack</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">scratch</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">JE_OBJ_ALIAS</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">logfs_load_object_aliases</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">unpack</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">scratch</span><span class="p">),</span>
				<span class="n">datalen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">logfs_read_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">segno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">logfs_journal_header</span> <span class="o">*</span><span class="n">jh</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_compressed_je</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">seg_ofs</span> <span class="o">=</span> <span class="n">dev_ofs</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">segno</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">h_ofs</span><span class="p">,</span> <span class="n">last_ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">len</span><span class="p">,</span> <span class="n">datalen</span><span class="p">,</span> <span class="n">last_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* search for most recent commit */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">h_ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">h_ofs</span> <span class="o">&lt;</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_segsize</span><span class="p">;</span> <span class="n">h_ofs</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">jh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ofs</span> <span class="o">=</span> <span class="n">seg_ofs</span> <span class="o">+</span> <span class="n">h_ofs</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">__read_je_header</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">jh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_type</span> <span class="o">!=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">JE_COMMIT</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">__read_je_payload</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">jh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_len</span><span class="p">);</span>
		<span class="n">datalen</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_datalen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">datalen</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_je_array</span><span class="p">))</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">datalen</span> <span class="o">%</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__be64</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">last_ofs</span> <span class="o">=</span> <span class="n">h_ofs</span><span class="p">;</span>
		<span class="n">last_len</span> <span class="o">=</span> <span class="n">datalen</span><span class="p">;</span>
		<span class="n">h_ofs</span> <span class="o">+=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">jh</span><span class="p">))</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">jh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* read commit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_ofs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">ofs</span> <span class="o">=</span> <span class="n">seg_ofs</span> <span class="o">+</span> <span class="n">last_ofs</span><span class="p">;</span>
	<span class="n">log_journal</span><span class="p">(</span><span class="s">&quot;Read commit from %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">__read_je</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">jh</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span><span class="p">);</span> <span class="cm">/* We should have caught it in the scan loop already */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="cm">/* uncompress */</span>
	<span class="n">unpack</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_je_array</span><span class="p">);</span>
	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_no_je</span> <span class="o">=</span> <span class="n">last_len</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__be64</span><span class="p">);</span>
	<span class="cm">/* iterate over array */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_no_je</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">read_je</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_je_array</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_area</span><span class="o">-&gt;</span><span class="n">a_segno</span> <span class="o">=</span> <span class="n">segno</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">read_gec</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">segno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_segment_header</span> <span class="n">sh</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">crc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">segno</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">wbuf_read</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">dev_ofs</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">segno</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sh</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">sh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">crc</span> <span class="o">=</span> <span class="n">logfs_crc32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sh</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sh</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">crc</span> <span class="o">!=</span> <span class="n">sh</span><span class="p">.</span><span class="n">crc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">sh</span><span class="p">.</span><span class="n">gec</span> <span class="o">!=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="mh">0xffffffffffffffffull</span><span class="p">));</span>
		<span class="cm">/* Most likely it was just erased */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">sh</span><span class="p">.</span><span class="n">gec</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">logfs_read_journal</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">gec</span><span class="p">[</span><span class="n">LOGFS_JOURNAL_SEGS</span><span class="p">],</span> <span class="n">max</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">segno</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">max_i</span><span class="p">;</span>

	<span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">max_i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">journal_for_each</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">segno</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_seg</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">gec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_gec</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_seg</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">max</span> <span class="o">=</span> <span class="n">gec</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">max_i</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="cm">/* FIXME: Try older segments in case of error */</span>
	<span class="k">return</span> <span class="n">logfs_read_segment</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_seg</span><span class="p">[</span><span class="n">max_i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * First search the current segment (outer loop), then pick the next segment</span>
<span class="cm"> * in the array, skipping any zero entries (inner loop).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">journal_get_free_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_area</span> <span class="o">*</span><span class="n">area</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">a_sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">journal_for_each</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">a_segno</span> <span class="o">!=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_seg</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">LOGFS_JOURNAL_SEGS</span><span class="p">)</span>
				<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_seg</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="n">area</span><span class="o">-&gt;</span><span class="n">a_segno</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_seg</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">area</span><span class="o">-&gt;</span><span class="n">a_erase_count</span> <span class="o">=</span> <span class="o">++</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_ec</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">log_journal</span><span class="p">(</span><span class="s">&quot;Journal now at %x (ec %x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">a_segno</span><span class="p">,</span>
				<span class="n">area</span><span class="o">-&gt;</span><span class="n">a_erase_count</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">journal_get_erase_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_area</span> <span class="o">*</span><span class="n">area</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* erase count is stored globally and incremented in</span>
<span class="cm">	 * journal_get_free_segment() - nothing to do here */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">journal_erase_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_area</span> <span class="o">*</span><span class="n">area</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">a_sb</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">logfs_segment_header</span> <span class="n">sh</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">[</span><span class="n">ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_segment_header</span><span class="p">),</span> <span class="mi">16</span><span class="p">)];</span>
	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ofs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">logfs_erase_segment</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">a_segno</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u</span><span class="p">));</span>
	<span class="n">u</span><span class="p">.</span><span class="n">sh</span><span class="p">.</span><span class="n">pad</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u</span><span class="p">.</span><span class="n">sh</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">SEG_JOURNAL</span><span class="p">;</span>
	<span class="n">u</span><span class="p">.</span><span class="n">sh</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u</span><span class="p">.</span><span class="n">sh</span><span class="p">.</span><span class="n">segno</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">a_segno</span><span class="p">);</span>
	<span class="n">u</span><span class="p">.</span><span class="n">sh</span><span class="p">.</span><span class="n">ec</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">a_erase_count</span><span class="p">);</span>
	<span class="n">u</span><span class="p">.</span><span class="n">sh</span><span class="p">.</span><span class="n">gec</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_gec</span><span class="p">);</span>
	<span class="n">u</span><span class="p">.</span><span class="n">sh</span><span class="p">.</span><span class="n">crc</span> <span class="o">=</span> <span class="n">logfs_crc32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">sh</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">sh</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>

	<span class="cm">/* This causes a bug in segment.c.  Not yet. */</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>logfs<em>set</em>segment<em>erased(sb, area->a</em>segno, area->a<em>erase</em>count, 0);</p></td><td class="code"><div class="highlight"><pre>	<span class="n">ofs</span> <span class="o">=</span> <span class="n">dev_ofs</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">a_segno</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">area</span><span class="o">-&gt;</span><span class="n">a_used_bytes</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
	<span class="n">logfs_buf_write</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">__logfs_write_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">logfs_journal_header</span> <span class="o">*</span><span class="n">jh</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">datalen</span><span class="p">,</span>
		<span class="n">u16</span> <span class="n">type</span><span class="p">,</span> <span class="n">u8</span> <span class="n">compr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_len</span>	<span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_type</span>	<span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_datalen</span>	<span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">datalen</span><span class="p">);</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_compr</span>	<span class="o">=</span> <span class="n">compr</span><span class="p">;</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_pad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="sc">&#39;H&#39;</span><span class="p">;</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_pad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>	<span class="o">=</span> <span class="sc">&#39;E&#39;</span><span class="p">;</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_pad</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>	<span class="o">=</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_pad</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>	<span class="o">=</span> <span class="sc">&#39;D&#39;</span><span class="p">;</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_pad</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>	<span class="o">=</span> <span class="sc">&#39;R&#39;</span><span class="p">;</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_crc</span>	<span class="o">=</span> <span class="n">logfs_crc32</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">len</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">jh</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">jh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">logfs_write_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">logfs_journal_header</span> <span class="o">*</span><span class="n">jh</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">datalen</span><span class="p">,</span> <span class="n">u16</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">datalen</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__logfs_write_header</span><span class="p">(</span><span class="n">super</span><span class="p">,</span> <span class="n">jh</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">datalen</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">COMPR_NONE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">size_t</span> <span class="nf">logfs_journal_erasecount_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">LOGFS_JOURNAL_SEGS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__be32</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">logfs_write_erasecount</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_ec</span><span class="p">,</span>
		<span class="n">u16</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">logfs_je_journal_ec</span> <span class="o">*</span><span class="n">ec</span> <span class="o">=</span> <span class="n">_ec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">journal_for_each</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">ec</span><span class="o">-&gt;</span><span class="n">ec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_ec</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">JE_ERASECOUNT</span><span class="p">;</span>
	<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">logfs_journal_erasecount_size</span><span class="p">(</span><span class="n">super</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ec</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">account_shadow</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">_shadow</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ignore</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">ignore2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_shadow</span> <span class="o">*</span><span class="n">shadow</span> <span class="o">=</span> <span class="n">_shadow</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="cm">/* consume new space */</span>
	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_free_bytes</span>	  <span class="o">-=</span> <span class="n">shadow</span><span class="o">-&gt;</span><span class="n">new_len</span><span class="p">;</span>
	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_used_bytes</span>	  <span class="o">+=</span> <span class="n">shadow</span><span class="o">-&gt;</span><span class="n">new_len</span><span class="p">;</span>
	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_dirty_used_bytes</span> <span class="o">-=</span> <span class="n">shadow</span><span class="o">-&gt;</span><span class="n">new_len</span><span class="p">;</span>

	<span class="cm">/* free up old space */</span>
	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_free_bytes</span>	  <span class="o">+=</span> <span class="n">shadow</span><span class="o">-&gt;</span><span class="n">old_len</span><span class="p">;</span>
	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_used_bytes</span>	  <span class="o">-=</span> <span class="n">shadow</span><span class="o">-&gt;</span><span class="n">old_len</span><span class="p">;</span>
	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_dirty_free_bytes</span> <span class="o">-=</span> <span class="n">shadow</span><span class="o">-&gt;</span><span class="n">old_len</span><span class="p">;</span>

	<span class="n">logfs_set_segment_used</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">shadow</span><span class="o">-&gt;</span><span class="n">old_ofs</span><span class="p">,</span> <span class="o">-</span><span class="n">shadow</span><span class="o">-&gt;</span><span class="n">old_len</span><span class="p">);</span>
	<span class="n">logfs_set_segment_used</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">shadow</span><span class="o">-&gt;</span><span class="n">new_ofs</span><span class="p">,</span> <span class="n">shadow</span><span class="o">-&gt;</span><span class="n">new_len</span><span class="p">);</span>

	<span class="n">log_journal</span><span class="p">(</span><span class="s">&quot;account_shadow(%llx, %llx, %x) %llx-&gt;%llx %x-&gt;%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">shadow</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">shadow</span><span class="o">-&gt;</span><span class="n">bix</span><span class="p">,</span> <span class="n">shadow</span><span class="o">-&gt;</span><span class="n">gc_level</span><span class="p">,</span>
			<span class="n">shadow</span><span class="o">-&gt;</span><span class="n">old_ofs</span><span class="p">,</span> <span class="n">shadow</span><span class="o">-&gt;</span><span class="n">new_ofs</span><span class="p">,</span>
			<span class="n">shadow</span><span class="o">-&gt;</span><span class="n">old_len</span><span class="p">,</span> <span class="n">shadow</span><span class="o">-&gt;</span><span class="n">new_len</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">shadow</span><span class="p">,</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_shadow_pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">account_shadows</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_master_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">logfs_inode</span> <span class="o">*</span><span class="n">li</span> <span class="o">=</span> <span class="n">logfs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">shadow_tree</span> <span class="o">*</span><span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_shadow_tree</span><span class="p">;</span>

	<span class="n">btree_grim_visitor64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sb</span><span class="p">,</span> <span class="n">account_shadow</span><span class="p">);</span>
	<span class="n">btree_grim_visitor64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">old</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sb</span><span class="p">,</span> <span class="n">account_shadow</span><span class="p">);</span>
	<span class="n">btree_grim_visitor32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">segment_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">tree</span><span class="o">-&gt;</span><span class="n">no_shadowed_segments</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">li_block</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We never actually use the structure, when attached to the</span>
<span class="cm">		 * master inode.  But it is easier to always free it here than</span>
<span class="cm">		 * to have checks in several places elsewhere when allocating</span>
<span class="cm">		 * it.</span>
<span class="cm">		 */</span>
		<span class="n">li</span><span class="o">-&gt;</span><span class="n">li_block</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">free_block</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">li</span><span class="o">-&gt;</span><span class="n">li_block</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">s64</span><span class="p">)</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">li_used_bytes</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">__logfs_write_anchor</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_da</span><span class="p">,</span>
		<span class="n">u16</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">logfs_je_anchor</span> <span class="o">*</span><span class="n">da</span> <span class="o">=</span> <span class="n">_da</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_master_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">logfs_inode</span> <span class="o">*</span><span class="n">li</span> <span class="o">=</span> <span class="n">logfs_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">da</span><span class="o">-&gt;</span><span class="n">da_height</span>	<span class="o">=</span> <span class="n">li</span><span class="o">-&gt;</span><span class="n">li_height</span><span class="p">;</span>
	<span class="n">da</span><span class="o">-&gt;</span><span class="n">da_last_ino</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_last_ino</span><span class="p">);</span>
	<span class="n">da</span><span class="o">-&gt;</span><span class="n">da_size</span>	<span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="n">da</span><span class="o">-&gt;</span><span class="n">da_used_bytes</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">li_used_bytes</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LOGFS_EMBEDDED_FIELDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">da</span><span class="o">-&gt;</span><span class="n">da_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">li_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">JE_ANCHOR</span><span class="p">;</span>
	<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">da</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">da</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">logfs_write_dynsb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_dynsb</span><span class="p">,</span>
		<span class="n">u16</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">logfs_je_dynsb</span> <span class="o">*</span><span class="n">dynsb</span> <span class="o">=</span> <span class="n">_dynsb</span><span class="p">;</span>

	<span class="n">dynsb</span><span class="o">-&gt;</span><span class="n">ds_gec</span>		<span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_gec</span><span class="p">);</span>
	<span class="n">dynsb</span><span class="o">-&gt;</span><span class="n">ds_sweeper</span>	<span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_sweeper</span><span class="p">);</span>
	<span class="n">dynsb</span><span class="o">-&gt;</span><span class="n">ds_victim_ino</span>	<span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_victim_ino</span><span class="p">);</span>
	<span class="n">dynsb</span><span class="o">-&gt;</span><span class="n">ds_rename_dir</span>	<span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_rename_dir</span><span class="p">);</span>
	<span class="n">dynsb</span><span class="o">-&gt;</span><span class="n">ds_rename_pos</span>	<span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_rename_pos</span><span class="p">);</span>
	<span class="n">dynsb</span><span class="o">-&gt;</span><span class="n">ds_used_bytes</span>	<span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_used_bytes</span><span class="p">);</span>
	<span class="n">dynsb</span><span class="o">-&gt;</span><span class="n">ds_generation</span>	<span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_generation</span><span class="p">);</span>
	<span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">JE_DYNSB</span><span class="p">;</span>
	<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dynsb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dynsb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_wbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">logfs_area</span> <span class="o">*</span><span class="n">area</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">wbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_mapping_inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ofs</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">page_ofs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">ofs</span> <span class="o">=</span> <span class="n">dev_ofs</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">a_segno</span><span class="p">,</span>
			<span class="n">area</span><span class="o">-&gt;</span><span class="n">a_used_bytes</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_writesize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">page_ofs</span> <span class="o">=</span> <span class="n">ofs</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">find_lock_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">wbuf</span><span class="p">,</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">page_ofs</span><span class="p">,</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_writesize</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">logfs_write_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_a</span><span class="p">,</span>
		<span class="n">u16</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">logfs_area</span> <span class="o">*</span><span class="n">area</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_area</span><span class="p">[</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_sum_index</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">logfs_je_area</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">_a</span><span class="p">;</span>

	<span class="n">a</span><span class="o">-&gt;</span><span class="n">vim</span> <span class="o">=</span> <span class="n">VIM_DEFAULT</span><span class="p">;</span>
	<span class="n">a</span><span class="o">-&gt;</span><span class="n">gc_level</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_sum_index</span><span class="p">;</span>
	<span class="n">a</span><span class="o">-&gt;</span><span class="n">used_bytes</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">a_used_bytes</span><span class="p">);</span>
	<span class="n">a</span><span class="o">-&gt;</span><span class="n">segno</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">a_segno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_writesize</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">write_wbuf</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">JE_AREA</span><span class="p">;</span>
	<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_writesize</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">logfs_write_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
		<span class="n">u16</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">JE_COMMIT</span><span class="p">;</span>
	<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_no_je</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__be64</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_je_array</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">__logfs_write_je</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u16</span> <span class="n">type</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_compressed_je</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">header</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_journal_header</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="n">compr_len</span><span class="p">,</span> <span class="n">pad_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">compr</span> <span class="o">=</span> <span class="n">COMPR_ZLIB</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">logfs_write_header</span><span class="p">(</span><span class="n">super</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>

	<span class="n">compr_len</span> <span class="o">=</span> <span class="n">logfs_compress</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">compr_len</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">type</span> <span class="o">==</span> <span class="n">JE_ANCHOR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">compr_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">compr</span> <span class="o">=</span> <span class="n">COMPR_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pad_len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">compr_len</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="n">compr_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pad_len</span> <span class="o">-</span> <span class="n">compr_len</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">__logfs_write_header</span><span class="p">(</span><span class="n">super</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">compr_len</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">compr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">s64</span> <span class="nf">logfs_get_free_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_area</span> <span class="o">*</span><span class="n">area</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">bytes</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">must_pad</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">writesize</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">a_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_writesize</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ofs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">logfs_open_area</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="o">*</span><span class="n">bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="n">ofs</span> <span class="o">=</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">a_used_bytes</span><span class="p">;</span>
	<span class="n">area</span><span class="o">-&gt;</span><span class="n">a_used_bytes</span> <span class="o">+=</span> <span class="o">*</span><span class="n">bytes</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">must_pad</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">area</span><span class="o">-&gt;</span><span class="n">a_used_bytes</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">a_used_bytes</span><span class="p">,</span> <span class="n">writesize</span><span class="p">);</span>
		<span class="o">*</span><span class="n">bytes</span> <span class="o">=</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">a_used_bytes</span> <span class="o">-</span> <span class="n">ofs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dev_ofs</span><span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">a_sb</span><span class="p">,</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">a_segno</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">logfs_write_je_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u16</span> <span class="n">type</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">buf_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">logfs_area</span> <span class="o">*</span><span class="n">area</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_area</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">logfs_journal_header</span> <span class="o">*</span><span class="n">jh</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_compressed_je</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">must_pad</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">ofs</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">__logfs_write_je</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">h_type</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">JE_COMMIT</span><span class="p">))</span>
		<span class="n">must_pad</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ofs</span> <span class="o">=</span> <span class="n">logfs_get_free_bytes</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="n">must_pad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ofs</span><span class="p">;</span>
	<span class="n">logfs_buf_write</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_compressed_je</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_no_je</span> <span class="o">&gt;=</span> <span class="n">MAX_JOURNAL_ENTRIES</span><span class="p">);</span>
	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_je_array</span><span class="p">[</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_no_je</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">ofs</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">logfs_write_je</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
		<span class="kt">void</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">scratch</span><span class="p">,</span>
			<span class="n">u16</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">len</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">type</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_je</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">logfs_write_je_buf</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">write_alias_journal</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ino</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bix</span><span class="p">,</span>
		<span class="n">level_t</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">child_no</span><span class="p">,</span> <span class="n">__be64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">logfs_obj_alias</span> <span class="o">*</span><span class="n">oa</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_je</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fill</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_je_fill</span><span class="p">;</span>

	<span class="n">log_aliases</span><span class="p">(</span><span class="s">&quot;logfs_write_obj_aliases #%x(%llx, %llx, %x, %x) %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">fill</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">bix</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">child_no</span><span class="p">,</span> <span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
	<span class="n">oa</span><span class="p">[</span><span class="n">fill</span><span class="p">].</span><span class="n">ino</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="n">oa</span><span class="p">[</span><span class="n">fill</span><span class="p">].</span><span class="n">bix</span> <span class="o">=</span> <span class="n">cpu_to_be64</span><span class="p">(</span><span class="n">bix</span><span class="p">);</span>
	<span class="n">oa</span><span class="p">[</span><span class="n">fill</span><span class="p">].</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">oa</span><span class="p">[</span><span class="n">fill</span><span class="p">].</span><span class="n">level</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u8</span><span class="p">)</span><span class="n">level</span><span class="p">;</span>
	<span class="n">oa</span><span class="p">[</span><span class="n">fill</span><span class="p">].</span><span class="n">child_no</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">child_no</span><span class="p">);</span>
	<span class="n">fill</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fill</span> <span class="o">&gt;=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">oa</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">logfs_write_je_buf</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">oa</span><span class="p">,</span> <span class="n">JE_OBJ_ALIAS</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
		<span class="n">fill</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_je_fill</span> <span class="o">=</span> <span class="n">fill</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">logfs_write_obj_aliases</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">log_journal</span><span class="p">(</span><span class="s">&quot;logfs_write_obj_aliases: %d aliases to write</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_no_object_aliases</span><span class="p">);</span>
	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_je_fill</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">logfs_write_obj_aliases_pagecache</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_je_fill</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">logfs_write_je_buf</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_je</span><span class="p">,</span> <span class="n">JE_OBJ_ALIAS</span><span class="p">,</span>
				<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_je_fill</span>
				<span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">logfs_obj_alias</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write all journal entries.  The goto logic ensures that all journal entries</span>
<span class="cm"> * are written whenever a new segment is used.  It is ugly and potentially a</span>
<span class="cm"> * bit wasteful, but robustness is more important.  With this we can *always*</span>
<span class="cm"> * erase all journal segments except the one containing the most recent commit.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">logfs_write_anchor</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">logfs_area</span> <span class="o">*</span><span class="n">area</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_area</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">LOGFS_SB_FLAG_DIRTY</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LOGFS_SB_FLAG_DIRTY</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">LOGFS_SB_FLAG_SHUTDOWN</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_mutex</span><span class="p">);</span>

	<span class="cm">/* Do this first or suffer corruption */</span>
	<span class="n">logfs_sync_segments</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">account_shadows</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

<span class="nl">again:</span>
	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_no_je</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_area</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_area</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">a_is_open</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_sum_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">logfs_write_je</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">logfs_write_area</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">logfs_write_obj_aliases</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">logfs_write_je</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">logfs_write_erasecount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">logfs_write_je</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">__logfs_write_anchor</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">logfs_write_je</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">logfs_write_dynsb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Order is imperative.  First we sync all writes, including the</span>
<span class="cm">	 * non-committed journal writes.  Then we write the final commit and</span>
<span class="cm">	 * sync the current journal segment.</span>
<span class="cm">	 * There is a theoretical bug here.  Syncing the journal segment will</span>
<span class="cm">	 * write a number of journal entries and the final commit.  All these</span>
<span class="cm">	 * are written in a single operation.  If the device layer writes the</span>
<span class="cm">	 * data back-to-front, the commit will precede the other journal</span>
<span class="cm">	 * entries, leaving a race window.</span>
<span class="cm">	 * Two fixes are possible.  Preferred is to fix the device layer to</span>
<span class="cm">	 * ensure writes happen front-to-back.  Alternatively we can insert</span>
<span class="cm">	 * another logfs_sync_area() super-&gt;s_devops-&gt;sync() combo before</span>
<span class="cm">	 * writing the commit.</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 * On another subject, super-&gt;s_devops-&gt;sync is usually not necessary.</span>
<span class="cm">	 * Unless called from sys_sync or friends, a barrier would suffice.</span>
<span class="cm">	 */</span>
	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_devops</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">logfs_write_je</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">logfs_write_commit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="n">log_journal</span><span class="p">(</span><span class="s">&quot;Write commit to %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">be64_to_cpu</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_je_array</span><span class="p">[</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_no_je</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]));</span>
	<span class="n">logfs_sync_area</span><span class="p">(</span><span class="n">area</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">a_used_bytes</span> <span class="o">!=</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">a_written_bytes</span><span class="p">);</span>
	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_devops</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_mutex</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">do_logfs_journal_wl_pass</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">logfs_area</span> <span class="o">*</span><span class="n">area</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_area</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btree_head32</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_reserved_segments</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">segno</span><span class="p">,</span> <span class="n">ec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">log_journal</span><span class="p">(</span><span class="s">&quot;Journal requires wear-leveling.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/* Drop old segments */</span>
	<span class="n">journal_for_each</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_seg</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">btree_remove32</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_seg</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">logfs_set_segment_unreserved</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
					<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_seg</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_ec</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_seg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_ec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="cm">/* Get new segments */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_no_journal_segs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">segno</span> <span class="o">=</span> <span class="n">get_best_cand</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_reserve_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ec</span><span class="p">);</span>
		<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_seg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">segno</span><span class="p">;</span>
		<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_ec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ec</span><span class="p">;</span>
		<span class="n">logfs_set_segment_reserved</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">segno</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">btree_insert32</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">segno</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span><span class="p">);</span> <span class="cm">/* mempool should prevent this */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">logfs_erase_segment</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">segno</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span><span class="p">);</span> <span class="cm">/* FIXME: remount-ro would be nicer */</span>
	<span class="p">}</span>
	<span class="cm">/* Manually move journal_area */</span>
	<span class="n">freeseg</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">a_segno</span><span class="p">);</span>
	<span class="n">area</span><span class="o">-&gt;</span><span class="n">a_segno</span> <span class="o">=</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_seg</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">area</span><span class="o">-&gt;</span><span class="n">a_is_open</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">area</span><span class="o">-&gt;</span><span class="n">a_used_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Write journal */</span>
	<span class="n">logfs_write_anchor</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="cm">/* Write superblocks */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">logfs_write_sb</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">logfs_area_ops</span> <span class="n">journal_area_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_free_segment</span>	<span class="o">=</span> <span class="n">journal_get_free_segment</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_erase_count</span>	<span class="o">=</span> <span class="n">journal_get_erase_count</span><span class="p">,</span>
	<span class="p">.</span><span class="n">erase_segment</span>		<span class="o">=</span> <span class="n">journal_erase_segment</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">logfs_init_journal</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">bufsize</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">,</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_writesize</span><span class="p">)</span>
		<span class="o">+</span> <span class="n">MAX_JOURNAL_HEADER</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_mutex</span><span class="p">);</span>
	<span class="n">btree_init_mempool32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_reserved_segments</span><span class="p">,</span> <span class="n">super</span><span class="o">-&gt;</span><span class="n">s_btree_pool</span><span class="p">);</span>

	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_je</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">bufsize</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_je</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_compressed_je</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">bufsize</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_compressed_je</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_master_inode</span> <span class="o">=</span> <span class="n">logfs_new_meta_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">LOGFS_INO_MASTER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_master_inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_master_inode</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">logfs_read_journal</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">reserve_sb_and_journal</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">logfs_calc_free</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">super</span><span class="o">-&gt;</span><span class="n">s_journal_area</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">journal_area_ops</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">logfs_cleanup_journal</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_super</span> <span class="o">*</span><span class="n">super</span> <span class="o">=</span> <span class="n">logfs_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">btree_grim_visitor32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_reserved_segments</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_compressed_je</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_je</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
