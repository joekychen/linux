<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › logfs › logfs_abi.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>logfs_abi.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * fs/logfs/logfs_abi.h</span>
<span class="cm"> *</span>
<span class="cm"> * As should be obvious for Linux kernel code, license is GPLv2</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2005-2008 Joern Engel &lt;joern@logfs.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Public header for logfs.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef FS_LOGFS_LOGFS_ABI_H</span>
<span class="cp">#define FS_LOGFS_LOGFS_ABI_H</span>

<span class="cm">/* For out-of-kernel compiles */</span>
<span class="cp">#ifndef BUILD_BUG_ON</span>
<span class="cp">#define BUILD_BUG_ON(condition) </span><span class="cm">/**/</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cp">#define SIZE_CHECK(type, size)					\</span>
<span class="cp">static inline void check_##type(void)				\</span>
<span class="cp">{								\</span>
<span class="cp">	BUILD_BUG_ON(sizeof(struct type) != (size));		\</span>
<span class="cp">}</span>

<span class="cm">/*</span>
<span class="cm"> * Throughout the logfs code, we&#39;re constantly dealing with blocks at</span>
<span class="cm"> * various positions or offsets.  To remove confusion, we stricly</span>
<span class="cm"> * distinguish between a &quot;position&quot; - the logical position within a</span>
<span class="cm"> * file and an &quot;offset&quot; - the physical location within the device.</span>
<span class="cm"> *</span>
<span class="cm"> * Any usage of the term offset for a logical location or position for</span>
<span class="cm"> * a physical one is a bug and should get fixed.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Block are allocated in one of several segments depending on their</span>
<span class="cm"> * level.  The following levels are used:</span>
<span class="cm"> *  0	- regular data block</span>
<span class="cm"> *  1	- i1 indirect blocks</span>
<span class="cm"> *  2	- i2 indirect blocks</span>
<span class="cm"> *  3	- i3 indirect blocks</span>
<span class="cm"> *  4	- i4 indirect blocks</span>
<span class="cm"> *  5	- i5 indirect blocks</span>
<span class="cm"> *  6	- ifile data blocks</span>
<span class="cm"> *  7	- ifile i1 indirect blocks</span>
<span class="cm"> *  8	- ifile i2 indirect blocks</span>
<span class="cm"> *  9	- ifile i3 indirect blocks</span>
<span class="cm"> * 10	- ifile i4 indirect blocks</span>
<span class="cm"> * 11	- ifile i5 indirect blocks</span>
<span class="cm"> * Potential levels to be used in the future:</span>
<span class="cm"> * 12	- gc recycled blocks, long-lived data</span>
<span class="cm"> * 13	- replacement blocks, short-lived data</span>
<span class="cm"> *</span>
<span class="cm"> * Levels 1-11 are necessary for robust gc operations and help separate</span>
<span class="cm"> * short-lived metadata from longer-lived file data.  In the future,</span>
<span class="cm"> * file data should get separated into several segments based on simple</span>
<span class="cm"> * heuristics.  Old data recycled during gc operation is expected to be</span>
<span class="cm"> * long-lived.  New data is of uncertain life expectancy.  New data</span>
<span class="cm"> * used to replace older blocks in existing files is expected to be</span>
<span class="cm"> * short-lived.</span>
<span class="cm"> */</span>


<span class="cm">/* Magic numbers.  64bit for superblock, 32bit for statfs f_type */</span>
<span class="cp">#define LOGFS_MAGIC		0x7a3a8e5cb9d5bf67ull</span>
<span class="cp">#define LOGFS_MAGIC_U32		0xc97e8168u</span>

<span class="cm">/*</span>
<span class="cm"> * Various blocksize related macros.  Blocksize is currently fixed at 4KiB.</span>
<span class="cm"> * Sooner or later that should become configurable and the macros replaced</span>
<span class="cm"> * by something superblock-dependent.  Pointers in indirect blocks are and</span>
<span class="cm"> * will remain 64bit.</span>
<span class="cm"> *</span>
<span class="cm"> * LOGFS_BLOCKSIZE	- self-explaining</span>
<span class="cm"> * LOGFS_BLOCK_FACTOR	- number of pointers per indirect block</span>
<span class="cm"> * LOGFS_BLOCK_BITS	- log2 of LOGFS_BLOCK_FACTOR, used for shifts</span>
<span class="cm"> */</span>
<span class="cp">#define LOGFS_BLOCKSIZE		(4096ull)</span>
<span class="cp">#define LOGFS_BLOCK_FACTOR	(LOGFS_BLOCKSIZE / sizeof(u64))</span>
<span class="cp">#define LOGFS_BLOCK_BITS	(9)</span>

<span class="cm">/*</span>
<span class="cm"> * Number of blocks at various levels of indirection.  There are 16 direct</span>
<span class="cm"> * block pointers plus a single indirect pointer.</span>
<span class="cm"> */</span>
<span class="cp">#define I0_BLOCKS		(16)</span>
<span class="cp">#define I1_BLOCKS		LOGFS_BLOCK_FACTOR</span>
<span class="cp">#define I2_BLOCKS		(LOGFS_BLOCK_FACTOR * I1_BLOCKS)</span>
<span class="cp">#define I3_BLOCKS		(LOGFS_BLOCK_FACTOR * I2_BLOCKS)</span>
<span class="cp">#define I4_BLOCKS		(LOGFS_BLOCK_FACTOR * I3_BLOCKS)</span>
<span class="cp">#define I5_BLOCKS		(LOGFS_BLOCK_FACTOR * I4_BLOCKS)</span>

<span class="cp">#define INDIRECT_INDEX		I0_BLOCKS</span>
<span class="cp">#define LOGFS_EMBEDDED_FIELDS	(I0_BLOCKS + 1)</span>

<span class="cm">/*</span>
<span class="cm"> * Sizes at which files require another level of indirection.  Files smaller</span>
<span class="cm"> * than LOGFS_EMBEDDED_SIZE can be completely stored in the inode itself,</span>
<span class="cm"> * similar like ext2 fast symlinks.</span>
<span class="cm"> *</span>
<span class="cm"> * Data at a position smaller than LOGFS_I0_SIZE is accessed through the</span>
<span class="cm"> * direct pointers, else through the 1x indirect pointer and so forth.</span>
<span class="cm"> */</span>
<span class="cp">#define LOGFS_EMBEDDED_SIZE	(LOGFS_EMBEDDED_FIELDS * sizeof(u64))</span>
<span class="cp">#define LOGFS_I0_SIZE		(I0_BLOCKS * LOGFS_BLOCKSIZE)</span>
<span class="cp">#define LOGFS_I1_SIZE		(I1_BLOCKS * LOGFS_BLOCKSIZE)</span>
<span class="cp">#define LOGFS_I2_SIZE		(I2_BLOCKS * LOGFS_BLOCKSIZE)</span>
<span class="cp">#define LOGFS_I3_SIZE		(I3_BLOCKS * LOGFS_BLOCKSIZE)</span>
<span class="cp">#define LOGFS_I4_SIZE		(I4_BLOCKS * LOGFS_BLOCKSIZE)</span>
<span class="cp">#define LOGFS_I5_SIZE		(I5_BLOCKS * LOGFS_BLOCKSIZE)</span>

<span class="cm">/*</span>
<span class="cm"> * Each indirect block pointer must have this flag set, if all block pointers</span>
<span class="cm"> * behind it are set, i.e. there is no hole hidden in the shadow of this</span>
<span class="cm"> * indirect block pointer.</span>
<span class="cm"> */</span>
<span class="cp">#define LOGFS_FULLY_POPULATED (1ULL &lt;&lt; 63)</span>
<span class="cp">#define pure_ofs(ofs) (ofs &amp; ~LOGFS_FULLY_POPULATED)</span>

<span class="cm">/*</span>
<span class="cm"> * LogFS needs to separate data into levels.  Each level is defined as the</span>
<span class="cm"> * maximal possible distance from the master inode (inode of the inode file).</span>
<span class="cm"> * Data blocks reside on level 0, 1x indirect block on level 1, etc.</span>
<span class="cm"> * Inodes reside on level 6, indirect blocks for the inode file on levels 7-11.</span>
<span class="cm"> * This effort is necessary to guarantee garbage collection to always make</span>
<span class="cm"> * progress.</span>
<span class="cm"> *</span>
<span class="cm"> * LOGFS_MAX_INDIRECT is the maximal indirection through indirect blocks,</span>
<span class="cm"> * LOGFS_MAX_LEVELS is one more for the actual data level of a file.  It is</span>
<span class="cm"> * the maximal number of levels for one file.</span>
<span class="cm"> * LOGFS_NO_AREAS is twice that, as the inode file and regular files are</span>
<span class="cm"> * effectively stacked on top of each other.</span>
<span class="cm"> */</span>
<span class="cp">#define LOGFS_MAX_INDIRECT	(5)</span>
<span class="cp">#define LOGFS_MAX_LEVELS	(LOGFS_MAX_INDIRECT + 1)</span>
<span class="cp">#define LOGFS_NO_AREAS		(2 * LOGFS_MAX_LEVELS)</span>

<span class="cm">/* Maximum size of filenames */</span>
<span class="cp">#define LOGFS_MAX_NAMELEN	(255)</span>

<span class="cm">/* Number of segments in the primary journal. */</span>
<span class="cp">#define LOGFS_JOURNAL_SEGS	(16)</span>

<span class="cm">/* Maximum number of free/erased/etc. segments in journal entries */</span>
<span class="cp">#define MAX_CACHED_SEGS		(64)</span>


<span class="cm">/*</span>
<span class="cm"> * LOGFS_OBJECT_HEADERSIZE is the size of a single header in the object store,</span>
<span class="cm"> * LOGFS_MAX_OBJECTSIZE the size of the largest possible object, including</span>
<span class="cm"> * its header,</span>
<span class="cm"> * LOGFS_SEGMENT_RESERVE is the amount of space reserved for each segment for</span>
<span class="cm"> * its segment header and the padded space at the end when no further objects</span>
<span class="cm"> * fit.</span>
<span class="cm"> */</span>
<span class="cp">#define LOGFS_OBJECT_HEADERSIZE	(0x1c)</span>
<span class="cp">#define LOGFS_SEGMENT_HEADERSIZE (0x18)</span>
<span class="cp">#define LOGFS_MAX_OBJECTSIZE	(LOGFS_OBJECT_HEADERSIZE + LOGFS_BLOCKSIZE)</span>
<span class="cp">#define LOGFS_SEGMENT_RESERVE	\</span>
<span class="cp">	(LOGFS_SEGMENT_HEADERSIZE + LOGFS_MAX_OBJECTSIZE - 1)</span>

<span class="cm">/*</span>
<span class="cm"> * Segment types:</span>
<span class="cm"> * SEG_SUPER	- Data or indirect block</span>
<span class="cm"> * SEG_JOURNAL	- Inode</span>
<span class="cm"> * SEG_OSTORE	- Dentry</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SEG_SUPER</span>	<span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
	<span class="n">SEG_JOURNAL</span>	<span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="n">SEG_OSTORE</span>	<span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct logfs_segment_header - per-segment header in the ostore</span>
<span class="cm"> *</span>
<span class="cm"> * @crc:			crc32 of header (there is no data)</span>
<span class="cm"> * @pad:			unused, must be 0</span>
<span class="cm"> * @type:			segment type, see above</span>
<span class="cm"> * @level:			GC level for all objects in this segment</span>
<span class="cm"> * @segno:			segment number</span>
<span class="cm"> * @ec:				erase count for this segment</span>
<span class="cm"> * @gec:			global erase count at time of writing</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">logfs_segment_header</span> <span class="p">{</span>
	<span class="n">__be32</span>	<span class="n">crc</span><span class="p">;</span>
	<span class="n">__be16</span>	<span class="n">pad</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">type</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">level</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">segno</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">ec</span><span class="p">;</span>
	<span class="n">__be64</span>	<span class="n">gec</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">SIZE_CHECK</span><span class="p">(</span><span class="n">logfs_segment_header</span><span class="p">,</span> <span class="n">LOGFS_SEGMENT_HEADERSIZE</span><span class="p">);</span>

<span class="cp">#define LOGFS_FEATURES_INCOMPAT		(0ull)</span>
<span class="cp">#define LOGFS_FEATURES_RO_COMPAT	(0ull)</span>
<span class="cp">#define LOGFS_FEATURES_COMPAT		(0ull)</span>

<span class="cm">/**</span>
<span class="cm"> * struct logfs_disk_super - on-medium superblock</span>
<span class="cm"> *</span>
<span class="cm"> * @ds_magic:			magic number, must equal LOGFS_MAGIC</span>
<span class="cm"> * @ds_crc:			crc32 of structure starting with the next field</span>
<span class="cm"> * @ds_ifile_levels:		maximum number of levels for ifile</span>
<span class="cm"> * @ds_iblock_levels:		maximum number of levels for regular files</span>
<span class="cm"> * @ds_data_levels:		number of separate levels for data</span>
<span class="cm"> * @pad0:			reserved, must be 0</span>
<span class="cm"> * @ds_feature_incompat:	incompatible filesystem features</span>
<span class="cm"> * @ds_feature_ro_compat:	read-only compatible filesystem features</span>
<span class="cm"> * @ds_feature_compat:		compatible filesystem features</span>
<span class="cm"> * @ds_flags:			flags</span>
<span class="cm"> * @ds_segment_shift:		log2 of segment size</span>
<span class="cm"> * @ds_block_shift:		log2 of block size</span>
<span class="cm"> * @ds_write_shift:		log2 of write size</span>
<span class="cm"> * @pad1:			reserved, must be 0</span>
<span class="cm"> * @ds_journal_seg:		segments used by primary journal</span>
<span class="cm"> * @ds_root_reserve:		bytes reserved for the superuser</span>
<span class="cm"> * @ds_speed_reserve:		bytes reserved to speed up GC</span>
<span class="cm"> * @ds_bad_seg_reserve:		number of segments reserved to handle bad blocks</span>
<span class="cm"> * @pad2:			reserved, must be 0</span>
<span class="cm"> * @pad3:			reserved, must be 0</span>
<span class="cm"> *</span>
<span class="cm"> * Contains only read-only fields.  Read-write fields like the amount of used</span>
<span class="cm"> * space is tracked in the dynamic superblock, which is stored in the journal.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">logfs_disk_super</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">logfs_segment_header</span> <span class="n">ds_sh</span><span class="p">;</span>
	<span class="n">__be64</span>	<span class="n">ds_magic</span><span class="p">;</span>

	<span class="n">__be32</span>	<span class="n">ds_crc</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">ds_ifile_levels</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">ds_iblock_levels</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">ds_data_levels</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">ds_segment_shift</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">ds_block_shift</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">ds_write_shift</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">pad0</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

	<span class="n">__be64</span>	<span class="n">ds_filesystem_size</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">ds_segment_size</span><span class="p">;</span>
	<span class="n">__be32</span>  <span class="n">ds_bad_seg_reserve</span><span class="p">;</span>

	<span class="n">__be64</span>	<span class="n">ds_feature_incompat</span><span class="p">;</span>
	<span class="n">__be64</span>	<span class="n">ds_feature_ro_compat</span><span class="p">;</span>

	<span class="n">__be64</span>	<span class="n">ds_feature_compat</span><span class="p">;</span>
	<span class="n">__be64</span>	<span class="n">ds_feature_flags</span><span class="p">;</span>

	<span class="n">__be64</span>	<span class="n">ds_root_reserve</span><span class="p">;</span>
	<span class="n">__be64</span>  <span class="n">ds_speed_reserve</span><span class="p">;</span>

	<span class="n">__be32</span>	<span class="n">ds_journal_seg</span><span class="p">[</span><span class="n">LOGFS_JOURNAL_SEGS</span><span class="p">];</span>

	<span class="n">__be64</span>	<span class="n">ds_super_ofs</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">__be64</span>	<span class="n">pad3</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">};</span>

<span class="n">SIZE_CHECK</span><span class="p">(</span><span class="n">logfs_disk_super</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Object types:</span>
<span class="cm"> * OBJ_BLOCK	- Data or indirect block</span>
<span class="cm"> * OBJ_INODE	- Inode</span>
<span class="cm"> * OBJ_DENTRY	- Dentry</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">OBJ_BLOCK</span>	<span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
	<span class="n">OBJ_INODE</span>	<span class="o">=</span> <span class="mh">0x05</span><span class="p">,</span>
	<span class="n">OBJ_DENTRY</span>	<span class="o">=</span> <span class="mh">0x06</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct logfs_object_header - per-object header in the ostore</span>
<span class="cm"> *</span>
<span class="cm"> * @crc:			crc32 of header, excluding data_crc</span>
<span class="cm"> * @len:			length of data</span>
<span class="cm"> * @type:			object type, see above</span>
<span class="cm"> * @compr:			compression type</span>
<span class="cm"> * @ino:			inode number</span>
<span class="cm"> * @bix:			block index</span>
<span class="cm"> * @data_crc:			crc32 of payload</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">logfs_object_header</span> <span class="p">{</span>
	<span class="n">__be32</span>	<span class="n">crc</span><span class="p">;</span>
	<span class="n">__be16</span>	<span class="n">len</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">type</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">compr</span><span class="p">;</span>
	<span class="n">__be64</span>	<span class="n">ino</span><span class="p">;</span>
	<span class="n">__be64</span>	<span class="n">bix</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">data_crc</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="n">SIZE_CHECK</span><span class="p">(</span><span class="n">logfs_object_header</span><span class="p">,</span> <span class="n">LOGFS_OBJECT_HEADERSIZE</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Reserved inode numbers:</span>
<span class="cm"> * LOGFS_INO_MASTER	- master inode (for inode file)</span>
<span class="cm"> * LOGFS_INO_ROOT	- root directory</span>
<span class="cm"> * LOGFS_INO_SEGFILE	- per-segment used bytes and erase count</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">LOGFS_INO_MAPPING</span>	<span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
	<span class="n">LOGFS_INO_MASTER</span>	<span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
	<span class="n">LOGFS_INO_ROOT</span>		<span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="n">LOGFS_INO_SEGFILE</span>	<span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
	<span class="n">LOGFS_RESERVED_INOS</span>	<span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Inode flags.  High bits should never be written to the medium.  They are</span>
<span class="cm"> * reserved for in-memory usage.</span>
<span class="cm"> * Low bits should either remain in sync with the corresponding FS_*_FL or</span>
<span class="cm"> * reuse slots that obviously don&#39;t make sense for logfs.</span>
<span class="cm"> *</span>
<span class="cm"> * LOGFS_IF_DIRTY	Inode must be written back</span>
<span class="cm"> * LOGFS_IF_ZOMBIE	Inode has been deleted</span>
<span class="cm"> * LOGFS_IF_STILLBORN	-ENOSPC happened when creating inode</span>
<span class="cm"> */</span>
<span class="cp">#define LOGFS_IF_COMPRESSED	0x00000004 </span><span class="cm">/* == FS_COMPR_FL */</span><span class="cp"></span>
<span class="cp">#define LOGFS_IF_DIRTY		0x20000000</span>
<span class="cp">#define LOGFS_IF_ZOMBIE		0x40000000</span>
<span class="cp">#define LOGFS_IF_STILLBORN	0x80000000</span>

<span class="cm">/* Flags available to chattr */</span>
<span class="cp">#define LOGFS_FL_USER_VISIBLE	(LOGFS_IF_COMPRESSED)</span>
<span class="cp">#define LOGFS_FL_USER_MODIFIABLE (LOGFS_IF_COMPRESSED)</span>
<span class="cm">/* Flags inherited from parent directory on file/directory creation */</span>
<span class="cp">#define LOGFS_FL_INHERITED	(LOGFS_IF_COMPRESSED)</span>

<span class="cm">/**</span>
<span class="cm"> * struct logfs_disk_inode - on-medium inode</span>
<span class="cm"> *</span>
<span class="cm"> * @di_mode:			file mode</span>
<span class="cm"> * @di_pad:			reserved, must be 0</span>
<span class="cm"> * @di_flags:			inode flags, see above</span>
<span class="cm"> * @di_uid:			user id</span>
<span class="cm"> * @di_gid:			group id</span>
<span class="cm"> * @di_ctime:			change time</span>
<span class="cm"> * @di_mtime:			modify time</span>
<span class="cm"> * @di_refcount:		reference count (aka nlink or link count)</span>
<span class="cm"> * @di_generation:		inode generation, for nfs</span>
<span class="cm"> * @di_used_bytes:		number of bytes used</span>
<span class="cm"> * @di_size:			file size</span>
<span class="cm"> * @di_data:			data pointers</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">logfs_disk_inode</span> <span class="p">{</span>
	<span class="n">__be16</span>	<span class="n">di_mode</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">di_height</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">di_pad</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">di_flags</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">di_uid</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">di_gid</span><span class="p">;</span>

	<span class="n">__be64</span>	<span class="n">di_ctime</span><span class="p">;</span>
	<span class="n">__be64</span>	<span class="n">di_mtime</span><span class="p">;</span>

	<span class="n">__be64</span>	<span class="n">di_atime</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">di_refcount</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">di_generation</span><span class="p">;</span>

	<span class="n">__be64</span>	<span class="n">di_used_bytes</span><span class="p">;</span>
	<span class="n">__be64</span>	<span class="n">di_size</span><span class="p">;</span>

	<span class="n">__be64</span>	<span class="n">di_data</span><span class="p">[</span><span class="n">LOGFS_EMBEDDED_FIELDS</span><span class="p">];</span>
<span class="p">};</span>

<span class="n">SIZE_CHECK</span><span class="p">(</span><span class="n">logfs_disk_inode</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>

<span class="cp">#define INODE_POINTER_OFS \</span>
<span class="cp">	(offsetof(struct logfs_disk_inode, di_data) / sizeof(__be64))</span>
<span class="cp">#define INODE_USED_OFS \</span>
<span class="cp">	(offsetof(struct logfs_disk_inode, di_used_bytes) / sizeof(__be64))</span>
<span class="cp">#define INODE_SIZE_OFS \</span>
<span class="cp">	(offsetof(struct logfs_disk_inode, di_size) / sizeof(__be64))</span>
<span class="cp">#define INODE_HEIGHT_OFS	(0)</span>

<span class="cm">/**</span>
<span class="cm"> * struct logfs_disk_dentry - on-medium dentry structure</span>
<span class="cm"> *</span>
<span class="cm"> * @ino:			inode number</span>
<span class="cm"> * @namelen:			length of file name</span>
<span class="cm"> * @type:			file type, identical to bits 12..15 of mode</span>
<span class="cm"> * @name:			file name</span>
<span class="cm"> */</span>
<span class="cm">/* FIXME: add 6 bytes of padding to remove the __packed */</span>
<span class="k">struct</span> <span class="n">logfs_disk_dentry</span> <span class="p">{</span>
	<span class="n">__be64</span>	<span class="n">ino</span><span class="p">;</span>
	<span class="n">__be16</span>	<span class="n">namelen</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">type</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">name</span><span class="p">[</span><span class="n">LOGFS_MAX_NAMELEN</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="n">SIZE_CHECK</span><span class="p">(</span><span class="n">logfs_disk_dentry</span><span class="p">,</span> <span class="mi">266</span><span class="p">);</span>

<span class="cp">#define RESERVED		0xffffffff</span>
<span class="cp">#define BADSEG			0xffffffff</span>
<span class="cm">/**</span>
<span class="cm"> * struct logfs_segment_entry - segment file entry</span>
<span class="cm"> *</span>
<span class="cm"> * @ec_level:			erase count and level</span>
<span class="cm"> * @valid:			number of valid bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Segment file contains one entry for every segment.  ec_level contains the</span>
<span class="cm"> * erasecount in the upper 28 bits and the level in the lower 4 bits.  An</span>
<span class="cm"> * ec_level of BADSEG (-1) identifies bad segments.  valid contains the number</span>
<span class="cm"> * of valid bytes or RESERVED (-1 again) if the segment is used for either the</span>
<span class="cm"> * superblock or the journal, or when the segment is bad.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">logfs_segment_entry</span> <span class="p">{</span>
	<span class="n">__be32</span>	<span class="n">ec_level</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">valid</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">SIZE_CHECK</span><span class="p">(</span><span class="n">logfs_segment_entry</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct logfs_journal_header - header for journal entries (JEs)</span>
<span class="cm"> *</span>
<span class="cm"> * @h_crc:			crc32 of journal entry</span>
<span class="cm"> * @h_len:			length of compressed journal entry,</span>
<span class="cm"> *				not including header</span>
<span class="cm"> * @h_datalen:			length of uncompressed data</span>
<span class="cm"> * @h_type:			JE type</span>
<span class="cm"> * @h_compr:			compression type</span>
<span class="cm"> * @h_pad:			reserved</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">logfs_journal_header</span> <span class="p">{</span>
	<span class="n">__be32</span>	<span class="n">h_crc</span><span class="p">;</span>
	<span class="n">__be16</span>	<span class="n">h_len</span><span class="p">;</span>
	<span class="n">__be16</span>	<span class="n">h_datalen</span><span class="p">;</span>
	<span class="n">__be16</span>	<span class="n">h_type</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">h_compr</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">h_pad</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="p">};</span>

<span class="n">SIZE_CHECK</span><span class="p">(</span><span class="n">logfs_journal_header</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Life expectency of data.</span>
<span class="cm"> * VIM_DEFAULT		- default vim</span>
<span class="cm"> * VIM_SEGFILE		- for segment file only - very short-living</span>
<span class="cm"> * VIM_GC		- GC&#39;d data - likely long-living</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">logfs_vim</span> <span class="p">{</span>
	<span class="n">VIM_DEFAULT</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">VIM_SEGFILE</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct logfs_je_area - wbuf header</span>
<span class="cm"> *</span>
<span class="cm"> * @segno:			segment number of area</span>
<span class="cm"> * @used_bytes:			number of bytes already used</span>
<span class="cm"> * @gc_level:			GC level</span>
<span class="cm"> * @vim:			life expectancy of data</span>
<span class="cm"> *</span>
<span class="cm"> * &quot;Areas&quot; are segments currently being used for writing.  There is at least</span>
<span class="cm"> * one area per GC level.  Several may be used to separate long-living from</span>
<span class="cm"> * short-living data.  If an area with unknown vim is encountered, it can</span>
<span class="cm"> * simply be closed.</span>
<span class="cm"> * The write buffer immediately follow this header.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">logfs_je_area</span> <span class="p">{</span>
	<span class="n">__be32</span>	<span class="n">segno</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">used_bytes</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">gc_level</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">vim</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="n">SIZE_CHECK</span><span class="p">(</span><span class="n">logfs_je_area</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

<span class="cp">#define MAX_JOURNAL_HEADER \</span>
<span class="cp">	(sizeof(struct logfs_journal_header) + sizeof(struct logfs_je_area))</span>

<span class="cm">/**</span>
<span class="cm"> * struct logfs_je_dynsb - dynamic superblock</span>
<span class="cm"> *</span>
<span class="cm"> * @ds_gec:			global erase count</span>
<span class="cm"> * @ds_sweeper:			current position of GC &quot;sweeper&quot;</span>
<span class="cm"> * @ds_rename_dir:		source directory ino (see dir.c documentation)</span>
<span class="cm"> * @ds_rename_pos:		position of source dd (see dir.c documentation)</span>
<span class="cm"> * @ds_victim_ino:		victims of incomplete dir operation (see dir.c)</span>
<span class="cm"> * @ds_victim_ino:		parent inode of victim (see dir.c)</span>
<span class="cm"> * @ds_used_bytes:		number of used bytes</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">logfs_je_dynsb</span> <span class="p">{</span>
	<span class="n">__be64</span>	<span class="n">ds_gec</span><span class="p">;</span>
	<span class="n">__be64</span>	<span class="n">ds_sweeper</span><span class="p">;</span>

	<span class="n">__be64</span>	<span class="n">ds_rename_dir</span><span class="p">;</span>
	<span class="n">__be64</span>	<span class="n">ds_rename_pos</span><span class="p">;</span>

	<span class="n">__be64</span>	<span class="n">ds_victim_ino</span><span class="p">;</span>
	<span class="n">__be64</span>	<span class="n">ds_victim_parent</span><span class="p">;</span> <span class="cm">/* XXX */</span>

	<span class="n">__be64</span>	<span class="n">ds_used_bytes</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">ds_generation</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">pad</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">SIZE_CHECK</span><span class="p">(</span><span class="n">logfs_je_dynsb</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct logfs_je_anchor - anchor of filesystem tree, aka master inode</span>
<span class="cm"> *</span>
<span class="cm"> * @da_size:			size of inode file</span>
<span class="cm"> * @da_last_ino:		last created inode</span>
<span class="cm"> * @da_used_bytes:		number of bytes used</span>
<span class="cm"> * @da_data:			data pointers</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">logfs_je_anchor</span> <span class="p">{</span>
	<span class="n">__be64</span>	<span class="n">da_size</span><span class="p">;</span>
	<span class="n">__be64</span>	<span class="n">da_last_ino</span><span class="p">;</span>

	<span class="n">__be64</span>	<span class="n">da_used_bytes</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">da_height</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">pad</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>

	<span class="n">__be64</span>	<span class="n">da_data</span><span class="p">[</span><span class="n">LOGFS_EMBEDDED_FIELDS</span><span class="p">];</span>
<span class="p">};</span>

<span class="n">SIZE_CHECK</span><span class="p">(</span><span class="n">logfs_je_anchor</span><span class="p">,</span> <span class="mi">168</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct logfs_je_spillout - spillout entry (from 1st to 2nd journal)</span>
<span class="cm"> *</span>
<span class="cm"> * @so_segment:			segments used for 2nd journal</span>
<span class="cm"> *</span>
<span class="cm"> * Length of the array is given by h_len field in the header.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">logfs_je_spillout</span> <span class="p">{</span>
	<span class="n">__be64</span>	<span class="n">so_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="n">SIZE_CHECK</span><span class="p">(</span><span class="n">logfs_je_spillout</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct logfs_je_journal_ec - erase counts for all journal segments</span>
<span class="cm"> *</span>
<span class="cm"> * @ec:				erase count</span>
<span class="cm"> *</span>
<span class="cm"> * Length of the array is given by h_len field in the header.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">logfs_je_journal_ec</span> <span class="p">{</span>
	<span class="n">__be32</span>	<span class="n">ec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="n">SIZE_CHECK</span><span class="p">(</span><span class="n">logfs_je_journal_ec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct logfs_je_free_segments - list of free segmetns with erase count</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">logfs_je_free_segments</span> <span class="p">{</span>
	<span class="n">__be32</span>	<span class="n">segno</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">ec</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">SIZE_CHECK</span><span class="p">(</span><span class="n">logfs_je_free_segments</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct logfs_seg_alias - list of segment aliases</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">logfs_seg_alias</span> <span class="p">{</span>
	<span class="n">__be32</span>	<span class="n">old_segno</span><span class="p">;</span>
	<span class="n">__be32</span>	<span class="n">new_segno</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">SIZE_CHECK</span><span class="p">(</span><span class="n">logfs_seg_alias</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * struct logfs_obj_alias - list of object aliases</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">logfs_obj_alias</span> <span class="p">{</span>
	<span class="n">__be64</span>	<span class="n">ino</span><span class="p">;</span>
	<span class="n">__be64</span>	<span class="n">bix</span><span class="p">;</span>
	<span class="n">__be64</span>	<span class="n">val</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">level</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">pad</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">__be16</span>	<span class="n">child_no</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">SIZE_CHECK</span><span class="p">(</span><span class="n">logfs_obj_alias</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Compression types.</span>
<span class="cm"> *</span>
<span class="cm"> * COMPR_NONE	- uncompressed</span>
<span class="cm"> * COMPR_ZLIB	- compressed with zlib</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">COMPR_NONE</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">COMPR_ZLIB</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Journal entries come in groups of 16.  First group contains unique</span>
<span class="cm"> * entries, next groups contain one entry per level</span>
<span class="cm"> *</span>
<span class="cm"> * JE_FIRST	- smallest possible journal entry number</span>
<span class="cm"> *</span>
<span class="cm"> * JEG_BASE	- base group, containing unique entries</span>
<span class="cm"> * JE_COMMIT	- commit entry, validates all previous entries</span>
<span class="cm"> * JE_DYNSB	- dynamic superblock, anything that ought to be in the</span>
<span class="cm"> *		  superblock but cannot because it is read-write data</span>
<span class="cm"> * JE_ANCHOR	- anchor aka master inode aka inode file&#39;s inode</span>
<span class="cm"> * JE_ERASECOUNT  erasecounts for all journal segments</span>
<span class="cm"> * JE_SPILLOUT	- unused</span>
<span class="cm"> * JE_SEG_ALIAS	- aliases segments</span>
<span class="cm"> * JE_AREA	- area description</span>
<span class="cm"> *</span>
<span class="cm"> * JE_LAST	- largest possible journal entry number</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">JE_FIRST</span>	<span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>

	<span class="n">JEG_BASE</span>	<span class="o">=</span> <span class="mh">0x00</span><span class="p">,</span>
	<span class="n">JE_COMMIT</span>	<span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>
	<span class="n">JE_DYNSB</span>	<span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
	<span class="n">JE_ANCHOR</span>	<span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>
	<span class="n">JE_ERASECOUNT</span>	<span class="o">=</span> <span class="mh">0x05</span><span class="p">,</span>
	<span class="n">JE_SPILLOUT</span>	<span class="o">=</span> <span class="mh">0x06</span><span class="p">,</span>
	<span class="n">JE_OBJ_ALIAS</span>	<span class="o">=</span> <span class="mh">0x0d</span><span class="p">,</span>
	<span class="n">JE_AREA</span>		<span class="o">=</span> <span class="mh">0x0e</span><span class="p">,</span>

	<span class="n">JE_LAST</span>		<span class="o">=</span> <span class="mh">0x0e</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
