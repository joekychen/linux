<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › hpfs › hpfs.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>hpfs.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/fs/hpfs/hpfs.h</span>
<span class="cm"> *</span>
<span class="cm"> *  HPFS structures by Chris Smith, 1993</span>
<span class="cm"> *</span>
<span class="cm"> *  a little bit modified by Mikulas Patocka, 1998-1999</span>
<span class="cm"> */</span>

<span class="cm">/* The paper</span>

<span class="cm">     Duncan, Roy</span>
<span class="cm">     Design goals and implementation of the new High Performance File System</span>
<span class="cm">     Microsoft Systems Journal  Sept 1989  v4 n5 p1(13)</span>

<span class="cm">   describes what HPFS looked like when it was new, and it is the source</span>
<span class="cm">   of most of the information given here.  The rest is conjecture.</span>

<span class="cm">   For definitive information on the Duncan paper, see it, not this file.</span>
<span class="cm">   For definitive information on HPFS, ask somebody else -- this is guesswork.</span>
<span class="cm">   There are certain to be many mistakes. */</span>

<span class="cp">#if !defined(__LITTLE_ENDIAN) &amp;&amp; !defined(__BIG_ENDIAN)</span>
<span class="cp">#error unknown endian</span>
<span class="cp">#endif</span>

<span class="cm">/* Notation */</span>

<span class="k">typedef</span> <span class="n">u32</span> <span class="n">secno</span><span class="p">;</span>			<span class="cm">/* sector number, partition relative */</span>

<span class="k">typedef</span> <span class="n">secno</span> <span class="n">dnode_secno</span><span class="p">;</span>		<span class="cm">/* sector number of a dnode */</span>
<span class="k">typedef</span> <span class="n">secno</span> <span class="n">fnode_secno</span><span class="p">;</span>		<span class="cm">/* sector number of an fnode */</span>
<span class="k">typedef</span> <span class="n">secno</span> <span class="n">anode_secno</span><span class="p">;</span>		<span class="cm">/* sector number of an anode */</span>

<span class="k">typedef</span> <span class="n">u32</span> <span class="n">time32_t</span><span class="p">;</span>		<span class="cm">/* 32-bit time_t type */</span>

<span class="cm">/* sector 0 */</span>

<span class="cm">/* The boot block is very like a FAT boot block, except that the</span>
<span class="cm">   29h signature byte is 28h instead, and the ID string is &quot;HPFS&quot;. */</span>

<span class="cp">#define BB_MAGIC 0xaa55</span>

<span class="k">struct</span> <span class="n">hpfs_boot_block</span>
<span class="p">{</span>
  <span class="n">u8</span> <span class="n">jmp</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="n">u8</span> <span class="n">oem_id</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
  <span class="n">u8</span> <span class="n">bytes_per_sector</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* 512 */</span>
  <span class="n">u8</span> <span class="n">sectors_per_cluster</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">n_reserved_sectors</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="n">u8</span> <span class="n">n_fats</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">n_rootdir_entries</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="n">u8</span> <span class="n">n_sectors_s</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="n">u8</span> <span class="n">media_byte</span><span class="p">;</span>
  <span class="n">__le16</span> <span class="n">sectors_per_fat</span><span class="p">;</span>
  <span class="n">__le16</span> <span class="n">sectors_per_track</span><span class="p">;</span>
  <span class="n">__le16</span> <span class="n">heads_per_cyl</span><span class="p">;</span>
  <span class="n">__le32</span> <span class="n">n_hidden_sectors</span><span class="p">;</span>
  <span class="n">__le32</span> <span class="n">n_sectors_l</span><span class="p">;</span>		<span class="cm">/* size of partition */</span>
  <span class="n">u8</span> <span class="n">drive_number</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">mbz</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">sig_28h</span><span class="p">;</span>			<span class="cm">/* 28h */</span>
  <span class="n">u8</span> <span class="n">vol_serno</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
  <span class="n">u8</span> <span class="n">vol_label</span><span class="p">[</span><span class="mi">11</span><span class="p">];</span>
  <span class="n">u8</span> <span class="n">sig_hpfs</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>		<span class="cm">/* &quot;HPFS    &quot; */</span>
  <span class="n">u8</span> <span class="n">pad</span><span class="p">[</span><span class="mi">448</span><span class="p">];</span>
  <span class="n">__le16</span> <span class="n">magic</span><span class="p">;</span>			<span class="cm">/* aa55 */</span>
<span class="p">};</span>


<span class="cm">/* sector 16 */</span>

<span class="cm">/* The super block has the pointer to the root directory. */</span>

<span class="cp">#define SB_MAGIC 0xf995e849</span>

<span class="k">struct</span> <span class="n">hpfs_super_block</span>
<span class="p">{</span>
  <span class="n">__le32</span> <span class="n">magic</span><span class="p">;</span>				<span class="cm">/* f995 e849 */</span>
  <span class="n">__le32</span> <span class="n">magic1</span><span class="p">;</span>			<span class="cm">/* fa53 e9c5, more magic? */</span>
  <span class="n">u8</span> <span class="n">version</span><span class="p">;</span>				<span class="cm">/* version of a filesystem  usually 2 */</span>
  <span class="n">u8</span> <span class="n">funcversion</span><span class="p">;</span>			<span class="cm">/* functional version - oldest version</span>
<span class="cm">  					   of filesystem that can understand</span>
<span class="cm">					   this disk */</span>
  <span class="n">__le16</span> <span class="n">zero</span><span class="p">;</span>				<span class="cm">/* 0 */</span>
  <span class="n">__le32</span> <span class="n">root</span><span class="p">;</span>				<span class="cm">/* fnode of root directory */</span>
  <span class="n">__le32</span> <span class="n">n_sectors</span><span class="p">;</span>			<span class="cm">/* size of filesystem */</span>
  <span class="n">__le32</span> <span class="n">n_badblocks</span><span class="p">;</span>			<span class="cm">/* number of bad blocks */</span>
  <span class="n">__le32</span> <span class="n">bitmaps</span><span class="p">;</span>			<span class="cm">/* pointers to free space bit maps */</span>
  <span class="n">__le32</span> <span class="n">zero1</span><span class="p">;</span>				<span class="cm">/* 0 */</span>
  <span class="n">__le32</span> <span class="n">badblocks</span><span class="p">;</span>			<span class="cm">/* bad block list */</span>
  <span class="n">__le32</span> <span class="n">zero3</span><span class="p">;</span>				<span class="cm">/* 0 */</span>
  <span class="n">__le32</span> <span class="n">last_chkdsk</span><span class="p">;</span>			<span class="cm">/* date last checked, 0 if never */</span>
  <span class="n">__le32</span> <span class="n">last_optimize</span><span class="p">;</span>			<span class="cm">/* date last optimized, 0 if never */</span>
  <span class="n">__le32</span> <span class="n">n_dir_band</span><span class="p">;</span>			<span class="cm">/* number of sectors in dir band */</span>
  <span class="n">__le32</span> <span class="n">dir_band_start</span><span class="p">;</span>			<span class="cm">/* first sector in dir band */</span>
  <span class="n">__le32</span> <span class="n">dir_band_end</span><span class="p">;</span>			<span class="cm">/* last sector in dir band */</span>
  <span class="n">__le32</span> <span class="n">dir_band_bitmap</span><span class="p">;</span>		<span class="cm">/* free space map, 1 dnode per bit */</span>
  <span class="n">u8</span> <span class="n">volume_name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>			<span class="cm">/* not used */</span>
  <span class="n">__le32</span> <span class="n">user_id_table</span><span class="p">;</span>			<span class="cm">/* 8 preallocated sectors - user id */</span>
  <span class="n">u32</span> <span class="n">zero6</span><span class="p">[</span><span class="mi">103</span><span class="p">];</span>			<span class="cm">/* 0 */</span>
<span class="p">};</span>


<span class="cm">/* sector 17 */</span>

<span class="cm">/* The spare block has pointers to spare sectors.  */</span>

<span class="cp">#define SP_MAGIC 0xf9911849</span>

<span class="k">struct</span> <span class="n">hpfs_spare_block</span>
<span class="p">{</span>
  <span class="n">__le32</span> <span class="n">magic</span><span class="p">;</span>				<span class="cm">/* f991 1849 */</span>
  <span class="n">__le32</span> <span class="n">magic1</span><span class="p">;</span>				<span class="cm">/* fa52 29c5, more magic? */</span>

<span class="cp">#ifdef __LITTLE_ENDIAN</span>
  <span class="n">u8</span> <span class="n">dirty</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>				<span class="cm">/* 0 clean, 1 &quot;improperly stopped&quot; */</span>
  <span class="n">u8</span> <span class="n">sparedir_used</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* spare dirblks used */</span>
  <span class="n">u8</span> <span class="n">hotfixes_used</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* hotfixes used */</span>
  <span class="n">u8</span> <span class="n">bad_sector</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* bad sector, corrupted disk (???) */</span>
  <span class="n">u8</span> <span class="n">bad_bitmap</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* bad bitmap */</span>
  <span class="n">u8</span> <span class="n">fast</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>				<span class="cm">/* partition was fast formatted */</span>
  <span class="n">u8</span> <span class="n">old_wrote</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* old version wrote to partion */</span>
  <span class="n">u8</span> <span class="n">old_wrote_1</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* old version wrote to partion (?) */</span>
<span class="cp">#else</span>
  <span class="n">u8</span> <span class="n">old_wrote_1</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* old version wrote to partion (?) */</span>
  <span class="n">u8</span> <span class="n">old_wrote</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* old version wrote to partion */</span>
  <span class="n">u8</span> <span class="n">fast</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>				<span class="cm">/* partition was fast formatted */</span>
  <span class="n">u8</span> <span class="n">bad_bitmap</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* bad bitmap */</span>
  <span class="n">u8</span> <span class="n">bad_sector</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* bad sector, corrupted disk (???) */</span>
  <span class="n">u8</span> <span class="n">hotfixes_used</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* hotfixes used */</span>
  <span class="n">u8</span> <span class="n">sparedir_used</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* spare dirblks used */</span>
  <span class="n">u8</span> <span class="n">dirty</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>				<span class="cm">/* 0 clean, 1 &quot;improperly stopped&quot; */</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef __LITTLE_ENDIAN</span>
  <span class="n">u8</span> <span class="n">install_dasd_limits</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* HPFS386 flags */</span>
  <span class="n">u8</span> <span class="n">resynch_dasd_limits</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">dasd_limits_operational</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">multimedia_active</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">dce_acls_active</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">dasd_limits_dirty</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">flag67</span><span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
<span class="cp">#else</span>
  <span class="n">u8</span> <span class="n">flag67</span><span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">dasd_limits_dirty</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">dce_acls_active</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">multimedia_active</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">dasd_limits_operational</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">resynch_dasd_limits</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">install_dasd_limits</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* HPFS386 flags */</span>
<span class="cp">#endif</span>

  <span class="n">u8</span> <span class="n">mm_contlgulty</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">unused</span><span class="p">;</span>

  <span class="n">__le32</span> <span class="n">hotfix_map</span><span class="p">;</span>			<span class="cm">/* info about remapped bad sectors */</span>
  <span class="n">__le32</span> <span class="n">n_spares_used</span><span class="p">;</span>			<span class="cm">/* number of hotfixes */</span>
  <span class="n">__le32</span> <span class="n">n_spares</span><span class="p">;</span>			<span class="cm">/* number of spares in hotfix map */</span>
  <span class="n">__le32</span> <span class="n">n_dnode_spares_free</span><span class="p">;</span>		<span class="cm">/* spare dnodes unused */</span>
  <span class="n">__le32</span> <span class="n">n_dnode_spares</span><span class="p">;</span>		<span class="cm">/* length of spare_dnodes[] list,</span>
<span class="cm">					   follows in this block*/</span>
  <span class="n">__le32</span> <span class="n">code_page_dir</span><span class="p">;</span>			<span class="cm">/* code page directory block */</span>
  <span class="n">__le32</span> <span class="n">n_code_pages</span><span class="p">;</span>			<span class="cm">/* number of code pages */</span>
  <span class="n">__le32</span> <span class="n">super_crc</span><span class="p">;</span>			<span class="cm">/* on HPFS386 and LAN Server this is</span>
<span class="cm">  					   checksum of superblock, on normal</span>
<span class="cm">					   OS/2 unused */</span>
  <span class="n">__le32</span> <span class="n">spare_crc</span><span class="p">;</span>			<span class="cm">/* on HPFS386 checksum of spareblock */</span>
  <span class="n">__le32</span> <span class="n">zero1</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>			<span class="cm">/* unused */</span>
  <span class="n">__le32</span> <span class="n">spare_dnodes</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>		<span class="cm">/* emergency free dnode list */</span>
  <span class="n">__le32</span> <span class="n">zero2</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>			<span class="cm">/* room for more? */</span>
<span class="p">};</span>

<span class="cm">/* The bad block list is 4 sectors long.  The first word must be zero,</span>
<span class="cm">   the remaining words give n_badblocks bad block numbers.</span>
<span class="cm">   I bet you can see it coming... */</span>

<span class="cp">#define BAD_MAGIC 0</span>
       
<span class="cm">/* The hotfix map is 4 sectors long.  It looks like</span>

<span class="cm">       secno from[n_spares];</span>
<span class="cm">       secno to[n_spares];</span>

<span class="cm">   The to[] list is initialized to point to n_spares preallocated empty</span>
<span class="cm">   sectors.  The from[] list contains the sector numbers of bad blocks</span>
<span class="cm">   which have been remapped to corresponding sectors in the to[] list.</span>
<span class="cm">   n_spares_used gives the length of the from[] list. */</span>


<span class="cm">/* Sectors 18 and 19 are preallocated and unused.</span>
<span class="cm">   Maybe they&#39;re spares for 16 and 17, but simple substitution fails. */</span>


<span class="cm">/* The code page info pointed to by the spare block consists of an index</span>
<span class="cm">   block and blocks containing uppercasing tables.  I don&#39;t know what</span>
<span class="cm">   these are for (CHKDSK, maybe?) -- OS/2 does not seem to use them</span>
<span class="cm">   itself.  Linux doesn&#39;t use them either. */</span>

<span class="cm">/* block pointed to by spareblock-&gt;code_page_dir */</span>

<span class="cp">#define CP_DIR_MAGIC 0x494521f7</span>

<span class="k">struct</span> <span class="n">code_page_directory</span>
<span class="p">{</span>
  <span class="n">__le32</span> <span class="n">magic</span><span class="p">;</span>				<span class="cm">/* 4945 21f7 */</span>
  <span class="n">__le32</span> <span class="n">n_code_pages</span><span class="p">;</span>			<span class="cm">/* number of pointers following */</span>
  <span class="n">__le32</span> <span class="n">zero1</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="k">struct</span> <span class="p">{</span>
    <span class="n">__le16</span> <span class="n">ix</span><span class="p">;</span>				<span class="cm">/* index */</span>
    <span class="n">__le16</span> <span class="n">code_page_number</span><span class="p">;</span>		<span class="cm">/* code page number */</span>
    <span class="n">__le32</span> <span class="n">bounds</span><span class="p">;</span>			<span class="cm">/* matches corresponding word</span>
<span class="cm">					   in data block */</span>
    <span class="n">__le32</span> <span class="n">code_page_data</span><span class="p">;</span>		<span class="cm">/* sector number of a code_page_data</span>
<span class="cm">					   containing c.p. array */</span>
    <span class="n">__le16</span> <span class="n">index</span><span class="p">;</span>			<span class="cm">/* index in c.p. array in that sector*/</span>
    <span class="n">__le16</span> <span class="n">unknown</span><span class="p">;</span>			<span class="cm">/* some unknown value; usually 0;</span>
<span class="cm">    					   2 in Japanese version */</span>
  <span class="p">}</span> <span class="n">array</span><span class="p">[</span><span class="mi">31</span><span class="p">];</span>				<span class="cm">/* unknown length */</span>
<span class="p">};</span>

<span class="cm">/* blocks pointed to by code_page_directory */</span>

<span class="cp">#define CP_DATA_MAGIC 0x894521f7</span>

<span class="k">struct</span> <span class="n">code_page_data</span>
<span class="p">{</span>
  <span class="n">__le32</span> <span class="n">magic</span><span class="p">;</span>				<span class="cm">/* 8945 21f7 */</span>
  <span class="n">__le32</span> <span class="n">n_used</span><span class="p">;</span>			<span class="cm">/* # elements used in c_p_data[] */</span>
  <span class="n">__le32</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>			<span class="cm">/* looks a bit like</span>
<span class="cm">					     (beg1,end1), (beg2,end2)</span>
<span class="cm">					   one byte each */</span>
  <span class="n">__le16</span> <span class="n">offs</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>			<span class="cm">/* offsets from start of sector</span>
<span class="cm">					   to start of c_p_data[ix] */</span>
  <span class="k">struct</span> <span class="p">{</span>
    <span class="n">__le16</span> <span class="n">ix</span><span class="p">;</span>				<span class="cm">/* index */</span>
    <span class="n">__le16</span> <span class="n">code_page_number</span><span class="p">;</span>		<span class="cm">/* code page number */</span>
    <span class="n">__le16</span> <span class="n">unknown</span><span class="p">;</span>			<span class="cm">/* the same as in cp directory */</span>
    <span class="n">u8</span> <span class="n">map</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>			<span class="cm">/* upcase table for chars 80..ff */</span>
    <span class="n">__le16</span> <span class="n">zero2</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">code_page</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="n">u8</span> <span class="n">incognita</span><span class="p">[</span><span class="mi">78</span><span class="p">];</span>
<span class="p">};</span>


<span class="cm">/* Free space bitmaps are 4 sectors long, which is 16384 bits.</span>
<span class="cm">   16384 sectors is 8 meg, and each 8 meg band has a 4-sector bitmap.</span>
<span class="cm">   Bit order in the maps is little-endian.  0 means taken, 1 means free.</span>

<span class="cm">   Bit map sectors are marked allocated in the bit maps, and so are sectors </span>
<span class="cm">   off the end of the partition.</span>

<span class="cm">   Band 0 is sectors 0-3fff, its map is in sectors 18-1b.</span>
<span class="cm">   Band 1 is 4000-7fff, its map is in 7ffc-7fff.</span>
<span class="cm">   Band 2 is 8000-ffff, its map is in 8000-8003.</span>
<span class="cm">   The remaining bands have maps in their first (even) or last (odd) 4 sectors</span>
<span class="cm">     -- if the last, partial, band is odd its map is in its last 4 sectors.</span>

<span class="cm">   The bitmap locations are given in a table pointed to by the super block.</span>
<span class="cm">   No doubt they aren&#39;t constrained to be at 18, 7ffc, 8000, ...; that is</span>
<span class="cm">   just where they usually are.</span>

<span class="cm">   The &quot;directory band&quot; is a bunch of sectors preallocated for dnodes.</span>
<span class="cm">   It has a 4-sector free space bitmap of its own.  Each bit in the map</span>
<span class="cm">   corresponds to one 4-sector dnode, bit 0 of the map corresponding to</span>
<span class="cm">   the first 4 sectors of the directory band.  The entire band is marked</span>
<span class="cm">   allocated in the main bitmap.   The super block gives the locations</span>
<span class="cm">   of the directory band and its bitmap.  (&quot;band&quot; doesn&#39;t mean it is</span>
<span class="cm">   8 meg long; it isn&#39;t.)  */</span>


<span class="cm">/* dnode: directory.  4 sectors long */</span>

<span class="cm">/* A directory is a tree of dnodes.  The fnode for a directory</span>
<span class="cm">   contains one pointer, to the root dnode of the tree.  The fnode</span>
<span class="cm">   never moves, the dnodes do the B-tree thing, splitting and merging</span>
<span class="cm">   as files are added and removed.  */</span>

<span class="cp">#define DNODE_MAGIC   0x77e40aae</span>

<span class="k">struct</span> <span class="n">dnode</span> <span class="p">{</span>
  <span class="n">__le32</span> <span class="n">magic</span><span class="p">;</span>				<span class="cm">/* 77e4 0aae */</span>
  <span class="n">__le32</span> <span class="n">first_free</span><span class="p">;</span>			<span class="cm">/* offset from start of dnode to</span>
<span class="cm">					   first free dir entry */</span>
<span class="cp">#ifdef __LITTLE_ENDIAN</span>
  <span class="n">u8</span> <span class="n">root_dnode</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* Is it root dnode? */</span>
  <span class="n">u8</span> <span class="n">increment_me</span><span class="o">:</span> <span class="mi">7</span><span class="p">;</span>			<span class="cm">/* some kind of activity counter? */</span>
					<span class="cm">/* Neither HPFS.IFS nor CHKDSK cares</span>
<span class="cm">					   if you change this word */</span>
<span class="cp">#else</span>
  <span class="n">u8</span> <span class="n">increment_me</span><span class="o">:</span> <span class="mi">7</span><span class="p">;</span>			<span class="cm">/* some kind of activity counter? */</span>
					<span class="cm">/* Neither HPFS.IFS nor CHKDSK cares</span>
<span class="cm">					   if you change this word */</span>
  <span class="n">u8</span> <span class="n">root_dnode</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* Is it root dnode? */</span>
<span class="cp">#endif</span>
  <span class="n">u8</span> <span class="n">increment_me2</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="n">__le32</span> <span class="n">up</span><span class="p">;</span>				<span class="cm">/* (root dnode) directory&#39;s fnode</span>
<span class="cm">					   (nonroot) parent dnode */</span>
  <span class="n">__le32</span> <span class="n">self</span><span class="p">;</span>			<span class="cm">/* pointer to this dnode */</span>
  <span class="n">u8</span> <span class="n">dirent</span><span class="p">[</span><span class="mi">2028</span><span class="p">];</span>			<span class="cm">/* one or more dirents */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hpfs_dirent</span> <span class="p">{</span>
  <span class="n">__le16</span> <span class="n">length</span><span class="p">;</span>			<span class="cm">/* offset to next dirent */</span>

<span class="cp">#ifdef __LITTLE_ENDIAN</span>
  <span class="n">u8</span> <span class="n">first</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>				<span class="cm">/* set on phony ^A^A (&quot;.&quot;) entry */</span>
  <span class="n">u8</span> <span class="n">has_acl</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">down</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>				<span class="cm">/* down pointer present (after name) */</span>
  <span class="n">u8</span> <span class="n">last</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>				<span class="cm">/* set on phony \377 entry */</span>
  <span class="n">u8</span> <span class="n">has_ea</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>				<span class="cm">/* entry has EA */</span>
  <span class="n">u8</span> <span class="n">has_xtd_perm</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* has extended perm list (???) */</span>
  <span class="n">u8</span> <span class="n">has_explicit_acl</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">has_needea</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* ?? some EA has NEEDEA set</span>
<span class="cm">					   I have no idea why this is</span>
<span class="cm">					   interesting in a dir entry */</span>
<span class="cp">#else</span>
  <span class="n">u8</span> <span class="n">has_needea</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* ?? some EA has NEEDEA set</span>
<span class="cm">					   I have no idea why this is</span>
<span class="cm">					   interesting in a dir entry */</span>
  <span class="n">u8</span> <span class="n">has_explicit_acl</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">has_xtd_perm</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* has extended perm list (???) */</span>
  <span class="n">u8</span> <span class="n">has_ea</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>				<span class="cm">/* entry has EA */</span>
  <span class="n">u8</span> <span class="n">last</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>				<span class="cm">/* set on phony \377 entry */</span>
  <span class="n">u8</span> <span class="n">down</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>				<span class="cm">/* down pointer present (after name) */</span>
  <span class="n">u8</span> <span class="n">has_acl</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">first</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>				<span class="cm">/* set on phony ^A^A (&quot;.&quot;) entry */</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef __LITTLE_ENDIAN</span>
  <span class="n">u8</span> <span class="n">read_only</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* dos attrib */</span>
  <span class="n">u8</span> <span class="n">hidden</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>				<span class="cm">/* dos attrib */</span>
  <span class="n">u8</span> <span class="n">system</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>				<span class="cm">/* dos attrib */</span>
  <span class="n">u8</span> <span class="n">flag11</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>				<span class="cm">/* would be volume label dos attrib */</span>
  <span class="n">u8</span> <span class="n">directory</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* dos attrib */</span>
  <span class="n">u8</span> <span class="n">archive</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* dos attrib */</span>
  <span class="n">u8</span> <span class="n">not_8x3</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* name is not 8.3 */</span>
  <span class="n">u8</span> <span class="n">flag15</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
  <span class="n">u8</span> <span class="n">flag15</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">not_8x3</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* name is not 8.3 */</span>
  <span class="n">u8</span> <span class="n">archive</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* dos attrib */</span>
  <span class="n">u8</span> <span class="n">directory</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* dos attrib */</span>
  <span class="n">u8</span> <span class="n">flag11</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>				<span class="cm">/* would be volume label dos attrib */</span>
  <span class="n">u8</span> <span class="n">system</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>				<span class="cm">/* dos attrib */</span>
  <span class="n">u8</span> <span class="n">hidden</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>				<span class="cm">/* dos attrib */</span>
  <span class="n">u8</span> <span class="n">read_only</span><span class="o">:</span> <span class="mi">1</span><span class="p">;</span>			<span class="cm">/* dos attrib */</span>
<span class="cp">#endif</span>

  <span class="n">__le32</span> <span class="n">fnode</span><span class="p">;</span>				<span class="cm">/* fnode giving allocation info */</span>
  <span class="n">__le32</span> <span class="n">write_date</span><span class="p">;</span>			<span class="cm">/* mtime */</span>
  <span class="n">__le32</span> <span class="n">file_size</span><span class="p">;</span>			<span class="cm">/* file length, bytes */</span>
  <span class="n">__le32</span> <span class="n">read_date</span><span class="p">;</span>			<span class="cm">/* atime */</span>
  <span class="n">__le32</span> <span class="n">creation_date</span><span class="p">;</span>			<span class="cm">/* ctime */</span>
  <span class="n">__le32</span> <span class="n">ea_size</span><span class="p">;</span>			<span class="cm">/* total EA length, bytes */</span>
  <span class="n">u8</span> <span class="n">no_of_acls</span><span class="p">;</span>			<span class="cm">/* number of ACL&#39;s (low 3 bits) */</span>
  <span class="n">u8</span> <span class="n">ix</span><span class="p">;</span>				<span class="cm">/* code page index (of filename), see</span>
<span class="cm">					   struct code_page_data */</span>
  <span class="n">u8</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>			<span class="cm">/* file name */</span>
  <span class="cm">/* dnode_secno down;	  btree down pointer, if present,</span>
<span class="cm">     			  follows name on next word boundary, or maybe it</span>
<span class="cm">			  precedes next dirent, which is on a word boundary. */</span>
<span class="p">};</span>


<span class="cm">/* B+ tree: allocation info in fnodes and anodes */</span>

<span class="cm">/* dnodes point to fnodes which are responsible for listing the sectors</span>
<span class="cm">   assigned to the file.  This is done with trees of (length,address)</span>
<span class="cm">   pairs.  (Actually triples, of (length, file-address, disk-address)</span>
<span class="cm">   which can represent holes.  Find out if HPFS does that.)</span>
<span class="cm">   At any rate, fnodes contain a small tree; if subtrees are needed</span>
<span class="cm">   they occupy essentially a full block in anodes.  A leaf-level tree node</span>
<span class="cm">   has 3-word entries giving sector runs, a non-leaf node has 2-word</span>
<span class="cm">   entries giving subtree pointers.  A flag in the header says which. */</span>

<span class="k">struct</span> <span class="n">bplus_leaf_node</span>
<span class="p">{</span>
  <span class="n">__le32</span> <span class="n">file_secno</span><span class="p">;</span>			<span class="cm">/* first file sector in extent */</span>
  <span class="n">__le32</span> <span class="n">length</span><span class="p">;</span>			<span class="cm">/* length, sectors */</span>
  <span class="n">__le32</span> <span class="n">disk_secno</span><span class="p">;</span>			<span class="cm">/* first corresponding disk sector */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bplus_internal_node</span>
<span class="p">{</span>
  <span class="n">__le32</span> <span class="n">file_secno</span><span class="p">;</span>			<span class="cm">/* subtree maps sectors &lt; this  */</span>
  <span class="n">__le32</span> <span class="n">down</span><span class="p">;</span>				<span class="cm">/* pointer to subtree */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">BP_hbff</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">BP_fnode_parent</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>
	<span class="n">BP_binary_search</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">,</span>
	<span class="n">BP_internal</span> <span class="o">=</span> <span class="mh">0x80</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">bplus_header</span>
<span class="p">{</span>
  <span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>				<span class="cm">/* bit 0 - high bit of first free entry offset</span>
<span class="cm">					   bit 5 - we&#39;re pointed to by an fnode,</span>
<span class="cm">					   the data btree or some ea or the</span>
<span class="cm">					   main ea bootage pointer ea_secno</span>
<span class="cm">					   bit 6 - suggest binary search (unused)</span>
<span class="cm">					   bit 7 - 1 -&gt; (internal) tree of anodes</span>
<span class="cm">						   0 -&gt; (leaf) list of extents */</span>
  <span class="n">u8</span> <span class="n">fill</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="n">u8</span> <span class="n">n_free_nodes</span><span class="p">;</span>			<span class="cm">/* free nodes in following array */</span>
  <span class="n">u8</span> <span class="n">n_used_nodes</span><span class="p">;</span>			<span class="cm">/* used nodes in following array */</span>
  <span class="n">__le16</span> <span class="n">first_free</span><span class="p">;</span>			<span class="cm">/* offset from start of header to</span>
<span class="cm">					   first free node in array */</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">bplus_internal_node</span> <span class="n">internal</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="cm">/* (internal) 2-word entries giving</span>
<span class="cm">					       subtree pointers */</span>
    <span class="k">struct</span> <span class="n">bplus_leaf_node</span> <span class="n">external</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	    <span class="cm">/* (external) 3-word entries giving</span>
<span class="cm">					       sector runs */</span>
  <span class="p">}</span> <span class="n">u</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">bp_internal</span><span class="p">(</span><span class="k">struct</span> <span class="n">bplus_header</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BP_internal</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">bp_fnode_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">bplus_header</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BP_fnode_parent</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* fnode: root of allocation b+ tree, and EA&#39;s */</span>

<span class="cm">/* Every file and every directory has one fnode, pointed to by the directory</span>
<span class="cm">   entry and pointing to the file&#39;s sectors or directory&#39;s root dnode.  EA&#39;s</span>
<span class="cm">   are also stored here, and there are said to be ACL&#39;s somewhere here too. */</span>

<span class="cp">#define FNODE_MAGIC 0xf7e40aae</span>

<span class="k">enum</span> <span class="p">{</span><span class="n">FNODE_anode</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">FNODE_dir</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mi">256</span><span class="p">)};</span>
<span class="k">struct</span> <span class="n">fnode</span>
<span class="p">{</span>
  <span class="n">__le32</span> <span class="n">magic</span><span class="p">;</span>				<span class="cm">/* f7e4 0aae */</span>
  <span class="n">__le32</span> <span class="n">zero1</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>			<span class="cm">/* read history */</span>
  <span class="n">u8</span> <span class="n">len</span><span class="p">,</span> <span class="n">name</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>			<span class="cm">/* true length, truncated name */</span>
  <span class="n">__le32</span> <span class="n">up</span><span class="p">;</span>				<span class="cm">/* pointer to file&#39;s directory fnode */</span>
  <span class="n">__le32</span> <span class="n">acl_size_l</span><span class="p">;</span>
  <span class="n">__le32</span> <span class="n">acl_secno</span><span class="p">;</span>
  <span class="n">__le16</span> <span class="n">acl_size_s</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">acl_anode</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">zero2</span><span class="p">;</span>				<span class="cm">/* history bit count */</span>
  <span class="n">__le32</span> <span class="n">ea_size_l</span><span class="p">;</span>			<span class="cm">/* length of disk-resident ea&#39;s */</span>
  <span class="n">__le32</span> <span class="n">ea_secno</span><span class="p">;</span>			<span class="cm">/* first sector of disk-resident ea&#39;s*/</span>
  <span class="n">__le16</span> <span class="n">ea_size_s</span><span class="p">;</span>			<span class="cm">/* length of fnode-resident ea&#39;s */</span>

  <span class="n">__le16</span> <span class="n">flags</span><span class="p">;</span>				<span class="cm">/* bit 1 set -&gt; ea_secno is an anode */</span>
					<span class="cm">/* bit 8 set -&gt; directory.  first &amp; only extent</span>
<span class="cm">					   points to dnode. */</span>
  <span class="k">struct</span> <span class="n">bplus_header</span> <span class="n">btree</span><span class="p">;</span>		<span class="cm">/* b+ tree, 8 extents or 12 subtrees */</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">bplus_leaf_node</span> <span class="n">external</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">bplus_internal_node</span> <span class="n">internal</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
  <span class="p">}</span> <span class="n">u</span><span class="p">;</span>

  <span class="n">__le32</span> <span class="n">file_size</span><span class="p">;</span>			<span class="cm">/* file length, bytes */</span>
  <span class="n">__le32</span> <span class="n">n_needea</span><span class="p">;</span>			<span class="cm">/* number of EA&#39;s with NEEDEA set */</span>
  <span class="n">u8</span> <span class="n">user_id</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>			<span class="cm">/* unused */</span>
  <span class="n">__le16</span> <span class="n">ea_offs</span><span class="p">;</span>			<span class="cm">/* offset from start of fnode</span>
<span class="cm">					   to first fnode-resident ea */</span>
  <span class="n">u8</span> <span class="n">dasd_limit_treshhold</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">dasd_limit_delta</span><span class="p">;</span>
  <span class="n">__le32</span> <span class="n">dasd_limit</span><span class="p">;</span>
  <span class="n">__le32</span> <span class="n">dasd_usage</span><span class="p">;</span>
  <span class="n">u8</span> <span class="n">ea</span><span class="p">[</span><span class="mi">316</span><span class="p">];</span>				<span class="cm">/* zero or more EA&#39;s, packed together</span>
<span class="cm">					   with no alignment padding.</span>
<span class="cm">					   (Do not use this name, get here</span>
<span class="cm">					   via fnode + ea_offs. I think.) */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">fnode_in_anode</span><span class="p">(</span><span class="k">struct</span> <span class="n">fnode</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FNODE_anode</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">fnode_is_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">fnode</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FNODE_dir</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* anode: 99.44% pure allocation tree */</span>

<span class="cp">#define ANODE_MAGIC 0x37e40aae</span>

<span class="k">struct</span> <span class="n">anode</span>
<span class="p">{</span>
  <span class="n">__le32</span> <span class="n">magic</span><span class="p">;</span>				<span class="cm">/* 37e4 0aae */</span>
  <span class="n">__le32</span> <span class="n">self</span><span class="p">;</span>				<span class="cm">/* pointer to this anode */</span>
  <span class="n">__le32</span> <span class="n">up</span><span class="p">;</span>				<span class="cm">/* parent anode or fnode */</span>

  <span class="k">struct</span> <span class="n">bplus_header</span> <span class="n">btree</span><span class="p">;</span>		<span class="cm">/* b+tree, 40 extents or 60 subtrees */</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">bplus_leaf_node</span> <span class="n">external</span><span class="p">[</span><span class="mi">40</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">bplus_internal_node</span> <span class="n">internal</span><span class="p">[</span><span class="mi">60</span><span class="p">];</span>
  <span class="p">}</span> <span class="n">u</span><span class="p">;</span>

  <span class="n">__le32</span> <span class="n">fill</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>			<span class="cm">/* unused */</span>
<span class="p">};</span>


<span class="cm">/* extended attributes.</span>

<span class="cm">   A file&#39;s EA info is stored as a list of (name,value) pairs.  It is</span>
<span class="cm">   usually in the fnode, but (if it&#39;s large) it is moved to a single</span>
<span class="cm">   sector run outside the fnode, or to multiple runs with an anode tree</span>
<span class="cm">   that points to them.</span>

<span class="cm">   The value of a single EA is stored along with the name, or (if large)</span>
<span class="cm">   it is moved to a single sector run, or multiple runs pointed to by an</span>
<span class="cm">   anode tree, pointed to by the value field of the (name,value) pair.</span>

<span class="cm">   Flags in the EA tell whether the value is immediate, in a single sector</span>
<span class="cm">   run, or in multiple runs.  Flags in the fnode tell whether the EA list</span>
<span class="cm">   is immediate, in a single run, or in multiple runs. */</span>

<span class="k">enum</span> <span class="p">{</span><span class="n">EA_indirect</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">EA_anode</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">EA_needea</span> <span class="o">=</span> <span class="mi">128</span> <span class="p">};</span>
<span class="k">struct</span> <span class="n">extended_attribute</span>
<span class="p">{</span>
  <span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>				<span class="cm">/* bit 0 set -&gt; value gives sector number</span>
<span class="cm">					   where real value starts */</span>
					<span class="cm">/* bit 1 set -&gt; sector is an anode</span>
<span class="cm">					   that points to fragmented value */</span>
					<span class="cm">/* bit 7 set -&gt; required ea */</span>
  <span class="n">u8</span> <span class="n">namelen</span><span class="p">;</span>				<span class="cm">/* length of name, bytes */</span>
  <span class="n">u8</span> <span class="n">valuelen_lo</span><span class="p">;</span>			<span class="cm">/* length of value, bytes */</span>
  <span class="n">u8</span> <span class="n">valuelen_hi</span><span class="p">;</span>			<span class="cm">/* length of value, bytes */</span>
  <span class="n">u8</span> <span class="n">name</span><span class="p">[];</span>
  <span class="cm">/*</span>
<span class="cm">    u8 name[namelen];			ascii attrib name</span>
<span class="cm">    u8 nul;				terminating &#39;\0&#39;, not counted</span>
<span class="cm">    u8 value[valuelen];			value, arbitrary</span>
<span class="cm">      if this.flags &amp; 1, valuelen is 8 and the value is</span>
<span class="cm">        u32 length;			real length of value, bytes</span>
<span class="cm">        secno secno;			sector address where it starts</span>
<span class="cm">      if this.anode, the above sector number is the root of an anode tree</span>
<span class="cm">        which points to the value.</span>
<span class="cm">  */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">ea_indirect</span><span class="p">(</span><span class="k">struct</span> <span class="n">extended_attribute</span> <span class="o">*</span><span class="n">ea</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ea</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EA_indirect</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">ea_in_anode</span><span class="p">(</span><span class="k">struct</span> <span class="n">extended_attribute</span> <span class="o">*</span><span class="n">ea</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ea</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">EA_anode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">   Local Variables:</span>
<span class="cm">   comment-column: 40</span>
<span class="cm">   End:</span>
<span class="cm">*/</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
