<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › dcache.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>dcache.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * fs/dcache.c</span>
<span class="cm"> *</span>
<span class="cm"> * Complete reimplementation</span>
<span class="cm"> * (C) 1997 Thomas Schoebel-Theuer,</span>
<span class="cm"> * with heavy changes by Linus Torvalds</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Notes on the allocation strategy:</span>
<span class="cm"> *</span>
<span class="cm"> * The dcache is a master of the icache - whenever a dcache entry</span>
<span class="cm"> * exists, the inode will always exist. &quot;iput()&quot; is done either when</span>
<span class="cm"> * the dcache entry is deleted or garbage collected.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/fsnotify.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/hash.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/seqlock.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/fs_struct.h&gt;</span>
<span class="cp">#include &lt;linux/hardirq.h&gt;</span>
<span class="cp">#include &lt;linux/bit_spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/rculist_bl.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>
<span class="cp">#include &quot;mount.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Usage:</span>
<span class="cm"> * dcache-&gt;d_inode-&gt;i_lock protects:</span>
<span class="cm"> *   - i_dentry, d_alias, d_inode of aliases</span>
<span class="cm"> * dcache_hash_bucket lock protects:</span>
<span class="cm"> *   - the dcache hash table</span>
<span class="cm"> * s_anon bl list spinlock protects:</span>
<span class="cm"> *   - the s_anon list (see __d_drop)</span>
<span class="cm"> * dcache_lru_lock protects:</span>
<span class="cm"> *   - the dcache lru lists and counters</span>
<span class="cm"> * d_lock protects:</span>
<span class="cm"> *   - d_flags</span>
<span class="cm"> *   - d_name</span>
<span class="cm"> *   - d_lru</span>
<span class="cm"> *   - d_count</span>
<span class="cm"> *   - d_unhashed()</span>
<span class="cm"> *   - d_parent and d_subdirs</span>
<span class="cm"> *   - childrens&#39; d_child and d_parent</span>
<span class="cm"> *   - d_alias, d_inode</span>
<span class="cm"> *</span>
<span class="cm"> * Ordering:</span>
<span class="cm"> * dentry-&gt;d_inode-&gt;i_lock</span>
<span class="cm"> *   dentry-&gt;d_lock</span>
<span class="cm"> *     dcache_lru_lock</span>
<span class="cm"> *     dcache_hash_bucket lock</span>
<span class="cm"> *     s_anon lock</span>
<span class="cm"> *</span>
<span class="cm"> * If there is an ancestor relationship:</span>
<span class="cm"> * dentry-&gt;d_parent-&gt;...-&gt;d_parent-&gt;d_lock</span>
<span class="cm"> *   ...</span>
<span class="cm"> *     dentry-&gt;d_parent-&gt;d_lock</span>
<span class="cm"> *       dentry-&gt;d_lock</span>
<span class="cm"> *</span>
<span class="cm"> * If no ancestor relationship:</span>
<span class="cm"> * if (dentry1 &lt; dentry2)</span>
<span class="cm"> *   dentry1-&gt;d_lock</span>
<span class="cm"> *     dentry2-&gt;d_lock</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">sysctl_vfs_cache_pressure</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sysctl_vfs_cache_pressure</span><span class="p">);</span>

<span class="k">static</span> <span class="n">__cacheline_aligned_in_smp</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">dcache_lru_lock</span><span class="p">);</span>
<span class="n">__cacheline_aligned_in_smp</span> <span class="n">DEFINE_SEQLOCK</span><span class="p">(</span><span class="n">rename_lock</span><span class="p">);</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rename_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">dentry_cache</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This is the single most critical data structure when it comes</span>
<span class="cm"> * to the dcache: the hashtable for lookups. Somebody should try</span>
<span class="cm"> * to make this good - I&#39;ve just made it work.</span>
<span class="cm"> *</span>
<span class="cm"> * This hash-function tries to avoid losing too many bits of hash</span>
<span class="cm"> * information, yet avoid using a prime hash-size or similar.</span>
<span class="cm"> */</span>
<span class="cp">#define D_HASHBITS     d_hash_shift</span>
<span class="cp">#define D_HASHMASK     d_hash_mask</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">d_hash_mask</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">d_hash_shift</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">hlist_bl_head</span> <span class="o">*</span><span class="n">dentry_hashtable</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">hlist_bl_head</span> <span class="o">*</span><span class="nf">d_hash</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hash</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">parent</span> <span class="o">/</span> <span class="n">L1_CACHE_BYTES</span><span class="p">;</span>
	<span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span> <span class="o">+</span> <span class="p">(</span><span class="n">hash</span> <span class="o">&gt;&gt;</span> <span class="n">D_HASHBITS</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dentry_hashtable</span> <span class="o">+</span> <span class="p">(</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="n">D_HASHMASK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Statistics gathering. */</span>
<span class="k">struct</span> <span class="n">dentry_stat_t</span> <span class="n">dentry_stat</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">age_limit</span> <span class="o">=</span> <span class="mi">45</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">nr_dentry</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_SYSCTL) &amp;&amp; defined(CONFIG_PROC_FS)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_nr_dentry</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">nr_dentry</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">proc_nr_dentry</span><span class="p">(</span><span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
		   <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dentry_stat</span><span class="p">.</span><span class="n">nr_dentry</span> <span class="o">=</span> <span class="n">get_nr_dentry</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">proc_dointvec</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">lenp</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Compare 2 name strings, return 0 if they match, otherwise non-zero.</span>
<span class="cm"> * The strings are both count bytes long, and count is non-zero.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_DCACHE_WORD_ACCESS</span>

<span class="cp">#include &lt;asm/word-at-a-time.h&gt;</span>
<span class="cm">/*</span>
<span class="cm"> * NOTE! &#39;cs&#39; and &#39;scount&#39; come from a dentry, so it has a</span>
<span class="cm"> * aligned allocation for this particular component. We don&#39;t</span>
<span class="cm"> * strictly need the load_unaligned_zeropad() safety, but it</span>
<span class="cm"> * doesn&#39;t hurt either.</span>
<span class="cm"> *</span>
<span class="cm"> * In contrast, &#39;ct&#39; and &#39;tcount&#39; can be from a pathname, and do</span>
<span class="cm"> * need the careful unaligned handling.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dentry_string_cmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">tcount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">mask</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">cs</span><span class="p">;</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">load_unaligned_zeropad</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcount</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cs</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
		<span class="n">ct</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
		<span class="n">tcount</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcount</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="o">~</span><span class="mi">0ul</span> <span class="o">&lt;&lt;</span> <span class="n">tcount</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">unlikely</span><span class="p">(</span><span class="o">!!</span><span class="p">((</span><span class="n">a</span> <span class="o">^</span> <span class="n">b</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dentry_string_cmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">tcount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cs</span> <span class="o">!=</span> <span class="o">*</span><span class="n">ct</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cs</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ct</span><span class="o">++</span><span class="p">;</span>
		<span class="n">tcount</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">tcount</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dentry_cmp</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ct</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">tcount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cs</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Be careful about RCU walk racing with rename:</span>
<span class="cm">	 * use ACCESS_ONCE to fetch the name pointer.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE! Even if a rename will mean that the length</span>
<span class="cm">	 * was not loaded atomically, we don&#39;t care. The</span>
<span class="cm">	 * RCU walk will check the sequence count eventually,</span>
<span class="cm">	 * and catch it. And we won&#39;t overrun the buffer,</span>
<span class="cm">	 * because we&#39;re reading the name pointer atomically,</span>
<span class="cm">	 * and a dentry name is guaranteed to be properly</span>
<span class="cm">	 * terminated with a NUL byte.</span>
<span class="cm">	 *</span>
<span class="cm">	 * End result: even if &#39;len&#39; is wrong, we&#39;ll exit</span>
<span class="cm">	 * early because the data cannot match (there can</span>
<span class="cm">	 * be no NUL in the ct/tcount data)</span>
<span class="cm">	 */</span>
	<span class="n">cs</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="n">smp_read_barrier_depends</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">dentry_string_cmp</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">ct</span><span class="p">,</span> <span class="n">tcount</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__d_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">d_u</span><span class="p">.</span><span class="n">d_rcu</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_alias</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dname_external</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">dentry_cache</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span> 
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * no locks, please.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">d_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="p">);</span>
	<span class="n">this_cpu_dec</span><span class="p">(</span><span class="n">nr_dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span> <span class="o">&amp;&amp;</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_release</span><span class="p">)</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_release</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

	<span class="cm">/* if dentry was never visible to RCU, immediate free is OK */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_RCUACCESS</span><span class="p">))</span>
		<span class="n">__d_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_rcu</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_rcu</span><span class="p">,</span> <span class="n">__d_free</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dentry_rcuwalk_barrier - invalidate in-progress rcu-walk lookups</span>
<span class="cm"> * @dentry: the target dentry</span>
<span class="cm"> * After this call, in-progress rcu-walk path lookup will fail. This</span>
<span class="cm"> * should be called after unhashing, and after changing d_inode (if</span>
<span class="cm"> * the dentry has not already been unhashed).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dentry_rcuwalk_barrier</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="cm">/* Go through a barrier */</span>
	<span class="n">write_seqcount_barrier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release the dentry&#39;s inode, using the filesystem</span>
<span class="cm"> * d_iput() operation if defined. Dentry has no refcount</span>
<span class="cm"> * and is unhashed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dentry_iput</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_alias</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span>
			<span class="n">fsnotify_inoderemove</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span> <span class="o">&amp;&amp;</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_iput</span><span class="p">)</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_iput</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release the dentry&#39;s inode, using the filesystem</span>
<span class="cm"> * d_iput() operation if defined. dentry remains in-use.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dentry_unlink_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_alias</span><span class="p">);</span>
	<span class="n">dentry_rcuwalk_barrier</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span>
		<span class="n">fsnotify_inoderemove</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span> <span class="o">&amp;&amp;</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_iput</span><span class="p">)</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_iput</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * dentry_lru_(add|del|prune|move_tail) must be called with d_lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dentry_lru_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lru</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcache_lru_lock</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_dentry_lru</span><span class="p">);</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_nr_dentry_unused</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dentry_stat</span><span class="p">.</span><span class="n">nr_unused</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcache_lru_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__dentry_lru_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lru</span><span class="p">);</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DCACHE_SHRINK_LIST</span><span class="p">;</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_nr_dentry_unused</span><span class="o">--</span><span class="p">;</span>
	<span class="n">dentry_stat</span><span class="p">.</span><span class="n">nr_unused</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove a dentry with references from the LRU.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dentry_lru_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lru</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcache_lru_lock</span><span class="p">);</span>
		<span class="n">__dentry_lru_del</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcache_lru_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove a dentry that is unreferenced and about to be pruned</span>
<span class="cm"> * (unhashed and destroyed) from the LRU, and inform the file system.</span>
<span class="cm"> * This wrapper should be called _prior_ to unhashing a victim dentry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dentry_lru_prune</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lru</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_OP_PRUNE</span><span class="p">)</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_prune</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcache_lru_lock</span><span class="p">);</span>
		<span class="n">__dentry_lru_del</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcache_lru_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dentry_lru_move_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcache_lru_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lru</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lru</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_nr_dentry_unused</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dentry_stat</span><span class="p">.</span><span class="n">nr_unused</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lru</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcache_lru_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * d_kill - kill dentry and return parent</span>
<span class="cm"> * @dentry: dentry to kill</span>
<span class="cm"> * @parent: parent dentry</span>
<span class="cm"> *</span>
<span class="cm"> * The dentry must already be unhashed and removed from the LRU.</span>
<span class="cm"> *</span>
<span class="cm"> * If this is the root of the dentry tree, return NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * dentry-&gt;d_lock and parent-&gt;d_lock must be held by caller, and are dropped by</span>
<span class="cm"> * d_kill.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">d_kill</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Inform try_to_ascend() that we are no longer attached to the</span>
<span class="cm">	 * dentry tree</span>
<span class="cm">	 */</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="n">DCACHE_DISCONNECTED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">dentry_iput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * dentry_iput drops the locks, at which point nobody (except</span>
<span class="cm">	 * transient RCU lookups) can reach this dentry.</span>
<span class="cm">	 */</span>
	<span class="n">d_free</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">parent</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unhash a dentry without inserting an RCU walk barrier or checking that</span>
<span class="cm"> * dentry-&gt;d_lock is locked.  The caller must take care of that, if</span>
<span class="cm"> * appropriate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__d_shrink</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_unhashed</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hlist_bl_head</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_DISCONNECTED</span><span class="p">))</span>
			<span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_anon</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">d_hash</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash</span><span class="p">);</span>

		<span class="n">hlist_bl_lock</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
		<span class="n">__hlist_bl_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_hash</span><span class="p">);</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_hash</span><span class="p">.</span><span class="n">pprev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">hlist_bl_unlock</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * d_drop - drop a dentry</span>
<span class="cm"> * @dentry: dentry to drop</span>
<span class="cm"> *</span>
<span class="cm"> * d_drop() unhashes the entry from the parent dentry hashes, so that it won&#39;t</span>
<span class="cm"> * be found through a VFS lookup any more. Note that this is different from</span>
<span class="cm"> * deleting the dentry - d_delete will try to mark the dentry negative if</span>
<span class="cm"> * possible, giving a successful _negative_ lookup, while d_drop will</span>
<span class="cm"> * just make the cache lookup fail.</span>
<span class="cm"> *</span>
<span class="cm"> * d_drop() is used mainly for stuff that wants to invalidate a dentry for some</span>
<span class="cm"> * reason (NFS timeouts or autofs deletes).</span>
<span class="cm"> *</span>
<span class="cm"> * __d_drop requires dentry-&gt;d_lock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__d_drop</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_unhashed</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__d_shrink</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">dentry_rcuwalk_barrier</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__d_drop</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">d_drop</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">__d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">d_drop</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * d_clear_need_lookup - drop a dentry from cache and clear the need lookup flag</span>
<span class="cm"> * @dentry: dentry to drop</span>
<span class="cm"> *</span>
<span class="cm"> * This is called when we do a lookup on a placeholder dentry that needed to be</span>
<span class="cm"> * looked up.  The dentry should have been hashed in order for it to be found by</span>
<span class="cm"> * the lookup code, but now needs to be unhashed while we do the actual lookup</span>
<span class="cm"> * and clear the DCACHE_NEED_LOOKUP flag.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">d_clear_need_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">__d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DCACHE_NEED_LOOKUP</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">d_clear_need_lookup</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Finish off a dentry we&#39;ve decided to kill.</span>
<span class="cm"> * dentry-&gt;d_lock must be held, returns with it unlocked.</span>
<span class="cm"> * If ref is non-zero, then decrement the refcount too.</span>
<span class="cm"> * Returns dentry requiring refcount drop, or NULL if we&#39;re done.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">dentry_kill</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ref</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">))</span> <span class="p">{</span>
<span class="nl">relock:</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span> <span class="cm">/* try again with same dentry */</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ROOT</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">relock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="p">)</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="o">--</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * if dentry was on the d_lru list delete it from there.</span>
<span class="cm">	 * inform the fs via d_prune that this dentry is about to be</span>
<span class="cm">	 * unhashed and destroyed.</span>
<span class="cm">	 */</span>
	<span class="n">dentry_lru_prune</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="cm">/* if it was on the hash then remove it */</span>
	<span class="n">__d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">d_kill</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* </span>
<span class="cm"> * This is dput</span>
<span class="cm"> *</span>
<span class="cm"> * This is complicated by the fact that we do not want to put</span>
<span class="cm"> * dentries that are no longer on any hash chain on the unused</span>
<span class="cm"> * list: we&#39;d much rather just get rid of them immediately.</span>
<span class="cm"> *</span>
<span class="cm"> * However, that implies that we have to traverse the dentry</span>
<span class="cm"> * tree upwards to the parents which might _also_ now be</span>
<span class="cm"> * scheduled for deletion (it may have been only waiting for</span>
<span class="cm"> * its last child to go away).</span>
<span class="cm"> *</span>
<span class="cm"> * This tail recursion is done by hand as we don&#39;t want to depend</span>
<span class="cm"> * on the compiler to always get this right (gcc generally doesn&#39;t).</span>
<span class="cm"> * Real recursion would eat up our stack space.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * dput - release a dentry</span>
<span class="cm"> * @dentry: dentry to release </span>
<span class="cm"> *</span>
<span class="cm"> * Release a dentry. This will drop the usage count and if appropriate</span>
<span class="cm"> * call the dentry unlink method as well as removing it from the queues and</span>
<span class="cm"> * releasing its resources. If the parent dentries were scheduled for release</span>
<span class="cm"> * they too may now get deleted.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dput</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

<span class="nl">repeat:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">might_sleep</span><span class="p">();</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="o">--</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_OP_DELETE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_delete</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">kill_it</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Unreachable? Get rid of it */</span>
 	<span class="k">if</span> <span class="p">(</span><span class="n">d_unhashed</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">kill_it</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this dentry needs lookup, don&#39;t set the referenced flag so that it</span>
<span class="cm">	 * is more likely to be cleaned up by the dcache shrinker in case of</span>
<span class="cm">	 * memory pressure.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_need_lookup</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="n">DCACHE_REFERENCED</span><span class="p">;</span>
	<span class="n">dentry_lru_add</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="o">--</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">kill_it:</span>
	<span class="n">dentry</span> <span class="o">=</span> <span class="n">dentry_kill</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dput</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * d_invalidate - invalidate a dentry</span>
<span class="cm"> * @dentry: dentry to invalidate</span>
<span class="cm"> *</span>
<span class="cm"> * Try to invalidate the dentry if it turns out to be</span>
<span class="cm"> * possible. If there are other dentries that can be</span>
<span class="cm"> * reached through this one we can&#39;t delete it and we</span>
<span class="cm"> * return -EBUSY. On success we return 0.</span>
<span class="cm"> *</span>
<span class="cm"> * no dcache lock.</span>
<span class="cm"> */</span>
 
<span class="kt">int</span> <span class="nf">d_invalidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If it&#39;s already been dropped, return OK.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d_unhashed</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check whether to do a partial shrink_dcache</span>
<span class="cm">	 * to get rid of unused child entries.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="n">shrink_dcache_parent</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Somebody else still using it?</span>
<span class="cm">	 *</span>
<span class="cm">	 * If it&#39;s a directory, we can&#39;t drop it</span>
<span class="cm">	 * for fear of somebody re-populating it</span>
<span class="cm">	 * with children (even though dropping it</span>
<span class="cm">	 * would make it unreachable from the root,</span>
<span class="cm">	 * we might still populate it if it was a</span>
<span class="cm">	 * working directory or similar).</span>
<span class="cm">	 * We also need to leave mountpoints alone,</span>
<span class="cm">	 * directory or not.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">d_mountpoint</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">__d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">d_invalidate</span><span class="p">);</span>

<span class="cm">/* This must be called with d_lock held */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__dget_dlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__dget</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">__dget_dlock</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">dget_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

<span class="nl">repeat:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t need rcu_dereference because we re-check it was correct under</span>
<span class="cm">	 * the lock.</span>
<span class="cm">	 */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="p">);</span>
	<span class="n">ret</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dget_parent</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * d_find_alias - grab a hashed alias of inode</span>
<span class="cm"> * @inode: inode in question</span>
<span class="cm"> * @want_discon:  flag, used by d_splice_alias, to request</span>
<span class="cm"> *          that only a DISCONNECTED alias be returned.</span>
<span class="cm"> *</span>
<span class="cm"> * If inode has a hashed alias, or is a directory and has any alias,</span>
<span class="cm"> * acquire the reference to alias and return it. Otherwise return NULL.</span>
<span class="cm"> * Notice that if inode is a directory there can be only one alias and</span>
<span class="cm"> * it can be unhashed only if it has no children, or if it is the root</span>
<span class="cm"> * of a filesystem.</span>
<span class="cm"> *</span>
<span class="cm"> * If the inode has an IS_ROOT, DCACHE_DISCONNECTED alias, then prefer</span>
<span class="cm"> * any other hashed alias over that one unless @want_discon is set,</span>
<span class="cm"> * in which case only return an IS_ROOT, DCACHE_DISCONNECTED alias.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">__d_find_alias</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">want_discon</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">alias</span><span class="p">,</span> <span class="o">*</span><span class="n">discon_alias</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="n">discon_alias</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_dentry</span><span class="p">,</span> <span class="n">d_alias</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alias</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
 		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">d_unhashed</span><span class="p">(</span><span class="n">alias</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ROOT</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">alias</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_DISCONNECTED</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">discon_alias</span> <span class="o">=</span> <span class="n">alias</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">want_discon</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">__dget_dlock</span><span class="p">(</span><span class="n">alias</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alias</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">alias</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alias</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">discon_alias</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">alias</span> <span class="o">=</span> <span class="n">discon_alias</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alias</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">d_unhashed</span><span class="p">(</span><span class="n">alias</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ROOT</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">alias</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_DISCONNECTED</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">__dget_dlock</span><span class="p">(</span><span class="n">alias</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alias</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">alias</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alias</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">d_find_alias</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">de</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">de</span> <span class="o">=</span> <span class="n">__d_find_alias</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">de</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">d_find_alias</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Try to kill dentries associated with this inode.</span>
<span class="cm"> * WARNING: you must own a reference to inode.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">d_prune_aliases</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
<span class="nl">restart:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_dentry</span><span class="p">,</span> <span class="n">d_alias</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__dget_dlock</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
			<span class="n">__d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">d_prune_aliases</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Try to throw away a dentry - free the inode, dput the parent.</span>
<span class="cm"> * Requires dentry-&gt;d_lock is held, and dentry-&gt;d_count == 0.</span>
<span class="cm"> * Releases dentry-&gt;d_lock.</span>
<span class="cm"> *</span>
<span class="cm"> * This may fail if locks cannot be acquired no problem, just try again.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">try_prune_one_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">dentry_kill</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If dentry_kill returns NULL, we have nothing more to do.</span>
<span class="cm">	 * if it returns the same dentry, trylocks failed. In either</span>
<span class="cm">	 * case, just loop again.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Otherwise, we need to prune ancestors too. This is necessary</span>
<span class="cm">	 * to prevent quadratic behavior of shrink_dcache_parent(), but</span>
<span class="cm">	 * is also expected to be beneficial in reducing dentry cache</span>
<span class="cm">	 * fragmentation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">==</span> <span class="n">dentry</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Prune ancestors. */</span>
	<span class="n">dentry</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="o">--</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dentry</span> <span class="o">=</span> <span class="n">dentry_kill</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">shrink_dentry_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">dentry</span> <span class="o">=</span> <span class="n">list_entry_rcu</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">d_lru</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lru</span> <span class="o">==</span> <span class="n">list</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span> <span class="cm">/* empty */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span> <span class="o">!=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">d_lru</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * We found an inuse dentry which was not removed from</span>
<span class="cm">		 * the LRU because of laziness during lookup.  Do not free</span>
<span class="cm">		 * it - just keep it off the LRU list.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dentry_lru_del</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rcu_read_unlock</span><span class="p">();</span>

		<span class="n">try_prune_one_dentry</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

		<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * prune_dcache_sb - shrink the dcache</span>
<span class="cm"> * @sb: superblock</span>
<span class="cm"> * @count: number of entries to try to free</span>
<span class="cm"> *</span>
<span class="cm"> * Attempt to shrink the superblock dcache LRU by @count entries. This is</span>
<span class="cm"> * done when we need more memory an called from the superblock shrinker</span>
<span class="cm"> * function.</span>
<span class="cm"> *</span>
<span class="cm"> * This function may fail to free any resources if all the dentries are in</span>
<span class="cm"> * use.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">prune_dcache_sb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">referenced</span><span class="p">);</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

<span class="nl">relock:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcache_lru_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_dentry_lru</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dentry</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_dentry_lru</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">d_lru</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span> <span class="o">!=</span> <span class="n">sb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcache_lru_lock</span><span class="p">);</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
			<span class="k">goto</span> <span class="n">relock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_REFERENCED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DCACHE_REFERENCED</span><span class="p">;</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">referenced</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="n">DCACHE_SHRINK_LIST</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">count</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cond_resched_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcache_lru_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">referenced</span><span class="p">))</span>
		<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">referenced</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_dentry_lru</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcache_lru_lock</span><span class="p">);</span>

	<span class="n">shrink_dentry_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * shrink_dcache_sb - shrink dcache for a superblock</span>
<span class="cm"> * @sb: superblock</span>
<span class="cm"> *</span>
<span class="cm"> * Shrink the dcache for the specified super block. This is used to free</span>
<span class="cm"> * the dcache before unmounting a file system.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">shrink_dcache_sb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcache_lru_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_dentry_lru</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_dentry_lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcache_lru_lock</span><span class="p">);</span>
		<span class="n">shrink_dentry_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcache_lru_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcache_lru_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">shrink_dcache_sb</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * destroy a single subtree of dentries for unmount</span>
<span class="cm"> * - see the comments on shrink_dcache_for_umount() for a description of the</span>
<span class="cm"> *   locking</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">shrink_dcache_for_umount_subtree</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">IS_ROOT</span><span class="p">(</span><span class="n">dentry</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="cm">/* descend to the first leaf in the current subtree */</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">))</span>
			<span class="n">dentry</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">);</span>

		<span class="cm">/* consume the dentries from this leaf up through its parents</span>
<span class="cm">		 * until we find one with children or run out altogether */</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * remove the dentry from the lru, and inform</span>
<span class="cm">			 * the fs that this dentry is about to be</span>
<span class="cm">			 * unhashed and destroyed.</span>
<span class="cm">			 */</span>
			<span class="n">dentry_lru_prune</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
			<span class="n">__d_shrink</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				       <span class="s">&quot;BUG: Dentry %p{i=%lx,n=%s}&quot;</span>
				       <span class="s">&quot; still in use (%d)&quot;</span>
				       <span class="s">&quot; [unmount of %s %s]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">dentry</span><span class="p">,</span>
				       <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">?</span>
				       <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">:</span> <span class="mi">0UL</span><span class="p">,</span>
				       <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
				       <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="p">,</span>
				       <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				       <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">);</span>
				<span class="n">BUG</span><span class="p">();</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ROOT</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">parent</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>
				<span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="o">--</span><span class="p">;</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_alias</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span> <span class="o">&amp;&amp;</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_iput</span><span class="p">)</span>
					<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_iput</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">d_free</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

			<span class="cm">/* finished when we fall off the top of the tree,</span>
<span class="cm">			 * otherwise we ascend to the parent and move to the</span>
<span class="cm">			 * next sibling if there is one */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="n">dentry</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">));</span>

		<span class="n">dentry</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * destroy the dentries attached to a superblock on unmounting</span>
<span class="cm"> * - we don&#39;t need to use dentry-&gt;d_lock because:</span>
<span class="cm"> *   - the superblock is detached from all mountings and open files, so the</span>
<span class="cm"> *     dentry trees will not be rearranged by the VFS</span>
<span class="cm"> *   - s_umount is write-locked, so the memory pressure shrinker will ignore</span>
<span class="cm"> *     any dentries belonging to this superblock that it comes across</span>
<span class="cm"> *   - the filesystem itself is no longer permitted to rearrange the dentries</span>
<span class="cm"> *     in this superblock</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">shrink_dcache_for_umount</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">down_read_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="o">--</span><span class="p">;</span>
	<span class="n">shrink_dcache_for_umount_subtree</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">hlist_bl_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_anon</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dentry</span> <span class="o">=</span> <span class="n">hlist_bl_entry</span><span class="p">(</span><span class="n">hlist_bl_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_anon</span><span class="p">),</span> <span class="k">struct</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">d_hash</span><span class="p">);</span>
		<span class="n">shrink_dcache_for_umount_subtree</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This tries to ascend one level of parenthood, but</span>
<span class="cm"> * we can race with renaming, so we need to re-check</span>
<span class="cm"> * the parenthood after dropping the lock and check</span>
<span class="cm"> * that the sequence number still matches.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">try_to_ascend</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="kt">int</span> <span class="n">locked</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * might go back up the wrong parent if we have had a rename</span>
<span class="cm">	 * or deletion</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span> <span class="o">!=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">||</span>
		 <span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_DISCONNECTED</span><span class="p">)</span> <span class="o">||</span>
		 <span class="p">(</span><span class="o">!</span><span class="n">locked</span> <span class="o">&amp;&amp;</span> <span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="n">new</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">new</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Search for at least 1 mount point in the dentry&#39;s subdirs.</span>
<span class="cm"> * We descend to the next level whenever the d_subdirs</span>
<span class="cm"> * list is non-empty and continue searching.</span>
<span class="cm"> */</span>
 
<span class="cm">/**</span>
<span class="cm"> * have_submounts - check for mounts over a dentry</span>
<span class="cm"> * @parent: dentry to check.</span>
<span class="cm"> *</span>
<span class="cm"> * Return true if the parent or its subdirectories contain</span>
<span class="cm"> * a mount point</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">have_submounts</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">this_parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">seq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
<span class="nl">again:</span>
	<span class="n">this_parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">d_mountpoint</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">positive</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="nl">repeat:</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
<span class="nl">resume:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">);</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

		<span class="n">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">,</span> <span class="n">DENTRY_D_LOCK_NESTED</span><span class="p">);</span>
		<span class="cm">/* Have we found a mount point ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d_mountpoint</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">positive</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="n">spin_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">.</span><span class="n">dep_map</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
			<span class="n">this_parent</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
			<span class="n">spin_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">.</span><span class="n">dep_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * All done at this level ... ascend and resume the search.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this_parent</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">child</span> <span class="o">=</span> <span class="n">this_parent</span><span class="p">;</span>
		<span class="n">this_parent</span> <span class="o">=</span> <span class="n">try_to_ascend</span><span class="p">(</span><span class="n">this_parent</span><span class="p">,</span> <span class="n">locked</span><span class="p">,</span> <span class="n">seq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this_parent</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">rename_retry</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">resume</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span> <span class="o">&amp;&amp;</span> <span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">rename_retry</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">locked</span><span class="p">)</span>
		<span class="n">write_sequnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* No mount points found in tree */</span>
<span class="nl">positive:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span> <span class="o">&amp;&amp;</span> <span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">rename_retry</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">locked</span><span class="p">)</span>
		<span class="n">write_sequnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">rename_retry:</span>
	<span class="n">locked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">write_seqlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">have_submounts</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Search the dentry child list for the specified parent,</span>
<span class="cm"> * and move any unused dentries to the end of the unused</span>
<span class="cm"> * list for prune_dcache(). We descend to the next level</span>
<span class="cm"> * whenever the d_subdirs list is non-empty and continue</span>
<span class="cm"> * searching.</span>
<span class="cm"> *</span>
<span class="cm"> * It returns zero iff there are no unused children,</span>
<span class="cm"> * otherwise  it returns the number of children moved to</span>
<span class="cm"> * the end of the unused list. This may not be the total</span>
<span class="cm"> * number of unused children, because select_parent can</span>
<span class="cm"> * drop the lock and return early due to latency</span>
<span class="cm"> * constraints.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">select_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">dispose</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">this_parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">seq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
<span class="nl">again:</span>
	<span class="n">this_parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="nl">repeat:</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
<span class="nl">resume:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">);</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

		<span class="n">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">,</span> <span class="n">DENTRY_D_LOCK_NESTED</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * move only zero ref count dentries to the dispose list.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Those which are presently on the shrink list, being processed</span>
<span class="cm">		 * by shrink_dentry_list(), shouldn&#39;t be moved.  Otherwise the</span>
<span class="cm">		 * loop in shrink_dcache_parent() might not make any progress</span>
<span class="cm">		 * and loop forever.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dentry_lru_del</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_SHRINK_LIST</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dentry_lru_move_list</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">dispose</span><span class="p">);</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="n">DCACHE_SHRINK_LIST</span><span class="p">;</span>
			<span class="n">found</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * We can return to the caller if we have found some (this</span>
<span class="cm">		 * ensures forward progress). We&#39;ll be coming back to find</span>
<span class="cm">		 * the rest.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">&amp;&amp;</span> <span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Descend a level if the d_subdirs list is non-empty.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="n">spin_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">.</span><span class="n">dep_map</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
			<span class="n">this_parent</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
			<span class="n">spin_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">.</span><span class="n">dep_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * All done at this level ... ascend and resume the search.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this_parent</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">child</span> <span class="o">=</span> <span class="n">this_parent</span><span class="p">;</span>
		<span class="n">this_parent</span> <span class="o">=</span> <span class="n">try_to_ascend</span><span class="p">(</span><span class="n">this_parent</span><span class="p">,</span> <span class="n">locked</span><span class="p">,</span> <span class="n">seq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this_parent</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">rename_retry</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">resume</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span> <span class="o">&amp;&amp;</span> <span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">rename_retry</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">locked</span><span class="p">)</span>
		<span class="n">write_sequnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>

<span class="nl">rename_retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
	<span class="n">locked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">write_seqlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * shrink_dcache_parent - prune dcache</span>
<span class="cm"> * @parent: parent of entries to prune</span>
<span class="cm"> *</span>
<span class="cm"> * Prune the dcache to remove unused children of the parent dentry.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">shrink_dcache_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">dispose</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">found</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">found</span> <span class="o">=</span> <span class="n">select_parent</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dispose</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">shrink_dentry_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dispose</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">shrink_dcache_parent</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __d_alloc	-	allocate a dcache entry</span>
<span class="cm"> * @sb: filesystem it will belong to</span>
<span class="cm"> * @name: qstr of the name</span>
<span class="cm"> *</span>
<span class="cm"> * Allocates a dentry. It returns %NULL if there is insufficient memory</span>
<span class="cm"> * available. On a success the dentry is returned. The name passed in is</span>
<span class="cm"> * copied and the copy passed in may be reused after this call.</span>
<span class="cm"> */</span>
 
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">__d_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">dname</span><span class="p">;</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">dentry_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We guarantee that the inline name is always NUL-terminated.</span>
<span class="cm">	 * This way the memcpy() done by the name switching in rename</span>
<span class="cm">	 * will still always have a NUL at the end, even if we might</span>
<span class="cm">	 * be overwriting an internal NUL character</span>
<span class="cm">	 */</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_iname</span><span class="p">[</span><span class="n">DNAME_INLINE_LEN</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">DNAME_INLINE_LEN</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dname</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dname</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">dentry_cache</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span> 
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>  <span class="p">{</span>
		<span class="n">dname</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_iname</span><span class="p">;</span>
	<span class="p">}</span>	

	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dname</span><span class="p">,</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">dname</span><span class="p">[</span><span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Make sure we always see the terminating NUL character */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">dname</span><span class="p">;</span>

	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">seqcount_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">INIT_HLIST_BL_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_hash</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lru</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_alias</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">);</span>
	<span class="n">d_set_d_op</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_d_op</span><span class="p">);</span>

	<span class="n">this_cpu_inc</span><span class="p">(</span><span class="n">nr_dentry</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * d_alloc	-	allocate a dcache entry</span>
<span class="cm"> * @parent: parent of entry to allocate</span>
<span class="cm"> * @name: qstr of the name</span>
<span class="cm"> *</span>
<span class="cm"> * Allocates a dentry. It returns %NULL if there is insufficient memory</span>
<span class="cm"> * available. On a success the dentry is returned. The name passed in is</span>
<span class="cm"> * copied and the copy passed in may be reused after this call.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">d_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">parent</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">__d_alloc</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * don&#39;t need child lock because it is not subject</span>
<span class="cm">	 * to concurrency here</span>
<span class="cm">	 */</span>
	<span class="n">__dget_dlock</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">d_alloc</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">d_alloc_pseudo</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">__d_alloc</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="p">)</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="n">DCACHE_DISCONNECTED</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">d_alloc_pseudo</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">d_alloc_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">q</span><span class="p">;</span>

	<span class="n">q</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">q</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="n">q</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="n">full_name_hash</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">d_alloc</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">d_alloc_name</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">d_set_d_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="p">);</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DCACHE_OP_HASH</span>	<span class="o">|</span>
				<span class="n">DCACHE_OP_COMPARE</span>	<span class="o">|</span>
				<span class="n">DCACHE_OP_REVALIDATE</span>	<span class="o">|</span>
				<span class="n">DCACHE_OP_DELETE</span> <span class="p">));</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">d_hash</span><span class="p">)</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="n">DCACHE_OP_HASH</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">d_compare</span><span class="p">)</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="n">DCACHE_OP_COMPARE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">d_revalidate</span><span class="p">)</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="n">DCACHE_OP_REVALIDATE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">d_delete</span><span class="p">)</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="n">DCACHE_OP_DELETE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">d_prune</span><span class="p">)</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="n">DCACHE_OP_PRUNE</span><span class="p">;</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">d_set_d_op</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__d_instantiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">IS_AUTOMOUNT</span><span class="p">(</span><span class="n">inode</span><span class="p">)))</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="n">DCACHE_NEED_AUTOMOUNT</span><span class="p">;</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_alias</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_dentry</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>
	<span class="n">dentry_rcuwalk_barrier</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">fsnotify_d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * d_instantiate - fill in inode information for a dentry</span>
<span class="cm"> * @entry: dentry to complete</span>
<span class="cm"> * @inode: inode to attach to this dentry</span>
<span class="cm"> *</span>
<span class="cm"> * Fill in inode information in the entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This turns negative dentries into productive full members</span>
<span class="cm"> * of society.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE! This assumes that the inode count has been incremented</span>
<span class="cm"> * (or otherwise set) by the caller to indicate that it is now</span>
<span class="cm"> * in use by the dcache.</span>
<span class="cm"> */</span>
 
<span class="kt">void</span> <span class="nf">d_instantiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_alias</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">__d_instantiate</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">security_d_instantiate</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">d_instantiate</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * d_instantiate_unique - instantiate a non-aliased dentry</span>
<span class="cm"> * @entry: dentry to instantiate</span>
<span class="cm"> * @inode: inode to attach to this dentry</span>
<span class="cm"> *</span>
<span class="cm"> * Fill in inode information in the entry. On success, it returns NULL.</span>
<span class="cm"> * If an unhashed alias of &quot;entry&quot; already exists, then we return the</span>
<span class="cm"> * aliased dentry instead and drop one reference to inode.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that in order to avoid conflicts with rename() etc, the caller</span>
<span class="cm"> * had better be holding the parent directory semaphore.</span>
<span class="cm"> *</span>
<span class="cm"> * This also assumes that the inode count has been incremented</span>
<span class="cm"> * (or otherwise set) by the caller to indicate that it is now</span>
<span class="cm"> * in use by the dcache.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">__d_instantiate_unique</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">alias</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__d_instantiate</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_dentry</span><span class="p">,</span> <span class="n">d_alias</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t need alias-&gt;d_lock here, because aliases with</span>
<span class="cm">		 * d_parent == entry-&gt;d_parent are not subject to name or</span>
<span class="cm">		 * parent changes, because the parent inode i_mutex is held.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">alias</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash</span> <span class="o">!=</span> <span class="n">hash</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">alias</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">!=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">alias</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dentry_cmp</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">__dget</span><span class="p">(</span><span class="n">alias</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">alias</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">__d_instantiate</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">d_instantiate_unique</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_alias</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">__d_instantiate_unique</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">security_d_instantiate</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">d_unhashed</span><span class="p">(</span><span class="n">result</span><span class="p">));</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">d_instantiate_unique</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">d_make_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">root_inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="n">name</span> <span class="o">=</span> <span class="n">QSTR_INIT</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">res</span> <span class="o">=</span> <span class="n">__d_alloc</span><span class="p">(</span><span class="n">root_inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
			<span class="n">d_instantiate</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">root_inode</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">root_inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">d_make_root</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="nf">__d_find_any_alias</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">alias</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_dentry</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">alias</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">d_alias</span><span class="p">);</span>
	<span class="n">__dget</span><span class="p">(</span><span class="n">alias</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">alias</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * d_find_any_alias - find any alias for a given inode</span>
<span class="cm"> * @inode: inode to find an alias for</span>
<span class="cm"> *</span>
<span class="cm"> * If any aliases exist for the given inode, take and return a</span>
<span class="cm"> * reference for one of them.  If no aliases exist, return %NULL.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">d_find_any_alias</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">de</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">de</span> <span class="o">=</span> <span class="n">__d_find_any_alias</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">de</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">d_find_any_alias</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * d_obtain_alias - find or allocate a dentry for a given inode</span>
<span class="cm"> * @inode: inode to allocate the dentry for</span>
<span class="cm"> *</span>
<span class="cm"> * Obtain a dentry for an inode resulting from NFS filehandle conversion or</span>
<span class="cm"> * similar open by handle operations.  The returned dentry may be anonymous,</span>
<span class="cm"> * or may have a full name (if the inode was already in the cache).</span>
<span class="cm"> *</span>
<span class="cm"> * When called on a directory inode, we must ensure that the inode only ever</span>
<span class="cm"> * has one dentry.  If a dentry is found, that is returned instead of</span>
<span class="cm"> * allocating a new one.</span>
<span class="cm"> *</span>
<span class="cm"> * On successful return, the reference to the inode has been transferred</span>
<span class="cm"> * to the dentry.  In case of an error the reference on the inode is released.</span>
<span class="cm"> * To make it easier to use in export operations a %NULL or IS_ERR inode may</span>
<span class="cm"> * be passed in and will be the error will be propagate to the return value,</span>
<span class="cm"> * with a %NULL @inode replaced by ERR_PTR(-ESTALE).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">d_obtain_alias</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="n">anonstring</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ESTALE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">d_find_any_alias</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_iput</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">__d_alloc</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">anonstring</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_iput</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">__d_find_any_alias</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_iput</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* attach a disconnected dentry */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="n">DCACHE_DISCONNECTED</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">d_alias</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_dentry</span><span class="p">);</span>
	<span class="n">hlist_bl_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_anon</span><span class="p">);</span>
	<span class="n">hlist_bl_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">d_hash</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_anon</span><span class="p">);</span>
	<span class="n">hlist_bl_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_anon</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">security_d_instantiate</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>

 <span class="nl">out_iput:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
		<span class="n">security_d_instantiate</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">d_obtain_alias</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * d_splice_alias - splice a disconnected dentry into the tree if one exists</span>
<span class="cm"> * @inode:  the inode which may have a disconnected dentry</span>
<span class="cm"> * @dentry: a negative dentry which we want to point to the inode.</span>
<span class="cm"> *</span>
<span class="cm"> * If inode is a directory and has a &#39;disconnected&#39; dentry (i.e. IS_ROOT and</span>
<span class="cm"> * DCACHE_DISCONNECTED), then d_move that in place of the given dentry</span>
<span class="cm"> * and return it, else simply d_add the inode to the dentry and return NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * This is needed in the lookup routine of any filesystem that is exportable</span>
<span class="cm"> * (via knfsd) so that we can build dcache paths to directories effectively.</span>
<span class="cm"> *</span>
<span class="cm"> * If a dentry was found and moved, then it is returned.  Otherwise NULL</span>
<span class="cm"> * is returned.  This matches the expected return value of -&gt;lookup.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">d_splice_alias</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">&amp;&amp;</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">__d_find_alias</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_DISCONNECTED</span><span class="p">));</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="n">security_d_instantiate</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="n">d_move</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* already taking inode-&gt;i_lock, so d_add() by hand */</span>
			<span class="n">__d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="n">security_d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="n">d_rehash</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">d_add</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">new</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">d_splice_alias</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * d_add_ci - lookup or allocate new dentry with case-exact name</span>
<span class="cm"> * @inode:  the inode case-insensitive lookup has found</span>
<span class="cm"> * @dentry: the negative dentry that was passed to the parent&#39;s lookup func</span>
<span class="cm"> * @name:   the case-exact name to be associated with the returned dentry</span>
<span class="cm"> *</span>
<span class="cm"> * This is to avoid filling the dcache with case-insensitive names to the</span>
<span class="cm"> * same inode, only the actual correct case is stored in the dcache for</span>
<span class="cm"> * case-insensitive filesystems.</span>
<span class="cm"> *</span>
<span class="cm"> * For a case-insensitive lookup match and if the the case-exact dentry</span>
<span class="cm"> * already exists in in the dcache, use it and return it.</span>
<span class="cm"> *</span>
<span class="cm"> * If no entry exists with the exact case name, allocate new dentry with</span>
<span class="cm"> * the exact case, and return the spliced entry.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">d_add_ci</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">found</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First check if a dentry matching the name already exists,</span>
<span class="cm">	 * if not go ahead and create it now.</span>
<span class="cm">	 */</span>
	<span class="n">found</span> <span class="o">=</span> <span class="n">d_hash_and_lookup</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">d_alloc</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">found</span> <span class="o">=</span> <span class="n">d_splice_alias</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dput</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">new</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If a matching dentry exists, and it&#39;s not negative use it.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Decrement the reference count to balance the iget() done</span>
<span class="cm">	 * earlier on.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">found</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">!=</span> <span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* This can&#39;t happen because bad inodes are unhashed. */</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_bad_inode</span><span class="p">(</span><span class="n">found</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are going to instantiate this dentry, unhash it and clear the</span>
<span class="cm">	 * lookup flag so we can do that.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">d_need_lookup</span><span class="p">(</span><span class="n">found</span><span class="p">)))</span>
		<span class="n">d_clear_need_lookup</span><span class="p">(</span><span class="n">found</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Negative dentry: instantiate it unless the inode is a directory and</span>
<span class="cm">	 * already has a dentry.</span>
<span class="cm">	 */</span>
	<span class="n">new</span> <span class="o">=</span> <span class="n">d_splice_alias</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">found</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">found</span><span class="p">);</span>
		<span class="n">found</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>

<span class="nl">err_out:</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">d_add_ci</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Do the slow-case of the dentry name compare.</span>
<span class="cm"> *</span>
<span class="cm"> * Unlike the dentry_cmp() function, we need to atomically</span>
<span class="cm"> * load the name, length and inode information, so that the</span>
<span class="cm"> * filesystem can rely on them, and can use the &#39;name&#39; and</span>
<span class="cm"> * &#39;len&#39; information without worrying about walking off the</span>
<span class="cm"> * end of memory etc.</span>
<span class="cm"> *</span>
<span class="cm"> * Thus the read_seqcount_retry() and the &quot;duplicate&quot; info</span>
<span class="cm"> * in arguments (the low-level filesystem should not look</span>
<span class="cm"> * at the dentry inode or name contents directly, since</span>
<span class="cm"> * rename can change them while we&#39;re in RCU mode).</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">slow_d_compare</span> <span class="p">{</span>
	<span class="n">D_COMP_OK</span><span class="p">,</span>
	<span class="n">D_COMP_NOMATCH</span><span class="p">,</span>
	<span class="n">D_COMP_SEQRETRY</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="k">enum</span> <span class="n">slow_d_compare</span> <span class="nf">slow_dentry_cmp</span><span class="p">(</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seq</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tlen</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tname</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">read_seqcount_retry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">,</span> <span class="n">seq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">D_COMP_SEQRETRY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_compare</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
				<span class="n">dentry</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
				<span class="n">tlen</span><span class="p">,</span> <span class="n">tname</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">D_COMP_NOMATCH</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">D_COMP_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __d_lookup_rcu - search for a dentry (racy, store-free)</span>
<span class="cm"> * @parent: parent dentry</span>
<span class="cm"> * @name: qstr of name we wish to find</span>
<span class="cm"> * @seqp: returns d_seq value at the point where the dentry was found</span>
<span class="cm"> * @inode: returns dentry-&gt;d_inode when the inode was found valid.</span>
<span class="cm"> * Returns: dentry, or NULL</span>
<span class="cm"> *</span>
<span class="cm"> * __d_lookup_rcu is the dcache lookup function for rcu-walk name</span>
<span class="cm"> * resolution (store-free path walking) design described in</span>
<span class="cm"> * Documentation/filesystems/path-lookup.txt.</span>
<span class="cm"> *</span>
<span class="cm"> * This is not to be used outside core vfs.</span>
<span class="cm"> *</span>
<span class="cm"> * __d_lookup_rcu must only be used in rcu-walk mode, ie. with vfsmount lock</span>
<span class="cm"> * held, and rcu_read_lock held. The returned dentry must not be stored into</span>
<span class="cm"> * without taking d_lock and checking d_seq sequence count against @seq</span>
<span class="cm"> * returned here.</span>
<span class="cm"> *</span>
<span class="cm"> * A refcount may be taken on the found dentry with the __d_rcu_to_refcount</span>
<span class="cm"> * function.</span>
<span class="cm"> *</span>
<span class="cm"> * Alternatively, __d_lookup_rcu may be called again to look up the child of</span>
<span class="cm"> * the returned dentry, so long as its parent&#39;s seqlock is checked after the</span>
<span class="cm"> * child is looked up. Thus, an interlocking stepping of sequence lock checks</span>
<span class="cm"> * is formed, giving integrity down the path walk.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE! The caller *has* to check the resulting dentry against the sequence</span>
<span class="cm"> * number we&#39;ve returned before using any of the resulting dentry state!</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">__d_lookup_rcu</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="o">*</span><span class="n">seqp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">hashlen</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">hash_len</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_bl_head</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">d_hash</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">hashlen_hash</span><span class="p">(</span><span class="n">hashlen</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">hlist_bl_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note: There is significant duplication with __d_lookup_rcu which is</span>
<span class="cm">	 * required to prevent single threaded performance regressions</span>
<span class="cm">	 * especially on architectures where smp_rmb (in seqcounts) are costly.</span>
<span class="cm">	 * Keep the two functions in sync.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * The hash list is protected using RCU.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Carefully use d_seq when comparing a candidate dentry, to avoid</span>
<span class="cm">	 * races with d_move().</span>
<span class="cm">	 *</span>
<span class="cm">	 * It is possible that concurrent renames can mess up our list</span>
<span class="cm">	 * walk here and result in missing our dentry, resulting in the</span>
<span class="cm">	 * false-negative result. d_lookup() protects against concurrent</span>
<span class="cm">	 * renames using rename_lock seqlock.</span>
<span class="cm">	 *</span>
<span class="cm">	 * See Documentation/filesystems/path-lookup.txt for more details.</span>
<span class="cm">	 */</span>
	<span class="n">hlist_bl_for_each_entry_rcu</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">d_hash</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">seq</span><span class="p">;</span>

<span class="nl">seqretry:</span>
		<span class="cm">/*</span>
<span class="cm">		 * The dentry sequence count protects us from concurrent</span>
<span class="cm">		 * renames, and thus protects inode, parent and name fields.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The caller must perform a seqcount check in order</span>
<span class="cm">		 * to do anything useful with the returned dentry,</span>
<span class="cm">		 * including using the &#39;d_inode&#39; pointer.</span>
<span class="cm">		 *</span>
<span class="cm">		 * NOTE! We do a &quot;raw&quot; seqcount_begin here. That means that</span>
<span class="cm">		 * we don&#39;t wait for the sequence count to stabilize if it</span>
<span class="cm">		 * is in the middle of a sequence change. If we do the slow</span>
<span class="cm">		 * dentry compare, we will do seqretries until it is stable,</span>
<span class="cm">		 * and if we end up with a successful lookup, we actually</span>
<span class="cm">		 * want to exit RCU lookup anyway.</span>
<span class="cm">		 */</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">raw_seqcount_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d_unhashed</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="o">*</span><span class="n">seqp</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_OP_COMPARE</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash</span> <span class="o">!=</span> <span class="n">hashlen_hash</span><span class="p">(</span><span class="n">hashlen</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">slow_dentry_cmp</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">D_COMP_OK</span>:
				<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">D_COMP_NOMATCH</span>:
				<span class="k">continue</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">goto</span> <span class="n">seqretry</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash_len</span> <span class="o">!=</span> <span class="n">hashlen</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry_cmp</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">hashlen_len</span><span class="p">(</span><span class="n">hashlen</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * d_lookup - search for a dentry</span>
<span class="cm"> * @parent: parent dentry</span>
<span class="cm"> * @name: qstr of name we wish to find</span>
<span class="cm"> * Returns: dentry, or NULL</span>
<span class="cm"> *</span>
<span class="cm"> * d_lookup searches the children of the parent dentry for the name in</span>
<span class="cm"> * question. If the dentry is found its reference count is incremented and the</span>
<span class="cm"> * dentry is returned. The caller must use dput to free the entry when it has</span>
<span class="cm"> * finished using it. %NULL is returned if the dentry does not exist.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">d_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">seq</span><span class="p">;</span>

        <span class="k">do</span> <span class="p">{</span>
                <span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
                <span class="n">dentry</span> <span class="o">=</span> <span class="n">__d_lookup</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">d_lookup</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __d_lookup - search for a dentry (racy)</span>
<span class="cm"> * @parent: parent dentry</span>
<span class="cm"> * @name: qstr of name we wish to find</span>
<span class="cm"> * Returns: dentry, or NULL</span>
<span class="cm"> *</span>
<span class="cm"> * __d_lookup is like d_lookup, however it may (rarely) return a</span>
<span class="cm"> * false-negative result due to unrelated rename activity.</span>
<span class="cm"> *</span>
<span class="cm"> * __d_lookup is slightly faster by avoiding rename_lock read seqlock,</span>
<span class="cm"> * however it must be used carefully, eg. with a following d_lookup in</span>
<span class="cm"> * the case of failure.</span>
<span class="cm"> *</span>
<span class="cm"> * __d_lookup callers must be commented.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">__d_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_bl_head</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">d_hash</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hlist_bl_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">found</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note: There is significant duplication with __d_lookup_rcu which is</span>
<span class="cm">	 * required to prevent single threaded performance regressions</span>
<span class="cm">	 * especially on architectures where smp_rmb (in seqcounts) are costly.</span>
<span class="cm">	 * Keep the two functions in sync.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * The hash list is protected using RCU.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Take d_lock when comparing a candidate dentry, to avoid races</span>
<span class="cm">	 * with d_move().</span>
<span class="cm">	 *</span>
<span class="cm">	 * It is possible that concurrent renames can mess up our list</span>
<span class="cm">	 * walk here and result in missing our dentry, resulting in the</span>
<span class="cm">	 * false-negative result. d_lookup() protects against concurrent</span>
<span class="cm">	 * renames using rename_lock seqlock.</span>
<span class="cm">	 *</span>
<span class="cm">	 * See Documentation/filesystems/path-lookup.txt for more details.</span>
<span class="cm">	 */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	
	<span class="n">hlist_bl_for_each_entry_rcu</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">d_hash</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash</span> <span class="o">!=</span> <span class="n">hash</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d_unhashed</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * It is safe to compare names since d_move() cannot</span>
<span class="cm">		 * change the qstr (protected by d_lock).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_OP_COMPARE</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">tlen</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tname</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_compare</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span>
						<span class="n">dentry</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span>
						<span class="n">tlen</span><span class="p">,</span> <span class="n">tname</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dentry_cmp</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">found</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="nl">next:</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
 	<span class="p">}</span>
 	<span class="n">rcu_read_unlock</span><span class="p">();</span>

 	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * d_hash_and_lookup - hash the qstr then search for a dentry</span>
<span class="cm"> * @dir: Directory to search in</span>
<span class="cm"> * @name: qstr of name we wish to find</span>
<span class="cm"> *</span>
<span class="cm"> * On hash failure or on lookup failure NULL is returned.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">d_hash_and_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for a fs-specific hash function. Note that we must</span>
<span class="cm">	 * calculate the standard hash first, as the d_op-&gt;d_hash()</span>
<span class="cm">	 * routine may choose to leave the hash value unchanged.</span>
<span class="cm">	 */</span>
	<span class="n">name</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">full_name_hash</span><span class="p">(</span><span class="n">name</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_OP_HASH</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_hash</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dentry</span> <span class="o">=</span> <span class="n">d_lookup</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * d_validate - verify dentry provided from insecure source (deprecated)</span>
<span class="cm"> * @dentry: The dentry alleged to be valid child of @dparent</span>
<span class="cm"> * @dparent: The parent dentry (known to be valid)</span>
<span class="cm"> *</span>
<span class="cm"> * An insecure source has sent us a dentry, here we verify it and dget() it.</span>
<span class="cm"> * This is used by ncpfs in its readdir implementation.</span>
<span class="cm"> * Zero is returned in the dentry is invalid.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is slow for big directories, and deprecated, do not use it.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">d_validate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dparent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dparent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dparent</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">,</span> <span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span> <span class="o">==</span> <span class="n">child</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">,</span> <span class="n">DENTRY_D_LOCK_NESTED</span><span class="p">);</span>
			<span class="n">__dget_dlock</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dparent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dparent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">d_validate</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * When a file is deleted, we have two options:</span>
<span class="cm"> * - turn this dentry into a negative dentry</span>
<span class="cm"> * - unhash this dentry and free it.</span>
<span class="cm"> *</span>
<span class="cm"> * Usually, we want to just turn this into</span>
<span class="cm"> * a negative dentry, but if anybody else is</span>
<span class="cm"> * currently using the dentry or the inode</span>
<span class="cm"> * we can&#39;t do that and we fall back on removing</span>
<span class="cm"> * it from the hash queues and waiting for</span>
<span class="cm"> * it to be deleted later when it has no users</span>
<span class="cm"> */</span>
 
<span class="cm">/**</span>
<span class="cm"> * d_delete - delete a dentry</span>
<span class="cm"> * @dentry: The dentry to delete</span>
<span class="cm"> *</span>
<span class="cm"> * Turn the dentry into a negative dentry if possible, otherwise</span>
<span class="cm"> * remove it from the hash queues so it can be deleted later</span>
<span class="cm"> */</span>
 
<span class="kt">void</span> <span class="nf">d_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">isdir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Are we the only user?</span>
<span class="cm">	 */</span>
<span class="nl">again:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">isdir</span> <span class="o">=</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DCACHE_CANT_MOUNT</span><span class="p">;</span>
		<span class="n">dentry_unlink_inode</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">fsnotify_nameremove</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">isdir</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_unhashed</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
		<span class="n">__d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>

	<span class="n">fsnotify_nameremove</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">isdir</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">d_delete</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__d_rehash</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hlist_bl_head</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">d_unhashed</span><span class="p">(</span><span class="n">entry</span><span class="p">));</span>
	<span class="n">hlist_bl_lock</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="n">DCACHE_RCUACCESS</span><span class="p">;</span>
	<span class="n">hlist_bl_add_head_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_hash</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
	<span class="n">hlist_bl_unlock</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_d_rehash</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__d_rehash</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">d_hash</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * d_rehash	- add an entry back to the hash</span>
<span class="cm"> * @entry: dentry to add to the hash</span>
<span class="cm"> *</span>
<span class="cm"> * Adds a dentry to the hash according to its name.</span>
<span class="cm"> */</span>
 
<span class="kt">void</span> <span class="nf">d_rehash</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">_d_rehash</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">d_rehash</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * dentry_update_name_case - update case insensitive dentry with a new name</span>
<span class="cm"> * @dentry: dentry to be updated</span>
<span class="cm"> * @name: new name</span>
<span class="cm"> *</span>
<span class="cm"> * Update a case insensitive dentry with new case of name.</span>
<span class="cm"> *</span>
<span class="cm"> * dentry must have been returned by d_lookup with name @name. Old and new</span>
<span class="cm"> * name lengths must match (ie. no d_compare which allows mismatched name</span>
<span class="cm"> * lengths).</span>
<span class="cm"> *</span>
<span class="cm"> * Parent inode i_mutex must be held over d_lookup and into this call (to</span>
<span class="cm"> * keep renames and concurrent inserts, and readdir(2) away).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dentry_update_name_case</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">!=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span> <span class="cm">/* d_lookup gives this */</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">write_seqcount_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">write_seqcount_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dentry_update_name_case</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">switch_names</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dname_external</span><span class="p">(</span><span class="n">target</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dname_external</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Both external: swap the pointers</span>
<span class="cm">			 */</span>
			<span class="n">swap</span><span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * dentry:internal, target:external.  Steal target&#39;s</span>
<span class="cm">			 * storage and make target internal.</span>
<span class="cm">			 */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">d_iname</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
					<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
			<span class="n">target</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">d_iname</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dname_external</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * dentry:external, target:internal.  Give dentry&#39;s</span>
<span class="cm">			 * storage to target and make dentry internal</span>
<span class="cm">			 */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_iname</span><span class="p">,</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
					<span class="n">target</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">target</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_iname</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Both are internal.  Just copy target to dentry</span>
<span class="cm">			 */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_iname</span><span class="p">,</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
					<span class="n">target</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">swap</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dentry_lock_for_move</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * XXXX: do we really need to take target-&gt;d_lock?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ROOT</span><span class="p">(</span><span class="n">dentry</span><span class="p">)</span> <span class="o">||</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">==</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">)</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d_ancestor</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">,</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="n">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">,</span>
						<span class="n">DENTRY_D_LOCK_NESTED</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="n">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">,</span>
						<span class="n">DENTRY_D_LOCK_NESTED</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">&lt;</span> <span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dentry_unlock_parents_for_move</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">!=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">)</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">!=</span> <span class="n">target</span><span class="p">)</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When switching names, the actual string doesn&#39;t strictly have to</span>
<span class="cm"> * be preserved in the target - because we&#39;re dropping the target</span>
<span class="cm"> * anyway. As such, we can just do a simple memcpy() to copy over</span>
<span class="cm"> * the new name before we switch.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we have to be a lot more careful about getting the hash</span>
<span class="cm"> * switched - we have to switch the hash value properly even if it</span>
<span class="cm"> * then no longer matches the actual (corrupted) string of the target.</span>
<span class="cm"> * The hash value has to match the hash queue that the dentry is on..</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * __d_move - move a dentry</span>
<span class="cm"> * @dentry: entry to move</span>
<span class="cm"> * @target: new dentry</span>
<span class="cm"> *</span>
<span class="cm"> * Update the dcache to reflect the move of a file name. Negative</span>
<span class="cm"> * dcache entries should not be moved in this way. Caller must hold</span>
<span class="cm"> * rename_lock, the i_mutex of the source and target directories,</span>
<span class="cm"> * and the sb-&gt;s_vfs_rename_mutex if they differ. See lock_rename().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__d_move</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;VFS: moving negative dcache entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">d_ancestor</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">target</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">d_ancestor</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">dentry</span><span class="p">));</span>

	<span class="n">dentry_lock_for_move</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>

	<span class="n">write_seqcount_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>
	<span class="n">write_seqcount_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>

	<span class="cm">/* __d_drop does write_seqcount_barrier, but they&#39;re OK to nest. */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Move the dentry to the target hash queue. Don&#39;t bother checking</span>
<span class="cm">	 * for the same hash queue because of how unlikely it is.</span>
<span class="cm">	 */</span>
	<span class="n">__d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">__d_rehash</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">d_hash</span><span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">,</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash</span><span class="p">));</span>

	<span class="cm">/* Unhash the target: dput() will then get rid of it */</span>
	<span class="n">__d_drop</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">);</span>

	<span class="cm">/* Switch the names.. */</span>
	<span class="n">switch_names</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
	<span class="n">swap</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash</span><span class="p">,</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash</span><span class="p">);</span>

	<span class="cm">/* ... and switch the parents */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ROOT</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>
		<span class="n">target</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">swap</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">,</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">);</span>

		<span class="cm">/* And add them back to the (new) parent lists */</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">);</span>

	<span class="n">write_seqcount_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>
	<span class="n">write_seqcount_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>

	<span class="n">dentry_unlock_parents_for_move</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">fsnotify_d_move</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * d_move - move a dentry</span>
<span class="cm"> * @dentry: entry to move</span>
<span class="cm"> * @target: new dentry</span>
<span class="cm"> *</span>
<span class="cm"> * Update the dcache to reflect the move of a file name. Negative</span>
<span class="cm"> * dcache entries should not be moved in this way. See the locking</span>
<span class="cm"> * requirements for __d_move.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">d_move</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_seqlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
	<span class="n">__d_move</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
	<span class="n">write_sequnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">d_move</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * d_ancestor - search for an ancestor</span>
<span class="cm"> * @p1: ancestor dentry</span>
<span class="cm"> * @p2: child dentry</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the ancestor dentry of p2 which is a child of p1, if p1 is</span>
<span class="cm"> * an ancestor of p2, else NULL.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">d_ancestor</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">p2</span><span class="p">;</span> <span class="o">!</span><span class="n">IS_ROOT</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">==</span> <span class="n">p1</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This helper attempts to cope with remotely renamed directories</span>
<span class="cm"> *</span>
<span class="cm"> * It assumes that the caller is already holding</span>
<span class="cm"> * dentry-&gt;d_parent-&gt;d_inode-&gt;i_mutex, inode-&gt;i_lock and rename_lock</span>
<span class="cm"> *</span>
<span class="cm"> * Note: If ever the locking in lock_rename() changes, then please</span>
<span class="cm"> * remember to update this too...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">__d_unalias</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">alias</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">m1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">m2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* If alias and dentry share a parent, then no extra locks required */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alias</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">==</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unalias</span><span class="p">;</span>

	<span class="cm">/* See lock_rename() */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EBUSY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_vfs_rename_mutex</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="n">m1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_vfs_rename_mutex</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alias</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="n">m2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">alias</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">;</span>
<span class="nl">out_unalias:</span>
	<span class="n">__d_move</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">alias</span><span class="p">;</span>
<span class="nl">out_err:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m2</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">m2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m1</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="n">m1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Prepare an anonymous dentry for life in the superblock&#39;s dentry tree as a</span>
<span class="cm"> * named dentry in place of the dentry to be replaced.</span>
<span class="cm"> * returns with anon-&gt;d_lock held!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__d_materialise_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">anon</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dparent</span><span class="p">,</span> <span class="o">*</span><span class="n">aparent</span><span class="p">;</span>

	<span class="n">dentry_lock_for_move</span><span class="p">(</span><span class="n">anon</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>

	<span class="n">write_seqcount_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>
	<span class="n">write_seqcount_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>

	<span class="n">dparent</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>
	<span class="n">aparent</span> <span class="o">=</span> <span class="n">anon</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>

	<span class="n">switch_names</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">anon</span><span class="p">);</span>
	<span class="n">swap</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash</span><span class="p">,</span> <span class="n">anon</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash</span><span class="p">);</span>

	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">=</span> <span class="p">(</span><span class="n">aparent</span> <span class="o">==</span> <span class="n">anon</span><span class="p">)</span> <span class="o">?</span> <span class="n">dentry</span> <span class="o">:</span> <span class="n">aparent</span><span class="p">;</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ROOT</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">);</span>

	<span class="n">anon</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">=</span> <span class="p">(</span><span class="n">dparent</span> <span class="o">==</span> <span class="n">dentry</span><span class="p">)</span> <span class="o">?</span> <span class="n">anon</span> <span class="o">:</span> <span class="n">dparent</span><span class="p">;</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ROOT</span><span class="p">(</span><span class="n">anon</span><span class="p">))</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">anon</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">);</span>

	<span class="n">write_seqcount_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>
	<span class="n">write_seqcount_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">anon</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>

	<span class="n">dentry_unlock_parents_for_move</span><span class="p">(</span><span class="n">anon</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>

	<span class="cm">/* anon-&gt;d_lock still locked, returns locked */</span>
	<span class="n">anon</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DCACHE_DISCONNECTED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * d_materialise_unique - introduce an inode into the tree</span>
<span class="cm"> * @dentry: candidate dentry</span>
<span class="cm"> * @inode: inode to bind to the dentry, to which aliases may be attached</span>
<span class="cm"> *</span>
<span class="cm"> * Introduces an dentry into the tree, substituting an extant disconnected</span>
<span class="cm"> * root directory alias in its place if there is one. Caller must hold the</span>
<span class="cm"> * i_mutex of the parent directory.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">d_materialise_unique</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">actual</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">d_unhashed</span><span class="p">(</span><span class="n">dentry</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">actual</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
		<span class="n">__d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">d_rehash</span><span class="p">(</span><span class="n">actual</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_nolock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">alias</span><span class="p">;</span>

		<span class="cm">/* Does an aliased dentry already exist? */</span>
		<span class="n">alias</span> <span class="o">=</span> <span class="n">__d_find_alias</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">alias</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">actual</span> <span class="o">=</span> <span class="n">alias</span><span class="p">;</span>
			<span class="n">write_seqlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">d_ancestor</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Check for loops */</span>
				<span class="n">actual</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ELOOP</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_ROOT</span><span class="p">(</span><span class="n">alias</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Is this an anonymous mountpoint that we</span>
<span class="cm">				 * could splice into our tree? */</span>
				<span class="n">__d_materialise_dentry</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">alias</span><span class="p">);</span>
				<span class="n">write_sequnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
				<span class="n">__d_drop</span><span class="p">(</span><span class="n">alias</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Nope, but we must(!) avoid directory</span>
<span class="cm">				 * aliasing. This drops inode-&gt;i_lock */</span>
				<span class="n">actual</span> <span class="o">=</span> <span class="n">__d_unalias</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">alias</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">write_sequnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">actual</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">actual</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">ELOOP</span><span class="p">)</span>
					<span class="n">pr_warn_ratelimited</span><span class="p">(</span>
						<span class="s">&quot;VFS: Lookup of &#39;%s&#39; in %s %s&quot;</span>
						<span class="s">&quot; would have caused loop</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
						<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
						<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">);</span>
				<span class="n">dput</span><span class="p">(</span><span class="n">alias</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">out_nolock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Add a unique reference */</span>
	<span class="n">actual</span> <span class="o">=</span> <span class="n">__d_instantiate_unique</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">actual</span><span class="p">)</span>
		<span class="n">actual</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">d_unhashed</span><span class="p">(</span><span class="n">actual</span><span class="p">));</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">actual</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="nl">found:</span>
	<span class="n">_d_rehash</span><span class="p">(</span><span class="n">actual</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">actual</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
<span class="nl">out_nolock:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">actual</span> <span class="o">==</span> <span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">security_d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">actual</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">d_materialise_unique</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">prepend</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">buflen</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">buflen</span> <span class="o">-=</span> <span class="n">namelen</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">buflen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">;</span>
	<span class="o">*</span><span class="n">buffer</span> <span class="o">-=</span> <span class="n">namelen</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">prepend_name</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">buflen</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">prepend</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">buflen</span><span class="p">,</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * prepend_path - Prepend path string to a buffer</span>
<span class="cm"> * @path: the dentry/vfsmount to report</span>
<span class="cm"> * @root: root vfsmnt/dentry</span>
<span class="cm"> * @buffer: pointer to the end of the buffer</span>
<span class="cm"> * @buflen: pointer to buffer length</span>
<span class="cm"> *</span>
<span class="cm"> * Caller holds the rename_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">prepend_path</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">**</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">vfsmnt</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mount</span> <span class="o">*</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">real_mount</span><span class="p">(</span><span class="n">vfsmnt</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">slash</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">br_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">dentry</span> <span class="o">!=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">||</span> <span class="n">vfsmnt</span> <span class="o">!=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">parent</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span> <span class="o">==</span> <span class="n">vfsmnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span> <span class="o">||</span> <span class="n">IS_ROOT</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Global root? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mnt_has_parent</span><span class="p">(</span><span class="n">mnt</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">global_root</span><span class="p">;</span>
			<span class="n">dentry</span> <span class="o">=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_mountpoint</span><span class="p">;</span>
			<span class="n">mnt</span> <span class="o">=</span> <span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_parent</span><span class="p">;</span>
			<span class="n">vfsmnt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>
		<span class="n">prefetch</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">prepend_name</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">buflen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">prepend</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">buflen</span><span class="p">,</span> <span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">slash</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">dentry</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">slash</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">prepend</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">buflen</span><span class="p">,</span> <span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">br_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vfsmount_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

<span class="nl">global_root:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Filesystems needing to implement special &quot;root names&quot;</span>
<span class="cm">	 * should do so with -&gt;d_dname()</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ROOT</span><span class="p">(</span><span class="n">dentry</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;/&#39;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Root dentry has weird name &lt;%.*s&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slash</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">prepend</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">buflen</span><span class="p">,</span> <span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">real_mount</span><span class="p">(</span><span class="n">vfsmnt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mnt_ns</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __d_path - return the path of a dentry</span>
<span class="cm"> * @path: the dentry/vfsmount to report</span>
<span class="cm"> * @root: root vfsmnt/dentry</span>
<span class="cm"> * @buf: buffer to return value in</span>
<span class="cm"> * @buflen: buffer length</span>
<span class="cm"> *</span>
<span class="cm"> * Convert a dentry into an ASCII path name.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer into the buffer or an error code if the</span>
<span class="cm"> * path was too long.</span>
<span class="cm"> *</span>
<span class="cm"> * &quot;buflen&quot; should be positive.</span>
<span class="cm"> *</span>
<span class="cm"> * If the path is not reachable from the supplied root, return %NULL.</span>
<span class="cm"> */</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">__d_path</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
	       <span class="k">const</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
	       <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">buflen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">prepend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buflen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">write_seqlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">prepend_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buflen</span><span class="p">);</span>
	<span class="n">write_sequnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">d_absolute_path</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
	       <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">root</span> <span class="o">=</span> <span class="p">{};</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">buflen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">prepend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buflen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">write_seqlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">prepend_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buflen</span><span class="p">);</span>
	<span class="n">write_sequnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * same as __d_path but appends &quot;(deleted)&quot; for unlinked files.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">path_with_deleted</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="o">**</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">prepend</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d_unlinked</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">prepend</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">,</span> <span class="s">&quot; (deleted)&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">prepend_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">prepend_unreachable</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">prepend</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">buflen</span><span class="p">,</span> <span class="s">&quot;(unreachable)&quot;</span><span class="p">,</span> <span class="mi">13</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * d_path - return the path of a dentry</span>
<span class="cm"> * @path: path to report</span>
<span class="cm"> * @buf: buffer to return value in</span>
<span class="cm"> * @buflen: buffer length</span>
<span class="cm"> *</span>
<span class="cm"> * Convert a dentry into an ASCII path name. If the entry has been deleted</span>
<span class="cm"> * the string &quot; (deleted)&quot; is appended. Note that this is ambiguous.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer into the buffer or an error code if the path was</span>
<span class="cm"> * too long. Note: Callers should use the returned pointer, not the passed</span>
<span class="cm"> * in buffer, to use the name! The implementation often starts at an offset</span>
<span class="cm"> * into the buffer, and may leave 0 bytes at the start.</span>
<span class="cm"> *</span>
<span class="cm"> * &quot;buflen&quot; should be positive.</span>
<span class="cm"> */</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">d_path</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">buflen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have various synthetic filesystems that never get mounted.  On</span>
<span class="cm">	 * these filesystems dentries are never used for lookup purposes, and</span>
<span class="cm">	 * thus don&#39;t need to be hashed.  They also don&#39;t need a name until a</span>
<span class="cm">	 * user wants to identify the object in /proc/pid/fd/.  The little hack</span>
<span class="cm">	 * below allows us to generate a name for these objects on demand:</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_dname</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_dname</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">);</span>

	<span class="n">get_fs_root</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="p">);</span>
	<span class="n">write_seqlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">path_with_deleted</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buflen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="n">write_sequnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">d_path</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * d_path_with_unreachable - return the path of a dentry</span>
<span class="cm"> * @path: path to report</span>
<span class="cm"> * @buf: buffer to return value in</span>
<span class="cm"> * @buflen: buffer length</span>
<span class="cm"> *</span>
<span class="cm"> * The difference from d_path() is that this prepends &quot;(unreachable)&quot;</span>
<span class="cm"> * to paths which are unreachable from the current process&#39; root.</span>
<span class="cm"> */</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">d_path_with_unreachable</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">buflen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_dname</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_dname</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">);</span>

	<span class="n">get_fs_root</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="p">);</span>
	<span class="n">write_seqlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">path_with_deleted</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buflen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">prepend_unreachable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buflen</span><span class="p">);</span>
	<span class="n">write_sequnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">res</span> <span class="o">=</span>  <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Helper function for dentry_operations.d_dname() members</span>
<span class="cm"> */</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">dynamic_dname</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">temp</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">sz</span> <span class="o">=</span> <span class="n">vsnprintf</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp</span><span class="p">),</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sz</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">||</span> <span class="n">sz</span> <span class="o">&gt;</span> <span class="n">buflen</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">);</span>

	<span class="n">buffer</span> <span class="o">+=</span> <span class="n">buflen</span> <span class="o">-</span> <span class="n">sz</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write full pathname from the root of the filesystem into the buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">__dentry_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">buflen</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>

	<span class="n">prepend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buflen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">Elong</span><span class="p">;</span>
	<span class="cm">/* Get &#39;/&#39; right */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">end</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="o">*</span><span class="n">retval</span> <span class="o">=</span> <span class="sc">&#39;/&#39;</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ROOT</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">prefetch</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">prepend_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buflen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">prepend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buflen</span><span class="p">,</span> <span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">Elong</span><span class="p">;</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
		<span class="n">dentry</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="nl">Elong:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">dentry_path_raw</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>

	<span class="n">write_seqlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">__dentry_path</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">);</span>
	<span class="n">write_sequnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dentry_path_raw</span><span class="p">);</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">dentry_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>

	<span class="n">write_seqlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d_unlinked</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">buflen</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prepend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buflen</span><span class="p">,</span> <span class="s">&quot;//deleted&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">Elong</span><span class="p">;</span>
		<span class="n">buflen</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">__dentry_path</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">);</span>
	<span class="n">write_sequnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">)</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;/&#39;</span><span class="p">;</span>	<span class="cm">/* restore &#39;/&#39; overriden with &#39;\0&#39; */</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="nl">Elong:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NOTE! The user-level library version returns a</span>
<span class="cm"> * character pointer. The kernel system call just</span>
<span class="cm"> * returns the length of the buffer filled (which</span>
<span class="cm"> * includes the ending &#39;\0&#39; character), or a negative</span>
<span class="cm"> * error value. So libc would do something like</span>
<span class="cm"> *</span>
<span class="cm"> *	char *getcwd(char * buf, size_t size)</span>
<span class="cm"> *	{</span>
<span class="cm"> *		int retval;</span>
<span class="cm"> *</span>
<span class="cm"> *		retval = sys_getcwd(buf, size);</span>
<span class="cm"> *		if (retval &gt;= 0)</span>
<span class="cm"> *			return buf;</span>
<span class="cm"> *		errno = -retval;</span>
<span class="cm"> *		return NULL;</span>
<span class="cm"> *	}</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">getcwd</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">pwd</span><span class="p">,</span> <span class="n">root</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_USER</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">get_fs_root_and_pwd</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pwd</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">write_seqlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_unlinked</span><span class="p">(</span><span class="n">pwd</span><span class="p">.</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">cwd</span> <span class="o">=</span> <span class="n">page</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">buflen</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

		<span class="n">prepend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cwd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buflen</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\0</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">prepend_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pwd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cwd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buflen</span><span class="p">);</span>
		<span class="n">write_sequnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* Unreachable from current root */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">prepend_unreachable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cwd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buflen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">+</span> <span class="n">page</span> <span class="o">-</span> <span class="n">cwd</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">cwd</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
				<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">write_sequnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pwd</span><span class="p">);</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="p">);</span>
	<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Test whether new_dentry is a subdirectory of old_dentry.</span>
<span class="cm"> *</span>
<span class="cm"> * Trivially implemented using the dcache structure</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * is_subdir - is new dentry a subdirectory of old_dentry</span>
<span class="cm"> * @new_dentry: new dentry</span>
<span class="cm"> * @old_dentry: old dentry</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if new_dentry is a subdirectory of the parent (at any depth).</span>
<span class="cm"> * Returns 0 otherwise.</span>
<span class="cm"> * Caller must ensure that &quot;new_dentry&quot; is pinned before calling is_subdir()</span>
<span class="cm"> */</span>
  
<span class="kt">int</span> <span class="n">is_subdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">seq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_dentry</span> <span class="o">==</span> <span class="n">old_dentry</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* for restarting inner loop in case of seq retry */</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Need rcu_readlock to protect against the d_parent trashing</span>
<span class="cm">		 * due to d_move</span>
<span class="cm">		 */</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d_ancestor</span><span class="p">(</span><span class="n">old_dentry</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">))</span>
			<span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">d_genocide</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">this_parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">seq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
<span class="nl">again:</span>
	<span class="n">this_parent</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="nl">repeat:</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
<span class="nl">resume:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">);</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

		<span class="n">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">,</span> <span class="n">DENTRY_D_LOCK_NESTED</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d_unhashed</span><span class="p">(</span><span class="n">dentry</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="n">spin_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">.</span><span class="n">dep_map</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
			<span class="n">this_parent</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
			<span class="n">spin_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">.</span><span class="n">dep_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_GENOCIDE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="n">DCACHE_GENOCIDE</span><span class="p">;</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this_parent</span> <span class="o">!=</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">child</span> <span class="o">=</span> <span class="n">this_parent</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_GENOCIDE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="n">DCACHE_GENOCIDE</span><span class="p">;</span>
			<span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">this_parent</span> <span class="o">=</span> <span class="n">try_to_ascend</span><span class="p">(</span><span class="n">this_parent</span><span class="p">,</span> <span class="n">locked</span><span class="p">,</span> <span class="n">seq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this_parent</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">rename_retry</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_child</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">resume</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span> <span class="o">&amp;&amp;</span> <span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">rename_retry</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">locked</span><span class="p">)</span>
		<span class="n">write_sequnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">rename_retry:</span>
	<span class="n">locked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">write_seqlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_inode_number - check for dentry with name</span>
<span class="cm"> * @dir: directory to check</span>
<span class="cm"> * @name: Name to find.</span>
<span class="cm"> *</span>
<span class="cm"> * Check whether a dentry already exists for the given name,</span>
<span class="cm"> * and return the inode number if it has an inode. Otherwise</span>
<span class="cm"> * 0 is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to post-process directory listings for</span>
<span class="cm"> * filesystems using synthetic inode numbers, and is necessary</span>
<span class="cm"> * to keep getcwd() working.</span>
<span class="cm"> */</span>
 
<span class="n">ino_t</span> <span class="n">find_inode_number</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">ino</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">d_hash_and_lookup</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
			<span class="n">ino</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ino</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">find_inode_number</span><span class="p">);</span>

<span class="k">static</span> <span class="n">__initdata</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dhash_entries</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">set_dhash_entries</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dhash_entries</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;dhash_entries=&quot;</span><span class="p">,</span> <span class="n">set_dhash_entries</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">dcache_init_early</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">loop</span><span class="p">;</span>

	<span class="cm">/* If hashes are distributed across NUMA nodes, defer</span>
<span class="cm">	 * hash allocation until vmalloc space is available.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hashdist</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dentry_hashtable</span> <span class="o">=</span>
		<span class="n">alloc_large_system_hash</span><span class="p">(</span><span class="s">&quot;Dentry cache&quot;</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_bl_head</span><span class="p">),</span>
					<span class="n">dhash_entries</span><span class="p">,</span>
					<span class="mi">13</span><span class="p">,</span>
					<span class="n">HASH_EARLY</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">d_hash_shift</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">d_hash_mask</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">loop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">loop</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">d_hash_shift</span><span class="p">);</span> <span class="n">loop</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_HLIST_BL_HEAD</span><span class="p">(</span><span class="n">dentry_hashtable</span> <span class="o">+</span> <span class="n">loop</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">dcache_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">loop</span><span class="p">;</span>

	<span class="cm">/* </span>
<span class="cm">	 * A constructor could be added for stable state like the lists,</span>
<span class="cm">	 * but it is probably not worth it because of the cache nature</span>
<span class="cm">	 * of the dcache. </span>
<span class="cm">	 */</span>
	<span class="n">dentry_cache</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span>
		<span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="o">|</span><span class="n">SLAB_PANIC</span><span class="o">|</span><span class="n">SLAB_MEM_SPREAD</span><span class="p">);</span>

	<span class="cm">/* Hash may have been set up in dcache_init_early */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hashdist</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dentry_hashtable</span> <span class="o">=</span>
		<span class="n">alloc_large_system_hash</span><span class="p">(</span><span class="s">&quot;Dentry cache&quot;</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_bl_head</span><span class="p">),</span>
					<span class="n">dhash_entries</span><span class="p">,</span>
					<span class="mi">13</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">d_hash_shift</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">d_hash_mask</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">loop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">loop</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">d_hash_shift</span><span class="p">);</span> <span class="n">loop</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_HLIST_BL_HEAD</span><span class="p">(</span><span class="n">dentry_hashtable</span> <span class="o">+</span> <span class="n">loop</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* SLAB cache for __getname() consumers */</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">names_cachep</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">names_cachep</span><span class="p">);</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">d_genocide</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">vfs_caches_init_early</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dcache_init_early</span><span class="p">();</span>
	<span class="n">inode_init_early</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">vfs_caches_init</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mempages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reserve</span><span class="p">;</span>

	<span class="cm">/* Base hash sizes on available memory, with a reserve equal to</span>
<span class="cm">           150% of current kernel size */</span>

	<span class="n">reserve</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="n">mempages</span> <span class="o">-</span> <span class="n">nr_free_pages</span><span class="p">())</span> <span class="o">*</span> <span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">mempages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mempages</span> <span class="o">-=</span> <span class="n">reserve</span><span class="p">;</span>

	<span class="n">names_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;names_cache&quot;</span><span class="p">,</span> <span class="n">PATH_MAX</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">SLAB_HWCACHE_ALIGN</span><span class="o">|</span><span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">dcache_init</span><span class="p">();</span>
	<span class="n">inode_init</span><span class="p">();</span>
	<span class="n">files_init</span><span class="p">(</span><span class="n">mempages</span><span class="p">);</span>
	<span class="n">mnt_init</span><span class="p">();</span>
	<span class="n">bdev_cache_init</span><span class="p">();</span>
	<span class="n">chrdev_init</span><span class="p">();</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
