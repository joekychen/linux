<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › mpage.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>mpage.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * fs/mpage.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2002, Linus Torvalds.</span>
<span class="cm"> *</span>
<span class="cm"> * Contains functions related to preparing and submitting BIOs which contain</span>
<span class="cm"> * multiple pagecache pages.</span>
<span class="cm"> *</span>
<span class="cm"> * 15May2002	Andrew Morton</span>
<span class="cm"> *		Initial version</span>
<span class="cm"> * 27Jun2002	axboe@suse.de</span>
<span class="cm"> *		use bio_add_page() to build bio&#39;s just the right size</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/kdev_t.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/bio.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>
<span class="cp">#include &lt;linux/mpage.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/pagevec.h&gt;</span>
<span class="cp">#include &lt;linux/cleancache.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * I/O completion handler for multipage BIOs.</span>
<span class="cm"> *</span>
<span class="cm"> * The mpage code never puts partial pages into a BIO (except for end-of-file).</span>
<span class="cm"> * If a page does not map to a contiguous run of blocks then it simply falls</span>
<span class="cm"> * back to block_read_full_page().</span>
<span class="cm"> *</span>
<span class="cm"> * Why is this?  If a page&#39;s completion depends on a number of different BIOs</span>
<span class="cm"> * which can complete in any order (or at the same time) then determining the</span>
<span class="cm"> * status of that page is hard.  See end_buffer_async_read() for the details.</span>
<span class="cm"> * There is no point in duplicating all that complexity.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mpage_end_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">uptodate</span> <span class="o">=</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">BIO_UPTODATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span> <span class="o">+</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">bvec</span> <span class="o">&gt;=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">)</span>
			<span class="n">prefetchw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bio_data_dir</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">uptodate</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">ClearPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">SetPageError</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* bio_data_dir(bio) == WRITE */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uptodate</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">SetPageError</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">)</span>
					<span class="n">set_bit</span><span class="p">(</span><span class="n">AS_EIO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">end_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bvec</span> <span class="o">&gt;=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">);</span>
	<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="nf">mpage_bio_submit</span><span class="p">(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">mpage_end_io</span><span class="p">;</span>
	<span class="n">submit_bio</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span>
<span class="nf">mpage_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
		<span class="n">sector_t</span> <span class="n">first_sector</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_vecs</span><span class="p">,</span>
		<span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>

	<span class="n">bio</span> <span class="o">=</span> <span class="n">bio_alloc</span><span class="p">(</span><span class="n">gfp_flags</span><span class="p">,</span> <span class="n">nr_vecs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_MEMALLOC</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">bio</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nr_vecs</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">))</span>
			<span class="n">bio</span> <span class="o">=</span> <span class="n">bio_alloc</span><span class="p">(</span><span class="n">gfp_flags</span><span class="p">,</span> <span class="n">nr_vecs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">bdev</span><span class="p">;</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">first_sector</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">bio</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * support function for mpage_readpages.  The fs supplied get_block might</span>
<span class="cm"> * return an up to date buffer.  This is used to map that buffer into</span>
<span class="cm"> * the page, which allows readpage to avoid triggering a duplicate call</span>
<span class="cm"> * to get_block.</span>
<span class="cm"> *</span>
<span class="cm"> * The idea is to avoid adding buffers to pages that don&#39;t already have</span>
<span class="cm"> * them.  So when the buffer is up to date and the page size == block size,</span>
<span class="cm"> * this marks the page up to date instead of adding new buffers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> 
<span class="nf">map_buffer_to_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page_block</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">page_bh</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * don&#39;t make any buffers if there is only one buffer on</span>
<span class="cm">		 * the page and the page just needs to be set up to date</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span> <span class="o">==</span> <span class="n">PAGE_CACHE_SHIFT</span> <span class="o">&amp;&amp;</span> 
		    <span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>    
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">create_empty_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">==</span> <span class="n">page_block</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page_bh</span><span class="o">-&gt;</span><span class="n">b_state</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">;</span>
			<span class="n">page_bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">;</span>
			<span class="n">page_bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">page_bh</span> <span class="o">=</span> <span class="n">page_bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
		<span class="n">block</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">page_bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is the worker routine which does all the work of mapping the disk</span>
<span class="cm"> * blocks and constructs largest possible bios, submits them for IO if the</span>
<span class="cm"> * blocks are not contiguous on the disk.</span>
<span class="cm"> *</span>
<span class="cm"> * We pass a buffer_head back and forth and use its buffer_mapped() flag to</span>
<span class="cm"> * represent the validity of its disk mapping and to decide when to do the next</span>
<span class="cm"> * get_block() call.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span>
<span class="nf">do_mpage_readpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nr_pages</span><span class="p">,</span>
		<span class="n">sector_t</span> <span class="o">*</span><span class="n">last_block_in_bio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">map_bh</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">first_logical_block</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="n">get_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">blkbits</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">blocks_per_page</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">block_in_file</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">last_block</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">last_block_in_file</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">blocks</span><span class="p">[</span><span class="n">MAX_BUF_PER_PAGE</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">page_block</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">first_hole</span> <span class="o">=</span> <span class="n">blocks_per_page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fully_mapped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">nblocks</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">relative_block</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">confused</span><span class="p">;</span>

	<span class="n">block_in_file</span> <span class="o">=</span> <span class="p">(</span><span class="n">sector_t</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">blkbits</span><span class="p">);</span>
	<span class="n">last_block</span> <span class="o">=</span> <span class="n">block_in_file</span> <span class="o">+</span> <span class="n">nr_pages</span> <span class="o">*</span> <span class="n">blocks_per_page</span><span class="p">;</span>
	<span class="n">last_block_in_file</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">+</span> <span class="n">blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_block</span> <span class="o">&gt;</span> <span class="n">last_block_in_file</span><span class="p">)</span>
		<span class="n">last_block</span> <span class="o">=</span> <span class="n">last_block_in_file</span><span class="p">;</span>
	<span class="n">page_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Map blocks using the result from the previous get_blocks call first.</span>
<span class="cm">	 */</span>
	<span class="n">nblocks</span> <span class="o">=</span> <span class="n">map_bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">map_bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">block_in_file</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">first_logical_block</span> <span class="o">&amp;&amp;</span>
			<span class="n">block_in_file</span> <span class="o">&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">first_logical_block</span> <span class="o">+</span> <span class="n">nblocks</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">map_offset</span> <span class="o">=</span> <span class="n">block_in_file</span> <span class="o">-</span> <span class="o">*</span><span class="n">first_logical_block</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">last</span> <span class="o">=</span> <span class="n">nblocks</span> <span class="o">-</span> <span class="n">map_offset</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">relative_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">relative_block</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">relative_block</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">clear_buffer_mapped</span><span class="p">(</span><span class="n">map_bh</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page_block</span> <span class="o">==</span> <span class="n">blocks_per_page</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">blocks</span><span class="p">[</span><span class="n">page_block</span><span class="p">]</span> <span class="o">=</span> <span class="n">map_bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">+</span> <span class="n">map_offset</span> <span class="o">+</span>
						<span class="n">relative_block</span><span class="p">;</span>
			<span class="n">page_block</span><span class="o">++</span><span class="p">;</span>
			<span class="n">block_in_file</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bdev</span> <span class="o">=</span> <span class="n">map_bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Then do more get_blocks calls until we are done with this page.</span>
<span class="cm">	 */</span>
	<span class="n">map_bh</span><span class="o">-&gt;</span><span class="n">b_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">page_block</span> <span class="o">&lt;</span> <span class="n">blocks_per_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">map_bh</span><span class="o">-&gt;</span><span class="n">b_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">map_bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">block_in_file</span> <span class="o">&lt;</span> <span class="n">last_block</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">map_bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">last_block</span><span class="o">-</span><span class="n">block_in_file</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">get_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block_in_file</span><span class="p">,</span> <span class="n">map_bh</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">confused</span><span class="p">;</span>
			<span class="o">*</span><span class="n">first_logical_block</span> <span class="o">=</span> <span class="n">block_in_file</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">map_bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">fully_mapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">first_hole</span> <span class="o">==</span> <span class="n">blocks_per_page</span><span class="p">)</span>
				<span class="n">first_hole</span> <span class="o">=</span> <span class="n">page_block</span><span class="p">;</span>
			<span class="n">page_block</span><span class="o">++</span><span class="p">;</span>
			<span class="n">block_in_file</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* some filesystems will copy data into the page during</span>
<span class="cm">		 * the get_block call, in which case we don&#39;t want to</span>
<span class="cm">		 * read it again.  map_buffer_to_page copies the data</span>
<span class="cm">		 * we just collected from get_block into the page&#39;s buffers</span>
<span class="cm">		 * so readpage doesn&#39;t have to repeat the get_block call</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">map_bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">map_buffer_to_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">map_bh</span><span class="p">,</span> <span class="n">page_block</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">confused</span><span class="p">;</span>
		<span class="p">}</span>
	
		<span class="k">if</span> <span class="p">(</span><span class="n">first_hole</span> <span class="o">!=</span> <span class="n">blocks_per_page</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">confused</span><span class="p">;</span>		<span class="cm">/* hole -&gt; non-hole */</span>

		<span class="cm">/* Contiguous blocks? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_block</span> <span class="o">&amp;&amp;</span> <span class="n">blocks</span><span class="p">[</span><span class="n">page_block</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">map_bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">confused</span><span class="p">;</span>
		<span class="n">nblocks</span> <span class="o">=</span> <span class="n">map_bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">relative_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">relative_block</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">relative_block</span> <span class="o">==</span> <span class="n">nblocks</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">clear_buffer_mapped</span><span class="p">(</span><span class="n">map_bh</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">page_block</span> <span class="o">==</span> <span class="n">blocks_per_page</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">blocks</span><span class="p">[</span><span class="n">page_block</span><span class="p">]</span> <span class="o">=</span> <span class="n">map_bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="o">+</span><span class="n">relative_block</span><span class="p">;</span>
			<span class="n">page_block</span><span class="o">++</span><span class="p">;</span>
			<span class="n">block_in_file</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bdev</span> <span class="o">=</span> <span class="n">map_bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">first_hole</span> <span class="o">!=</span> <span class="n">blocks_per_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">zero_user_segment</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">first_hole</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">first_hole</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fully_mapped</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SetPageMappedToDisk</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fully_mapped</span> <span class="o">&amp;&amp;</span> <span class="n">blocks_per_page</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cleancache_get_page</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">confused</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This page will go to BIO.  Do we need to send this BIO off first?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">last_block_in_bio</span> <span class="o">!=</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">bio</span> <span class="o">=</span> <span class="n">mpage_bio_submit</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

<span class="nl">alloc_new:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bio</span> <span class="o">=</span> <span class="n">mpage_alloc</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">blkbits</span> <span class="o">-</span> <span class="mi">9</span><span class="p">),</span>
			  	<span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">bio_get_nr_vecs</span><span class="p">(</span><span class="n">bdev</span><span class="p">)),</span>
				<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bio</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">confused</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">length</span> <span class="o">=</span> <span class="n">first_hole</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio_add_page</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bio</span> <span class="o">=</span> <span class="n">mpage_bio_submit</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">alloc_new</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">relative_block</span> <span class="o">=</span> <span class="n">block_in_file</span> <span class="o">-</span> <span class="o">*</span><span class="n">first_logical_block</span><span class="p">;</span>
	<span class="n">nblocks</span> <span class="o">=</span> <span class="n">map_bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">buffer_boundary</span><span class="p">(</span><span class="n">map_bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">relative_block</span> <span class="o">==</span> <span class="n">nblocks</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">first_hole</span> <span class="o">!=</span> <span class="n">blocks_per_page</span><span class="p">))</span>
		<span class="n">bio</span> <span class="o">=</span> <span class="n">mpage_bio_submit</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">last_block_in_bio</span> <span class="o">=</span> <span class="n">blocks</span><span class="p">[</span><span class="n">blocks_per_page</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">bio</span><span class="p">;</span>

<span class="nl">confused:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="p">)</span>
		<span class="n">bio</span> <span class="o">=</span> <span class="n">mpage_bio_submit</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
	        <span class="n">block_read_full_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">get_block</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mpage_readpages - populate an address space with some pages &amp; start reads against them</span>
<span class="cm"> * @mapping: the address_space</span>
<span class="cm"> * @pages: The address of a list_head which contains the target pages.  These</span>
<span class="cm"> *   pages have their -&gt;index populated and are otherwise uninitialised.</span>
<span class="cm"> *   The page at @pages-&gt;prev has the lowest file offset, and reads should be</span>
<span class="cm"> *   issued in @pages-&gt;prev to @pages-&gt;next order.</span>
<span class="cm"> * @nr_pages: The number of pages at *@pages</span>
<span class="cm"> * @get_block: The filesystem&#39;s block mapper function.</span>
<span class="cm"> *</span>
<span class="cm"> * This function walks the pages and the blocks within each page, building and</span>
<span class="cm"> * emitting large BIOs.</span>
<span class="cm"> *</span>
<span class="cm"> * If anything unusual happens, such as:</span>
<span class="cm"> *</span>
<span class="cm"> * - encountering a page which has buffers</span>
<span class="cm"> * - encountering a page which has a non-hole after a hole</span>
<span class="cm"> * - encountering a page with non-contiguous blocks</span>
<span class="cm"> *</span>
<span class="cm"> * then this code just gives up and calls the buffer_head-based read function.</span>
<span class="cm"> * It does handle a page which has holes at the end - that is a common case:</span>
<span class="cm"> * the end-of-file on blocksize &lt; PAGE_CACHE_SIZE setups.</span>
<span class="cm"> *</span>
<span class="cm"> * BH_Boundary explanation:</span>
<span class="cm"> *</span>
<span class="cm"> * There is a problem.  The mpage read code assembles several pages, gets all</span>
<span class="cm"> * their disk mappings, and then submits them all.  That&#39;s fine, but obtaining</span>
<span class="cm"> * the disk mappings may require I/O.  Reads of indirect blocks, for example.</span>
<span class="cm"> *</span>
<span class="cm"> * So an mpage read of the first 16 blocks of an ext2 file will cause I/O to be</span>
<span class="cm"> * submitted in the following order:</span>
<span class="cm"> * 	12 0 1 2 3 4 5 6 7 8 9 10 11 13 14 15 16</span>
<span class="cm"> *</span>
<span class="cm"> * because the indirect block has to be read to get the mappings of blocks</span>
<span class="cm"> * 13,14,15,16.  Obviously, this impacts performance.</span>
<span class="cm"> *</span>
<span class="cm"> * So what we do it to allow the filesystem&#39;s get_block() function to set</span>
<span class="cm"> * BH_Boundary when it maps block 11.  BH_Boundary says: mapping of the block</span>
<span class="cm"> * after this one will require I/O against a block which is probably close to</span>
<span class="cm"> * this one.  So you should push what I/O you have currently accumulated.</span>
<span class="cm"> *</span>
<span class="cm"> * This all causes the disk requests to be issued in the correct order.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">mpage_readpages</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pages</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="n">get_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">page_idx</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">last_block_in_bio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="n">map_bh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first_logical_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">map_bh</span><span class="p">.</span><span class="n">b_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">map_bh</span><span class="p">.</span><span class="n">b_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">page_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">page_idx</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">page_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pages</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>

		<span class="n">prefetchw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">add_to_page_cache_lru</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span>
					<span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">bio</span> <span class="o">=</span> <span class="n">do_mpage_readpage</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
					<span class="n">nr_pages</span> <span class="o">-</span> <span class="n">page_idx</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">last_block_in_bio</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map_bh</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">first_logical_block</span><span class="p">,</span>
					<span class="n">get_block</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">pages</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="p">)</span>
		<span class="n">mpage_bio_submit</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mpage_readpages</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This isn&#39;t called much at all</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">mpage_readpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="n">get_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">last_block_in_bio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="n">map_bh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first_logical_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">map_bh</span><span class="p">.</span><span class="n">b_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">map_bh</span><span class="p">.</span><span class="n">b_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bio</span> <span class="o">=</span> <span class="n">do_mpage_readpage</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last_block_in_bio</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">map_bh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first_logical_block</span><span class="p">,</span> <span class="n">get_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="p">)</span>
		<span class="n">mpage_bio_submit</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mpage_readpage</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Writing is not so simple.</span>
<span class="cm"> *</span>
<span class="cm"> * If the page has buffers then they will be used for obtaining the disk</span>
<span class="cm"> * mapping.  We only support pages which are fully mapped-and-dirty, with a</span>
<span class="cm"> * special case for pages which are unmapped at the end: end-of-file.</span>
<span class="cm"> *</span>
<span class="cm"> * If the page has no buffers (preferred) then the page is mapped here.</span>
<span class="cm"> *</span>
<span class="cm"> * If all blocks are found to be contiguous then the page can go into the</span>
<span class="cm"> * BIO.  Otherwise fall back to the mapping&#39;s writepage().</span>
<span class="cm"> * </span>
<span class="cm"> * FIXME: This code wants an estimate of how many pages are still to be</span>
<span class="cm"> * written, so it can intelligently allocate a suitably-sized BIO.  For now,</span>
<span class="cm"> * just allocate full-size (16-page) BIOs.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">mpage_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">last_block_in_bio</span><span class="p">;</span>
	<span class="n">get_block_t</span> <span class="o">*</span><span class="n">get_block</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">use_writepage</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__mpage_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">,</span>
		      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mpage_data</span> <span class="o">*</span><span class="n">mpd</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span> <span class="o">=</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">blkbits</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_index</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">blocks_per_page</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">last_block</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">block_in_file</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">blocks</span><span class="p">[</span><span class="n">MAX_BUF_PER_PAGE</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">page_block</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">first_unmapped</span> <span class="o">=</span> <span class="n">blocks_per_page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">boundary</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">boundary_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">boundary_bdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="n">map_bh</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">i_size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>

		<span class="cm">/* If they&#39;re all mapped and dirty, do it */</span>
		<span class="n">page_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * unmapped dirty buffers are created by</span>
<span class="cm">				 * __set_page_dirty_buffers -&gt; mmapped data</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">confused</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">first_unmapped</span> <span class="o">==</span> <span class="n">blocks_per_page</span><span class="p">)</span>
					<span class="n">first_unmapped</span> <span class="o">=</span> <span class="n">page_block</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">first_unmapped</span> <span class="o">!=</span> <span class="n">blocks_per_page</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">confused</span><span class="p">;</span>	<span class="cm">/* hole -&gt; non-hole */</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">confused</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page_block</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">!=</span> <span class="n">blocks</span><span class="p">[</span><span class="n">page_block</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">confused</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">blocks</span><span class="p">[</span><span class="n">page_block</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">;</span>
			<span class="n">boundary</span> <span class="o">=</span> <span class="n">buffer_boundary</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">boundary</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">boundary_block</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">;</span>
				<span class="n">boundary_bdev</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">bdev</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">first_unmapped</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">page_is_mapped</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Page has buffers, but they are all unmapped. The page was</span>
<span class="cm">		 * created by pagein or read over a hole which was handled by</span>
<span class="cm">		 * block_read_full_page().  If this address_space is also</span>
<span class="cm">		 * using mpage_readpages then this can rarely happen.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">confused</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The page has no buffers: map it to disk</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">block_in_file</span> <span class="o">=</span> <span class="p">(</span><span class="n">sector_t</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SHIFT</span> <span class="o">-</span> <span class="n">blkbits</span><span class="p">);</span>
	<span class="n">last_block</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">;</span>
	<span class="n">map_bh</span><span class="p">.</span><span class="n">b_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">page_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">page_block</span> <span class="o">&lt;</span> <span class="n">blocks_per_page</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>

		<span class="n">map_bh</span><span class="p">.</span><span class="n">b_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">map_bh</span><span class="p">.</span><span class="n">b_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">get_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">block_in_file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map_bh</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">confused</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map_bh</span><span class="p">))</span>
			<span class="n">unmap_underlying_metadata</span><span class="p">(</span><span class="n">map_bh</span><span class="p">.</span><span class="n">b_bdev</span><span class="p">,</span>
						<span class="n">map_bh</span><span class="p">.</span><span class="n">b_blocknr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_boundary</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map_bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">boundary_block</span> <span class="o">=</span> <span class="n">map_bh</span><span class="p">.</span><span class="n">b_blocknr</span><span class="p">;</span>
			<span class="n">boundary_bdev</span> <span class="o">=</span> <span class="n">map_bh</span><span class="p">.</span><span class="n">b_bdev</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_block</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">map_bh</span><span class="p">.</span><span class="n">b_blocknr</span> <span class="o">!=</span> <span class="n">blocks</span><span class="p">[</span><span class="n">page_block</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">confused</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">blocks</span><span class="p">[</span><span class="n">page_block</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">map_bh</span><span class="p">.</span><span class="n">b_blocknr</span><span class="p">;</span>
		<span class="n">boundary</span> <span class="o">=</span> <span class="n">buffer_boundary</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map_bh</span><span class="p">);</span>
		<span class="n">bdev</span> <span class="o">=</span> <span class="n">map_bh</span><span class="p">.</span><span class="n">b_bdev</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block_in_file</span> <span class="o">==</span> <span class="n">last_block</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">block_in_file</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">page_block</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">first_unmapped</span> <span class="o">=</span> <span class="n">page_block</span><span class="p">;</span>

<span class="nl">page_is_mapped:</span>
	<span class="n">end_index</span> <span class="o">=</span> <span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">end_index</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The page straddles i_size.  It must be zeroed out on each</span>
<span class="cm">		 * and every writepage invocation because it may be mmapped.</span>
<span class="cm">		 * &quot;A file is mapped in multiples of the page size.  For a file</span>
<span class="cm">		 * that is not a multiple of the page size, the remaining memory</span>
<span class="cm">		 * is zeroed when mapped, and writes to that region are not</span>
<span class="cm">		 * written out to the file.&quot;</span>
<span class="cm">		 */</span>
		<span class="kt">unsigned</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">i_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">end_index</span> <span class="o">||</span> <span class="o">!</span><span class="n">offset</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">confused</span><span class="p">;</span>
		<span class="n">zero_user_segment</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This page will go to BIO.  Do we need to send this BIO off first?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span> <span class="o">&amp;&amp;</span> <span class="n">mpd</span><span class="o">-&gt;</span><span class="n">last_block_in_bio</span> <span class="o">!=</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">bio</span> <span class="o">=</span> <span class="n">mpage_bio_submit</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

<span class="nl">alloc_new:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bio</span> <span class="o">=</span> <span class="n">mpage_alloc</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">blkbits</span> <span class="o">-</span> <span class="mi">9</span><span class="p">),</span>
				<span class="n">bio_get_nr_vecs</span><span class="p">(</span><span class="n">bdev</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="o">|</span><span class="n">__GFP_HIGH</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bio</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">confused</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Must try to add the page before marking the buffer clean or</span>
<span class="cm">	 * the confused fail path above (OOM) will be very confused when</span>
<span class="cm">	 * it finds all bh marked clean (i.e. it will not write anything)</span>
<span class="cm">	 */</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">first_unmapped</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio_add_page</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bio</span> <span class="o">=</span> <span class="n">mpage_bio_submit</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">alloc_new</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * OK, we have our BIO, so we can now mark the buffers clean.  Make</span>
<span class="cm">	 * sure to only clean buffers which we know we&#39;ll be writing.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">buffer_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buffer_counter</span><span class="o">++</span> <span class="o">==</span> <span class="n">first_unmapped</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * we cannot drop the bh if the page is not uptodate</span>
<span class="cm">		 * or a concurrent readpage would fail to serialize with the bh</span>
<span class="cm">		 * and it would read from disk before we reach the platter.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_heads_over_limit</span> <span class="o">&amp;&amp;</span> <span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">try_to_free_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">set_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">boundary</span> <span class="o">||</span> <span class="p">(</span><span class="n">first_unmapped</span> <span class="o">!=</span> <span class="n">blocks_per_page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bio</span> <span class="o">=</span> <span class="n">mpage_bio_submit</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">boundary_block</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">write_boundary_block</span><span class="p">(</span><span class="n">boundary_bdev</span><span class="p">,</span>
					<span class="n">boundary_block</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mpd</span><span class="o">-&gt;</span><span class="n">last_block_in_bio</span> <span class="o">=</span> <span class="n">blocks</span><span class="p">[</span><span class="n">blocks_per_page</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">confused:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="p">)</span>
		<span class="n">bio</span> <span class="o">=</span> <span class="n">mpage_bio_submit</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mpd</span><span class="o">-&gt;</span><span class="n">use_writepage</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">writepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * The caller has a ref on the inode, so *mapping is stable</span>
<span class="cm">	 */</span>
	<span class="n">mapping_set_error</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mpd</span><span class="o">-&gt;</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mpage_writepages - walk the list of dirty pages of the given address space &amp; writepage() all of them</span>
<span class="cm"> * @mapping: address space structure to write</span>
<span class="cm"> * @wbc: subtract the number of written pages from *@wbc-&gt;nr_to_write</span>
<span class="cm"> * @get_block: the filesystem&#39;s block mapper function.</span>
<span class="cm"> *             If this is NULL then use a_ops-&gt;writepage.  Otherwise, go</span>
<span class="cm"> *             direct-to-BIO.</span>
<span class="cm"> *</span>
<span class="cm"> * This is a library function, which implements the writepages()</span>
<span class="cm"> * address_space_operation.</span>
<span class="cm"> *</span>
<span class="cm"> * If a page is already under I/O, generic_writepages() skips it, even</span>
<span class="cm"> * if it&#39;s dirty.  This is desirable behaviour for memory-cleaning writeback,</span>
<span class="cm"> * but it is INCORRECT for data-integrity system calls such as fsync().  fsync()</span>
<span class="cm"> * and msync() need to guarantee that all the data which was dirty at the time</span>
<span class="cm"> * the call was made get new I/O started against them.  If wbc-&gt;sync_mode is</span>
<span class="cm"> * WB_SYNC_ALL then we were called for data integrity and we must wait for</span>
<span class="cm"> * existing IO to complete.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">mpage_writepages</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="n">get_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">blk_plug</span> <span class="n">plug</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">blk_start_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_block</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">generic_writepages</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mpage_data</span> <span class="n">mpd</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
			<span class="p">.</span><span class="n">last_block_in_bio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
			<span class="p">.</span><span class="n">get_block</span> <span class="o">=</span> <span class="n">get_block</span><span class="p">,</span>
			<span class="p">.</span><span class="n">use_writepage</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">};</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">write_cache_pages</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">wbc</span><span class="p">,</span> <span class="n">__mpage_writepage</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mpd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mpd</span><span class="p">.</span><span class="n">bio</span><span class="p">)</span>
			<span class="n">mpage_bio_submit</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">mpd</span><span class="p">.</span><span class="n">bio</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">blk_finish_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mpage_writepages</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">mpage_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">get_block_t</span> <span class="n">get_block</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mpage_data</span> <span class="n">mpd</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
		<span class="p">.</span><span class="n">last_block_in_bio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">get_block</span> <span class="o">=</span> <span class="n">get_block</span><span class="p">,</span>
		<span class="p">.</span><span class="n">use_writepage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">__mpage_writepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">wbc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mpd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mpd</span><span class="p">.</span><span class="n">bio</span><span class="p">)</span>
		<span class="n">mpage_bio_submit</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">mpd</span><span class="p">.</span><span class="n">bio</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mpage_writepage</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
