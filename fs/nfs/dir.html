<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › nfs › dir.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>dir.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/fs/nfs/dir.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1992  Rick Sladkey</span>
<span class="cm"> *</span>
<span class="cm"> *  nfs directory handling functions</span>
<span class="cm"> *</span>
<span class="cm"> * 10 Apr 1996	Added silly rename for unlink	--okir</span>
<span class="cm"> * 28 Sep 1996	Improved directory cache --okir</span>
<span class="cm"> * 23 Aug 1997  Claus Heine claus@momo.math.rwth-aachen.de </span>
<span class="cm"> *              Re-implemented silly rename for unlink, newly implemented</span>
<span class="cm"> *              silly rename for nfs_rename() following the suggestions</span>
<span class="cm"> *              of Olaf Kirch (okir) found in this file.</span>
<span class="cm"> *              Following Linus comments on my original hack, this version</span>
<span class="cm"> *              depends only on the dcache stuff and doesn&#39;t touch the inode</span>
<span class="cm"> *              layer (iput() and friends).</span>
<span class="cm"> *  6 Jun 1999	Cache readdir lookups in the page cache. -DaveM</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/clnt.h&gt;</span>
<span class="cp">#include &lt;linux/nfs_fs.h&gt;</span>
<span class="cp">#include &lt;linux/nfs_mount.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/pagevec.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/kmemleak.h&gt;</span>
<span class="cp">#include &lt;linux/xattr.h&gt;</span>

<span class="cp">#include &quot;delegation.h&quot;</span>
<span class="cp">#include &quot;iostat.h&quot;</span>
<span class="cp">#include &quot;internal.h&quot;</span>
<span class="cp">#include &quot;fscache.h&quot;</span>

<span class="cm">/* #define NFS_DEBUG_VERBOSE 1 */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">nfs_opendir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nfs_closedir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nfs_readdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">filldir_t</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">nfs_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nfs_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="n">umode_t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nfs_mkdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="n">umode_t</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nfs_rmdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nfs_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nfs_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nfs_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nfs_mknod</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="n">umode_t</span><span class="p">,</span> <span class="n">dev_t</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nfs_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nfs_fsync_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="n">loff_t</span> <span class="n">nfs_llseek_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">nfs_readdir_clear_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span><span class="o">*</span><span class="p">);</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">nfs_dir_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">nfs_llseek_dir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">generic_read_dir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readdir</span>	<span class="o">=</span> <span class="n">nfs_readdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">nfs_opendir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">nfs_closedir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fsync</span>		<span class="o">=</span> <span class="n">nfs_fsync_dir</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">nfs_dir_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">create</span>		<span class="o">=</span> <span class="n">nfs_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lookup</span>		<span class="o">=</span> <span class="n">nfs_lookup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">link</span>		<span class="o">=</span> <span class="n">nfs_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlink</span>		<span class="o">=</span> <span class="n">nfs_unlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symlink</span>	<span class="o">=</span> <span class="n">nfs_symlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mkdir</span>		<span class="o">=</span> <span class="n">nfs_mkdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rmdir</span>		<span class="o">=</span> <span class="n">nfs_rmdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mknod</span>		<span class="o">=</span> <span class="n">nfs_mknod</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rename</span>		<span class="o">=</span> <span class="n">nfs_rename</span><span class="p">,</span>
	<span class="p">.</span><span class="n">permission</span>	<span class="o">=</span> <span class="n">nfs_permission</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getattr</span>	<span class="o">=</span> <span class="n">nfs_getattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">nfs_setattr</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">nfs_dir_aops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">freepage</span> <span class="o">=</span> <span class="n">nfs_readdir_clear_array</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_NFS_V3</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">nfs3_dir_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">create</span>		<span class="o">=</span> <span class="n">nfs_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lookup</span>		<span class="o">=</span> <span class="n">nfs_lookup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">link</span>		<span class="o">=</span> <span class="n">nfs_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlink</span>		<span class="o">=</span> <span class="n">nfs_unlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symlink</span>	<span class="o">=</span> <span class="n">nfs_symlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mkdir</span>		<span class="o">=</span> <span class="n">nfs_mkdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rmdir</span>		<span class="o">=</span> <span class="n">nfs_rmdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mknod</span>		<span class="o">=</span> <span class="n">nfs_mknod</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rename</span>		<span class="o">=</span> <span class="n">nfs_rename</span><span class="p">,</span>
	<span class="p">.</span><span class="n">permission</span>	<span class="o">=</span> <span class="n">nfs_permission</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getattr</span>	<span class="o">=</span> <span class="n">nfs_getattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">nfs_setattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span>	<span class="o">=</span> <span class="n">nfs3_listxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span>	<span class="o">=</span> <span class="n">nfs3_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setxattr</span>	<span class="o">=</span> <span class="n">nfs3_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span>	<span class="o">=</span> <span class="n">nfs3_removexattr</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif  </span><span class="cm">/* CONFIG_NFS_V3 */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_NFS_V4</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">nfs_atomic_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nfs_open_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">);</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">nfs4_dir_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">create</span>		<span class="o">=</span> <span class="n">nfs_open_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lookup</span>		<span class="o">=</span> <span class="n">nfs_atomic_lookup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">link</span>		<span class="o">=</span> <span class="n">nfs_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlink</span>		<span class="o">=</span> <span class="n">nfs_unlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symlink</span>	<span class="o">=</span> <span class="n">nfs_symlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mkdir</span>		<span class="o">=</span> <span class="n">nfs_mkdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rmdir</span>		<span class="o">=</span> <span class="n">nfs_rmdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mknod</span>		<span class="o">=</span> <span class="n">nfs_mknod</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rename</span>		<span class="o">=</span> <span class="n">nfs_rename</span><span class="p">,</span>
	<span class="p">.</span><span class="n">permission</span>	<span class="o">=</span> <span class="n">nfs_permission</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getattr</span>	<span class="o">=</span> <span class="n">nfs_getattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">nfs_setattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span>	<span class="o">=</span> <span class="n">generic_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setxattr</span>	<span class="o">=</span> <span class="n">generic_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span>	<span class="o">=</span> <span class="n">generic_listxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span>	<span class="o">=</span> <span class="n">generic_removexattr</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_NFS_V4 */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nfs_open_dir_context</span> <span class="o">*</span><span class="nf">alloc_nfs_open_dir_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpc_cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_open_dir_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="n">ctx</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ctx</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">duped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr_gencount</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">attr_gencount</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dir_cookie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dup_cookie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">cred</span> <span class="o">=</span> <span class="n">get_rpccred</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span>  <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_nfs_open_dir_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_open_dir_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_rpccred</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Open file</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">nfs_opendir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_open_dir_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">;</span>

	<span class="n">dfprintk</span><span class="p">(</span><span class="kt">FILE</span><span class="p">,</span> <span class="s">&quot;NFS: open dir(%s/%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="n">nfs_inc_stats</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">NFSIOS_VFSOPEN</span><span class="p">);</span>

	<span class="n">cred</span> <span class="o">=</span> <span class="n">rpc_lookup_cred</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">cred</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>
	<span class="n">ctx</span> <span class="o">=</span> <span class="n">alloc_nfs_open_dir_context</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">cred</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">==</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This is a mountpoint, so d_revalidate will never</span>
<span class="cm">		 * have been called, so we need to refresh the</span>
<span class="cm">		 * inode (for close-open consistency) ourselves.</span>
<span class="cm">		 */</span>
		<span class="n">__nfs_revalidate_inode</span><span class="p">(</span><span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">put_rpccred</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">nfs_closedir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_nfs_open_dir_context</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">nfs_cache_array_entry</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">cookie</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ino</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">string</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">d_type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">nfs_cache_array</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">eof_index</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">last_cookie</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_cache_array_entry</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">decode_dirent_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_entry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span>	<span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span>	<span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">page_index</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="o">*</span><span class="n">dir_cookie</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">last_cookie</span><span class="p">;</span>
	<span class="n">loff_t</span>		<span class="n">current_index</span><span class="p">;</span>
	<span class="n">decode_dirent_t</span>	<span class="n">decode</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">timestamp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">gencount</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">cache_entry_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">plus</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">eof</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nfs_readdir_descriptor_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The caller is responsible for calling nfs_readdir_release_array(page)</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="k">struct</span> <span class="n">nfs_cache_array</span> <span class="o">*</span><span class="nf">nfs_readdir_get_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="kt">void</span> <span class="nf">nfs_readdir_release_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * we are freeing strings created by nfs_add_to_readdir_array()</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">void</span> <span class="nf">nfs_readdir_clear_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_cache_array</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">array</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">string</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * the caller is responsible for freeing qstr.name</span>
<span class="cm"> * when called by nfs_readdir_add_to_array, the strings will be freed in</span>
<span class="cm"> * nfs_clear_readdir_array()</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">nfs_readdir_make_qstr</span><span class="p">(</span><span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">string</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">string</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">string</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">string</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Avoid a kmemleak false positive. The pointer to the name is stored</span>
<span class="cm">	 * in a page cache page which kmemleak does not scan.</span>
<span class="cm">	 */</span>
	<span class="n">kmemleak_not_leak</span><span class="p">(</span><span class="n">string</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">string</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">full_name_hash</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="kt">int</span> <span class="nf">nfs_readdir_add_to_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_cache_array</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="n">nfs_readdir_get_array</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nfs_cache_array_entry</span> <span class="o">*</span><span class="n">cache_entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>

	<span class="n">cache_entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">];</span>

	<span class="cm">/* Check that this entry lies within the page bounds */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cache_entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">cache_entry</span><span class="o">-&gt;</span><span class="n">cookie</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">prev_cookie</span><span class="p">;</span>
	<span class="n">cache_entry</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">;</span>
	<span class="n">cache_entry</span><span class="o">-&gt;</span><span class="n">d_type</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_type</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nfs_readdir_make_qstr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache_entry</span><span class="o">-&gt;</span><span class="n">string</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">array</span><span class="o">-&gt;</span><span class="n">last_cookie</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">cookie</span><span class="p">;</span>
	<span class="n">array</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">array</span><span class="o">-&gt;</span><span class="n">eof_index</span> <span class="o">=</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">nfs_readdir_release_array</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="kt">int</span> <span class="nf">nfs_readdir_search_for_pos</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_cache_array</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="n">nfs_readdir_descriptor_t</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">-</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">current_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_eof</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&gt;=</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">eof_index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_eof</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">diff</span><span class="p">;</span>
	<span class="o">*</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">dir_cookie</span> <span class="o">=</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">cookie</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">cache_entry_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_eof:</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EBADCOOKIE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="kt">int</span> <span class="nf">nfs_readdir_search_for_cookie</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_cache_array</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="n">nfs_readdir_descriptor_t</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">new_pos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cookie</span> <span class="o">==</span> <span class="o">*</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">dir_cookie</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
			<span class="k">struct</span> <span class="n">nfs_open_dir_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

			<span class="n">new_pos</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">current_index</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr_gencount</span> <span class="o">!=</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">attr_gencount</span>
			    <span class="o">||</span> <span class="p">(</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NFS_INO_INVALID_ATTR</span><span class="o">|</span><span class="n">NFS_INO_INVALID_DATA</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">duped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">attr_gencount</span> <span class="o">=</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">attr_gencount</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new_pos</span> <span class="o">&lt;</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">duped</span> <span class="o">&gt;</span> <span class="mi">0</span>
				    <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dup_cookie</span> <span class="o">==</span> <span class="o">*</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">dir_cookie</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span> <span class="p">{</span>
						<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;NFS: directory %s/%s contains a readdir loop.&quot;</span>
								<span class="s">&quot;Please contact your server vendor.  &quot;</span>
								<span class="s">&quot;The file: %s has duplicate cookie %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">desc</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
								<span class="n">desc</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
								<span class="n">array</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">string</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
								<span class="o">*</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">dir_cookie</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ELOOP</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dup_cookie</span> <span class="o">=</span> <span class="o">*</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">dir_cookie</span><span class="p">;</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">duped</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">new_pos</span><span class="p">;</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">cache_entry_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">eof_index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADCOOKIE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">dir_cookie</span> <span class="o">==</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">last_cookie</span><span class="p">)</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="kt">int</span> <span class="nf">nfs_readdir_search_array</span><span class="p">(</span><span class="n">nfs_readdir_descriptor_t</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_cache_array</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">array</span> <span class="o">=</span> <span class="n">nfs_readdir_get_array</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">array</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">dir_cookie</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">nfs_readdir_search_for_pos</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">nfs_readdir_search_for_cookie</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">last_cookie</span> <span class="o">=</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">last_cookie</span><span class="p">;</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">current_index</span> <span class="o">+=</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">page_index</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nfs_readdir_release_array</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Fill a page with xdr information before transferring to the cache page */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">nfs_readdir_xdr_filler</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="n">nfs_readdir_descriptor_t</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">nfs_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_open_dir_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_cred</span>	<span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">timestamp</span><span class="p">,</span> <span class="n">gencount</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">error</span><span class="p">;</span>

 <span class="nl">again:</span>
	<span class="n">timestamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">gencount</span> <span class="o">=</span> <span class="n">nfs_inc_attr_generation_counter</span><span class="p">();</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">NFS_PROTO</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">readdir</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">,</span> <span class="n">cred</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">cookie</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span>
					  <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dtsize</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">plus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We requested READDIRPLUS, but the server doesn&#39;t grok it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOTSUPP</span> <span class="o">&amp;&amp;</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">plus</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">caps</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NFS_CAP_READDIRPLUS</span><span class="p">;</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">NFS_INO_ADVISE_RDPLUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">plus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">timestamp</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">gencount</span> <span class="o">=</span> <span class="n">gencount</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">xdr_decode</span><span class="p">(</span><span class="n">nfs_readdir_descriptor_t</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">nfs_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">plus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">time_start</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">gencount</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">gencount</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="kt">int</span> <span class="nf">nfs_same_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">different</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfs_compare_fh</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">,</span> <span class="n">NFS_FH</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">different</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">different:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="n">bool</span> <span class="nf">nfs_use_readdirplus</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nfs_server_capable</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">NFS_CAP_READDIRPLUS</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">NFS_INO_ADVISE_RDPLUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is called by the lookup code to request the use of</span>
<span class="cm"> * readdirplus to accelerate any future lookups in the same</span>
<span class="cm"> * directory.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">void</span> <span class="nf">nfs_advise_use_readdirplus</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">NFS_INO_ADVISE_RDPLUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="kt">void</span> <span class="nf">nfs_prime_dcache</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">QSTR_INIT</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">alias</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">filename</span><span class="p">.</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filename</span><span class="p">.</span><span class="n">len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filename</span><span class="p">.</span><span class="n">len</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">filename</span><span class="p">.</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">filename</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="n">full_name_hash</span><span class="p">(</span><span class="n">filename</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">filename</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">d_lookup</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">filename</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nfs_same_file</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">nfs_refresh_inode</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
			<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">d_alloc</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">filename</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">nfs_fhget</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">alias</span> <span class="o">=</span> <span class="n">d_materialise_unique</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">alias</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">alias</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nfs_set_verifier</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">nfs_save_change_attribute</span><span class="p">(</span><span class="n">dir</span><span class="p">));</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">alias</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">nfs_set_verifier</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">nfs_save_change_attribute</span><span class="p">(</span><span class="n">dir</span><span class="p">));</span>

<span class="nl">out:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Perform conversion from xdr to cache array */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">nfs_readdir_page_filler</span><span class="p">(</span><span class="n">nfs_readdir_descriptor_t</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">xdr_pages</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">xdr_stream</span> <span class="n">stream</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xdr_buf</span> <span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">scratch</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_cache_array</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">scratch</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scratch</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">xdr_init_decode_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">xdr_pages</span><span class="p">,</span> <span class="n">buflen</span><span class="p">);</span>
	<span class="n">xdr_set_scratch_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="p">,</span> <span class="n">page_address</span><span class="p">(</span><span class="n">scratch</span><span class="p">),</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">xdr_decode</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stream</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
				<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">count</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">plus</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">nfs_prime_dcache</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">nfs_readdir_add_to_array</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">eof</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBADCOOKIE</span> <span class="o">&amp;&amp;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">array</span> <span class="o">=</span> <span class="n">nfs_readdir_get_array</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">array</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">array</span><span class="o">-&gt;</span><span class="n">eof_index</span> <span class="o">=</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">nfs_readdir_release_array</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">put_page</span><span class="p">(</span><span class="n">scratch</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="kt">void</span> <span class="nf">nfs_readdir_free_pagearray</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">npages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="kt">void</span> <span class="nf">nfs_readdir_free_large_page</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">npages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nfs_readdir_free_pagearray</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="n">npages</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * nfs_readdir_large_page will allocate pages that must be freed with a call</span>
<span class="cm"> * to nfs_readdir_free_large_page</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">nfs_readdir_large_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">npages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_freepages</span><span class="p">;</span>
		<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_freepages:</span>
	<span class="n">nfs_readdir_free_pagearray</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="kt">int</span> <span class="nf">nfs_readdir_xdr_to_array</span><span class="p">(</span><span class="n">nfs_readdir_descriptor_t</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pages</span><span class="p">[</span><span class="n">NFS_MAX_READDIR_PAGES</span><span class="p">];</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">pages_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_entry</span> <span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span>	<span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_cache_array</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">array_size</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>

	<span class="n">entry</span><span class="p">.</span><span class="n">prev_cookie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">entry</span><span class="p">.</span><span class="n">cookie</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">last_cookie</span><span class="p">;</span>
	<span class="n">entry</span><span class="p">.</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">entry</span><span class="p">.</span><span class="n">fh</span> <span class="o">=</span> <span class="n">nfs_alloc_fhandle</span><span class="p">();</span>
	<span class="n">entry</span><span class="p">.</span><span class="n">fattr</span> <span class="o">=</span> <span class="n">nfs_alloc_fattr</span><span class="p">();</span>
	<span class="n">entry</span><span class="p">.</span><span class="n">server</span> <span class="o">=</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">fh</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">entry</span><span class="p">.</span><span class="n">fattr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">array</span> <span class="o">=</span> <span class="n">nfs_readdir_get_array</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">array</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_cache_array</span><span class="p">));</span>
	<span class="n">array</span><span class="o">-&gt;</span><span class="n">eof_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">nfs_readdir_large_page</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="n">array_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_release_array</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pglen</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">nfs_readdir_xdr_filler</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">pglen</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">nfs_readdir_page_filler</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">pglen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
				<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">eof_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">nfs_readdir_free_large_page</span><span class="p">(</span><span class="n">pages_ptr</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">array_size</span><span class="p">);</span>
<span class="nl">out_release_array:</span>
	<span class="n">nfs_readdir_release_array</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">nfs_free_fattr</span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">fattr</span><span class="p">);</span>
	<span class="n">nfs_free_fhandle</span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">fh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Now we cache directories properly, by converting xdr information</span>
<span class="cm"> * to an array that can be used for lookups later.  This results in</span>
<span class="cm"> * fewer cache pages, since we can store more information on each page.</span>
<span class="cm"> * We only need to convert from xdr once so future lookups are much simpler</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">nfs_readdir_filler</span><span class="p">(</span><span class="n">nfs_readdir_descriptor_t</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="o">*</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">nfs_readdir_xdr_to_array</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">invalidate_inode_pages2_range</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Should never happen */</span>
		<span class="n">nfs_zap_mapping</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">error:</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="kt">void</span> <span class="nf">cache_page_release</span><span class="p">(</span><span class="n">nfs_readdir_descriptor_t</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">)</span>
		<span class="n">nfs_readdir_clear_array</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">get_cache_page</span><span class="p">(</span><span class="n">nfs_readdir_descriptor_t</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">read_cache_page</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">page_index</span><span class="p">,</span> <span class="p">(</span><span class="n">filler_t</span> <span class="o">*</span><span class="p">)</span><span class="n">nfs_readdir_filler</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns 0 if desc-&gt;dir_cookie was found on page desc-&gt;page_index</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">find_cache_page</span><span class="p">(</span><span class="n">nfs_readdir_descriptor_t</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">get_cache_page</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">nfs_readdir_search_array</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cache_page_release</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Search for desc-&gt;dir_cookie from the beginning of the page cache */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">readdir_search_pagecache</span><span class="p">(</span><span class="n">nfs_readdir_descriptor_t</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">page_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">current_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">last_cookie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">find_cache_page</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Once we&#39;ve found the start of the dirent within a page: fill &#39;er up...</span>
<span class="cm"> */</span>
<span class="k">static</span> 
<span class="kt">int</span> <span class="nf">nfs_do_filldir</span><span class="p">(</span><span class="n">nfs_readdir_descriptor_t</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dirent</span><span class="p">,</span>
		   <span class="n">filldir_t</span> <span class="n">filldir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span>	<span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_cache_array</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_open_dir_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">array</span> <span class="o">=</span> <span class="n">nfs_readdir_get_array</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">array</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">cache_entry_index</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nfs_cache_array_entry</span> <span class="o">*</span><span class="n">ent</span><span class="p">;</span>

		<span class="n">ent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">string</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">string</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
		    <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">,</span> <span class="n">nfs_compat_user_ino64</span><span class="p">(</span><span class="n">ent</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">),</span>
		    <span class="n">ent</span><span class="o">-&gt;</span><span class="n">d_type</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
			<span class="o">*</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">dir_cookie</span> <span class="o">=</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">cookie</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">dir_cookie</span> <span class="o">=</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">last_cookie</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">duped</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">duped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">eof_index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">nfs_readdir_release_array</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">cache_page_release</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="n">dfprintk</span><span class="p">(</span><span class="n">DIRCACHE</span><span class="p">,</span> <span class="s">&quot;NFS: nfs_do_filldir() filling ended @ cookie %Lu; returning = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">dir_cookie</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If we cannot find a cookie in our cache, we suspect that this is</span>
<span class="cm"> * because it points to a deleted file, so we ask the server to return</span>
<span class="cm"> * whatever it thinks is the next entry. We then feed this to filldir.</span>
<span class="cm"> * If all goes well, we should then be able to find our way round the</span>
<span class="cm"> * cache on the next call to readdir_search_pagecache();</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: we cannot add the anonymous page to the pagecache because</span>
<span class="cm"> *	 the data it contains might not be page aligned. Besides,</span>
<span class="cm"> *	 we should already have a complete representation of the</span>
<span class="cm"> *	 directory in the page cache by the time we get here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">uncached_readdir</span><span class="p">(</span><span class="n">nfs_readdir_descriptor_t</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dirent</span><span class="p">,</span>
		     <span class="n">filldir_t</span> <span class="n">filldir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span>	<span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_open_dir_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">dfprintk</span><span class="p">(</span><span class="n">DIRCACHE</span><span class="p">,</span> <span class="s">&quot;NFS: uncached_readdir() searching for cookie %Lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">dir_cookie</span><span class="p">);</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_HIGHUSER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">page_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">last_cookie</span> <span class="o">=</span> <span class="o">*</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">dir_cookie</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">duped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">nfs_readdir_xdr_to_array</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">nfs_do_filldir</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">dirent</span><span class="p">,</span> <span class="n">filldir</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="n">dfprintk</span><span class="p">(</span><span class="n">DIRCACHE</span><span class="p">,</span> <span class="s">&quot;NFS: %s: returns %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
 <span class="nl">out_release:</span>
	<span class="n">cache_page_release</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The file offset position represents the dirent entry number.  A</span>
<span class="cm">   last cookie cache takes care of the common case of reading the</span>
<span class="cm">   whole directory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_readdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dirent</span><span class="p">,</span> <span class="n">filldir_t</span> <span class="n">filldir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span>	<span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span>	<span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">nfs_readdir_descriptor_t</span> <span class="n">my_desc</span><span class="p">,</span>
			<span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_open_dir_context</span> <span class="o">*</span><span class="n">dir_ctx</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">dfprintk</span><span class="p">(</span><span class="kt">FILE</span><span class="p">,</span> <span class="s">&quot;NFS: readdir(%s/%s) starting at cookie %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">);</span>
	<span class="n">nfs_inc_stats</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">NFSIOS_VFSGETDENTS</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * filp-&gt;f_pos points to the dirent entry number.</span>
<span class="cm">	 * *desc-&gt;dir_cookie has the cookie for the next entry. We have</span>
<span class="cm">	 * to either find the entry with the appropriate number or</span>
<span class="cm">	 * revalidate the cookie.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">desc</span><span class="p">));</span>

	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">=</span> <span class="n">filp</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">dir_cookie</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dir_ctx</span><span class="o">-&gt;</span><span class="n">dir_cookie</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">decode</span> <span class="o">=</span> <span class="n">NFS_PROTO</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">decode_dirent</span><span class="p">;</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">plus</span> <span class="o">=</span> <span class="n">nfs_use_readdirplus</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">nfs_block_sillyrename</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">nfs_revalidate_mapping</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">readdir_search_pagecache</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBADCOOKIE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* This means either end of directory */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">dir_cookie</span> <span class="o">&amp;&amp;</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Or that the server has &#39;lost&#39; a cookie */</span>
				<span class="n">res</span> <span class="o">=</span> <span class="n">uncached_readdir</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">dirent</span><span class="p">,</span> <span class="n">filldir</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="o">-</span><span class="n">ETOOSMALL</span> <span class="o">&amp;&amp;</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">plus</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">NFS_INO_ADVISE_RDPLUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">nfs_zap_caches</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">page_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">plus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">res</span> <span class="o">=</span> <span class="n">nfs_do_filldir</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">dirent</span><span class="p">,</span> <span class="n">filldir</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">eof</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">nfs_unblock_sillyrename</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dfprintk</span><span class="p">(</span><span class="kt">FILE</span><span class="p">,</span> <span class="s">&quot;NFS: readdir(%s/%s) returns %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			<span class="n">res</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">loff_t</span> <span class="nf">nfs_llseek_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_open_dir_context</span> <span class="o">*</span><span class="n">dir_ctx</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">dfprintk</span><span class="p">(</span><span class="kt">FILE</span><span class="p">,</span> <span class="s">&quot;NFS: llseek dir(%s/%s, %lld, %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			<span class="n">offset</span><span class="p">,</span> <span class="n">origin</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">origin</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">!=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">dir_ctx</span><span class="o">-&gt;</span><span class="n">dir_cookie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dir_ctx</span><span class="o">-&gt;</span><span class="n">duped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * All directory operations under NFS are synchronous, so fsync()</span>
<span class="cm"> * is a dummy operation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_fsync_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">end</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">datasync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="n">dfprintk</span><span class="p">(</span><span class="kt">FILE</span><span class="p">,</span> <span class="s">&quot;NFS: fsync dir(%s/%s) datasync %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			<span class="n">datasync</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">nfs_inc_stats</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">NFSIOS_VFSFSYNC</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_force_lookup_revalidate - Mark the directory as having changed</span>
<span class="cm"> * @dir - pointer to directory inode</span>
<span class="cm"> *</span>
<span class="cm"> * This forces the revalidation code in nfs_lookup_revalidate() to do a</span>
<span class="cm"> * full lookup on all child dentries of &#39;dir&#39; whenever a change occurs</span>
<span class="cm"> * on the server that might have invalidated our dcache.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller should be holding dir-&gt;i_lock</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nfs_force_lookup_revalidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">NFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cache_change_attribute</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A check for whether or not the parent directory has changed.</span>
<span class="cm"> * In the case it has, we assume that the dentries are untrustworthy</span>
<span class="cm"> * and may need to be looked up again.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_check_verifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ROOT</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NFS_MOUNT_LOOKUP_CACHE_NONE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nfs_verify_change_attribute</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_time</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Revalidate nfsi-&gt;cache_change_attribute before we declare a match */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfs_revalidate_inode</span><span class="p">(</span><span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">dir</span><span class="p">),</span> <span class="n">dir</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nfs_verify_change_attribute</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_time</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the intent data that applies to this particular path component</span>
<span class="cm"> *</span>
<span class="cm"> * Note that the current set of intents only apply to the very last</span>
<span class="cm"> * component of the path and none of them is set before that last</span>
<span class="cm"> * component.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">nfs_lookup_check_intent</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Use intent information to check whether or not we&#39;re going to do</span>
<span class="cm"> * an O_EXCL create using this path component.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_is_exclusive_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">NFS_PROTO</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">nd</span> <span class="o">&amp;&amp;</span> <span class="n">nfs_lookup_check_intent</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">LOOKUP_EXCL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Inode and filehandle revalidation for lookups.</span>
<span class="cm"> *</span>
<span class="cm"> * We force revalidation in the cases where the VFS sets LOOKUP_REVAL,</span>
<span class="cm"> * or if the intent information indicates that we&#39;re about to open this</span>
<span class="cm"> * particular file and the &quot;nocto&quot; mount flag is not set.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">nfs_lookup_verify_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span> <span class="o">=</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_AUTOMOUNT</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* VFS wants an on-the-wire revalidation */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_REVAL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_force</span><span class="p">;</span>
		<span class="cm">/* This is an open(2) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nfs_lookup_check_intent</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">LOOKUP_OPEN</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NFS_MOUNT_NOCTO</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span>
				 <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">out_force</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">nfs_revalidate_inode</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
<span class="nl">out_force:</span>
	<span class="k">return</span> <span class="n">__nfs_revalidate_inode</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We judge how long we want to trust negative</span>
<span class="cm"> * dentries by looking at the parent inode mtime.</span>
<span class="cm"> *</span>
<span class="cm"> * If parent mtime has changed, we revalidate, else we wait for a</span>
<span class="cm"> * period corresponding to the parent&#39;s attribute cache timeout value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">nfs_neg_need_reval</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Don&#39;t revalidate a negative dentry if we&#39;re creating a new file */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">nfs_lookup_check_intent</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">LOOKUP_CREATE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NFS_MOUNT_LOOKUP_CACHE_NONEG</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">nfs_check_verifier</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called every time the dcache has a lookup hit,</span>
<span class="cm"> * and we should check whether we can really trust that</span>
<span class="cm"> * lookup.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE! The hit can be a negative hit too, don&#39;t assume</span>
<span class="cm"> * we have an inode!</span>
<span class="cm"> *</span>
<span class="cm"> * If the parent directory is seen to have changed, we throw out the</span>
<span class="cm"> * cached dentry and do a new lookup.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_lookup_revalidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">fhandle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_RCU</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">dget_parent</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">dir</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">nfs_inc_stats</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">NFSIOS_DENTRYREVALIDATE</span><span class="p">);</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nfs_neg_need_reval</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">nd</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_bad</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_valid_noent</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dfprintk</span><span class="p">(</span><span class="n">LOOKUPCACHE</span><span class="p">,</span> <span class="s">&quot;%s: %s/%s has dud inode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
				<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nfs_have_delegation</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">FMODE_READ</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_set_verifier</span><span class="p">;</span>

	<span class="cm">/* Force a full look up iff the parent directory has changed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nfs_is_exclusive_create</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">nd</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">nfs_check_verifier</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nfs_lookup_verify_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">nd</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_zap_parent</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_valid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">NFS_STALE</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_bad</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">fhandle</span> <span class="o">=</span> <span class="n">nfs_alloc_fhandle</span><span class="p">();</span>
	<span class="n">fattr</span> <span class="o">=</span> <span class="n">nfs_alloc_fattr</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fhandle</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">fattr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">NFS_PROTO</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lookup</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="n">fhandle</span><span class="p">,</span> <span class="n">fattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_bad</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfs_compare_fh</span><span class="p">(</span><span class="n">NFS_FH</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">fhandle</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_bad</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">nfs_refresh_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fattr</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_bad</span><span class="p">;</span>

	<span class="n">nfs_free_fattr</span><span class="p">(</span><span class="n">fattr</span><span class="p">);</span>
	<span class="n">nfs_free_fhandle</span><span class="p">(</span><span class="n">fhandle</span><span class="p">);</span>
<span class="nl">out_set_verifier:</span>
	<span class="n">nfs_set_verifier</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">nfs_save_change_attribute</span><span class="p">(</span><span class="n">dir</span><span class="p">));</span>
 <span class="nl">out_valid:</span>
	<span class="cm">/* Success: notify readdir to use READDIRPLUS */</span>
	<span class="n">nfs_advise_use_readdirplus</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
 <span class="nl">out_valid_noent:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">dfprintk</span><span class="p">(</span><span class="n">LOOKUPCACHE</span><span class="p">,</span> <span class="s">&quot;NFS: %s(%s/%s) is valid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out_zap_parent:</span>
	<span class="n">nfs_zap_caches</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
 <span class="nl">out_bad:</span>
	<span class="n">nfs_mark_for_revalidate</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">&amp;&amp;</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Purge readdir caches. */</span>
		<span class="n">nfs_zap_caches</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="cm">/* If we have submounts, don&#39;t unhash ! */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">have_submounts</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_valid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_DISCONNECTED</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_valid</span><span class="p">;</span>
		<span class="n">shrink_dcache_parent</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">nfs_free_fattr</span><span class="p">(</span><span class="n">fattr</span><span class="p">);</span>
	<span class="n">nfs_free_fhandle</span><span class="p">(</span><span class="n">fhandle</span><span class="p">);</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">dfprintk</span><span class="p">(</span><span class="n">LOOKUPCACHE</span><span class="p">,</span> <span class="s">&quot;NFS: %s(%s/%s) is invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_error:</span>
	<span class="n">nfs_free_fattr</span><span class="p">(</span><span class="n">fattr</span><span class="p">);</span>
	<span class="n">nfs_free_fhandle</span><span class="p">(</span><span class="n">fhandle</span><span class="p">);</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">dfprintk</span><span class="p">(</span><span class="n">LOOKUPCACHE</span><span class="p">,</span> <span class="s">&quot;NFS: %s(%s/%s) lookup returned error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called from dput() when d_count is going to 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_dentry_delete</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dfprintk</span><span class="p">(</span><span class="n">VFS</span><span class="p">,</span> <span class="s">&quot;NFS: dentry_delete(%s/%s, %x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span><span class="p">);</span>

	<span class="cm">/* Unhash any dentry with a stale inode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">NFS_STALE</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_NFSFS_RENAMED</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Unhash it, so that -&gt;d_iput() would be called */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_ACTIVE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Unhash it, so that ancestors of killed async unlink</span>
<span class="cm">		 * files will be cleaned up during umount */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs_drop_nlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">drop_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called when the dentry loses inode.</span>
<span class="cm"> * We use it to clean up silly-renamed files.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs_dentry_iput</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="cm">/* drop any readdir cache as it could easily be old */</span>
		<span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_DATA</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_NFSFS_RENAMED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drop_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">nfs_complete_unlink</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs_d_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* free cached devname value, if it survived that far */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_NFSFS_RENAMED</span><span class="p">)</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="n">nfs_dentry_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">d_revalidate</span>	<span class="o">=</span> <span class="n">nfs_lookup_revalidate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">d_delete</span>	<span class="o">=</span> <span class="n">nfs_dentry_delete</span><span class="p">,</span>
	<span class="p">.</span><span class="n">d_iput</span>		<span class="o">=</span> <span class="n">nfs_dentry_iput</span><span class="p">,</span>
	<span class="p">.</span><span class="n">d_automount</span>	<span class="o">=</span> <span class="n">nfs_d_automount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">d_release</span>	<span class="o">=</span> <span class="n">nfs_d_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">nfs_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">fhandle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">dfprintk</span><span class="p">(</span><span class="n">VFS</span><span class="p">,</span> <span class="s">&quot;NFS: lookup(%s/%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
	<span class="n">nfs_inc_stats</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">NFSIOS_VFSLOOKUP</span><span class="p">);</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re doing an exclusive create, optimize away the lookup</span>
<span class="cm">	 * but don&#39;t hash the dentry.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfs_is_exclusive_create</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">nd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="n">fhandle</span> <span class="o">=</span> <span class="n">nfs_alloc_fhandle</span><span class="p">();</span>
	<span class="n">fattr</span> <span class="o">=</span> <span class="n">nfs_alloc_fattr</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fhandle</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">fattr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>
	<span class="cm">/* Protect against concurrent sillydeletes */</span>
	<span class="n">nfs_block_sillyrename</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">NFS_PROTO</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lookup</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="n">fhandle</span><span class="p">,</span> <span class="n">fattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_entry</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unblock_sillyrename</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">nfs_fhget</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">,</span> <span class="n">fhandle</span><span class="p">,</span> <span class="n">fattr</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unblock_sillyrename</span><span class="p">;</span>

	<span class="cm">/* Success: notify readdir to use READDIRPLUS */</span>
	<span class="n">nfs_advise_use_readdirplus</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>

<span class="nl">no_entry:</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">d_materialise_unique</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_unblock_sillyrename</span><span class="p">;</span>
		<span class="n">dentry</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nfs_set_verifier</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">nfs_save_change_attribute</span><span class="p">(</span><span class="n">dir</span><span class="p">));</span>
<span class="nl">out_unblock_sillyrename:</span>
	<span class="n">nfs_unblock_sillyrename</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">nfs_free_fattr</span><span class="p">(</span><span class="n">fattr</span><span class="p">);</span>
	<span class="n">nfs_free_fhandle</span><span class="p">(</span><span class="n">fhandle</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NFS_V4</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nfs4_lookup_revalidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="p">);</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="n">nfs4_dentry_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">d_revalidate</span>	<span class="o">=</span> <span class="n">nfs4_lookup_revalidate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">d_delete</span>	<span class="o">=</span> <span class="n">nfs_dentry_delete</span><span class="p">,</span>
	<span class="p">.</span><span class="n">d_iput</span>		<span class="o">=</span> <span class="n">nfs_dentry_iput</span><span class="p">,</span>
	<span class="p">.</span><span class="n">d_automount</span>	<span class="o">=</span> <span class="n">nfs_d_automount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">d_release</span>	<span class="o">=</span> <span class="n">nfs_d_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Use intent information to determine whether we need to substitute</span>
<span class="cm"> * the NFSv4-style stateful OPEN for the LOOKUP call</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_atomic_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">nfs_lookup_check_intent</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">LOOKUP_OPEN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* NFS does not (yet) have a stateful open for directories */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_DIRECTORY</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Are we trying to write to a read only partition? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__mnt_is_readonly</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">intent</span><span class="p">.</span><span class="n">open</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">O_CREAT</span><span class="o">|</span><span class="n">O_TRUNC</span><span class="o">|</span><span class="n">O_ACCMODE</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">fmode_t</span> <span class="nf">flags_to_mode</span><span class="p">(</span><span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fmode_t</span> <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">fmode_t</span><span class="p">)</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FMODE_EXEC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">)</span> <span class="o">!=</span> <span class="n">O_WRONLY</span><span class="p">)</span>
		<span class="n">res</span> <span class="o">|=</span> <span class="n">FMODE_READ</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">)</span> <span class="o">!=</span> <span class="n">O_RDONLY</span><span class="p">)</span>
		<span class="n">res</span> <span class="o">|=</span> <span class="n">FMODE_WRITE</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="nf">create_nfs_open_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">int</span> <span class="n">open_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">alloc_nfs_open_context</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">flags_to_mode</span><span class="p">(</span><span class="n">open_flags</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nfs_fscache_set_inode_cookie</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_intent_set_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If the open_intent is for execute, we have an extra check to make */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FMODE_EXEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nfs_may_open</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">,</span>
				<span class="n">nd</span><span class="o">-&gt;</span><span class="n">intent</span><span class="p">.</span><span class="n">open</span><span class="p">.</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">filp</span> <span class="o">=</span> <span class="n">lookup_instantiate_filp</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span> <span class="n">do_open</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">filp</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">nfs_file_set_open_context</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">put_nfs_open_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">nfs_atomic_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iattr</span> <span class="n">attr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">open_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">dfprintk</span><span class="p">(</span><span class="n">VFS</span><span class="p">,</span> <span class="s">&quot;NFS: atomic_lookup(%s/%ld), %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* Check that we are indeed trying to open this file */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_atomic_open</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">no_open</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">namelen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Let vfs_create() deal with O_EXCL. Instantiate, but don&#39;t hash</span>
<span class="cm">	 * the dentry. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_EXCL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">open_flags</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">intent</span><span class="p">.</span><span class="n">open</span><span class="p">.</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">attr</span><span class="p">.</span><span class="n">ia_valid</span> <span class="o">=</span> <span class="n">ATTR_OPEN</span><span class="p">;</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">create_nfs_open_context</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">open_flags</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_CREATE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">attr</span><span class="p">.</span><span class="n">ia_mode</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">intent</span><span class="p">.</span><span class="n">open</span><span class="p">.</span><span class="n">create_mode</span><span class="p">;</span>
		<span class="n">attr</span><span class="p">.</span><span class="n">ia_valid</span> <span class="o">|=</span> <span class="n">ATTR_MODE</span><span class="p">;</span>
		<span class="n">attr</span><span class="p">.</span><span class="n">ia_mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">current_umask</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">open_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">O_EXCL</span> <span class="o">|</span> <span class="n">O_CREAT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">open_flags</span> <span class="o">&amp;</span> <span class="n">O_TRUNC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">attr</span><span class="p">.</span><span class="n">ia_valid</span> <span class="o">|=</span> <span class="n">ATTR_SIZE</span><span class="p">;</span>
		<span class="n">attr</span><span class="p">.</span><span class="n">ia_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Open the file on the server */</span>
	<span class="n">nfs_block_sillyrename</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">);</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">NFS_PROTO</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">open_context</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">open_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nfs_unblock_sillyrename</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">);</span>
		<span class="n">put_nfs_open_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Make a negative dentry */</span>
			<span class="k">case</span> <span class="o">-</span><span class="n">ENOENT</span>:
				<span class="n">d_add</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
				<span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="cm">/* This turned out not to be a regular file */</span>
			<span class="k">case</span> <span class="o">-</span><span class="n">EISDIR</span>:
			<span class="k">case</span> <span class="o">-</span><span class="n">ENOTDIR</span>:
				<span class="k">goto</span> <span class="n">no_open</span><span class="p">;</span>
			<span class="k">case</span> <span class="o">-</span><span class="n">ELOOP</span>:
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">intent</span><span class="p">.</span><span class="n">open</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_NOFOLLOW</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">no_open</span><span class="p">;</span>
			<span class="cm">/* case -EINVAL: */</span>
			<span class="nl">default:</span>
				<span class="n">res</span> <span class="o">=</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">d_add_unique</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">nfs_unblock_sillyrename</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
		<span class="n">dentry</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfs_intent_set_file</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">dput</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">nfs_set_verifier</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">nfs_save_change_attribute</span><span class="p">(</span><span class="n">dir</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="nl">no_open:</span>
	<span class="k">return</span> <span class="n">nfs_lookup</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs4_lookup_revalidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">openflags</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_RCU</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_atomic_open</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span> <span class="o">||</span> <span class="n">d_mountpoint</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">no_open</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">dget_parent</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">dir</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="cm">/* We can&#39;t create new files in nfs_open_revalidate(), so we</span>
<span class="cm">	 * optimize away revalidation of negative dentries.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nfs_neg_need_reval</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">nd</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* NFS only supports OPEN on regular files */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">no_open_dput</span><span class="p">;</span>
	<span class="n">openflags</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">intent</span><span class="p">.</span><span class="n">open</span><span class="p">.</span><span class="n">flags</span><span class="p">;</span>
	<span class="cm">/* We cannot do exclusive creation on a positive dentry */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">openflags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">O_CREAT</span><span class="o">|</span><span class="n">O_EXCL</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="n">O_CREAT</span><span class="o">|</span><span class="n">O_EXCL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">no_open_dput</span><span class="p">;</span>

	<span class="cm">/* Let f_op-&gt;open() actually open (and revalidate) the file */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">no_open_dput:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
<span class="nl">no_open:</span>
	<span class="k">return</span> <span class="n">nfs_lookup_revalidate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">nd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_open_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
		<span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iattr</span> <span class="n">attr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">open_flags</span> <span class="o">=</span> <span class="n">O_CREAT</span><span class="o">|</span><span class="n">O_EXCL</span><span class="p">;</span>

	<span class="n">dfprintk</span><span class="p">(</span><span class="n">VFS</span><span class="p">,</span> <span class="s">&quot;NFS: create(%s/%ld), %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="n">attr</span><span class="p">.</span><span class="n">ia_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">attr</span><span class="p">.</span><span class="n">ia_valid</span> <span class="o">=</span> <span class="n">ATTR_MODE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="p">)</span>
		<span class="n">open_flags</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">intent</span><span class="p">.</span><span class="n">open</span><span class="p">.</span><span class="n">flags</span><span class="p">;</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">create_nfs_open_context</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">open_flags</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_err_drop</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">NFS_PROTO</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">open_flags</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put_ctx</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">nfs_intent_set_file</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">put_nfs_open_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_put_ctx:</span>
	<span class="n">put_nfs_open_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="nl">out_err_drop:</span>
	<span class="n">d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
<span class="nl">out_err:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_NFSV4 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Code common to create, mkdir, and mknod.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nfs_instantiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">fhandle</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">dget_parent</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="n">d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

	<span class="cm">/* We may have been initialized further down */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fhandle</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">NFS_PROTO</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lookup</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="n">fhandle</span><span class="p">,</span> <span class="n">fattr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nfs_set_verifier</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">nfs_save_change_attribute</span><span class="p">(</span><span class="n">dir</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span> <span class="o">=</span> <span class="n">NFS_SB</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">nfs_client</span><span class="o">-&gt;</span><span class="n">rpc_ops</span><span class="o">-&gt;</span><span class="n">getattr</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">fhandle</span><span class="p">,</span> <span class="n">fattr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">nfs_fhget</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">,</span> <span class="n">fhandle</span><span class="p">,</span> <span class="n">fattr</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_error</span><span class="p">;</span>
	<span class="n">d_add</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_error:</span>
	<span class="n">nfs_mark_for_revalidate</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Following a failed create operation, we drop the dentry rather</span>
<span class="cm"> * than retain a negative dentry. This avoids a problem in the event</span>
<span class="cm"> * that the operation succeeded on the server, but an error in the</span>
<span class="cm"> * reply path made it appear to have failed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
		<span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iattr</span> <span class="n">attr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">open_flags</span> <span class="o">=</span> <span class="n">O_CREAT</span><span class="o">|</span><span class="n">O_EXCL</span><span class="p">;</span>

	<span class="n">dfprintk</span><span class="p">(</span><span class="n">VFS</span><span class="p">,</span> <span class="s">&quot;NFS: create(%s/%ld), %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="n">attr</span><span class="p">.</span><span class="n">ia_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">attr</span><span class="p">.</span><span class="n">ia_valid</span> <span class="o">=</span> <span class="n">ATTR_MODE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="p">)</span>
		<span class="n">open_flags</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">intent</span><span class="p">.</span><span class="n">open</span><span class="p">.</span><span class="n">flags</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">NFS_PROTO</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">open_flags</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_err:</span>
	<span class="n">d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * See comments for nfs_proc_create regarding failed operations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">nfs_mknod</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dev_t</span> <span class="n">rdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iattr</span> <span class="n">attr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">dfprintk</span><span class="p">(</span><span class="n">VFS</span><span class="p">,</span> <span class="s">&quot;NFS: mknod(%s/%ld), %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_valid_dev</span><span class="p">(</span><span class="n">rdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">attr</span><span class="p">.</span><span class="n">ia_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">attr</span><span class="p">.</span><span class="n">ia_valid</span> <span class="o">=</span> <span class="n">ATTR_MODE</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">NFS_PROTO</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mknod</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">rdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_err:</span>
	<span class="n">d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * See comments for nfs_proc_create regarding failed operations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_mkdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iattr</span> <span class="n">attr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">dfprintk</span><span class="p">(</span><span class="n">VFS</span><span class="p">,</span> <span class="s">&quot;NFS: mkdir(%s/%ld), %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="n">attr</span><span class="p">.</span><span class="n">ia_valid</span> <span class="o">=</span> <span class="n">ATTR_MODE</span><span class="p">;</span>
	<span class="n">attr</span><span class="p">.</span><span class="n">ia_mode</span> <span class="o">=</span> <span class="n">mode</span> <span class="o">|</span> <span class="n">S_IFDIR</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">NFS_PROTO</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mkdir</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_err:</span>
	<span class="n">d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs_dentry_handle_enoent</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">d_unhashed</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
		<span class="n">d_delete</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_rmdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">dfprintk</span><span class="p">(</span><span class="n">VFS</span><span class="p">,</span> <span class="s">&quot;NFS: rmdir(%s/%ld), %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">NFS_PROTO</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rmdir</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
	<span class="cm">/* Ensure the VFS deletes this inode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">clear_nlink</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
		<span class="n">nfs_dentry_handle_enoent</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove a file after making sure there are no pending writes,</span>
<span class="cm"> * and after checking that the file has only one user. </span>
<span class="cm"> *</span>
<span class="cm"> * We invalidate the attribute cache and free the inode prior to the operation</span>
<span class="cm"> * to avoid possible races if the server reuses the inode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_safe_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		
	<span class="n">dfprintk</span><span class="p">(</span><span class="n">VFS</span><span class="p">,</span> <span class="s">&quot;NFS: safe_remove(%s/%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* If the dentry was sillyrenamed, we simply call d_delete() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_NFSFS_RENAMED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nfs_inode_return_delegation</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">NFS_PROTO</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
		<span class="cm">/* The VFS may want to delete this inode */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">nfs_drop_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">nfs_mark_for_revalidate</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">NFS_PROTO</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
		<span class="n">nfs_dentry_handle_enoent</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*  We do silly rename. In case sillyrename() returns -EBUSY, the inode</span>
<span class="cm"> *  belongs to an active &quot;.nfs...&quot; file and we return -EBUSY.</span>
<span class="cm"> *</span>
<span class="cm"> *  If sillyrename() returns 0, we do nothing, otherwise we unlink.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">need_rehash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dfprintk</span><span class="p">(</span><span class="n">VFS</span><span class="p">,</span> <span class="s">&quot;NFS: unlink(%s/%ld, %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span>
		<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="cm">/* Start asynchronous writeout of the inode */</span>
		<span class="n">write_inode_now</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">nfs_sillyrename</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_unhashed</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">need_rehash</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">nfs_safe_remove</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">||</span> <span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nfs_set_verifier</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">nfs_save_change_attribute</span><span class="p">(</span><span class="n">dir</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">need_rehash</span><span class="p">)</span>
		<span class="n">d_rehash</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * To create a symbolic link, most file systems instantiate a new inode,</span>
<span class="cm"> * add a page to it containing the path, then write it out to the disk</span>
<span class="cm"> * using prepare_write/commit_write.</span>
<span class="cm"> *</span>
<span class="cm"> * Unfortunately the NFS client can&#39;t create the in-core inode first</span>
<span class="cm"> * because it needs a file handle to create an in-core inode (see</span>
<span class="cm"> * fs/nfs/inode.c:nfs_fhget).  We only have a file handle *after* the</span>
<span class="cm"> * symlink request has completed on the server.</span>
<span class="cm"> *</span>
<span class="cm"> * So instead we allocate a raw page, copy the symname into it, then do</span>
<span class="cm"> * the SYMLINK request with the page as the buffer.  If it succeeds, we</span>
<span class="cm"> * now have a new file handle and can instantiate an in-core NFS inode</span>
<span class="cm"> * and move the raw page into its mapping.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pagevec</span> <span class="n">lru_pvec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iattr</span> <span class="n">attr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pathlen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">symname</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">dfprintk</span><span class="p">(</span><span class="n">VFS</span><span class="p">,</span> <span class="s">&quot;NFS: symlink(%s/%ld, %s, %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span>
		<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">symname</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pathlen</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">;</span>

	<span class="n">attr</span><span class="p">.</span><span class="n">ia_mode</span> <span class="o">=</span> <span class="n">S_IFLNK</span> <span class="o">|</span> <span class="n">S_IRWXUGO</span><span class="p">;</span>
	<span class="n">attr</span><span class="p">.</span><span class="n">ia_valid</span> <span class="o">=</span> <span class="n">ATTR_MODE</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_HIGHUSER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">kaddr</span><span class="p">,</span> <span class="n">symname</span><span class="p">,</span> <span class="n">pathlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pathlen</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">kaddr</span> <span class="o">+</span> <span class="n">pathlen</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">pathlen</span><span class="p">);</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">NFS_PROTO</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">symlink</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">pathlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dfprintk</span><span class="p">(</span><span class="n">VFS</span><span class="p">,</span> <span class="s">&quot;NFS: symlink(%s/%ld, %s, %s) error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">symname</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="n">d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * No big deal if we can&#39;t add this page to the page cache here.</span>
<span class="cm">	 * READLINK will get the missing page from the server if needed.</span>
<span class="cm">	 */</span>
	<span class="n">pagevec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lru_pvec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">add_to_page_cache</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
							<span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pagevec_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lru_pvec</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">pagevec_lru_add_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lru_pvec</span><span class="p">);</span>
		<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> 
<span class="nf">nfs_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">dfprintk</span><span class="p">(</span><span class="n">VFS</span><span class="p">,</span> <span class="s">&quot;NFS: link(%s/%s -&gt; %s/%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="n">nfs_inode_return_delegation</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">NFS_PROTO</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ihold</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">d_add</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * RENAME</span>
<span class="cm"> * FIXME: Some nfsds, like the Linux user space nfsd, may generate a</span>
<span class="cm"> * different file handle for the same inode after a rename (e.g. when</span>
<span class="cm"> * moving to a different directory). A fail-safe method to do so would</span>
<span class="cm"> * be to look up old_dir/old_name, create a link to new_dir/new_name and</span>
<span class="cm"> * rename the old file using the sillyrename stuff. This way, the original</span>
<span class="cm"> * file in old_dir will go away when the last process iput()s the inode.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXED.</span>
<span class="cm"> * </span>
<span class="cm"> * It actually works quite well. One needs to have the possibility for</span>
<span class="cm"> * at least one &quot;.nfs...&quot; file in each directory the file ever gets</span>
<span class="cm"> * moved or linked to which happens automagically with the new</span>
<span class="cm"> * implementation that only depends on the dcache stuff instead of</span>
<span class="cm"> * using the inode layer</span>
<span class="cm"> *</span>
<span class="cm"> * Unfortunately, things are a little more complicated than indicated</span>
<span class="cm"> * above. For a cross-directory move, we want to make sure we can get</span>
<span class="cm"> * rid of the old inode after the operation.  This means there must be</span>
<span class="cm"> * no pending writes (if it&#39;s a file), and the use count must be 1.</span>
<span class="cm"> * If these conditions are met, we can drop the dentries before doing</span>
<span class="cm"> * the rename.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">new_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old_inode</span> <span class="o">=</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">new_inode</span> <span class="o">=</span> <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">rehash</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">dfprintk</span><span class="p">(</span><span class="n">VFS</span><span class="p">,</span> <span class="s">&quot;NFS: rename(%s/%s -&gt; %s/%s, ct=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
		 <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
		 <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * For non-directories, check whether the target is busy and if so,</span>
<span class="cm">	 * make a copy of the dentry and then do a silly-rename. If the</span>
<span class="cm">	 * silly-rename succeeds, the copied dentry is hashed and becomes</span>
<span class="cm">	 * the new target.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_inode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">new_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * To prevent any new references to the target during the</span>
<span class="cm">		 * rename, we unhash the dentry in advance.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_unhashed</span><span class="p">(</span><span class="n">new_dentry</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">d_drop</span><span class="p">(</span><span class="n">new_dentry</span><span class="p">);</span>
			<span class="n">rehash</span> <span class="o">=</span> <span class="n">new_dentry</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_count</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

			<span class="cm">/* copy the target dentry&#39;s name */</span>
			<span class="n">dentry</span> <span class="o">=</span> <span class="n">d_alloc</span><span class="p">(</span><span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="cm">/* silly-rename the existing target ... */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">nfs_sillyrename</span><span class="p">(</span><span class="n">new_dir</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="n">new_dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
			<span class="n">rehash</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">new_inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">nfs_inode_return_delegation</span><span class="p">(</span><span class="n">old_inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_inode</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">nfs_inode_return_delegation</span><span class="p">(</span><span class="n">new_inode</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">NFS_PROTO</span><span class="p">(</span><span class="n">old_dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rename</span><span class="p">(</span><span class="n">old_dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span>
					   <span class="n">new_dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
	<span class="n">nfs_mark_for_revalidate</span><span class="p">(</span><span class="n">old_inode</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rehash</span><span class="p">)</span>
		<span class="n">d_rehash</span><span class="p">(</span><span class="n">rehash</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_inode</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">nfs_drop_nlink</span><span class="p">(</span><span class="n">new_inode</span><span class="p">);</span>
		<span class="n">d_move</span><span class="p">(</span><span class="n">old_dentry</span><span class="p">,</span> <span class="n">new_dentry</span><span class="p">);</span>
		<span class="n">nfs_set_verifier</span><span class="p">(</span><span class="n">new_dentry</span><span class="p">,</span>
					<span class="n">nfs_save_change_attribute</span><span class="p">(</span><span class="n">new_dir</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
		<span class="n">nfs_dentry_handle_enoent</span><span class="p">(</span><span class="n">old_dentry</span><span class="p">);</span>

	<span class="cm">/* new dentry created? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="p">)</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">nfs_access_lru_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">nfs_access_lru_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">atomic_long_t</span> <span class="n">nfs_access_nr_entries</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs_access_free_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_access_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_rpccred</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">smp_mb__before_atomic_dec</span><span class="p">();</span>
	<span class="n">atomic_long_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfs_access_nr_entries</span><span class="p">);</span>
	<span class="n">smp_mb__after_atomic_dec</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs_access_free_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_access_entry</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cache</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_access_entry</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
		<span class="n">nfs_access_free_entry</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nfs_access_cache_shrinker</span><span class="p">(</span><span class="k">struct</span> <span class="n">shrinker</span> <span class="o">*</span><span class="n">shrink</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">shrink_control</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_access_entry</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_to_scan</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">nr_to_scan</span><span class="p">;</span>
	<span class="n">gfp_t</span> <span class="n">gfp_mask</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">gfp_mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">GFP_KERNEL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">GFP_KERNEL</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">nr_to_scan</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfs_access_lru_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">nfsi</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfs_access_lru_list</span><span class="p">,</span> <span class="n">access_cache_inode_lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nr_to_scan</span><span class="o">--</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">access_cache_entry_lru</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">remove_lru_entry</span><span class="p">;</span>
		<span class="n">cache</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">access_cache_entry_lru</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">nfs_access_entry</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">);</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">access_cache</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">access_cache_entry_lru</span><span class="p">))</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">access_cache_inode_lru</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">nfs_access_lru_list</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
<span class="nl">remove_lru_entry:</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">access_cache_inode_lru</span><span class="p">);</span>
			<span class="n">smp_mb__before_clear_bit</span><span class="p">();</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">NFS_INO_ACL_LRU_SET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfs_access_lru_lock</span><span class="p">);</span>
	<span class="n">nfs_access_free_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfs_access_nr_entries</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span> <span class="o">*</span> <span class="n">sysctl_vfs_cache_pressure</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__nfs_access_zap_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root_node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">access_cache</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_access_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="cm">/* Unhook entries from the cache */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="n">root_node</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_access_entry</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">root_node</span><span class="p">);</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NFS_INO_INVALID_ACCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nfs_access_zap_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NFS_INO_ACL_LRU_SET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* Remove from global LRU init */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfs_access_lru_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">NFS_INO_ACL_LRU_SET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">access_cache_inode_lru</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">__nfs_access_zap_cache</span><span class="p">(</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfs_access_lru_lock</span><span class="p">);</span>
	<span class="n">nfs_access_free_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nfs_access_entry</span> <span class="o">*</span><span class="nf">nfs_access_search_rbtree</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpc_cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">access_cache</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_access_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_access_entry</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cred</span> <span class="o">&lt;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cred</span> <span class="o">&gt;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_access_get_cached</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpc_cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_access_entry</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nfs_access_entry</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">&amp;</span> <span class="n">NFS_INO_INVALID_ACCESS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_zap</span><span class="p">;</span>
	<span class="n">cache</span> <span class="o">=</span> <span class="n">nfs_access_search_rbtree</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">cred</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cache</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nfs_have_delegated_attributes</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">time_in_range_open</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">jiffies</span> <span class="o">+</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">attrtimeo</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_stale</span><span class="p">;</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">jiffies</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">jiffies</span><span class="p">;</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">cred</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">;</span>
	<span class="n">res</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">access_cache_entry_lru</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="nl">out_stale:</span>
	<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">access_cache</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">nfs_access_free_entry</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="nl">out_zap:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">nfs_access_zap_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs_access_add_rbtree</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_access_entry</span> <span class="o">*</span><span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root_node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">access_cache</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root_node</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_access_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_access_entry</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">cred</span> <span class="o">&lt;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">cred</span> <span class="o">&gt;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">root_node</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">access_cache_entry_lru</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">found:</span>
	<span class="n">rb_replace_node</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">root_node</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">access_cache_entry_lru</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">nfs_access_free_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs_access_add_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_access_entry</span> <span class="o">*</span><span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_access_entry</span> <span class="o">*</span><span class="n">cache</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cache</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cache</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">RB_CLEAR_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>
	<span class="n">cache</span><span class="o">-&gt;</span><span class="n">jiffies</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">jiffies</span><span class="p">;</span>
	<span class="n">cache</span><span class="o">-&gt;</span><span class="n">cred</span> <span class="o">=</span> <span class="n">get_rpccred</span><span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">);</span>
	<span class="n">cache</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">=</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>

	<span class="n">nfs_access_add_rbtree</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>

	<span class="cm">/* Update accounting */</span>
	<span class="n">smp_mb__before_atomic_inc</span><span class="p">();</span>
	<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfs_access_nr_entries</span><span class="p">);</span>
	<span class="n">smp_mb__after_atomic_inc</span><span class="p">();</span>

	<span class="cm">/* Add inode to global LRU list */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NFS_INO_ACL_LRU_SET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfs_access_lru_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">NFS_INO_ACL_LRU_SET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">access_cache_inode_lru</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">nfs_access_lru_list</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfs_access_lru_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_do_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpc_cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_access_entry</span> <span class="n">cache</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">nfs_access_get_cached</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">cred</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Be clever: ask server to check for all possible rights */</span>
	<span class="n">cache</span><span class="p">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">MAY_EXEC</span> <span class="o">|</span> <span class="n">MAY_WRITE</span> <span class="o">|</span> <span class="n">MAY_READ</span><span class="p">;</span>
	<span class="n">cache</span><span class="p">.</span><span class="n">cred</span> <span class="o">=</span> <span class="n">cred</span><span class="p">;</span>
	<span class="n">cache</span><span class="p">.</span><span class="n">jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">NFS_PROTO</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ESTALE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nfs_zap_caches</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">NFS_INO_STALE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nfs_access_add_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">cache</span><span class="p">.</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MAY_READ</span> <span class="o">|</span> <span class="n">MAY_WRITE</span> <span class="o">|</span> <span class="n">MAY_EXEC</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_open_permission_mask</span><span class="p">(</span><span class="kt">int</span> <span class="n">openflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">openflags</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">)</span> <span class="o">!=</span> <span class="n">O_WRONLY</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">MAY_READ</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">openflags</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">)</span> <span class="o">!=</span> <span class="n">O_RDONLY</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">MAY_WRITE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">openflags</span> <span class="o">&amp;</span> <span class="n">__FMODE_EXEC</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">MAY_EXEC</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nfs_may_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpc_cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="kt">int</span> <span class="n">openflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nfs_do_access</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">cred</span><span class="p">,</span> <span class="n">nfs_open_permission_mask</span><span class="p">(</span><span class="n">openflags</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nfs_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_NOT_BLOCK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">;</span>

	<span class="n">nfs_inc_stats</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">NFSIOS_VFSACCESS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MAY_READ</span> <span class="o">|</span> <span class="n">MAY_WRITE</span> <span class="o">|</span> <span class="n">MAY_EXEC</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/* Is this sys_access() ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MAY_ACCESS</span> <span class="o">|</span> <span class="n">MAY_CHDIR</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">force_lookup</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">S_IFLNK</span>:
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">S_IFREG</span>:
			<span class="cm">/* NFSv4 has atomic_open... */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nfs_server_capable</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">NFS_CAP_ATOMIC_OPEN</span><span class="p">)</span>
					<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_OPEN</span><span class="p">)</span>
					<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_EXEC</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">S_IFDIR</span>:
			<span class="cm">/*</span>
<span class="cm">			 * Optimize away all write operations, since the server</span>
<span class="cm">			 * will check permissions when we perform the op.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_READ</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">force_lookup:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NFS_PROTO</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_notsup</span><span class="p">;</span>

	<span class="n">cred</span> <span class="o">=</span> <span class="n">rpc_lookup_cred</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">cred</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">nfs_do_access</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">cred</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
		<span class="n">put_rpccred</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_EXEC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">execute_ok</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="n">dfprintk</span><span class="p">(</span><span class="n">VFS</span><span class="p">,</span> <span class="s">&quot;NFS: permission(%s/%ld), mask=0x%x, res=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="nl">out_notsup:</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">nfs_revalidate_inode</span><span class="p">(</span><span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">generic_permission</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Local variables:</span>
<span class="cm"> *  version-control: t</span>
<span class="cm"> *  kept-new-versions: 5</span>
<span class="cm"> * End:</span>
<span class="cm"> */</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
