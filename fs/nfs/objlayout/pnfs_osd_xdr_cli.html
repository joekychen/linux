<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › nfs › objlayout › pnfs_osd_xdr_cli.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>pnfs_osd_xdr_cli.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Object-Based pNFS Layout XDR layer</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2007 Panasas Inc. [year of first publication]</span>
<span class="cm"> *  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *  Benny Halevy &lt;bhalevy@panasas.com&gt;</span>
<span class="cm"> *  Boaz Harrosh &lt;bharrosh@panasas.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License version 2</span>
<span class="cm"> *  See the file COPYING included with this distribution for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> *  modification, are permitted provided that the following conditions</span>
<span class="cm"> *  are met:</span>
<span class="cm"> *</span>
<span class="cm"> *  1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *  2. Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer in the</span>
<span class="cm"> *     documentation and/or other materials provided with the distribution.</span>
<span class="cm"> *  3. Neither the name of the Panasas company nor the names of its</span>
<span class="cm"> *     contributors may be used to endorse or promote products derived</span>
<span class="cm"> *     from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> *  THIS SOFTWARE IS PROVIDED ``AS IS&#39;&#39; AND ANY EXPRESS OR IMPLIED</span>
<span class="cm"> *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
<span class="cm"> *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="cm"> *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</span>
<span class="cm"> *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="cm"> *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="cm"> *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR</span>
<span class="cm"> *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span>
<span class="cm"> *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<span class="cm"> *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<span class="cm"> *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/pnfs_osd_xdr.h&gt;</span>

<span class="cp">#define NFSDBG_FACILITY         NFSDBG_PNFS_LD</span>

<span class="cm">/*</span>
<span class="cm"> * The following implementation is based on RFC5664</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * struct pnfs_osd_objid {</span>
<span class="cm"> *	struct nfs4_deviceid	oid_device_id;</span>
<span class="cm"> *	u64			oid_partition_id;</span>
<span class="cm"> *	u64			oid_object_id;</span>
<span class="cm"> * }; // xdr size 32 bytes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span>
<span class="nf">_osd_xdr_decode_objid</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pnfs_osd_objid</span> <span class="o">*</span><span class="n">objid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_opaque_fixed</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">objid</span><span class="o">-&gt;</span><span class="n">oid_device_id</span><span class="p">.</span><span class="n">data</span><span class="p">,</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="n">objid</span><span class="o">-&gt;</span><span class="n">oid_device_id</span><span class="p">.</span><span class="n">data</span><span class="p">));</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_hyper</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">objid</span><span class="o">-&gt;</span><span class="n">oid_partition_id</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_hyper</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">objid</span><span class="o">-&gt;</span><span class="n">oid_object_id</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * struct pnfs_osd_opaque_cred {</span>
<span class="cm"> *	u32 cred_len;</span>
<span class="cm"> *	void *cred;</span>
<span class="cm"> * }; // xdr size [variable]</span>
<span class="cm"> * The return pointers are from the xdr buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">_osd_xdr_decode_opaque_cred</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_osd_opaque_cred</span> <span class="o">*</span><span class="n">opaque_cred</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">opaque_cred</span><span class="o">-&gt;</span><span class="n">cred_len</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">opaque_cred</span><span class="o">-&gt;</span><span class="n">cred_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">opaque_cred</span><span class="o">-&gt;</span><span class="n">cred</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * struct pnfs_osd_object_cred {</span>
<span class="cm"> *	struct pnfs_osd_objid		oc_object_id;</span>
<span class="cm"> *	u32				oc_osd_version;</span>
<span class="cm"> *	u32				oc_cap_key_sec;</span>
<span class="cm"> *	struct pnfs_osd_opaque_cred	oc_cap_key</span>
<span class="cm"> *	struct pnfs_osd_opaque_cred	oc_cap;</span>
<span class="cm"> * }; // xdr size 32 + 4 + 4 + [variable] + [variable]</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">_osd_xdr_decode_object_cred</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_osd_object_cred</span> <span class="o">*</span><span class="n">comp</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">32</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">_osd_xdr_decode_objid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">comp</span><span class="o">-&gt;</span><span class="n">oc_object_id</span><span class="p">);</span>
	<span class="n">comp</span><span class="o">-&gt;</span><span class="n">oc_osd_version</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">comp</span><span class="o">-&gt;</span><span class="n">oc_cap_key_sec</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">_osd_xdr_decode_opaque_cred</span><span class="p">(</span><span class="o">&amp;</span><span class="n">comp</span><span class="o">-&gt;</span><span class="n">oc_cap_key</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">_osd_xdr_decode_opaque_cred</span><span class="p">(</span><span class="o">&amp;</span><span class="n">comp</span><span class="o">-&gt;</span><span class="n">oc_cap</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * struct pnfs_osd_data_map {</span>
<span class="cm"> *	u32	odm_num_comps;</span>
<span class="cm"> *	u64	odm_stripe_unit;</span>
<span class="cm"> *	u32	odm_group_width;</span>
<span class="cm"> *	u32	odm_group_depth;</span>
<span class="cm"> *	u32	odm_mirror_cnt;</span>
<span class="cm"> *	u32	odm_raid_algorithm;</span>
<span class="cm"> * }; // xdr size 4 + 8 + 4 + 4 + 4 + 4</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">_osd_data_map_xdr_sz</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span>
<span class="nf">_osd_xdr_decode_data_map</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pnfs_osd_data_map</span> <span class="o">*</span><span class="n">data_map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">data_map</span><span class="o">-&gt;</span><span class="n">odm_num_comps</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_hyper</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data_map</span><span class="o">-&gt;</span><span class="n">odm_stripe_unit</span><span class="p">);</span>
	<span class="n">data_map</span><span class="o">-&gt;</span><span class="n">odm_group_width</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">data_map</span><span class="o">-&gt;</span><span class="n">odm_group_depth</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">data_map</span><span class="o">-&gt;</span><span class="n">odm_mirror_cnt</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">data_map</span><span class="o">-&gt;</span><span class="n">odm_raid_algorithm</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: odm_num_comps=%u odm_stripe_unit=%llu odm_group_width=%u &quot;</span>
		<span class="s">&quot;odm_group_depth=%u odm_mirror_cnt=%u odm_raid_algorithm=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span>
		<span class="n">data_map</span><span class="o">-&gt;</span><span class="n">odm_num_comps</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">data_map</span><span class="o">-&gt;</span><span class="n">odm_stripe_unit</span><span class="p">,</span>
		<span class="n">data_map</span><span class="o">-&gt;</span><span class="n">odm_group_width</span><span class="p">,</span>
		<span class="n">data_map</span><span class="o">-&gt;</span><span class="n">odm_group_depth</span><span class="p">,</span>
		<span class="n">data_map</span><span class="o">-&gt;</span><span class="n">odm_mirror_cnt</span><span class="p">,</span>
		<span class="n">data_map</span><span class="o">-&gt;</span><span class="n">odm_raid_algorithm</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">pnfs_osd_xdr_decode_layout_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_osd_layout</span> <span class="o">*</span><span class="n">layout</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">pnfs_osd_xdr_decode_layout_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">));</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">_osd_data_map_xdr_sz</span><span class="p">()</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">_osd_xdr_decode_data_map</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">layout</span><span class="o">-&gt;</span><span class="n">olo_map</span><span class="p">);</span>
	<span class="n">layout</span><span class="o">-&gt;</span><span class="n">olo_comps_index</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">layout</span><span class="o">-&gt;</span><span class="n">olo_num_comps</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: olo_comps_index=%d olo_num_comps=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">layout</span><span class="o">-&gt;</span><span class="n">olo_comps_index</span><span class="p">,</span> <span class="n">layout</span><span class="o">-&gt;</span><span class="n">olo_num_comps</span><span class="p">);</span>

	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">total_comps</span> <span class="o">=</span> <span class="n">layout</span><span class="o">-&gt;</span><span class="n">olo_num_comps</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">pnfs_osd_xdr_decode_layout_comp</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_osd_object_cred</span> <span class="o">*</span><span class="n">comp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">pnfs_osd_xdr_decode_layout_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">decoded_comps</span> <span class="o">&gt;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">total_comps</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">decoded_comps</span> <span class="o">==</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">total_comps</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="n">_osd_xdr_decode_object_cred</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">*</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: _osd_xdr_decode_object_cred=&gt;%d decoded_comps=%d &quot;</span>
			<span class="s">&quot;total_comps=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="o">*</span><span class="n">err</span><span class="p">,</span>
			<span class="n">iter</span><span class="o">-&gt;</span><span class="n">decoded_comps</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">total_comps</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="cm">/* stop the loop */</span>
	<span class="p">}</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: dev(%llx:%llx) par=0x%llx obj=0x%llx &quot;</span>
		<span class="s">&quot;key_len=%u cap_len=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span>
		<span class="n">_DEVID_LO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">comp</span><span class="o">-&gt;</span><span class="n">oc_object_id</span><span class="p">.</span><span class="n">oid_device_id</span><span class="p">),</span>
		<span class="n">_DEVID_HI</span><span class="p">(</span><span class="o">&amp;</span><span class="n">comp</span><span class="o">-&gt;</span><span class="n">oc_object_id</span><span class="p">.</span><span class="n">oid_device_id</span><span class="p">),</span>
		<span class="n">comp</span><span class="o">-&gt;</span><span class="n">oc_object_id</span><span class="p">.</span><span class="n">oid_partition_id</span><span class="p">,</span>
		<span class="n">comp</span><span class="o">-&gt;</span><span class="n">oc_object_id</span><span class="p">.</span><span class="n">oid_object_id</span><span class="p">,</span>
		<span class="n">comp</span><span class="o">-&gt;</span><span class="n">oc_cap_key</span><span class="p">.</span><span class="n">cred_len</span><span class="p">,</span> <span class="n">comp</span><span class="o">-&gt;</span><span class="n">oc_cap</span><span class="p">.</span><span class="n">cred_len</span><span class="p">);</span>

	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">decoded_comps</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get Device Information Decoding</span>
<span class="cm"> *</span>
<span class="cm"> * Note: since Device Information is currently done synchronously, all</span>
<span class="cm"> *       variable strings fields are left inside the rpc buffer and are only</span>
<span class="cm"> *       pointed to by the pnfs_osd_deviceaddr members. So the read buffer</span>
<span class="cm"> *       should not be freed while the returned information is in use.</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> *struct nfs4_string {</span>
<span class="cm"> *	unsigned int len;</span>
<span class="cm"> *	char *data;</span>
<span class="cm"> *}; // size [variable]</span>
<span class="cm"> * NOTE: Returned string points to inside the XDR buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span>
<span class="nf">__read_u8_opaque</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs4_string</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">str</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">str</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">+=</span> <span class="n">XDR_QUADLEN</span><span class="p">(</span><span class="n">str</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * struct pnfs_osd_targetid {</span>
<span class="cm"> *	u32			oti_type;</span>
<span class="cm"> *	struct nfs4_string	oti_scsi_device_id;</span>
<span class="cm"> * };// size 4 + [variable]</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span>
<span class="nf">__read_targetid</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pnfs_osd_targetid</span><span class="o">*</span> <span class="n">targetid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">oti_type</span><span class="p">;</span>

	<span class="n">oti_type</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">targetid</span><span class="o">-&gt;</span><span class="n">oti_type</span> <span class="o">=</span> <span class="n">oti_type</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">oti_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">OBJ_TARGET_SCSI_NAME</span>:
	<span class="k">case</span> <span class="n">OBJ_TARGET_SCSI_DEVICE_ID</span>:
		<span class="n">p</span> <span class="o">=</span> <span class="n">__read_u8_opaque</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">targetid</span><span class="o">-&gt;</span><span class="n">oti_scsi_device_id</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * struct pnfs_osd_net_addr {</span>
<span class="cm"> *	struct nfs4_string	r_netid;</span>
<span class="cm"> *	struct nfs4_string	r_addr;</span>
<span class="cm"> * };</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span>
<span class="nf">__read_net_addr</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pnfs_osd_net_addr</span><span class="o">*</span> <span class="n">netaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">__read_u8_opaque</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">netaddr</span><span class="o">-&gt;</span><span class="n">r_netid</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">__read_u8_opaque</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">netaddr</span><span class="o">-&gt;</span><span class="n">r_addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * struct pnfs_osd_targetaddr {</span>
<span class="cm"> *	u32				ota_available;</span>
<span class="cm"> *	struct pnfs_osd_net_addr	ota_netaddr;</span>
<span class="cm"> * };</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span>
<span class="nf">__read_targetaddr</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pnfs_osd_targetaddr</span> <span class="o">*</span><span class="n">targetaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ota_available</span><span class="p">;</span>

	<span class="n">ota_available</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">targetaddr</span><span class="o">-&gt;</span><span class="n">ota_available</span> <span class="o">=</span> <span class="n">ota_available</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ota_available</span><span class="p">)</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">__read_net_addr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">targetaddr</span><span class="o">-&gt;</span><span class="n">ota_netaddr</span><span class="p">);</span>


	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * struct pnfs_osd_deviceaddr {</span>
<span class="cm"> *	struct pnfs_osd_targetid	oda_targetid;</span>
<span class="cm"> *	struct pnfs_osd_targetaddr	oda_targetaddr;</span>
<span class="cm"> *	u8				oda_lun[8];</span>
<span class="cm"> *	struct nfs4_string		oda_systemid;</span>
<span class="cm"> *	struct pnfs_osd_object_cred	oda_root_obj_cred;</span>
<span class="cm"> *	struct nfs4_string		oda_osdname;</span>
<span class="cm"> * };</span>
<span class="cm"> */</span>

<span class="cm">/* We need this version for the pnfs_osd_xdr_decode_deviceaddr which does</span>
<span class="cm"> * not have an xdr_stream</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span>
<span class="nf">__read_opaque_cred</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">pnfs_osd_opaque_cred</span> <span class="o">*</span><span class="n">opaque_cred</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">opaque_cred</span><span class="o">-&gt;</span><span class="n">cred_len</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">opaque_cred</span><span class="o">-&gt;</span><span class="n">cred</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">p</span> <span class="o">+</span> <span class="n">XDR_QUADLEN</span><span class="p">(</span><span class="n">opaque_cred</span><span class="o">-&gt;</span><span class="n">cred_len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span>
<span class="nf">__read_object_cred</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pnfs_osd_object_cred</span> <span class="o">*</span><span class="n">comp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">_osd_xdr_decode_objid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">comp</span><span class="o">-&gt;</span><span class="n">oc_object_id</span><span class="p">);</span>
	<span class="n">comp</span><span class="o">-&gt;</span><span class="n">oc_osd_version</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">comp</span><span class="o">-&gt;</span><span class="n">oc_cap_key_sec</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">__read_opaque_cred</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">comp</span><span class="o">-&gt;</span><span class="n">oc_cap_key</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">__read_opaque_cred</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">comp</span><span class="o">-&gt;</span><span class="n">oc_cap</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">pnfs_osd_xdr_decode_deviceaddr</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">pnfs_osd_deviceaddr</span> <span class="o">*</span><span class="n">deviceaddr</span><span class="p">,</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">__read_targetid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">deviceaddr</span><span class="o">-&gt;</span><span class="n">oda_targetid</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">__read_targetaddr</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">deviceaddr</span><span class="o">-&gt;</span><span class="n">oda_targetaddr</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_opaque_fixed</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">deviceaddr</span><span class="o">-&gt;</span><span class="n">oda_lun</span><span class="p">,</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="n">deviceaddr</span><span class="o">-&gt;</span><span class="n">oda_lun</span><span class="p">));</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">__read_u8_opaque</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">deviceaddr</span><span class="o">-&gt;</span><span class="n">oda_systemid</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">__read_object_cred</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">deviceaddr</span><span class="o">-&gt;</span><span class="n">oda_root_obj_cred</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">__read_u8_opaque</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">deviceaddr</span><span class="o">-&gt;</span><span class="n">oda_osdname</span><span class="p">);</span>

	<span class="cm">/* libosd likes this terminated in dbg. It&#39;s last, so no problems */</span>
	<span class="n">deviceaddr</span><span class="o">-&gt;</span><span class="n">oda_osdname</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">deviceaddr</span><span class="o">-&gt;</span><span class="n">oda_osdname</span><span class="p">.</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * struct pnfs_osd_layoutupdate {</span>
<span class="cm"> *	u32	dsu_valid;</span>
<span class="cm"> *	s64	dsu_delta;</span>
<span class="cm"> *	u32	olu_ioerr_flag;</span>
<span class="cm"> * }; xdr size 4 + 8 + 4</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">pnfs_osd_xdr_encode_layoutupdate</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">pnfs_osd_layoutupdate</span> <span class="o">*</span><span class="n">lou</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span>  <span class="mi">4</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>

	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">lou</span><span class="o">-&gt;</span><span class="n">dsu_valid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lou</span><span class="o">-&gt;</span><span class="n">dsu_valid</span><span class="p">)</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_encode_hyper</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">lou</span><span class="o">-&gt;</span><span class="n">dsu_delta</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">lou</span><span class="o">-&gt;</span><span class="n">olu_ioerr_flag</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * struct pnfs_osd_objid {</span>
<span class="cm"> *	struct nfs4_deviceid	oid_device_id;</span>
<span class="cm"> *	u64			oid_partition_id;</span>
<span class="cm"> *	u64			oid_object_id;</span>
<span class="cm"> * }; // xdr size 32 bytes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__be32</span> <span class="o">*</span>
<span class="nf">pnfs_osd_xdr_encode_objid</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pnfs_osd_objid</span> <span class="o">*</span><span class="n">object_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_encode_opaque_fixed</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object_id</span><span class="o">-&gt;</span><span class="n">oid_device_id</span><span class="p">.</span><span class="n">data</span><span class="p">,</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="n">object_id</span><span class="o">-&gt;</span><span class="n">oid_device_id</span><span class="p">.</span><span class="n">data</span><span class="p">));</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_encode_hyper</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">object_id</span><span class="o">-&gt;</span><span class="n">oid_partition_id</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_encode_hyper</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">object_id</span><span class="o">-&gt;</span><span class="n">oid_object_id</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * struct pnfs_osd_ioerr {</span>
<span class="cm"> *	struct pnfs_osd_objid	oer_component;</span>
<span class="cm"> *	u64			oer_comp_offset;</span>
<span class="cm"> *	u64			oer_comp_length;</span>
<span class="cm"> *	u32			oer_iswrite;</span>
<span class="cm"> *	u32			oer_errno;</span>
<span class="cm"> * }; // xdr size 32 + 24 bytes</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pnfs_osd_xdr_encode_ioerr</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pnfs_osd_ioerr</span> <span class="o">*</span><span class="n">ioerr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">pnfs_osd_xdr_encode_objid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ioerr</span><span class="o">-&gt;</span><span class="n">oer_component</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_encode_hyper</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ioerr</span><span class="o">-&gt;</span><span class="n">oer_comp_offset</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_encode_hyper</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ioerr</span><span class="o">-&gt;</span><span class="n">oer_comp_length</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">ioerr</span><span class="o">-&gt;</span><span class="n">oer_iswrite</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span>   <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">ioerr</span><span class="o">-&gt;</span><span class="n">oer_errno</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">__be32</span> <span class="o">*</span><span class="nf">pnfs_osd_xdr_ioerr_reserve_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">32</span> <span class="o">+</span> <span class="mi">24</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">))</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: out of xdr space</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
