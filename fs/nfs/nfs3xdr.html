<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › nfs › nfs3xdr.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>nfs3xdr.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/fs/nfs/nfs3xdr.c</span>
<span class="cm"> *</span>
<span class="cm"> * XDR functions to encode/decode NFSv3 RPC arguments and results.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1996, 1997 Olaf Kirch</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/param.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/kdev_t.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/clnt.h&gt;</span>
<span class="cp">#include &lt;linux/nfs.h&gt;</span>
<span class="cp">#include &lt;linux/nfs3.h&gt;</span>
<span class="cp">#include &lt;linux/nfs_fs.h&gt;</span>
<span class="cp">#include &lt;linux/nfsacl.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cp">#define NFSDBG_FACILITY		NFSDBG_XDR</span>

<span class="cm">/* Mapping from NFS error code to &quot;errno&quot; error code. */</span>
<span class="cp">#define errno_NFSERR_IO		EIO</span>

<span class="cm">/*</span>
<span class="cm"> * Declare the space requirements for NFS arguments and replies as</span>
<span class="cm"> * number of 32bit-words</span>
<span class="cm"> */</span>
<span class="cp">#define NFS3_fhandle_sz		(1+16)</span>
<span class="cp">#define NFS3_fh_sz		(NFS3_fhandle_sz)	</span><span class="cm">/* shorthand */</span><span class="cp"></span>
<span class="cp">#define NFS3_sattr_sz		(15)</span>
<span class="cp">#define NFS3_filename_sz	(1+(NFS3_MAXNAMLEN&gt;&gt;2))</span>
<span class="cp">#define NFS3_path_sz		(1+(NFS3_MAXPATHLEN&gt;&gt;2))</span>
<span class="cp">#define NFS3_fattr_sz		(21)</span>
<span class="cp">#define NFS3_cookieverf_sz	(NFS3_COOKIEVERFSIZE&gt;&gt;2)</span>
<span class="cp">#define NFS3_wcc_attr_sz	(6)</span>
<span class="cp">#define NFS3_pre_op_attr_sz	(1+NFS3_wcc_attr_sz)</span>
<span class="cp">#define NFS3_post_op_attr_sz	(1+NFS3_fattr_sz)</span>
<span class="cp">#define NFS3_wcc_data_sz	(NFS3_pre_op_attr_sz+NFS3_post_op_attr_sz)</span>
<span class="cp">#define NFS3_diropargs_sz	(NFS3_fh_sz+NFS3_filename_sz)</span>

<span class="cp">#define NFS3_getattrargs_sz	(NFS3_fh_sz)</span>
<span class="cp">#define NFS3_setattrargs_sz	(NFS3_fh_sz+NFS3_sattr_sz+3)</span>
<span class="cp">#define NFS3_lookupargs_sz	(NFS3_fh_sz+NFS3_filename_sz)</span>
<span class="cp">#define NFS3_accessargs_sz	(NFS3_fh_sz+1)</span>
<span class="cp">#define NFS3_readlinkargs_sz	(NFS3_fh_sz)</span>
<span class="cp">#define NFS3_readargs_sz	(NFS3_fh_sz+3)</span>
<span class="cp">#define NFS3_writeargs_sz	(NFS3_fh_sz+5)</span>
<span class="cp">#define NFS3_createargs_sz	(NFS3_diropargs_sz+NFS3_sattr_sz)</span>
<span class="cp">#define NFS3_mkdirargs_sz	(NFS3_diropargs_sz+NFS3_sattr_sz)</span>
<span class="cp">#define NFS3_symlinkargs_sz	(NFS3_diropargs_sz+1+NFS3_sattr_sz)</span>
<span class="cp">#define NFS3_mknodargs_sz	(NFS3_diropargs_sz+2+NFS3_sattr_sz)</span>
<span class="cp">#define NFS3_removeargs_sz	(NFS3_fh_sz+NFS3_filename_sz)</span>
<span class="cp">#define NFS3_renameargs_sz	(NFS3_diropargs_sz+NFS3_diropargs_sz)</span>
<span class="cp">#define NFS3_linkargs_sz		(NFS3_fh_sz+NFS3_diropargs_sz)</span>
<span class="cp">#define NFS3_readdirargs_sz	(NFS3_fh_sz+NFS3_cookieverf_sz+3)</span>
<span class="cp">#define NFS3_readdirplusargs_sz	(NFS3_fh_sz+NFS3_cookieverf_sz+4)</span>
<span class="cp">#define NFS3_commitargs_sz	(NFS3_fh_sz+3)</span>

<span class="cp">#define NFS3_getattrres_sz	(1+NFS3_fattr_sz)</span>
<span class="cp">#define NFS3_setattrres_sz	(1+NFS3_wcc_data_sz)</span>
<span class="cp">#define NFS3_removeres_sz	(NFS3_setattrres_sz)</span>
<span class="cp">#define NFS3_lookupres_sz	(1+NFS3_fh_sz+(2 * NFS3_post_op_attr_sz))</span>
<span class="cp">#define NFS3_accessres_sz	(1+NFS3_post_op_attr_sz+1)</span>
<span class="cp">#define NFS3_readlinkres_sz	(1+NFS3_post_op_attr_sz+1)</span>
<span class="cp">#define NFS3_readres_sz		(1+NFS3_post_op_attr_sz+3)</span>
<span class="cp">#define NFS3_writeres_sz	(1+NFS3_wcc_data_sz+4)</span>
<span class="cp">#define NFS3_createres_sz	(1+NFS3_fh_sz+NFS3_post_op_attr_sz+NFS3_wcc_data_sz)</span>
<span class="cp">#define NFS3_renameres_sz	(1+(2 * NFS3_wcc_data_sz))</span>
<span class="cp">#define NFS3_linkres_sz		(1+NFS3_post_op_attr_sz+NFS3_wcc_data_sz)</span>
<span class="cp">#define NFS3_readdirres_sz	(1+NFS3_post_op_attr_sz+2)</span>
<span class="cp">#define NFS3_fsstatres_sz	(1+NFS3_post_op_attr_sz+13)</span>
<span class="cp">#define NFS3_fsinfores_sz	(1+NFS3_post_op_attr_sz+12)</span>
<span class="cp">#define NFS3_pathconfres_sz	(1+NFS3_post_op_attr_sz+6)</span>
<span class="cp">#define NFS3_commitres_sz	(1+NFS3_wcc_data_sz+2)</span>

<span class="cp">#define ACL3_getaclargs_sz	(NFS3_fh_sz+1)</span>
<span class="cp">#define ACL3_setaclargs_sz	(NFS3_fh_sz+1+ \</span>
<span class="cp">				XDR_QUADLEN(NFS_ACL_INLINE_BUFSIZE))</span>
<span class="cp">#define ACL3_getaclres_sz	(1+NFS3_post_op_attr_sz+1+ \</span>
<span class="cp">				XDR_QUADLEN(NFS_ACL_INLINE_BUFSIZE))</span>
<span class="cp">#define ACL3_setaclres_sz	(1+NFS3_post_op_attr_sz)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">nfs3_stat_to_errno</span><span class="p">(</span><span class="k">enum</span> <span class="n">nfs_stat</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Map file type to S_IFMT bits</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">umode_t</span> <span class="n">nfs_type2fmt</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">NF3BAD</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">[</span><span class="n">NF3REG</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_IFREG</span><span class="p">,</span>
	<span class="p">[</span><span class="n">NF3DIR</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_IFDIR</span><span class="p">,</span>
	<span class="p">[</span><span class="n">NF3BLK</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_IFBLK</span><span class="p">,</span>
	<span class="p">[</span><span class="n">NF3CHR</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_IFCHR</span><span class="p">,</span>
	<span class="p">[</span><span class="n">NF3LNK</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_IFLNK</span><span class="p">,</span>
	<span class="p">[</span><span class="n">NF3SOCK</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_IFSOCK</span><span class="p">,</span>
	<span class="p">[</span><span class="n">NF3FIFO</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_IFIFO</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * While encoding arguments, set up the reply buffer in advance to</span>
<span class="cm"> * receive reply data directly into the page cache.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">prepare_reply_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bufsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_auth</span>	<span class="o">*</span><span class="n">auth</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_cred</span><span class="o">-&gt;</span><span class="n">cr_auth</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">replen</span><span class="p">;</span>

	<span class="n">replen</span> <span class="o">=</span> <span class="n">RPC_REPHDRSIZE</span> <span class="o">+</span> <span class="n">auth</span><span class="o">-&gt;</span><span class="n">au_rslack</span> <span class="o">+</span> <span class="n">bufsize</span><span class="p">;</span>
	<span class="n">xdr_inline_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_rcv_buf</span><span class="p">,</span> <span class="n">replen</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle decode buffer overflows out-of-line.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_overflow_msg</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: %s prematurely hit the end of our receive buffer. &quot;</span>
		<span class="s">&quot;Remaining buffer length is %tu words.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">func</span><span class="p">,</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Encode/decode NFSv3 basic data types</span>
<span class="cm"> *</span>
<span class="cm"> * Basic NFSv3 data types are defined in section 2.5 of RFC 1813:</span>
<span class="cm"> * &quot;NFS Version 3 Protocol Specification&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * Not all basic data types have their own encoding and decoding</span>
<span class="cm"> * functions.  For run-time efficiency, some data types are encoded</span>
<span class="cm"> * or decoded inline.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_uint32</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_uint32</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_uint64</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="n">xdr_decode_hyper</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fileid3</span>
<span class="cm"> *</span>
<span class="cm"> *	typedef uint64 fileid3;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span><span class="nf">xdr_decode_fileid3</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">fileid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xdr_decode_hyper</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">fileid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_fileid3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">fileid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">decode_uint64</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">fileid</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * filename3</span>
<span class="cm"> *</span>
<span class="cm"> *	typedef string filename3&lt;&gt;;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_filename3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">u32</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">NFS3_MAXNAMLEN</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">length</span><span class="p">);</span>
	<span class="n">xdr_encode_opaque</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_inline_filename3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">name</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">NFS3_MAXNAMLEN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_nametoolong</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
	<span class="o">*</span><span class="n">length</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_nametoolong:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: returned filename too long: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * nfspath3</span>
<span class="cm"> *</span>
<span class="cm"> *	typedef string nfspath3&lt;&gt;;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_nfspath3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span>
			    <span class="k">const</span> <span class="n">u32</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">NFS3_MAXPATHLEN</span><span class="p">);</span>
	<span class="n">encode_uint32</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="n">xdr_write_pages</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_nfspath3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">recvd</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">hdrlen</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">page_len</span> <span class="o">||</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">NFS3_MAXPATHLEN</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_nametoolong</span><span class="p">;</span>
	<span class="n">hdrlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">xdr</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">-</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">xdr</span><span class="o">-&gt;</span><span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">;</span>
	<span class="n">recvd</span> <span class="o">=</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">hdrlen</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">recvd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_cheating</span><span class="p">;</span>

	<span class="n">xdr_read_pages</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">xdr_terminate_string</span><span class="p">(</span><span class="n">xdr</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_nametoolong:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: returned pathname too long: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">;</span>
<span class="nl">out_cheating:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: server cheating in pathname result: &quot;</span>
		<span class="s">&quot;count %u &gt; recvd %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">recvd</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cookie3</span>
<span class="cm"> *</span>
<span class="cm"> *	typedef uint64 cookie3</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span><span class="nf">xdr_encode_cookie3</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">u64</span> <span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xdr_encode_hyper</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cookie</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_cookie3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">decode_uint64</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">cookie</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cookieverf3</span>
<span class="cm"> *</span>
<span class="cm"> *	typedef opaque cookieverf3[NFS3_COOKIEVERFSIZE];</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span><span class="nf">xdr_encode_cookieverf3</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">verifier</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">verifier</span><span class="p">,</span> <span class="n">NFS3_COOKIEVERFSIZE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span> <span class="o">+</span> <span class="n">XDR_QUADLEN</span><span class="p">(</span><span class="n">NFS3_COOKIEVERFSIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_cookieverf3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">verifier</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">NFS3_COOKIEVERFSIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">verifier</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">NFS3_COOKIEVERFSIZE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * createverf3</span>
<span class="cm"> *</span>
<span class="cm"> *	typedef opaque createverf3[NFS3_CREATEVERFSIZE];</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_createverf3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">verifier</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">NFS3_CREATEVERFSIZE</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">verifier</span><span class="p">,</span> <span class="n">NFS3_CREATEVERFSIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_writeverf3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">verifier</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">NFS3_WRITEVERFSIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">verifier</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">NFS3_WRITEVERFSIZE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * size3</span>
<span class="cm"> *</span>
<span class="cm"> *	typedef uint64 size3;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span><span class="nf">xdr_decode_size3</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">xdr_decode_hyper</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * nfsstat3</span>
<span class="cm"> *</span>
<span class="cm"> *	enum nfsstat3 {</span>
<span class="cm"> *		NFS3_OK = 0,</span>
<span class="cm"> *		...</span>
<span class="cm"> *	}</span>
<span class="cm"> */</span>
<span class="cp">#define NFS3_OK		NFS_OK</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_nfsstat3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">nfs_stat</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ftype3</span>
<span class="cm"> *</span>
<span class="cm"> *	enum ftype3 {</span>
<span class="cm"> *		NF3REG	= 1,</span>
<span class="cm"> *		NF3DIR	= 2,</span>
<span class="cm"> *		NF3BLK	= 3,</span>
<span class="cm"> *		NF3CHR	= 4,</span>
<span class="cm"> *		NF3LNK	= 5,</span>
<span class="cm"> *		NF3SOCK	= 6,</span>
<span class="cm"> *		NF3FIFO	= 7</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_ftype3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">type</span> <span class="o">&gt;</span> <span class="n">NF3FIFO</span><span class="p">);</span>
	<span class="n">encode_uint32</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span><span class="nf">xdr_decode_ftype3</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">umode_t</span> <span class="o">*</span><span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">type</span><span class="p">;</span>

	<span class="n">type</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&gt;</span> <span class="n">NF3FIFO</span><span class="p">)</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">NF3NON</span><span class="p">;</span>
	<span class="o">*</span><span class="n">mode</span> <span class="o">=</span> <span class="n">nfs_type2fmt</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * specdata3</span>
<span class="cm"> *</span>
<span class="cm"> *     struct specdata3 {</span>
<span class="cm"> *             uint32  specdata1;</span>
<span class="cm"> *             uint32  specdata2;</span>
<span class="cm"> *     };</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_specdata3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">const</span> <span class="n">dev_t</span> <span class="n">rdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">MAJOR</span><span class="p">(</span><span class="n">rdev</span><span class="p">));</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">MINOR</span><span class="p">(</span><span class="n">rdev</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span><span class="nf">xdr_decode_specdata3</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">dev_t</span> <span class="o">*</span><span class="n">rdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">;</span>

	<span class="n">major</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">minor</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="o">*</span><span class="n">rdev</span> <span class="o">=</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">MAJOR</span><span class="p">(</span><span class="o">*</span><span class="n">rdev</span><span class="p">)</span> <span class="o">!=</span> <span class="n">major</span> <span class="o">||</span> <span class="n">MINOR</span><span class="p">(</span><span class="o">*</span><span class="n">rdev</span><span class="p">)</span> <span class="o">!=</span> <span class="n">minor</span><span class="p">)</span>
		<span class="o">*</span><span class="n">rdev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * nfs_fh3</span>
<span class="cm"> *</span>
<span class="cm"> *	struct nfs_fh3 {</span>
<span class="cm"> *		opaque       data&lt;NFS3_FHSIZE&gt;;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_nfs_fh3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">NFS3_FHSIZE</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="n">xdr_encode_opaque</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_nfs_fh3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">NFS3_FHSIZE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_toobig</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="n">fh</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_toobig:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: file handle size (%u) too big</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">zero_nfs_fh3</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">fh</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fh</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * nfstime3</span>
<span class="cm"> *</span>
<span class="cm"> *	struct nfstime3 {</span>
<span class="cm"> *		uint32	seconds;</span>
<span class="cm"> *		uint32	nseconds;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span><span class="nf">xdr_encode_nfstime3</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">timep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">timep</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">timep</span><span class="o">-&gt;</span><span class="n">tv_nsec</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span><span class="nf">xdr_decode_nfstime3</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">timep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timep</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">timep</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sattr3</span>
<span class="cm"> *</span>
<span class="cm"> *	enum time_how {</span>
<span class="cm"> *		DONT_CHANGE		= 0,</span>
<span class="cm"> *		SET_TO_SERVER_TIME	= 1,</span>
<span class="cm"> *		SET_TO_CLIENT_TIME	= 2</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union set_mode3 switch (bool set_it) {</span>
<span class="cm"> *	case TRUE:</span>
<span class="cm"> *		mode3	mode;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		void;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union set_uid3 switch (bool set_it) {</span>
<span class="cm"> *	case TRUE:</span>
<span class="cm"> *		uid3	uid;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		void;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union set_gid3 switch (bool set_it) {</span>
<span class="cm"> *	case TRUE:</span>
<span class="cm"> *		gid3	gid;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		void;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union set_size3 switch (bool set_it) {</span>
<span class="cm"> *	case TRUE:</span>
<span class="cm"> *		size3	size;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		void;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union set_atime switch (time_how set_it) {</span>
<span class="cm"> *	case SET_TO_CLIENT_TIME:</span>
<span class="cm"> *		nfstime3	atime;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		void;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union set_mtime switch (time_how set_it) {</span>
<span class="cm"> *	case SET_TO_CLIENT_TIME:</span>
<span class="cm"> *		nfstime3  mtime;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		void;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct sattr3 {</span>
<span class="cm"> *		set_mode3	mode;</span>
<span class="cm"> *		set_uid3	uid;</span>
<span class="cm"> *		set_gid3	gid;</span>
<span class="cm"> *		set_size3	size;</span>
<span class="cm"> *		set_atime	atime;</span>
<span class="cm"> *		set_mtime	mtime;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_sattr3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">nbytes</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In order to make only a single xdr_reserve_space() call,</span>
<span class="cm">	 * pre-compute the total number of bytes to be reserved.</span>
<span class="cm">	 * Six boolean values, one for each set_foo field, are always</span>
<span class="cm">	 * present in the encoded result, so start there.</span>
<span class="cm">	 */</span>
	<span class="n">nbytes</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MODE</span><span class="p">)</span>
		<span class="n">nbytes</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_UID</span><span class="p">)</span>
		<span class="n">nbytes</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_GID</span><span class="p">)</span>
		<span class="n">nbytes</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span>
		<span class="n">nbytes</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_ATIME_SET</span><span class="p">)</span>
		<span class="n">nbytes</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MTIME_SET</span><span class="p">)</span>
		<span class="n">nbytes</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">xdr_one</span><span class="p">;</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_mode</span> <span class="o">&amp;</span> <span class="n">S_IALLUGO</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">xdr_zero</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_UID</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">xdr_one</span><span class="p">;</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_uid</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">xdr_zero</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_GID</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">xdr_one</span><span class="p">;</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_gid</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">xdr_zero</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">xdr_one</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_encode_hyper</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">xdr_zero</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_ATIME_SET</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">xdr_two</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_encode_nfstime3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_atime</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_ATIME</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">xdr_one</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">xdr_zero</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MTIME_SET</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">xdr_two</span><span class="p">;</span>
		<span class="n">xdr_encode_nfstime3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_mtime</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MTIME</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">xdr_one</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">xdr_zero</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fattr3</span>
<span class="cm"> *</span>
<span class="cm"> *	struct fattr3 {</span>
<span class="cm"> *		ftype3		type;</span>
<span class="cm"> *		mode3		mode;</span>
<span class="cm"> *		uint32		nlink;</span>
<span class="cm"> *		uid3		uid;</span>
<span class="cm"> *		gid3		gid;</span>
<span class="cm"> *		size3		size;</span>
<span class="cm"> *		size3		used;</span>
<span class="cm"> *		specdata3	rdev;</span>
<span class="cm"> *		uint64		fsid;</span>
<span class="cm"> *		fileid3		fileid;</span>
<span class="cm"> *		nfstime3	atime;</span>
<span class="cm"> *		nfstime3	mtime;</span>
<span class="cm"> *		nfstime3	ctime;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_fattr3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">umode_t</span> <span class="n">fmode</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">NFS3_fattr_sz</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_ftype3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fmode</span><span class="p">);</span>

	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">S_IFMT</span><span class="p">)</span> <span class="o">|</span> <span class="n">fmode</span><span class="p">;</span>
	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">nlink</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">gid</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_size3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_size3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">du</span><span class="p">.</span><span class="n">nfs3</span><span class="p">.</span><span class="n">used</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_specdata3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">rdev</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_hyper</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">.</span><span class="n">major</span><span class="p">);</span>
	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">.</span><span class="n">minor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_fileid3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">fileid</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_nfstime3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">atime</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_nfstime3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">mtime</span><span class="p">);</span>
	<span class="n">xdr_decode_nfstime3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">ctime</span><span class="p">);</span>
	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">change_attr</span> <span class="o">=</span> <span class="n">nfs_timespec_to_change_attr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">ctime</span><span class="p">);</span>

	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">|=</span> <span class="n">NFS_ATTR_FATTR_V3</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * post_op_attr</span>
<span class="cm"> *</span>
<span class="cm"> *	union post_op_attr switch (bool attributes_follow) {</span>
<span class="cm"> *	case TRUE:</span>
<span class="cm"> *		fattr3	attributes;</span>
<span class="cm"> *	case FALSE:</span>
<span class="cm"> *		void;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_post_op_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="n">xdr_zero</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">decode_fattr3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">fattr</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * wcc_attr</span>
<span class="cm"> *	struct wcc_attr {</span>
<span class="cm"> *		size3		size;</span>
<span class="cm"> *		nfstime3	mtime;</span>
<span class="cm"> *		nfstime3	ctime;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_wcc_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">NFS3_wcc_attr_sz</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>

	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">|=</span> <span class="n">NFS_ATTR_FATTR_PRESIZE</span>
		<span class="o">|</span> <span class="n">NFS_ATTR_FATTR_PRECHANGE</span>
		<span class="o">|</span> <span class="n">NFS_ATTR_FATTR_PREMTIME</span>
		<span class="o">|</span> <span class="n">NFS_ATTR_FATTR_PRECTIME</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_size3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">pre_size</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_nfstime3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">pre_mtime</span><span class="p">);</span>
	<span class="n">xdr_decode_nfstime3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">pre_ctime</span><span class="p">);</span>
	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">pre_change_attr</span> <span class="o">=</span> <span class="n">nfs_timespec_to_change_attr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">pre_ctime</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * pre_op_attr</span>
<span class="cm"> *	union pre_op_attr switch (bool attributes_follow) {</span>
<span class="cm"> *	case TRUE:</span>
<span class="cm"> *		wcc_attr	attributes;</span>
<span class="cm"> *	case FALSE:</span>
<span class="cm"> *		void;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> * wcc_data</span>
<span class="cm"> *</span>
<span class="cm"> *	struct wcc_data {</span>
<span class="cm"> *		pre_op_attr	before;</span>
<span class="cm"> *		post_op_attr	after;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_pre_op_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="n">xdr_zero</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">decode_wcc_attr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">fattr</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_wcc_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_pre_op_attr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">fattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_post_op_attr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">fattr</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * post_op_fh3</span>
<span class="cm"> *</span>
<span class="cm"> *	union post_op_fh3 switch (bool handle_follows) {</span>
<span class="cm"> *	case TRUE:</span>
<span class="cm"> *		nfs_fh3  handle;</span>
<span class="cm"> *	case FALSE:</span>
<span class="cm"> *		void;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_post_op_fh3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="n">xdr_zero</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">decode_nfs_fh3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">fh</span><span class="p">);</span>
	<span class="n">zero_nfs_fh3</span><span class="p">(</span><span class="n">fh</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * diropargs3</span>
<span class="cm"> *</span>
<span class="cm"> *	struct diropargs3 {</span>
<span class="cm"> *		nfs_fh3		dir;</span>
<span class="cm"> *		filename3	name;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_diropargs3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">u32</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_nfs_fh3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">fh</span><span class="p">);</span>
	<span class="n">encode_filename3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NFSv3 XDR encode functions</span>
<span class="cm"> *</span>
<span class="cm"> * NFSv3 argument types are defined in section 3.3 of RFC 1813:</span>
<span class="cm"> * &quot;NFS Version 3 Protocol Specification&quot;.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.1  GETATTR3args</span>
<span class="cm"> *</span>
<span class="cm"> *	struct GETATTR3args {</span>
<span class="cm"> *		nfs_fh3  object;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs3_xdr_enc_getattr3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_nfs_fh3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">fh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.2  SETATTR3args</span>
<span class="cm"> *</span>
<span class="cm"> *	union sattrguard3 switch (bool check) {</span>
<span class="cm"> *	case TRUE:</span>
<span class="cm"> *		nfstime3  obj_ctime;</span>
<span class="cm"> *	case FALSE:</span>
<span class="cm"> *		void;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct SETATTR3args {</span>
<span class="cm"> *		nfs_fh3		object;</span>
<span class="cm"> *		sattr3		new_attributes;</span>
<span class="cm"> *		sattrguard3	guard;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_sattrguard3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs3_sattrargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">guard</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">xdr_one</span><span class="p">;</span>
		<span class="n">xdr_encode_nfstime3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">guardtime</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">xdr_zero</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs3_xdr_enc_setattr3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs3_sattrargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_nfs_fh3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">);</span>
	<span class="n">encode_sattr3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">sattr</span><span class="p">);</span>
	<span class="n">encode_sattrguard3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.3  LOOKUP3args</span>
<span class="cm"> *</span>
<span class="cm"> *	struct LOOKUP3args {</span>
<span class="cm"> *		diropargs3  what;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs3_xdr_enc_lookup3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs3_diropargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_diropargs3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.4  ACCESS3args</span>
<span class="cm"> *</span>
<span class="cm"> *	struct ACCESS3args {</span>
<span class="cm"> *		nfs_fh3		object;</span>
<span class="cm"> *		uint32		access;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_access3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs3_accessargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_nfs_fh3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">);</span>
	<span class="n">encode_uint32</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs3_xdr_enc_access3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs3_accessargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_access3args</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.5  READLINK3args</span>
<span class="cm"> *</span>
<span class="cm"> *	struct READLINK3args {</span>
<span class="cm"> *		nfs_fh3	symlink;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs3_xdr_enc_readlink3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs3_readlinkargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_nfs_fh3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">);</span>
	<span class="n">prepare_reply_buffer</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pgbase</span><span class="p">,</span>
					<span class="n">args</span><span class="o">-&gt;</span><span class="n">pglen</span><span class="p">,</span> <span class="n">NFS3_readlinkres_sz</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.6  READ3args</span>
<span class="cm"> *</span>
<span class="cm"> *	struct READ3args {</span>
<span class="cm"> *		nfs_fh3		file;</span>
<span class="cm"> *		offset3		offset;</span>
<span class="cm"> *		count3		count;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_read3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_readargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">encode_nfs_fh3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_encode_hyper</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs3_xdr_enc_read3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_readargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_read3args</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">prepare_reply_buffer</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pgbase</span><span class="p">,</span>
					<span class="n">args</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">NFS3_readres_sz</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_rcv_buf</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">XDRBUF_READ</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.7  WRITE3args</span>
<span class="cm"> *</span>
<span class="cm"> *	enum stable_how {</span>
<span class="cm"> *		UNSTABLE  = 0,</span>
<span class="cm"> *		DATA_SYNC = 1,</span>
<span class="cm"> *		FILE_SYNC = 2</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct WRITE3args {</span>
<span class="cm"> *		nfs_fh3		file;</span>
<span class="cm"> *		offset3		offset;</span>
<span class="cm"> *		count3		count;</span>
<span class="cm"> *		stable_how	stable;</span>
<span class="cm"> *		opaque		data&lt;&gt;;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_write3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_writeargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">encode_nfs_fh3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_encode_hyper</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">stable</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="n">xdr_write_pages</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pgbase</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs3_xdr_enc_write3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_writeargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_write3args</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">xdr</span><span class="o">-&gt;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">XDRBUF_WRITE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.8  CREATE3args</span>
<span class="cm"> *</span>
<span class="cm"> *	enum createmode3 {</span>
<span class="cm"> *		UNCHECKED = 0,</span>
<span class="cm"> *		GUARDED   = 1,</span>
<span class="cm"> *		EXCLUSIVE = 2</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union createhow3 switch (createmode3 mode) {</span>
<span class="cm"> *	case UNCHECKED:</span>
<span class="cm"> *	case GUARDED:</span>
<span class="cm"> *		sattr3       obj_attributes;</span>
<span class="cm"> *	case EXCLUSIVE:</span>
<span class="cm"> *		createverf3  verf;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct CREATE3args {</span>
<span class="cm"> *		diropargs3	where;</span>
<span class="cm"> *		createhow3	how;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_createhow3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs3_createargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_uint32</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">createmode</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">createmode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NFS3_CREATE_UNCHECKED</span>:
	<span class="k">case</span> <span class="n">NFS3_CREATE_GUARDED</span>:
		<span class="n">encode_sattr3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">sattr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NFS3_CREATE_EXCLUSIVE</span>:
		<span class="n">encode_createverf3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">verifier</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs3_xdr_enc_create3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs3_createargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_diropargs3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">encode_createhow3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.9  MKDIR3args</span>
<span class="cm"> *</span>
<span class="cm"> *	struct MKDIR3args {</span>
<span class="cm"> *		diropargs3	where;</span>
<span class="cm"> *		sattr3		attributes;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs3_xdr_enc_mkdir3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs3_mkdirargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_diropargs3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">encode_sattr3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">sattr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.10  SYMLINK3args</span>
<span class="cm"> *</span>
<span class="cm"> *	struct symlinkdata3 {</span>
<span class="cm"> *		sattr3		symlink_attributes;</span>
<span class="cm"> *		nfspath3	symlink_data;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct SYMLINK3args {</span>
<span class="cm"> *		diropargs3	where;</span>
<span class="cm"> *		symlinkdata3	symlink;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_symlinkdata3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">nfs3_symlinkargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_sattr3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">sattr</span><span class="p">);</span>
	<span class="n">encode_nfspath3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pathlen</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs3_xdr_enc_symlink3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs3_symlinkargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_diropargs3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fromfh</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fromname</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fromlen</span><span class="p">);</span>
	<span class="n">encode_symlinkdata3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.11  MKNOD3args</span>
<span class="cm"> *</span>
<span class="cm"> *	struct devicedata3 {</span>
<span class="cm"> *		sattr3		dev_attributes;</span>
<span class="cm"> *		specdata3	spec;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union mknoddata3 switch (ftype3 type) {</span>
<span class="cm"> *	case NF3CHR:</span>
<span class="cm"> *	case NF3BLK:</span>
<span class="cm"> *		devicedata3	device;</span>
<span class="cm"> *	case NF3SOCK:</span>
<span class="cm"> *	case NF3FIFO:</span>
<span class="cm"> *		sattr3		pipe_attributes;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		void;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct MKNOD3args {</span>
<span class="cm"> *		diropargs3	where;</span>
<span class="cm"> *		mknoddata3	what;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_devicedata3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs3_mknodargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_sattr3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">sattr</span><span class="p">);</span>
	<span class="n">encode_specdata3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">rdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_mknoddata3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs3_mknodargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_ftype3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NF3CHR</span>:
	<span class="k">case</span> <span class="n">NF3BLK</span>:
		<span class="n">encode_devicedata3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NF3SOCK</span>:
	<span class="k">case</span> <span class="n">NF3FIFO</span>:
		<span class="n">encode_sattr3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">sattr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NF3REG</span>:
	<span class="k">case</span> <span class="n">NF3DIR</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs3_xdr_enc_mknod3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs3_mknodargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_diropargs3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">encode_mknoddata3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.12  REMOVE3args</span>
<span class="cm"> *</span>
<span class="cm"> *	struct REMOVE3args {</span>
<span class="cm"> *		diropargs3  object;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs3_xdr_enc_remove3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_removeargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_diropargs3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.14  RENAME3args</span>
<span class="cm"> *</span>
<span class="cm"> *	struct RENAME3args {</span>
<span class="cm"> *		diropargs3	from;</span>
<span class="cm"> *		diropargs3	to;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs3_xdr_enc_rename3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_renameargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">old_name</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">new_name</span><span class="p">;</span>

	<span class="n">encode_diropargs3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">old_dir</span><span class="p">,</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">encode_diropargs3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">new_dir</span><span class="p">,</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.15  LINK3args</span>
<span class="cm"> *</span>
<span class="cm"> *	struct LINK3args {</span>
<span class="cm"> *		nfs_fh3		file;</span>
<span class="cm"> *		diropargs3	link;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs3_xdr_enc_link3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs3_linkargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_nfs_fh3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fromfh</span><span class="p">);</span>
	<span class="n">encode_diropargs3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">tofh</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">toname</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">tolen</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.16  READDIR3args</span>
<span class="cm"> *</span>
<span class="cm"> *	struct READDIR3args {</span>
<span class="cm"> *		nfs_fh3		dir;</span>
<span class="cm"> *		cookie3		cookie;</span>
<span class="cm"> *		cookieverf3	cookieverf;</span>
<span class="cm"> *		count3		count;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_readdir3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">nfs3_readdirargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">encode_nfs_fh3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">NFS3_COOKIEVERFSIZE</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_encode_cookie3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">cookie</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_encode_cookieverf3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">verf</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs3_xdr_enc_readdir3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs3_readdirargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_readdir3args</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">prepare_reply_buffer</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">args</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">NFS3_readdirres_sz</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.17  READDIRPLUS3args</span>
<span class="cm"> *</span>
<span class="cm"> *	struct READDIRPLUS3args {</span>
<span class="cm"> *		nfs_fh3		dir;</span>
<span class="cm"> *		cookie3		cookie;</span>
<span class="cm"> *		cookieverf3	cookieverf;</span>
<span class="cm"> *		count3		dircount;</span>
<span class="cm"> *		count3		maxcount;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_readdirplus3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs3_readdirargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">encode_nfs_fh3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">NFS3_COOKIEVERFSIZE</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_encode_cookie3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">cookie</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_encode_cookieverf3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">verf</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * readdirplus: need dircount + buffer size.</span>
<span class="cm">	 * We just make sure we make dircount big enough</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>

	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs3_xdr_enc_readdirplus3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
					  <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs3_readdirargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_readdirplus3args</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">prepare_reply_buffer</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">args</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">NFS3_readdirres_sz</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.21  COMMIT3args</span>
<span class="cm"> *</span>
<span class="cm"> *	struct COMMIT3args {</span>
<span class="cm"> *		nfs_fh3		file;</span>
<span class="cm"> *		offset3		offset;</span>
<span class="cm"> *		count3		count;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_commit3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_commitargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">encode_nfs_fh3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_encode_hyper</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs3_xdr_enc_commit3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_commitargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_commit3args</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NFS_V3_ACL</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs3_xdr_enc_getacl3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs3_getaclargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_nfs_fh3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">);</span>
	<span class="n">encode_uint32</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NFS_ACL</span> <span class="o">|</span> <span class="n">NFS_DFACL</span><span class="p">))</span>
		<span class="n">prepare_reply_buffer</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">NFSACL_MAXPAGES</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span>
					<span class="n">ACL3_getaclres_sz</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs3_xdr_enc_setacl3args</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs3_setaclargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">encode_nfs_fh3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">NFS_FH</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">));</span>
	<span class="n">encode_uint32</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">);</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_slen</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">npages</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">xdr_write_pages</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">NFS_ACL_INLINE_BUFSIZE</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">nfsacl_encode</span><span class="p">(</span><span class="n">xdr</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">,</span>
			    <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">NFS_ACL</span><span class="p">)</span> <span class="o">?</span>
			    <span class="n">args</span><span class="o">-&gt;</span><span class="n">acl_access</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">nfsacl_encode</span><span class="p">(</span><span class="n">xdr</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">error</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">,</span>
			    <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">NFS_DFACL</span><span class="p">)</span> <span class="o">?</span>
			    <span class="n">args</span><span class="o">-&gt;</span><span class="n">acl_default</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			    <span class="n">NFS_ACL_DEFAULT</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif  </span><span class="cm">/* CONFIG_NFS_V3_ACL */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * NFSv3 XDR decode functions</span>
<span class="cm"> *</span>
<span class="cm"> * NFSv3 result types are defined in section 3.3 of RFC 1813:</span>
<span class="cm"> * &quot;NFS Version 3 Protocol Specification&quot;.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.1  GETATTR3res</span>
<span class="cm"> *</span>
<span class="cm"> *	struct GETATTR3resok {</span>
<span class="cm"> *		fattr3		obj_attributes;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union GETATTR3res switch (nfsstat3 status) {</span>
<span class="cm"> *	case NFS3_OK:</span>
<span class="cm"> *		GETATTR3resok  resok;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		void;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs3_xdr_dec_getattr3res</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_nfsstat3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS3_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_default</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_fattr3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_default:</span>
	<span class="k">return</span> <span class="n">nfs3_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.2  SETATTR3res</span>
<span class="cm"> *</span>
<span class="cm"> *	struct SETATTR3resok {</span>
<span class="cm"> *		wcc_data  obj_wcc;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct SETATTR3resfail {</span>
<span class="cm"> *		wcc_data  obj_wcc;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union SETATTR3res switch (nfsstat3 status) {</span>
<span class="cm"> *	case NFS3_OK:</span>
<span class="cm"> *		SETATTR3resok   resok;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		SETATTR3resfail resfail;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs3_xdr_dec_setattr3res</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_nfsstat3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_wcc_data</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS3_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_status</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_status:</span>
	<span class="k">return</span> <span class="n">nfs3_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.3  LOOKUP3res</span>
<span class="cm"> *</span>
<span class="cm"> *	struct LOOKUP3resok {</span>
<span class="cm"> *		nfs_fh3		object;</span>
<span class="cm"> *		post_op_attr	obj_attributes;</span>
<span class="cm"> *		post_op_attr	dir_attributes;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct LOOKUP3resfail {</span>
<span class="cm"> *		post_op_attr	dir_attributes;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union LOOKUP3res switch (nfsstat3 status) {</span>
<span class="cm"> *	case NFS3_OK:</span>
<span class="cm"> *		LOOKUP3resok	resok;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		LOOKUP3resfail	resfail;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs3_xdr_dec_lookup3res</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">nfs3_diropres</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_nfsstat3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS3_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_default</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_nfs_fh3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_post_op_attr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_post_op_attr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">dir_attr</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_default:</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_post_op_attr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">dir_attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">nfs3_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.4  ACCESS3res</span>
<span class="cm"> *</span>
<span class="cm"> *	struct ACCESS3resok {</span>
<span class="cm"> *		post_op_attr	obj_attributes;</span>
<span class="cm"> *		uint32		access;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct ACCESS3resfail {</span>
<span class="cm"> *		post_op_attr	obj_attributes;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union ACCESS3res switch (nfsstat3 status) {</span>
<span class="cm"> *	case NFS3_OK:</span>
<span class="cm"> *		ACCESS3resok	resok;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		ACCESS3resfail	resfail;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs3_xdr_dec_access3res</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">nfs3_accessres</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_nfsstat3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_post_op_attr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS3_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_default</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_uint32</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">access</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_default:</span>
	<span class="k">return</span> <span class="n">nfs3_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.5  READLINK3res</span>
<span class="cm"> *</span>
<span class="cm"> *	struct READLINK3resok {</span>
<span class="cm"> *		post_op_attr	symlink_attributes;</span>
<span class="cm"> *		nfspath3	data;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct READLINK3resfail {</span>
<span class="cm"> *		post_op_attr	symlink_attributes;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union READLINK3res switch (nfsstat3 status) {</span>
<span class="cm"> *	case NFS3_OK:</span>
<span class="cm"> *		READLINK3resok	resok;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		READLINK3resfail resfail;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs3_xdr_dec_readlink3res</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_nfsstat3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_post_op_attr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS3_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_default</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_nfspath3</span><span class="p">(</span><span class="n">xdr</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_default:</span>
	<span class="k">return</span> <span class="n">nfs3_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.6  READ3res</span>
<span class="cm"> *</span>
<span class="cm"> *	struct READ3resok {</span>
<span class="cm"> *		post_op_attr	file_attributes;</span>
<span class="cm"> *		count3		count;</span>
<span class="cm"> *		bool		eof;</span>
<span class="cm"> *		opaque		data&lt;&gt;;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct READ3resfail {</span>
<span class="cm"> *		post_op_attr	file_attributes;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union READ3res switch (nfsstat3 status) {</span>
<span class="cm"> *	case NFS3_OK:</span>
<span class="cm"> *		READ3resok	resok;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		READ3resfail	resfail;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_read3resok</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">nfs_readres</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">eof</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ocount</span><span class="p">,</span> <span class="n">recvd</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">hdrlen</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">eof</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">ocount</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ocount</span> <span class="o">!=</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_mismatch</span><span class="p">;</span>
	<span class="n">hdrlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">xdr</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">-</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">xdr</span><span class="o">-&gt;</span><span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">;</span>
	<span class="n">recvd</span> <span class="o">=</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">hdrlen</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">recvd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_cheating</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">xdr_read_pages</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">=</span> <span class="n">eof</span><span class="p">;</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="nl">out_mismatch:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: READ count doesn&#39;t match length of opaque: &quot;</span>
		<span class="s">&quot;count %u != ocount %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ocount</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="nl">out_cheating:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: server cheating in read result: &quot;</span>
		<span class="s">&quot;count %u &gt; recvd %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">recvd</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">recvd</span><span class="p">;</span>
	<span class="n">eof</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs3_xdr_dec_read3res</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">nfs_readres</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_nfsstat3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_post_op_attr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS3_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_status</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_read3resok</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_status:</span>
	<span class="k">return</span> <span class="n">nfs3_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.7  WRITE3res</span>
<span class="cm"> *</span>
<span class="cm"> *	enum stable_how {</span>
<span class="cm"> *		UNSTABLE  = 0,</span>
<span class="cm"> *		DATA_SYNC = 1,</span>
<span class="cm"> *		FILE_SYNC = 2</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct WRITE3resok {</span>
<span class="cm"> *		wcc_data	file_wcc;</span>
<span class="cm"> *		count3		count;</span>
<span class="cm"> *		stable_how	committed;</span>
<span class="cm"> *		writeverf3	verf;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct WRITE3resfail {</span>
<span class="cm"> *		wcc_data	file_wcc;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union WRITE3res switch (nfsstat3 status) {</span>
<span class="cm"> *	case NFS3_OK:</span>
<span class="cm"> *		WRITE3resok	resok;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		WRITE3resfail	resfail;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_write3resok</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">nfs_writeres</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">NFS3_WRITEVERFSIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">verf</span><span class="o">-&gt;</span><span class="n">committed</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">verf</span><span class="o">-&gt;</span><span class="n">committed</span> <span class="o">&gt;</span> <span class="n">NFS_FILE_SYNC</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_badvalue</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">verf</span><span class="o">-&gt;</span><span class="n">verifier</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">NFS3_WRITEVERFSIZE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
<span class="nl">out_badvalue:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: bad stable_how value: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">verf</span><span class="o">-&gt;</span><span class="n">committed</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs3_xdr_dec_write3res</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">nfs_writeres</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_nfsstat3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_wcc_data</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS3_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_status</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_write3resok</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_status:</span>
	<span class="k">return</span> <span class="n">nfs3_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.8  CREATE3res</span>
<span class="cm"> *</span>
<span class="cm"> *	struct CREATE3resok {</span>
<span class="cm"> *		post_op_fh3	obj;</span>
<span class="cm"> *		post_op_attr	obj_attributes;</span>
<span class="cm"> *		wcc_data	dir_wcc;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct CREATE3resfail {</span>
<span class="cm"> *		wcc_data	dir_wcc;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union CREATE3res switch (nfsstat3 status) {</span>
<span class="cm"> *	case NFS3_OK:</span>
<span class="cm"> *		CREATE3resok	resok;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		CREATE3resfail	resfail;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_create3resok</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">nfs3_diropres</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_post_op_fh3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_post_op_attr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/* The server isn&#39;t required to return a file handle.</span>
<span class="cm">	 * If it didn&#39;t, force the client to perform a LOOKUP</span>
<span class="cm">	 * to determine the correct file handle and attribute</span>
<span class="cm">	 * values for the new object. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">result</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_wcc_data</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">dir_attr</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs3_xdr_dec_create3res</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">nfs3_diropres</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_nfsstat3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS3_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_default</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_create3resok</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_default:</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_wcc_data</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">dir_attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">nfs3_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.12  REMOVE3res</span>
<span class="cm"> *</span>
<span class="cm"> *	struct REMOVE3resok {</span>
<span class="cm"> *		wcc_data    dir_wcc;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct REMOVE3resfail {</span>
<span class="cm"> *		wcc_data    dir_wcc;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union REMOVE3res switch (nfsstat3 status) {</span>
<span class="cm"> *	case NFS3_OK:</span>
<span class="cm"> *		REMOVE3resok   resok;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		REMOVE3resfail resfail;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs3_xdr_dec_remove3res</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">nfs_removeres</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_nfsstat3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_wcc_data</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">dir_attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS3_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_status</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_status:</span>
	<span class="k">return</span> <span class="n">nfs3_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.14  RENAME3res</span>
<span class="cm"> *</span>
<span class="cm"> *	struct RENAME3resok {</span>
<span class="cm"> *		wcc_data	fromdir_wcc;</span>
<span class="cm"> *		wcc_data	todir_wcc;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct RENAME3resfail {</span>
<span class="cm"> *		wcc_data	fromdir_wcc;</span>
<span class="cm"> *		wcc_data	todir_wcc;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union RENAME3res switch (nfsstat3 status) {</span>
<span class="cm"> *	case NFS3_OK:</span>
<span class="cm"> *		RENAME3resok   resok;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		RENAME3resfail resfail;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs3_xdr_dec_rename3res</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">nfs_renameres</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_nfsstat3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_wcc_data</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">old_fattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_wcc_data</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">new_fattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS3_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_status</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_status:</span>
	<span class="k">return</span> <span class="n">nfs3_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.15  LINK3res</span>
<span class="cm"> *</span>
<span class="cm"> *	struct LINK3resok {</span>
<span class="cm"> *		post_op_attr	file_attributes;</span>
<span class="cm"> *		wcc_data	linkdir_wcc;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct LINK3resfail {</span>
<span class="cm"> *		post_op_attr	file_attributes;</span>
<span class="cm"> *		wcc_data	linkdir_wcc;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union LINK3res switch (nfsstat3 status) {</span>
<span class="cm"> *	case NFS3_OK:</span>
<span class="cm"> *		LINK3resok	resok;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		LINK3resfail	resfail;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs3_xdr_dec_link3res</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">nfs3_linkres</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_nfsstat3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_post_op_attr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_wcc_data</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">dir_attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS3_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_status</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_status:</span>
	<span class="k">return</span> <span class="n">nfs3_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs3_decode_dirent - Decode a single NFSv3 directory entry stored in</span>
<span class="cm"> *			the local page cache</span>
<span class="cm"> * @xdr: XDR stream where entry resides</span>
<span class="cm"> * @entry: buffer to fill in with entry data</span>
<span class="cm"> * @plus: boolean indicating whether this should be a readdirplus entry</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero if successful, otherwise a negative errno value is</span>
<span class="cm"> * returned.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is not invoked during READDIR reply decoding, but</span>
<span class="cm"> * rather whenever an application invokes the getdents(2) system call</span>
<span class="cm"> * on a directory already in our cache.</span>
<span class="cm"> *</span>
<span class="cm"> * 3.3.16  entry3</span>
<span class="cm"> *</span>
<span class="cm"> *	struct entry3 {</span>
<span class="cm"> *		fileid3		fileid;</span>
<span class="cm"> *		filename3	name;</span>
<span class="cm"> *		cookie3		cookie;</span>
<span class="cm"> *		fhandle3	filehandle;</span>
<span class="cm"> *		post_op_attr3	attributes;</span>
<span class="cm"> *		entry3		*nextentry;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> * 3.3.17  entryplus3</span>
<span class="cm"> *	struct entryplus3 {</span>
<span class="cm"> *		fileid3		fileid;</span>
<span class="cm"> *		filename3	name;</span>
<span class="cm"> *		cookie3		cookie;</span>
<span class="cm"> *		post_op_attr	name_attributes;</span>
<span class="cm"> *		post_op_fh3	name_handle;</span>
<span class="cm"> *		entryplus3	*nextentry;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nfs3_decode_dirent</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">plus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_entry</span> <span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="n">xdr_zero</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="n">xdr_zero</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADCOOKIE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_fileid3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_inline_filename3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">prev_cookie</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">cookie</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_cookie3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">cookie</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_type</span> <span class="o">=</span> <span class="n">DT_UNKNOWN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">plus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">decode_post_op_attr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_V3</span><span class="p">)</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_type</span> <span class="o">=</span> <span class="n">nfs_umode_to_dtype</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">);</span>

		<span class="cm">/* In fact, a post_op_fh3: */</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="n">xdr_zero</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">decode_nfs_fh3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out_truncated</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">zero_nfs_fh3</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="nl">out_truncated:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: directory entry contains invalid file handle</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.16  READDIR3res</span>
<span class="cm"> *</span>
<span class="cm"> *	struct dirlist3 {</span>
<span class="cm"> *		entry3		*entries;</span>
<span class="cm"> *		bool		eof;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct READDIR3resok {</span>
<span class="cm"> *		post_op_attr	dir_attributes;</span>
<span class="cm"> *		cookieverf3	cookieverf;</span>
<span class="cm"> *		dirlist3	reply;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct READDIR3resfail {</span>
<span class="cm"> *		post_op_attr	dir_attributes;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union READDIR3res switch (nfsstat3 status) {</span>
<span class="cm"> *	case NFS3_OK:</span>
<span class="cm"> *		READDIR3resok	resok;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		READDIR3resfail	resfail;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> * Read the directory contents into the page cache, but otherwise</span>
<span class="cm"> * don&#39;t touch them.  The actual decoding is done by nfs3_decode_entry()</span>
<span class="cm"> * during subsequent nfs_readdir() calls.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_dirlist3</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">recvd</span><span class="p">,</span> <span class="n">pglen</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">hdrlen</span><span class="p">;</span>

	<span class="n">pglen</span> <span class="o">=</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">page_len</span><span class="p">;</span>
	<span class="n">hdrlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">xdr</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">-</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">xdr</span><span class="o">-&gt;</span><span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">;</span>
	<span class="n">recvd</span> <span class="o">=</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">hdrlen</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pglen</span> <span class="o">&gt;</span> <span class="n">recvd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_cheating</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">xdr_read_pages</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">pglen</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pglen</span><span class="p">;</span>
<span class="nl">out_cheating:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: server cheating in readdir result: &quot;</span>
		<span class="s">&quot;pglen %u &gt; recvd %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pglen</span><span class="p">,</span> <span class="n">recvd</span><span class="p">);</span>
	<span class="n">pglen</span> <span class="o">=</span> <span class="n">recvd</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_readdir3resok</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">nfs3_readdirres</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_post_op_attr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">dir_attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/* XXX: do we need to check if result-&gt;verf != NULL ? */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_cookieverf3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">verf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_dirlist3</span><span class="p">(</span><span class="n">xdr</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs3_xdr_dec_readdir3res</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">nfs3_readdirres</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_nfsstat3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS3_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_default</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_readdir3resok</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_default:</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_post_op_attr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">dir_attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">nfs3_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.18  FSSTAT3res</span>
<span class="cm"> *</span>
<span class="cm"> *	struct FSSTAT3resok {</span>
<span class="cm"> *		post_op_attr	obj_attributes;</span>
<span class="cm"> *		size3		tbytes;</span>
<span class="cm"> *		size3		fbytes;</span>
<span class="cm"> *		size3		abytes;</span>
<span class="cm"> *		size3		tfiles;</span>
<span class="cm"> *		size3		ffiles;</span>
<span class="cm"> *		size3		afiles;</span>
<span class="cm"> *		uint32		invarsec;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct FSSTAT3resfail {</span>
<span class="cm"> *		post_op_attr	obj_attributes;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union FSSTAT3res switch (nfsstat3 status) {</span>
<span class="cm"> *	case NFS3_OK:</span>
<span class="cm"> *		FSSTAT3resok	resok;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		FSSTAT3resfail	resfail;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_fsstat3resok</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">nfs_fsstat</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_size3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">tbytes</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_size3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">fbytes</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_size3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">abytes</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_size3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">tfiles</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_size3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">ffiles</span><span class="p">);</span>
	<span class="n">xdr_decode_size3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">afiles</span><span class="p">);</span>
	<span class="cm">/* ignore invarsec */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs3_xdr_dec_fsstat3res</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">nfs_fsstat</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_nfsstat3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_post_op_attr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS3_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_status</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_fsstat3resok</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_status:</span>
	<span class="k">return</span> <span class="n">nfs3_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.19  FSINFO3res</span>
<span class="cm"> *</span>
<span class="cm"> *	struct FSINFO3resok {</span>
<span class="cm"> *		post_op_attr	obj_attributes;</span>
<span class="cm"> *		uint32		rtmax;</span>
<span class="cm"> *		uint32		rtpref;</span>
<span class="cm"> *		uint32		rtmult;</span>
<span class="cm"> *		uint32		wtmax;</span>
<span class="cm"> *		uint32		wtpref;</span>
<span class="cm"> *		uint32		wtmult;</span>
<span class="cm"> *		uint32		dtpref;</span>
<span class="cm"> *		size3		maxfilesize;</span>
<span class="cm"> *		nfstime3	time_delta;</span>
<span class="cm"> *		uint32		properties;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct FSINFO3resfail {</span>
<span class="cm"> *		post_op_attr	obj_attributes;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union FSINFO3res switch (nfsstat3 status) {</span>
<span class="cm"> *	case NFS3_OK:</span>
<span class="cm"> *		FSINFO3resok	resok;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		FSINFO3resfail	resfail;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_fsinfo3resok</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">nfs_fsinfo</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">7</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">rtmax</span>  <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">rtpref</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">rtmult</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">wtmax</span>  <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">wtpref</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">wtmult</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">dtpref</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_size3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">maxfilesize</span><span class="p">);</span>
	<span class="n">xdr_decode_nfstime3</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">time_delta</span><span class="p">);</span>

	<span class="cm">/* ignore properties */</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">lease_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs3_xdr_dec_fsinfo3res</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">nfs_fsinfo</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_nfsstat3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_post_op_attr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS3_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_status</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_fsinfo3resok</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_status:</span>
	<span class="k">return</span> <span class="n">nfs3_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.20  PATHCONF3res</span>
<span class="cm"> *</span>
<span class="cm"> *	struct PATHCONF3resok {</span>
<span class="cm"> *		post_op_attr	obj_attributes;</span>
<span class="cm"> *		uint32		linkmax;</span>
<span class="cm"> *		uint32		name_max;</span>
<span class="cm"> *		bool		no_trunc;</span>
<span class="cm"> *		bool		chown_restricted;</span>
<span class="cm"> *		bool		case_insensitive;</span>
<span class="cm"> *		bool		case_preserving;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct PATHCONF3resfail {</span>
<span class="cm"> *		post_op_attr	obj_attributes;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union PATHCONF3res switch (nfsstat3 status) {</span>
<span class="cm"> *	case NFS3_OK:</span>
<span class="cm"> *		PATHCONF3resok	resok;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		PATHCONF3resfail resfail;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_pathconf3resok</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">nfs_pathconf</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">6</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">max_link</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">max_namelen</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="cm">/* ignore remaining fields */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs3_xdr_dec_pathconf3res</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">nfs_pathconf</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_nfsstat3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_post_op_attr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS3_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_status</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_pathconf3resok</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_status:</span>
	<span class="k">return</span> <span class="n">nfs3_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 3.3.21  COMMIT3res</span>
<span class="cm"> *</span>
<span class="cm"> *	struct COMMIT3resok {</span>
<span class="cm"> *		wcc_data	file_wcc;</span>
<span class="cm"> *		writeverf3	verf;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	struct COMMIT3resfail {</span>
<span class="cm"> *		wcc_data	file_wcc;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> *	union COMMIT3res switch (nfsstat3 status) {</span>
<span class="cm"> *	case NFS3_OK:</span>
<span class="cm"> *		COMMIT3resok	resok;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		COMMIT3resfail	resfail;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs3_xdr_dec_commit3res</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">nfs_commitres</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_nfsstat3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_wcc_data</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS3_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_status</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_writeverf3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">verf</span><span class="o">-&gt;</span><span class="n">verifier</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_status:</span>
	<span class="k">return</span> <span class="n">nfs3_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NFS_V3_ACL</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">decode_getacl3resok</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">nfs3_getaclres</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">posix_acl</span> <span class="o">**</span><span class="n">acl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">aclcnt</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">hdrlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_post_op_attr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_uint32</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">NFS_ACL</span><span class="o">|</span><span class="n">NFS_ACLCNT</span><span class="o">|</span><span class="n">NFS_DFACL</span><span class="o">|</span><span class="n">NFS_DFACLCNT</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">hdrlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">xdr</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">-</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">xdr</span><span class="o">-&gt;</span><span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">;</span>

	<span class="n">acl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">NFS_ACL</span><span class="p">)</span>
		<span class="n">acl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">acl_access</span><span class="p">;</span>
	<span class="n">aclcnt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">NFS_ACLCNT</span><span class="p">)</span>
		<span class="n">aclcnt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">acl_access_count</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">nfsacl_decode</span><span class="p">(</span><span class="n">xdr</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">hdrlen</span><span class="p">,</span> <span class="n">aclcnt</span><span class="p">,</span> <span class="n">acl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">acl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">NFS_DFACL</span><span class="p">)</span>
		<span class="n">acl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">acl_default</span><span class="p">;</span>
	<span class="n">aclcnt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">NFS_DFACLCNT</span><span class="p">)</span>
		<span class="n">aclcnt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">acl_default_count</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">nfsacl_decode</span><span class="p">(</span><span class="n">xdr</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">hdrlen</span> <span class="o">+</span> <span class="n">error</span><span class="p">,</span> <span class="n">aclcnt</span><span class="p">,</span> <span class="n">acl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs3_xdr_dec_getacl3res</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">nfs3_getaclres</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_nfsstat3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS3_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_default</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_getacl3resok</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_default:</span>
	<span class="k">return</span> <span class="n">nfs3_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs3_xdr_dec_setacl3res</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_nfsstat3</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS3_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_default</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_post_op_attr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_default:</span>
	<span class="k">return</span> <span class="n">nfs3_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif  </span><span class="cm">/* CONFIG_NFS_V3_ACL */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * We need to translate between nfs status return values and</span>
<span class="cm"> * the local errno values which may not be the same.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">stat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">errno</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nfs_errtbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">NFS_OK</span><span class="p">,</span>		<span class="mi">0</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_PERM</span><span class="p">,</span>		<span class="o">-</span><span class="n">EPERM</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_NOENT</span><span class="p">,</span>		<span class="o">-</span><span class="n">ENOENT</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_IO</span><span class="p">,</span>		<span class="o">-</span><span class="n">errno_NFSERR_IO</span><span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_NXIO</span><span class="p">,</span>		<span class="o">-</span><span class="n">ENXIO</span>		<span class="p">},</span>
<span class="cm">/*	{ NFSERR_EAGAIN,	-EAGAIN		}, */</span>
	<span class="p">{</span> <span class="n">NFSERR_ACCES</span><span class="p">,</span>		<span class="o">-</span><span class="n">EACCES</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_EXIST</span><span class="p">,</span>		<span class="o">-</span><span class="n">EEXIST</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_XDEV</span><span class="p">,</span>		<span class="o">-</span><span class="n">EXDEV</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_NODEV</span><span class="p">,</span>		<span class="o">-</span><span class="n">ENODEV</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_NOTDIR</span><span class="p">,</span>	<span class="o">-</span><span class="n">ENOTDIR</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_ISDIR</span><span class="p">,</span>		<span class="o">-</span><span class="n">EISDIR</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_INVAL</span><span class="p">,</span>		<span class="o">-</span><span class="n">EINVAL</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_FBIG</span><span class="p">,</span>		<span class="o">-</span><span class="n">EFBIG</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_NOSPC</span><span class="p">,</span>		<span class="o">-</span><span class="n">ENOSPC</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_ROFS</span><span class="p">,</span>		<span class="o">-</span><span class="n">EROFS</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_MLINK</span><span class="p">,</span>		<span class="o">-</span><span class="n">EMLINK</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_NAMETOOLONG</span><span class="p">,</span>	<span class="o">-</span><span class="n">ENAMETOOLONG</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_NOTEMPTY</span><span class="p">,</span>	<span class="o">-</span><span class="n">ENOTEMPTY</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_DQUOT</span><span class="p">,</span>		<span class="o">-</span><span class="n">EDQUOT</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_STALE</span><span class="p">,</span>		<span class="o">-</span><span class="n">ESTALE</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_REMOTE</span><span class="p">,</span>	<span class="o">-</span><span class="n">EREMOTE</span>	<span class="p">},</span>
<span class="cp">#ifdef EWFLUSH</span>
	<span class="p">{</span> <span class="n">NFSERR_WFLUSH</span><span class="p">,</span>	<span class="o">-</span><span class="n">EWFLUSH</span>	<span class="p">},</span>
<span class="cp">#endif</span>
	<span class="p">{</span> <span class="n">NFSERR_BADHANDLE</span><span class="p">,</span>	<span class="o">-</span><span class="n">EBADHANDLE</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_NOT_SYNC</span><span class="p">,</span>	<span class="o">-</span><span class="n">ENOTSYNC</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_BAD_COOKIE</span><span class="p">,</span>	<span class="o">-</span><span class="n">EBADCOOKIE</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_NOTSUPP</span><span class="p">,</span>	<span class="o">-</span><span class="n">ENOTSUPP</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_TOOSMALL</span><span class="p">,</span>	<span class="o">-</span><span class="n">ETOOSMALL</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_SERVERFAULT</span><span class="p">,</span>	<span class="o">-</span><span class="n">EREMOTEIO</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_BADTYPE</span><span class="p">,</span>	<span class="o">-</span><span class="n">EBADTYPE</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_JUKEBOX</span><span class="p">,</span>	<span class="o">-</span><span class="n">EJUKEBOX</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>			<span class="o">-</span><span class="n">EIO</span>		<span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * nfs3_stat_to_errno - convert an NFS status code to a local errno</span>
<span class="cm"> * @status: NFS status code to convert</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a local errno value, or -EIO if the NFS status code is</span>
<span class="cm"> * not recognized.  This function is used jointly by NFSv2 and NFSv3.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs3_stat_to_errno</span><span class="p">(</span><span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nfs_errtbl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">stat</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nfs_errtbl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">stat</span> <span class="o">==</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">status</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">nfs_errtbl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">errno</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: Unrecognized nfs status value: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nfs_errtbl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">errno</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#define PROC(proc, argtype, restype, timer)				\</span>
<span class="cp">[NFS3PROC_##proc] = {							\</span>
<span class="cp">	.p_proc      = NFS3PROC_##proc,					\</span>
<span class="cp">	.p_encode    = (kxdreproc_t)nfs3_xdr_enc_##argtype##3args,	\</span>
<span class="cp">	.p_decode    = (kxdrdproc_t)nfs3_xdr_dec_##restype##3res,	\</span>
<span class="cp">	.p_arglen    = NFS3_##argtype##args_sz,				\</span>
<span class="cp">	.p_replen    = NFS3_##restype##res_sz,				\</span>
<span class="cp">	.p_timer     = timer,						\</span>
<span class="cp">	.p_statidx   = NFS3PROC_##proc,					\</span>
<span class="cp">	.p_name      = #proc,						\</span>
<span class="cp">	}</span>

<span class="k">struct</span> <span class="n">rpc_procinfo</span>	<span class="n">nfs3_procedures</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">GETATTR</span><span class="p">,</span>		<span class="n">getattr</span><span class="p">,</span>	<span class="n">getattr</span><span class="p">,</span>	<span class="mi">1</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">SETATTR</span><span class="p">,</span>		<span class="n">setattr</span><span class="p">,</span>	<span class="n">setattr</span><span class="p">,</span>	<span class="mi">0</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">LOOKUP</span><span class="p">,</span>		<span class="n">lookup</span><span class="p">,</span>		<span class="n">lookup</span><span class="p">,</span>		<span class="mi">2</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">ACCESS</span><span class="p">,</span>		<span class="n">access</span><span class="p">,</span>		<span class="n">access</span><span class="p">,</span>		<span class="mi">1</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">READLINK</span><span class="p">,</span>		<span class="n">readlink</span><span class="p">,</span>	<span class="n">readlink</span><span class="p">,</span>	<span class="mi">3</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span>		<span class="n">read</span><span class="p">,</span>		<span class="n">read</span><span class="p">,</span>		<span class="mi">3</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span>		<span class="n">write</span><span class="p">,</span>		<span class="n">write</span><span class="p">,</span>		<span class="mi">4</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">CREATE</span><span class="p">,</span>		<span class="n">create</span><span class="p">,</span>		<span class="n">create</span><span class="p">,</span>		<span class="mi">0</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">MKDIR</span><span class="p">,</span>		<span class="n">mkdir</span><span class="p">,</span>		<span class="n">create</span><span class="p">,</span>		<span class="mi">0</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">SYMLINK</span><span class="p">,</span>		<span class="n">symlink</span><span class="p">,</span>	<span class="n">create</span><span class="p">,</span>		<span class="mi">0</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">MKNOD</span><span class="p">,</span>		<span class="n">mknod</span><span class="p">,</span>		<span class="n">create</span><span class="p">,</span>		<span class="mi">0</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">REMOVE</span><span class="p">,</span>		<span class="n">remove</span><span class="p">,</span>		<span class="n">remove</span><span class="p">,</span>		<span class="mi">0</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">RMDIR</span><span class="p">,</span>		<span class="n">lookup</span><span class="p">,</span>		<span class="n">setattr</span><span class="p">,</span>	<span class="mi">0</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">RENAME</span><span class="p">,</span>		<span class="n">rename</span><span class="p">,</span>		<span class="n">rename</span><span class="p">,</span>		<span class="mi">0</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">LINK</span><span class="p">,</span>		<span class="n">link</span><span class="p">,</span>		<span class="n">link</span><span class="p">,</span>		<span class="mi">0</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">READDIR</span><span class="p">,</span>		<span class="n">readdir</span><span class="p">,</span>	<span class="n">readdir</span><span class="p">,</span>	<span class="mi">3</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">READDIRPLUS</span><span class="p">,</span>	<span class="n">readdirplus</span><span class="p">,</span>	<span class="n">readdir</span><span class="p">,</span>	<span class="mi">3</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">FSSTAT</span><span class="p">,</span>		<span class="n">getattr</span><span class="p">,</span>	<span class="n">fsstat</span><span class="p">,</span>		<span class="mi">0</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">FSINFO</span><span class="p">,</span>		<span class="n">getattr</span><span class="p">,</span>	<span class="n">fsinfo</span><span class="p">,</span>		<span class="mi">0</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">PATHCONF</span><span class="p">,</span>		<span class="n">getattr</span><span class="p">,</span>	<span class="n">pathconf</span><span class="p">,</span>	<span class="mi">0</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">COMMIT</span><span class="p">,</span>		<span class="n">commit</span><span class="p">,</span>		<span class="n">commit</span><span class="p">,</span>		<span class="mi">5</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_version</span> <span class="n">nfs_version3</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">number</span>			<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nrprocs</span>		<span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">nfs3_procedures</span><span class="p">),</span>
	<span class="p">.</span><span class="n">procs</span>			<span class="o">=</span> <span class="n">nfs3_procedures</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_NFS_V3_ACL</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rpc_procinfo</span>	<span class="n">nfs3_acl_procedures</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">ACLPROC3_GETACL</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">p_proc</span> <span class="o">=</span> <span class="n">ACLPROC3_GETACL</span><span class="p">,</span>
		<span class="p">.</span><span class="n">p_encode</span> <span class="o">=</span> <span class="p">(</span><span class="n">kxdreproc_t</span><span class="p">)</span><span class="n">nfs3_xdr_enc_getacl3args</span><span class="p">,</span>
		<span class="p">.</span><span class="n">p_decode</span> <span class="o">=</span> <span class="p">(</span><span class="n">kxdrdproc_t</span><span class="p">)</span><span class="n">nfs3_xdr_dec_getacl3res</span><span class="p">,</span>
		<span class="p">.</span><span class="n">p_arglen</span> <span class="o">=</span> <span class="n">ACL3_getaclargs_sz</span><span class="p">,</span>
		<span class="p">.</span><span class="n">p_replen</span> <span class="o">=</span> <span class="n">ACL3_getaclres_sz</span><span class="p">,</span>
		<span class="p">.</span><span class="n">p_timer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">p_name</span> <span class="o">=</span> <span class="s">&quot;GETACL&quot;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">[</span><span class="n">ACLPROC3_SETACL</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">p_proc</span> <span class="o">=</span> <span class="n">ACLPROC3_SETACL</span><span class="p">,</span>
		<span class="p">.</span><span class="n">p_encode</span> <span class="o">=</span> <span class="p">(</span><span class="n">kxdreproc_t</span><span class="p">)</span><span class="n">nfs3_xdr_enc_setacl3args</span><span class="p">,</span>
		<span class="p">.</span><span class="n">p_decode</span> <span class="o">=</span> <span class="p">(</span><span class="n">kxdrdproc_t</span><span class="p">)</span><span class="n">nfs3_xdr_dec_setacl3res</span><span class="p">,</span>
		<span class="p">.</span><span class="n">p_arglen</span> <span class="o">=</span> <span class="n">ACL3_setaclargs_sz</span><span class="p">,</span>
		<span class="p">.</span><span class="n">p_replen</span> <span class="o">=</span> <span class="n">ACL3_setaclres_sz</span><span class="p">,</span>
		<span class="p">.</span><span class="n">p_timer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">p_name</span> <span class="o">=</span> <span class="s">&quot;SETACL&quot;</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_version</span> <span class="n">nfsacl_version3</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">number</span>			<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nrprocs</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nfs3_acl_procedures</span><span class="p">)</span><span class="o">/</span>
				  <span class="k">sizeof</span><span class="p">(</span><span class="n">nfs3_acl_procedures</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
	<span class="p">.</span><span class="n">procs</span>			<span class="o">=</span> <span class="n">nfs3_acl_procedures</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif  </span><span class="cm">/* CONFIG_NFS_V3_ACL */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
