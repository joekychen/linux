<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › nfs › delegation.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>delegation.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/fs/nfs/delegation.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004 Trond Myklebust</span>
<span class="cm"> *</span>
<span class="cm"> * NFS file delegation management</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>

<span class="cp">#include &lt;linux/nfs4.h&gt;</span>
<span class="cp">#include &lt;linux/nfs_fs.h&gt;</span>
<span class="cp">#include &lt;linux/nfs_xdr.h&gt;</span>

<span class="cp">#include &quot;nfs4_fs.h&quot;</span>
<span class="cp">#include &quot;delegation.h&quot;</span>
<span class="cp">#include &quot;internal.h&quot;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs_free_delegation</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">delegation</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_rpccred</span><span class="p">(</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">);</span>
		<span class="n">delegation</span><span class="o">-&gt;</span><span class="n">cred</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kfree_rcu</span><span class="p">(</span><span class="n">delegation</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_mark_delegation_referenced - set delegation&#39;s REFERENCED flag</span>
<span class="cm"> * @delegation: delegation to process</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nfs_mark_delegation_referenced</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">delegation</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">NFS_DELEGATION_REFERENCED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_have_delegation - check if inode has a delegation</span>
<span class="cm"> * @inode: inode to check</span>
<span class="cm"> * @flags: delegation types to check for</span>
<span class="cm"> *</span>
<span class="cm"> * Returns one if inode has the indicated delegation, otherwise zero.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nfs_have_delegation</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">delegation</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">FMODE_READ</span><span class="o">|</span><span class="n">FMODE_WRITE</span><span class="p">;</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">delegation</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">delegation</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delegation</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nfs_mark_delegation_referenced</span><span class="p">(</span><span class="n">delegation</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_delegation_claim_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs4_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flock</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Protect inode-&gt;i_flock using the file locks lock */</span>
	<span class="n">lock_flocks</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">fl</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flock</span><span class="p">;</span> <span class="n">fl</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">fl</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FL_POSIX</span><span class="o">|</span><span class="n">FL_FLOCK</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nfs_file_open_context</span><span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_file</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ctx</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">unlock_flocks</span><span class="p">();</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">nfs4_lock_delegation_recall</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">fl</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">lock_flocks</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">unlock_flocks</span><span class="p">();</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_delegation_claim_opens</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="n">nfs4_stateid</span> <span class="o">*</span><span class="n">stateid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_state</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">open_files</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NFS_DELEGATED_STATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nfs4_stateid_match</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">stateid</span><span class="p">,</span> <span class="n">stateid</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">get_nfs_open_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nfs4_open_delegation_recall</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">stateid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">nfs_delegation_claim_locks</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
		<span class="n">put_nfs_open_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_inode_reclaim_delegation - process a delegation reclaim request</span>
<span class="cm"> * @inode: inode to process</span>
<span class="cm"> * @cred: credential to use for request</span>
<span class="cm"> * @res: new delegation state from server</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nfs_inode_reclaim_delegation</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpc_cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">nfs_openres</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">delegation</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_cred</span> <span class="o">*</span><span class="n">oldcred</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">delegation</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">delegation</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delegation</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nfs4_stateid_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">stateid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">delegation</span><span class="p">);</span>
			<span class="n">delegation</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">delegation_type</span><span class="p">;</span>
			<span class="n">delegation</span><span class="o">-&gt;</span><span class="n">maxsize</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">maxsize</span><span class="p">;</span>
			<span class="n">oldcred</span> <span class="o">=</span> <span class="n">delegation</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">;</span>
			<span class="n">delegation</span><span class="o">-&gt;</span><span class="n">cred</span> <span class="o">=</span> <span class="n">get_rpccred</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">NFS_DELEGATION_NEED_RECLAIM</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">delegation_state</span> <span class="o">=</span> <span class="n">delegation</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">put_rpccred</span><span class="p">(</span><span class="n">oldcred</span><span class="p">);</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* We appear to have raced with a delegation return. */</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
			<span class="n">nfs_inode_set_delegation</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">cred</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_do_return_delegation</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">delegation</span><span class="p">,</span> <span class="kt">int</span> <span class="n">issync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">nfs4_proc_delegreturn</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">delegation</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">stateid</span><span class="p">,</span> <span class="n">issync</span><span class="p">);</span>
	<span class="n">nfs_free_delegation</span><span class="p">(</span><span class="n">delegation</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">nfs_delegation_grab_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">delegation</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="n">igrab</span><span class="p">(</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span>
<span class="nf">nfs_detach_delegation_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">delegation</span> <span class="o">=</span>
		<span class="n">rcu_dereference_protected</span><span class="p">(</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">delegation</span><span class="p">,</span>
				<span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">nfs_client</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">delegation</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomatch</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">super_list</span><span class="p">);</span>
	<span class="n">delegation</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">delegation_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">delegation</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">delegation</span><span class="p">;</span>
<span class="nl">nomatch:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="nf">nfs_detach_delegation</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span><span class="p">,</span>
						    <span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_client</span> <span class="o">*</span><span class="n">clp</span> <span class="o">=</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">nfs_client</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">delegation</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
	<span class="n">delegation</span> <span class="o">=</span> <span class="n">nfs_detach_delegation_locked</span><span class="p">(</span><span class="n">nfsi</span><span class="p">,</span> <span class="n">server</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">delegation</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_inode_set_delegation - set up a delegation on an inode</span>
<span class="cm"> * @inode: inode to which delegation applies</span>
<span class="cm"> * @cred: cred to use for subsequent delegation processing</span>
<span class="cm"> * @res: new delegation state from server</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, or a negative errno value.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nfs_inode_set_delegation</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpc_cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_openres</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span> <span class="o">=</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nfs_client</span> <span class="o">*</span><span class="n">clp</span> <span class="o">=</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">nfs_client</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">delegation</span><span class="p">,</span> <span class="o">*</span><span class="n">old_delegation</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">freeme</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">delegation</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">delegation</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delegation</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">nfs4_stateid_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">stateid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">delegation</span><span class="p">);</span>
	<span class="n">delegation</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">delegation_type</span><span class="p">;</span>
	<span class="n">delegation</span><span class="o">-&gt;</span><span class="n">maxsize</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">maxsize</span><span class="p">;</span>
	<span class="n">delegation</span><span class="o">-&gt;</span><span class="n">change_attr</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_version</span><span class="p">;</span>
	<span class="n">delegation</span><span class="o">-&gt;</span><span class="n">cred</span> <span class="o">=</span> <span class="n">get_rpccred</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>
	<span class="n">delegation</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>
	<span class="n">delegation</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">NFS_DELEGATION_REFERENCED</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
	<span class="n">old_delegation</span> <span class="o">=</span> <span class="n">rcu_dereference_protected</span><span class="p">(</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">delegation</span><span class="p">,</span>
					<span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_delegation</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nfs4_stateid_match</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">stateid</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">old_delegation</span><span class="o">-&gt;</span><span class="n">stateid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">delegation</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">old_delegation</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Deal with broken servers that hand out two</span>
<span class="cm">		 * delegations for the same file.</span>
<span class="cm">		 * Allow for upgrades to a WRITE delegation, but</span>
<span class="cm">		 * nothing else.</span>
<span class="cm">		 */</span>
		<span class="n">dfprintk</span><span class="p">(</span><span class="kt">FILE</span><span class="p">,</span> <span class="s">&quot;%s: server %s handed out &quot;</span>
				<span class="s">&quot;a duplicate delegation!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_hostname</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">old_delegation</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">||</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">freeme</span> <span class="o">=</span> <span class="n">delegation</span><span class="p">;</span>
			<span class="n">delegation</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">freeme</span> <span class="o">=</span> <span class="n">nfs_detach_delegation_locked</span><span class="p">(</span><span class="n">nfsi</span><span class="p">,</span> <span class="n">server</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">super_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">delegations</span><span class="p">);</span>
	<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">delegation_state</span> <span class="o">=</span> <span class="n">delegation</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">delegation</span><span class="p">,</span> <span class="n">delegation</span><span class="p">);</span>
	<span class="n">delegation</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Ensure we revalidate the attributes and page cache! */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">|=</span> <span class="n">NFS_INO_REVAL_FORCED</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delegation</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">nfs_free_delegation</span><span class="p">(</span><span class="n">delegation</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">freeme</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">nfs_do_return_delegation</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">freeme</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Basic procedure for returning a delegation to the server</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__nfs_inode_return_delegation</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">delegation</span><span class="p">,</span> <span class="kt">int</span> <span class="n">issync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Guard against new delegated open/lock/unlock calls and against</span>
<span class="cm">	 * state recovery</span>
<span class="cm">	 */</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">rwsem</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nfs_delegation_claim_opens</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">stateid</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">rwsem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfs_do_return_delegation</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">delegation</span><span class="p">,</span> <span class="n">issync</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_client_return_marked_delegations - return previously marked delegations</span>
<span class="cm"> * @clp: nfs_client to process</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this function is designed to be called by the state</span>
<span class="cm"> * manager thread. For this reason, it cannot flush the dirty data,</span>
<span class="cm"> * since that could deadlock in case of a state recovery error.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, or a negative errno value.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nfs_client_return_marked_delegations</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">delegation</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">restart:</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_superblocks</span><span class="p">,</span> <span class="n">client_link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">delegation</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">delegations</span><span class="p">,</span>
								<span class="n">super_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">NFS_DELEGATION_RETURN</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">inode</span> <span class="o">=</span> <span class="n">nfs_delegation_grab_inode</span><span class="p">(</span><span class="n">delegation</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">delegation</span> <span class="o">=</span> <span class="n">nfs_detach_delegation</span><span class="p">(</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span>
								<span class="n">server</span><span class="p">);</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">delegation</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">__nfs_inode_return_delegation</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
								<span class="n">delegation</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">NFS4CLNT_DELEGRETURN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_state</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_inode_return_delegation_noreclaim - return delegation, don&#39;t reclaim opens</span>
<span class="cm"> * @inode: inode to process</span>
<span class="cm"> *</span>
<span class="cm"> * Does not protect against delegation reclaims, therefore really only safe</span>
<span class="cm"> * to be called from nfs4_clear_inode().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nfs_inode_return_delegation_noreclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span> <span class="o">=</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">delegation</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_access_pointer</span><span class="p">(</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">delegation</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">delegation</span> <span class="o">=</span> <span class="n">nfs_detach_delegation</span><span class="p">(</span><span class="n">nfsi</span><span class="p">,</span> <span class="n">server</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delegation</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">nfs_do_return_delegation</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">delegation</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_inode_return_delegation - synchronously return a delegation</span>
<span class="cm"> * @inode: inode to process</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will always flush any dirty data to disk on the</span>
<span class="cm"> * assumption that if we need to return the delegation, then</span>
<span class="cm"> * we should stop caching.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, or a negative errno value.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nfs_inode_return_delegation</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span> <span class="o">=</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">delegation</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">nfs_wb_all</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_access_pointer</span><span class="p">(</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">delegation</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">delegation</span> <span class="o">=</span> <span class="n">nfs_detach_delegation</span><span class="p">(</span><span class="n">nfsi</span><span class="p">,</span> <span class="n">server</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delegation</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">__nfs_inode_return_delegation</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">delegation</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs_mark_return_delegation</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">delegation</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">NFS_DELEGATION_RETURN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">NFS4CLNT_DELEGRETURN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">nfs_client</span><span class="o">-&gt;</span><span class="n">cl_state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_super_return_all_delegations - return delegations for one superblock</span>
<span class="cm"> * @sb: sb to process</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nfs_super_return_all_delegations</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span> <span class="o">=</span> <span class="n">NFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nfs_client</span> <span class="o">*</span><span class="n">clp</span> <span class="o">=</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">nfs_client</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">delegation</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">delegation</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">delegations</span><span class="p">,</span> <span class="n">super_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">NFS_DELEGATION_RETURN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nfs_client_return_marked_delegations</span><span class="p">(</span><span class="n">clp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">nfs4_schedule_state_manager</span><span class="p">(</span><span class="n">clp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs_mark_return_all_delegation_types</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span>
						 <span class="n">fmode_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">delegation</span><span class="p">;</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">delegation</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">delegations</span><span class="p">,</span> <span class="n">super_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="p">(</span><span class="n">FMODE_READ</span><span class="o">|</span><span class="n">FMODE_WRITE</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span>
			<span class="n">nfs_mark_return_delegation</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">delegation</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs_client_mark_return_all_delegation_types</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">,</span>
							<span class="n">fmode_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_superblocks</span><span class="p">,</span> <span class="n">client_link</span><span class="p">)</span>
		<span class="n">nfs_mark_return_all_delegation_types</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs_delegation_run_state_manager</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NFS4CLNT_DELEGRETURN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_state</span><span class="p">))</span>
		<span class="n">nfs4_schedule_state_manager</span><span class="p">(</span><span class="n">clp</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nfs_remove_bad_delegation</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">delegation</span><span class="p">;</span>

	<span class="n">delegation</span> <span class="o">=</span> <span class="n">nfs_detach_delegation</span><span class="p">(</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delegation</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nfs_inode_find_state_and_recover</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">stateid</span><span class="p">);</span>
		<span class="n">nfs_free_delegation</span><span class="p">(</span><span class="n">delegation</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nfs_remove_bad_delegation</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_expire_all_delegation_types</span>
<span class="cm"> * @clp: client to process</span>
<span class="cm"> * @flags: delegation types to expire</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nfs_expire_all_delegation_types</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nfs_client_mark_return_all_delegation_types</span><span class="p">(</span><span class="n">clp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">nfs_delegation_run_state_manager</span><span class="p">(</span><span class="n">clp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_expire_all_delegations</span>
<span class="cm"> * @clp: client to process</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nfs_expire_all_delegations</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nfs_expire_all_delegation_types</span><span class="p">(</span><span class="n">clp</span><span class="p">,</span> <span class="n">FMODE_READ</span><span class="o">|</span><span class="n">FMODE_WRITE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs_mark_return_unreferenced_delegations</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">delegation</span><span class="p">;</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">delegation</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">delegations</span><span class="p">,</span> <span class="n">super_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">NFS_DELEGATION_REFERENCED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">nfs_mark_return_delegation</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">delegation</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_expire_unreferenced_delegations - Eliminate unused delegations</span>
<span class="cm"> * @clp: nfs_client to process</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nfs_expire_unreferenced_delegations</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_superblocks</span><span class="p">,</span> <span class="n">client_link</span><span class="p">)</span>
		<span class="n">nfs_mark_return_unreferenced_delegations</span><span class="p">(</span><span class="n">server</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">nfs_delegation_run_state_manager</span><span class="p">(</span><span class="n">clp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_async_inode_return_delegation - asynchronously return a delegation</span>
<span class="cm"> * @inode: inode to process</span>
<span class="cm"> * @stateid: state ID information</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, or a negative errno value.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nfs_async_inode_return_delegation</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				      <span class="k">const</span> <span class="n">nfs4_stateid</span> <span class="o">*</span><span class="n">stateid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span> <span class="o">=</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nfs_client</span> <span class="o">*</span><span class="n">clp</span> <span class="o">=</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">nfs_client</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">delegation</span><span class="p">;</span>

	<span class="n">filemap_flush</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">delegation</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">delegation</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_mvops</span><span class="o">-&gt;</span><span class="n">match_stateid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">stateid</span><span class="p">,</span> <span class="n">stateid</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nfs_mark_return_delegation</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">delegation</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">nfs_delegation_run_state_manager</span><span class="p">(</span><span class="n">clp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span>
<span class="nf">nfs_delegation_find_inode_server</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">fhandle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">delegation</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">delegation</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">delegations</span><span class="p">,</span> <span class="n">super_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
		    <span class="n">nfs_compare_fh</span><span class="p">(</span><span class="n">fhandle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">igrab</span><span class="p">(</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_delegation_find_inode - retrieve the inode associated with a delegation</span>
<span class="cm"> * @clp: client state handle</span>
<span class="cm"> * @fhandle: filehandle from a delegation recall</span>
<span class="cm"> *</span>
<span class="cm"> * Returns pointer to inode matching &quot;fhandle,&quot; or NULL if a matching inode</span>
<span class="cm"> * cannot be found.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">nfs_delegation_find_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">fhandle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_superblocks</span><span class="p">,</span> <span class="n">client_link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">nfs_delegation_find_inode_server</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">fhandle</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs_delegation_mark_reclaim_server</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">delegation</span><span class="p">;</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">delegation</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">delegations</span><span class="p">,</span> <span class="n">super_list</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">NFS_DELEGATION_NEED_RECLAIM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_delegation_mark_reclaim - mark all delegations as needing to be reclaimed</span>
<span class="cm"> * @clp: nfs_client to process</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nfs_delegation_mark_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_superblocks</span><span class="p">,</span> <span class="n">client_link</span><span class="p">)</span>
		<span class="n">nfs_delegation_mark_reclaim_server</span><span class="p">(</span><span class="n">server</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_delegation_reap_unclaimed - reap unclaimed delegations after reboot recovery is done</span>
<span class="cm"> * @clp: nfs_client to process</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nfs_delegation_reap_unclaimed</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">delegation</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

<span class="nl">restart:</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_superblocks</span><span class="p">,</span> <span class="n">client_link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">delegation</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">delegations</span><span class="p">,</span>
								<span class="n">super_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NFS_DELEGATION_NEED_RECLAIM</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">inode</span> <span class="o">=</span> <span class="n">nfs_delegation_grab_inode</span><span class="p">(</span><span class="n">delegation</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">delegation</span> <span class="o">=</span> <span class="n">nfs_detach_delegation</span><span class="p">(</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span>
								<span class="n">server</span><span class="p">);</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">delegation</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">nfs_free_delegation</span><span class="p">(</span><span class="n">delegation</span><span class="p">);</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_delegations_present - check for existence of delegations</span>
<span class="cm"> * @clp: client state handle</span>
<span class="cm"> *</span>
<span class="cm"> * Returns one if there are any nfs_delegation structures attached</span>
<span class="cm"> * to this nfs_client.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nfs_delegations_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_superblocks</span><span class="p">,</span> <span class="n">client_link</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">delegations</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs4_copy_delegation_stateid - Copy inode&#39;s state ID information</span>
<span class="cm"> * @dst: stateid data structure to fill in</span>
<span class="cm"> * @inode: inode to check</span>
<span class="cm"> * @flags: delegation type requirement</span>
<span class="cm"> *</span>
<span class="cm"> * Returns &quot;true&quot; and fills in &quot;dst-&gt;data&quot; * if inode had a delegation,</span>
<span class="cm"> * otherwise &quot;false&quot; is returned.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">nfs4_copy_delegation_stateid</span><span class="p">(</span><span class="n">nfs4_stateid</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		<span class="n">fmode_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nfs_delegation</span> <span class="o">*</span><span class="n">delegation</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">FMODE_READ</span><span class="o">|</span><span class="n">FMODE_WRITE</span><span class="p">;</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">delegation</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">delegation</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">delegation</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nfs4_stateid_copy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">delegation</span><span class="o">-&gt;</span><span class="n">stateid</span><span class="p">);</span>
		<span class="n">nfs_mark_delegation_referenced</span><span class="p">(</span><span class="n">delegation</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
