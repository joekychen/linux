<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › nfs › inode.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>inode.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/fs/nfs/inode.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1992  Rick Sladkey</span>
<span class="cm"> *</span>
<span class="cm"> *  nfs inode and superblock handling functions</span>
<span class="cm"> *</span>
<span class="cm"> *  Modularised by Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;, while hacking some</span>
<span class="cm"> *  experimental NFS changes. Modularisation taken straight from SYS5 fs.</span>
<span class="cm"> *</span>
<span class="cm"> *  Change to nfs_read_super() to permit NFS mounts to multi-homed hosts.</span>
<span class="cm"> *  J.S.Peatfield@damtp.cam.ac.uk</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/unistd.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/clnt.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/stats.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/metrics.h&gt;</span>
<span class="cp">#include &lt;linux/nfs_fs.h&gt;</span>
<span class="cp">#include &lt;linux/nfs_mount.h&gt;</span>
<span class="cp">#include &lt;linux/nfs4_mount.h&gt;</span>
<span class="cp">#include &lt;linux/lockd/bind.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/nfs_idmap.h&gt;</span>
<span class="cp">#include &lt;linux/vfs.h&gt;</span>
<span class="cp">#include &lt;linux/inet.h&gt;</span>
<span class="cp">#include &lt;linux/nfs_xdr.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#include &quot;nfs4_fs.h&quot;</span>
<span class="cp">#include &quot;callback.h&quot;</span>
<span class="cp">#include &quot;delegation.h&quot;</span>
<span class="cp">#include &quot;iostat.h&quot;</span>
<span class="cp">#include &quot;internal.h&quot;</span>
<span class="cp">#include &quot;fscache.h&quot;</span>
<span class="cp">#include &quot;dns_resolve.h&quot;</span>
<span class="cp">#include &quot;pnfs.h&quot;</span>
<span class="cp">#include &quot;netns.h&quot;</span>

<span class="cp">#define NFSDBG_FACILITY		NFSDBG_VFS</span>

<span class="cp">#define NFS_64_BIT_INODE_NUMBERS_ENABLED	1</span>

<span class="cm">/* Default is to see 64-bit inode numbers */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">enable_ino64</span> <span class="o">=</span> <span class="n">NFS_64_BIT_INODE_NUMBERS_ENABLED</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">nfs_invalidate_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nfs_update_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span> <span class="n">nfs_inode_cachep</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">nfs_fattr_to_ino_t</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nfs_fileid_to_ino_t</span><span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">fileid</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_wait_bit_killable - helper for functions that are sleeping on bit locks</span>
<span class="cm"> * @word: long word containing the bit lock</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nfs_wait_bit_killable</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">word</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fatal_signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
	<span class="n">freezable_schedule</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_compat_user_ino64 - returns the user-visible inode number</span>
<span class="cm"> * @fileid: 64-bit fileid</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns a 32-bit inode number if the boot parameter</span>
<span class="cm"> * nfs.enable_ino64 is zero.</span>
<span class="cm"> */</span>
<span class="n">u64</span> <span class="nf">nfs_compat_user_ino64</span><span class="p">(</span><span class="n">u64</span> <span class="n">fileid</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="n">compat_ulong_t</span> <span class="n">ino</span><span class="p">;</span>
<span class="cp">#else	</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">enable_ino64</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">fileid</span><span class="p">;</span>
	<span class="n">ino</span> <span class="o">=</span> <span class="n">fileid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ino</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fileid</span><span class="p">))</span>
		<span class="n">ino</span> <span class="o">^=</span> <span class="n">fileid</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">fileid</span><span class="p">)</span><span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ino</span><span class="p">))</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ino</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs_clear_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The following should never happen...</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">nfs_have_writebacks</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">open_files</span><span class="p">));</span>
	<span class="n">nfs_zap_acl_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">nfs_access_zap_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">nfs_fscache_release_inode_cookie</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nfs_evict_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">truncate_inode_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">clear_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">nfs_clear_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_sync_mapping - helper to flush all mmapped dirty data to disk</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nfs_sync_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unmap_mapping_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nfs_wb_all</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Invalidate the local caches</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs_zap_caches_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">;</span>

	<span class="n">nfs_inc_stats</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">NFSIOS_ATTRINVALIDATE</span><span class="p">);</span>

	<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">attrtimeo</span> <span class="o">=</span> <span class="n">NFS_MINATTRTIMEO</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">attrtimeo_timestamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">NFS_COOKIEVERF</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">NFS_COOKIEVERF</span><span class="p">(</span><span class="n">inode</span><span class="p">)));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISLNK</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
		<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="o">|</span><span class="n">NFS_INO_INVALID_DATA</span><span class="o">|</span><span class="n">NFS_INO_INVALID_ACCESS</span><span class="o">|</span><span class="n">NFS_INO_INVALID_ACL</span><span class="o">|</span><span class="n">NFS_INO_REVAL_PAGECACHE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="o">|</span><span class="n">NFS_INO_INVALID_ACCESS</span><span class="o">|</span><span class="n">NFS_INO_INVALID_ACL</span><span class="o">|</span><span class="n">NFS_INO_REVAL_PAGECACHE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nfs_zap_caches</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">nfs_zap_caches_locked</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nfs_zap_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_DATA</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nfs_zap_acl_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">clear_acl_cache</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>

	<span class="n">clear_acl_cache</span> <span class="o">=</span> <span class="n">NFS_PROTO</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clear_acl_cache</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clear_acl_cache</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">clear_acl_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NFS_INO_INVALID_ACL</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nfs_invalidate_atime</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATIME</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Invalidate, but do not unhash, the inode.</span>
<span class="cm"> * NB: must be called with inode-&gt;i_lock held!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs_invalidate_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">NFS_INO_STALE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">nfs_zap_caches_locked</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">nfs_find_desc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_fh</span>		<span class="o">*</span><span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_fattr</span>	<span class="o">*</span><span class="n">fattr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * In NFSv3 we can have 64bit inode numbers. In order to support</span>
<span class="cm"> * this, and re-exported directories (also seen in NFSv2)</span>
<span class="cm"> * we are forced to allow 2 different inodes to have the same</span>
<span class="cm"> * i_ino.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">nfs_find_actor</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_find_desc</span>	<span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nfs_find_desc</span> <span class="o">*</span><span class="p">)</span><span class="n">opaque</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_fh</span>		<span class="o">*</span><span class="n">fh</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_fattr</span>	<span class="o">*</span><span class="n">fattr</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">NFS_FILEID</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">!=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">fileid</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfs_compare_fh</span><span class="p">(</span><span class="n">NFS_FH</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">fh</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">||</span> <span class="n">NFS_STALE</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">nfs_init_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_find_desc</span>	<span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nfs_find_desc</span> <span class="o">*</span><span class="p">)</span><span class="n">opaque</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_fattr</span>	<span class="o">*</span><span class="n">fattr</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="p">;</span>

	<span class="n">set_nfs_fileid</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">fileid</span><span class="p">);</span>
	<span class="n">nfs_copy_fh</span><span class="p">(</span><span class="n">NFS_FH</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is our front-end to iget that looks up inodes by file handle</span>
<span class="cm"> * instead of inode number.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span>
<span class="nf">nfs_fhget</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_find_desc</span> <span class="n">desc</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">fh</span>	<span class="o">=</span> <span class="n">fh</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fattr</span>	<span class="o">=</span> <span class="n">fattr</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span><span class="p">;</span>

	<span class="n">nfs_attr_check_mountpoint</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">fattr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_FILEID</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">nfs_attr_use_mounted_on_fileid</span><span class="p">(</span><span class="n">fattr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_no_inode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_TYPE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_inode</span><span class="p">;</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">nfs_fattr_to_ino_t</span><span class="p">(</span><span class="n">fattr</span><span class="p">);</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">iget5_locked</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">hash</span><span class="p">,</span> <span class="n">nfs_find_actor</span><span class="p">,</span> <span class="n">nfs_init_locked</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_no_inode</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_NEW</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

		<span class="cm">/* We set i_ino for the few things that still rely on it,</span>
<span class="cm">		 * such as stat(2) */</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">hash</span><span class="p">;</span>

		<span class="cm">/* We can&#39;t support update_atime(), since the server will reset it */</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_NOATIME</span><span class="o">|</span><span class="n">S_NOCMTIME</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_MODE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
				<span class="o">&amp;&amp;</span> <span class="n">nfs_server_capable</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">NFS_CAP_MODE</span><span class="p">))</span>
			<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="p">;</span>
		<span class="cm">/* Why so? Because we want revalidate for devices/FIFOs, and</span>
<span class="cm">		 * that&#39;s precisely what we have in nfs_file_inode_operations.</span>
<span class="cm">		 */</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="n">NFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nfs_client</span><span class="o">-&gt;</span><span class="n">rpc_ops</span><span class="o">-&gt;</span><span class="n">file_inode_ops</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="n">NFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nfs_client</span><span class="o">-&gt;</span><span class="n">rpc_ops</span><span class="o">-&gt;</span><span class="n">file_ops</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">.</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nfs_file_aops</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">.</span><span class="n">backing_dev_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">NFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="n">NFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nfs_client</span><span class="o">-&gt;</span><span class="n">rpc_ops</span><span class="o">-&gt;</span><span class="n">dir_inode_ops</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nfs_dir_operations</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">.</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nfs_dir_aops</span><span class="p">;</span>
			<span class="cm">/* Deal with crossing mountpoints */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_MOUNTPOINT</span> <span class="o">||</span>
					<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_V4_REFERRAL</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_V4_REFERRAL</span><span class="p">)</span>
					<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nfs_referral_inode_operations</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nfs_mountpoint_inode_operations</span><span class="p">;</span>
				<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_AUTOMOUNT</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nfs_symlink_inode_operations</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">init_special_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">rdev</span><span class="p">);</span>

		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">));</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">));</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">));</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">clear_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cookieverf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cookieverf</span><span class="p">));</span>
		<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">write_io</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">read_io</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">read_cache_jiffies</span> <span class="o">=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">time_start</span><span class="p">;</span>
		<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">attr_gencount</span> <span class="o">=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">gencount</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_ATIME</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">atime</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nfs_server_capable</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">NFS_CAP_ATIME</span><span class="p">))</span>
			<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_MTIME</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">mtime</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nfs_server_capable</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">NFS_CAP_MTIME</span><span class="p">))</span>
			<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_CTIME</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">ctime</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nfs_server_capable</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">NFS_CAP_CTIME</span><span class="p">))</span>
			<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_CHANGE</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_version</span> <span class="o">=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">change_attr</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nfs_server_capable</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">NFS_CAP_CHANGE_ATTR</span><span class="p">))</span>
			<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_SIZE</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">nfs_size_to_loff_t</span><span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span>
				<span class="o">|</span> <span class="n">NFS_INO_REVAL_PAGECACHE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_NLINK</span><span class="p">)</span>
			<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nfs_server_capable</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">NFS_CAP_NLINK</span><span class="p">))</span>
			<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_OWNER</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nfs_server_capable</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">NFS_CAP_OWNER</span><span class="p">))</span>
			<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_GROUP</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nfs_server_capable</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">NFS_CAP_OWNER_GROUP</span><span class="p">))</span>
			<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_BLOCKS_USED</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">du</span><span class="p">.</span><span class="n">nfs2</span><span class="p">.</span><span class="n">blocks</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_SPACE_USED</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * report the blocks in 512byte units</span>
<span class="cm">			 */</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="n">nfs_calc_block_size</span><span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">du</span><span class="p">.</span><span class="n">nfs3</span><span class="p">.</span><span class="n">used</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">attrtimeo</span> <span class="o">=</span> <span class="n">NFS_MINATTRTIMEO</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">attrtimeo_timestamp</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
		<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">access_cache</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>

		<span class="n">nfs_fscache_init_inode_cookie</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

		<span class="n">unlock_new_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">nfs_refresh_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fattr</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: nfs_fhget(%s/%Ld fh_crc=0x%08x ct=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">NFS_FILEID</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span>
		<span class="n">nfs_display_fhandle_hash</span><span class="p">(</span><span class="n">fh</span><span class="p">),</span>
		<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="p">));</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>

<span class="nl">out_no_inode:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;nfs_fhget: iget failed with error %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define NFS_VALID_ATTRS (ATTR_MODE|ATTR_UID|ATTR_GID|ATTR_SIZE|ATTR_ATIME|ATTR_ATIME_SET|ATTR_MTIME|ATTR_MTIME_SET|ATTR_FILE|ATTR_OPEN)</span>

<span class="kt">int</span>
<span class="nf">nfs_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">nfs_inc_stats</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">NFSIOS_VFSSETATTR</span><span class="p">);</span>

	<span class="cm">/* skip mode change if it&#39;s just for clearing setuid/setgid */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATTR_KILL_SUID</span> <span class="o">|</span> <span class="n">ATTR_KILL_SGID</span><span class="p">))</span>
		<span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATTR_MODE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span> <span class="o">==</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
			<span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATTR_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Optimization: if the end result is no change, don&#39;t RPC */</span>
	<span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;=</span> <span class="n">NFS_VALID_ATTRS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">ATTR_FILE</span><span class="o">|</span><span class="n">ATTR_OPEN</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Write all dirty data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nfs_inode_dio_wait</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">nfs_wb_all</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">fattr</span> <span class="o">=</span> <span class="n">nfs_alloc_fattr</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Return any delegations if we&#39;re going to change ACLs</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATTR_MODE</span><span class="o">|</span><span class="n">ATTR_UID</span><span class="o">|</span><span class="n">ATTR_GID</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">nfs_inode_return_delegation</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">NFS_PROTO</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setattr</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">fattr</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">nfs_refresh_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fattr</span><span class="p">);</span>
	<span class="n">nfs_free_fattr</span><span class="p">(</span><span class="n">fattr</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_vmtruncate - unmap mappings &quot;freed&quot; by truncate() syscall</span>
<span class="cm"> * @inode: inode of the file used</span>
<span class="cm"> * @offset: file offset to start truncating</span>
<span class="cm"> *</span>
<span class="cm"> * This is a copy of the common vmtruncate, but with the locking</span>
<span class="cm"> * corrected to take into account the fact that NFS requires</span>
<span class="cm"> * inode-&gt;i_size to be updated under the inode-&gt;i_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_vmtruncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">oldsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">inode_newsize_ok</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">oldsize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>

	<span class="n">truncate_pagecache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">oldsize</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_setattr_update_inode - Update inode metadata after a setattr call.</span>
<span class="cm"> * @inode: pointer to struct inode</span>
<span class="cm"> * @attr: pointer to struct iattr</span>
<span class="cm"> *</span>
<span class="cm"> * Note: we do this in the *proc.c in order to ensure that</span>
<span class="cm"> *       it works for things like exclusive creates too.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nfs_setattr_update_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATTR_MODE</span><span class="o">|</span><span class="n">ATTR_UID</span><span class="o">|</span><span class="n">ATTR_GID</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MODE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_mode</span> <span class="o">&amp;</span> <span class="n">S_IALLUGO</span><span class="p">;</span>
			<span class="n">mode</span> <span class="o">|=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">S_IALLUGO</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_UID</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_uid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_GID</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_gid</span><span class="p">;</span>
		<span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ACCESS</span><span class="o">|</span><span class="n">NFS_INO_INVALID_ACL</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nfs_inc_stats</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">NFSIOS_SETATTRTRUNC</span><span class="p">);</span>
		<span class="n">nfs_vmtruncate</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nfs_getattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstat</span> <span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">need_atime</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">&amp;</span> <span class="n">NFS_INO_INVALID_ATIME</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Flush out writes to the server in order to update c/mtime.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nfs_inode_dio_wait</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">filemap_write_and_wait</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We may force a getattr if the user cares about atime.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that we only have to check the vfsmount flags here:</span>
<span class="cm">	 *  - NFS always sets S_NOATIME by so checking it would give a</span>
<span class="cm">	 *    bogus result</span>
<span class="cm">	 *  - NFS never sets MS_NOATIME or MS_NODIRATIME so there is</span>
<span class="cm">	 *    no point in checking those.</span>
<span class="cm">	 */</span>
 	<span class="k">if</span> <span class="p">((</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="n">MNT_NOATIME</span><span class="p">)</span> <span class="o">||</span>
 	    <span class="p">((</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="n">MNT_NODIRATIME</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)))</span>
		<span class="n">need_atime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">need_atime</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">__nfs_revalidate_inode</span><span class="p">(</span><span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nfs_revalidate_inode</span><span class="p">(</span><span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">generic_fillattr</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
		<span class="n">stat</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">=</span> <span class="n">nfs_compat_user_ino64</span><span class="p">(</span><span class="n">NFS_FILEID</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs_init_lock_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_lock_context</span> <span class="o">*</span><span class="n">l_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l_ctx</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">l_ctx</span><span class="o">-&gt;</span><span class="n">lockowner</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">;</span>
	<span class="n">l_ctx</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l_ctx</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nfs_lock_context</span> <span class="o">*</span><span class="nf">__nfs_find_lock_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_lock_context</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock_context</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">lockowner</span> <span class="o">!=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">!=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">nfs_lock_context</span> <span class="o">*</span><span class="nf">nfs_get_lock_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_lock_context</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">__nfs_find_lock_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">nfs_init_lock_context</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">__nfs_find_lock_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock_context</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
			<span class="n">new</span><span class="o">-&gt;</span><span class="n">open_context</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
			<span class="n">new</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nfs_put_lock_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_lock_context</span> <span class="o">*</span><span class="n">l_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">l_ctx</span><span class="o">-&gt;</span><span class="n">open_context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l_ctx</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l_ctx</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">l_ctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_close_context - Common close_context() routine NFSv2/v3</span>
<span class="cm"> * @ctx: pointer to context</span>
<span class="cm"> * @is_sync: is this a synchronous close</span>
<span class="cm"> *</span>
<span class="cm"> * always ensure that the attributes are up to date if we&#39;re mounted</span>
<span class="cm"> * with close-to-open semantics</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nfs_close_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_sync</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">open_files</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">server</span> <span class="o">=</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NFS_MOUNT_NOCTO</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">nfs_revalidate_inode</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="nf">alloc_nfs_open_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">f_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rpc_cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">rpc_lookup_cred</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">cred</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ctx</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_rpccred</span><span class="p">(</span><span class="n">cred</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">nfs_sb_active</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">cred</span> <span class="o">=</span> <span class="n">cred</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">f_mode</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">nfs_init_lock_context</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock_context</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock_context</span><span class="p">.</span><span class="n">open_context</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mdsthreshold</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ctx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="nf">get_nfs_open_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock_context</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ctx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__put_nfs_open_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock_context</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lock_context</span><span class="p">.</span><span class="n">count</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">NFS_PROTO</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">close_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">is_sync</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">cred</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">put_rpccred</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">);</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">nfs_sb_deactive</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mdsthreshold</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">put_nfs_open_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__put_nfs_open_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Ensure that mmap has a recent RPC credential for use when writing out</span>
<span class="cm"> * shared pages</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nfs_file_set_open_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">get_nfs_open_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">open_files</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Given an inode, search for an open context with the desired characteristics</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="nf">nfs_find_open_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rpc_cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">open_files</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cred</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">pos</span><span class="o">-&gt;</span><span class="n">cred</span> <span class="o">!=</span> <span class="n">cred</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pos</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FMODE_READ</span><span class="o">|</span><span class="n">FMODE_WRITE</span><span class="p">))</span> <span class="o">!=</span> <span class="n">mode</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ctx</span> <span class="o">=</span> <span class="n">get_nfs_open_context</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ctx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs_file_clear_open_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">nfs_file_open_context</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">open_files</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">__put_nfs_open_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_DIRECT</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These allocate and release file read/write context information.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nfs_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">alloc_nfs_open_context</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">,</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">nfs_file_set_open_context</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="n">put_nfs_open_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">nfs_fscache_set_inode_cookie</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nfs_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nfs_file_clear_open_context</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is called whenever some part of NFS notices that</span>
<span class="cm"> * the cached attributes have to be refreshed.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">__nfs_revalidate_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		 <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESTALE</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">dfprintk</span><span class="p">(</span><span class="n">PAGECACHE</span><span class="p">,</span> <span class="s">&quot;NFS: revalidating (%s/%Ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">NFS_FILEID</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">NFS_STALE</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">fattr</span> <span class="o">=</span> <span class="n">nfs_alloc_fattr</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">nfs_inc_stats</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">NFSIOS_INODEREVALIDATE</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">NFS_PROTO</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getattr</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">NFS_FH</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">fattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dfprintk</span><span class="p">(</span><span class="n">PAGECACHE</span><span class="p">,</span> <span class="s">&quot;nfs_revalidate_inode: (%s/%Ld) getattr failed, error=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">NFS_FILEID</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ESTALE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nfs_zap_caches</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">NFS_INO_STALE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">nfs_refresh_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dfprintk</span><span class="p">(</span><span class="n">PAGECACHE</span><span class="p">,</span> <span class="s">&quot;nfs_revalidate_inode: (%s/%Ld) refresh failed, error=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">NFS_FILEID</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">&amp;</span> <span class="n">NFS_INO_INVALID_ACL</span><span class="p">)</span>
		<span class="n">nfs_zap_acl_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">dfprintk</span><span class="p">(</span><span class="n">PAGECACHE</span><span class="p">,</span> <span class="s">&quot;NFS: (%s/%Ld) revalidation complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">NFS_FILEID</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>

 <span class="nl">out:</span>
	<span class="n">nfs_free_fattr</span><span class="p">(</span><span class="n">fattr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nfs_attribute_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">!</span><span class="n">time_in_range_open</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">read_cache_jiffies</span><span class="p">,</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">read_cache_jiffies</span> <span class="o">+</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">attrtimeo</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_attribute_cache_expired</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfs_have_delegated_attributes</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">nfs_attribute_timeout</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_revalidate_inode - Revalidate the inode attributes</span>
<span class="cm"> * @server - pointer to nfs_server struct</span>
<span class="cm"> * @inode - pointer to inode struct</span>
<span class="cm"> *</span>
<span class="cm"> * Updates inode attribute information by retrieving the data from the server.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nfs_revalidate_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">&amp;</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">nfs_attribute_cache_expired</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NFS_STALE</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">ESTALE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__nfs_revalidate_inode</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_invalidate_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">invalidate_inode_pages2</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NFS_INO_INVALID_DATA</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cookieverf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cookieverf</span><span class="p">));</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">nfs_inc_stats</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">NFSIOS_DATAINVALIDATE</span><span class="p">);</span>
	<span class="n">nfs_fscache_reset_inode_cookie</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">dfprintk</span><span class="p">(</span><span class="n">PAGECACHE</span><span class="p">,</span> <span class="s">&quot;NFS: (%s/%Ld) data cache invalidated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">NFS_FILEID</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">nfs_mapping_need_revalidate_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfs_have_delegated_attributes</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">&amp;</span> <span class="n">NFS_INO_REVAL_PAGECACHE</span><span class="p">)</span>
		<span class="o">||</span> <span class="n">nfs_attribute_timeout</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span>
		<span class="o">||</span> <span class="n">NFS_STALE</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_revalidate_mapping - Revalidate the pagecache</span>
<span class="cm"> * @inode - pointer to host inode</span>
<span class="cm"> * @mapping - pointer to mapping</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nfs_revalidate_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nfs_mapping_need_revalidate_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__nfs_revalidate_inode</span><span class="p">(</span><span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">&amp;</span> <span class="n">NFS_INO_INVALID_DATA</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nfs_invalidate_mapping</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">mapping</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">nfs_wcc_update_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_PRECHANGE</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_CHANGE</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_version</span> <span class="o">==</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">pre_change_attr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_version</span> <span class="o">=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">change_attr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
			<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_DATA</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* If we have atomic WCC data, we may update some attributes */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_PRECTIME</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_CTIME</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="n">timespec_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">pre_ctime</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">ctime</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_PREMTIME</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_MTIME</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="n">timespec_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">pre_mtime</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">mtime</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
			<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_DATA</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_PRESIZE</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_SIZE</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">==</span> <span class="n">nfs_size_to_loff_t</span><span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">pre_size</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">npages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">nfs_size_to_loff_t</span><span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_check_inode_attributes - verify consistency of the inode attribute cache</span>
<span class="cm"> * @inode - pointer to inode</span>
<span class="cm"> * @fattr - updated attributes</span>
<span class="cm"> *</span>
<span class="cm"> * Verifies the attribute cache. If we have just changed the attributes,</span>
<span class="cm"> * so that fattr carries weak cache consistency data, then it may</span>
<span class="cm"> * also update the ctime/mtime/change_attribute.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_check_inode_attributes</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">loff_t</span> <span class="n">cur_size</span><span class="p">,</span> <span class="n">new_isize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">invalid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">nfs_have_delegated_attributes</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Has the inode gone and changed behind our back? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_FILEID</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">fileid</span> <span class="o">!=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">fileid</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_TYPE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_CHANGE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_version</span> <span class="o">!=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">change_attr</span><span class="p">)</span>
		<span class="n">invalid</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="o">|</span><span class="n">NFS_INO_REVAL_PAGECACHE</span><span class="p">;</span>

	<span class="cm">/* Verify a few of the more important attributes */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_MTIME</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">timespec_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">mtime</span><span class="p">))</span>
		<span class="n">invalid</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cur_size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">new_isize</span> <span class="o">=</span> <span class="n">nfs_size_to_loff_t</span><span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur_size</span> <span class="o">!=</span> <span class="n">new_isize</span> <span class="o">&amp;&amp;</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">npages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">invalid</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="o">|</span><span class="n">NFS_INO_REVAL_PAGECACHE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Have any file permissions changed? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_MODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_IALLUGO</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_IALLUGO</span><span class="p">))</span>
		<span class="n">invalid</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span> <span class="o">|</span> <span class="n">NFS_INO_INVALID_ACCESS</span> <span class="o">|</span> <span class="n">NFS_INO_INVALID_ACL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_OWNER</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">!=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">)</span>
		<span class="n">invalid</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span> <span class="o">|</span> <span class="n">NFS_INO_INVALID_ACCESS</span> <span class="o">|</span> <span class="n">NFS_INO_INVALID_ACL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_GROUP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">!=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">)</span>
		<span class="n">invalid</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span> <span class="o">|</span> <span class="n">NFS_INO_INVALID_ACCESS</span> <span class="o">|</span> <span class="n">NFS_INO_INVALID_ACL</span><span class="p">;</span>

	<span class="cm">/* Has the link count changed? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_NLINK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">!=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="p">)</span>
		<span class="n">invalid</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_ATIME</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">timespec_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">atime</span><span class="p">))</span>
		<span class="n">invalid</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATIME</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">invalid</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">|=</span> <span class="n">invalid</span><span class="p">;</span>

	<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">read_cache_jiffies</span> <span class="o">=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">time_start</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_ctime_need_update</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_CTIME</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">timespec_compare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">ctime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_size_need_update</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_SIZE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">nfs_size_to_loff_t</span><span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">atomic_long_t</span> <span class="n">nfs_attr_generation_counter</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">nfs_read_attr_generation_counter</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfs_attr_generation_counter</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">nfs_inc_attr_generation_counter</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_long_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfs_attr_generation_counter</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nfs_fattr_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">time_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">gencount</span> <span class="o">=</span> <span class="n">nfs_inc_attr_generation_counter</span><span class="p">();</span>
	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">owner_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">group_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="nf">nfs_alloc_fattr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span><span class="p">;</span>

	<span class="n">fattr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fattr</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">nfs_fattr_init</span><span class="p">(</span><span class="n">fattr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">fattr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="nf">nfs_alloc_fhandle</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">;</span>

	<span class="n">fh</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_fh</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fh</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">fh</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">fh</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef NFS_DEBUG</span>
<span class="cm">/*</span>
<span class="cm"> * _nfs_display_fhandle_hash - calculate the crc32 hash for the filehandle</span>
<span class="cm"> *                             in the same way that wireshark does</span>
<span class="cm"> *</span>
<span class="cm"> * @fh: file handle</span>
<span class="cm"> *</span>
<span class="cm"> * For debugging only.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">_nfs_display_fhandle_hash</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* wireshark uses 32-bit AUTODIN crc and does a bitwise</span>
<span class="cm">	 * not on the result */</span>
	<span class="k">return</span> <span class="o">~</span><span class="n">crc32</span><span class="p">(</span><span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * _nfs_display_fhandle - display an NFS file handle on the console</span>
<span class="cm"> *</span>
<span class="cm"> * @fh: file handle to display</span>
<span class="cm"> * @caption: display caption</span>
<span class="cm"> *</span>
<span class="cm"> * For debugging only.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">_nfs_display_fhandle</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">caption</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fh</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEFAULT</span> <span class="s">&quot;%s at %p is empty</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">caption</span><span class="p">,</span> <span class="n">fh</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEFAULT</span> <span class="s">&quot;%s at %p is %u bytes, crc: 0x%08x:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">caption</span><span class="p">,</span> <span class="n">fh</span><span class="p">,</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">_nfs_display_fhandle_hash</span><span class="p">(</span><span class="n">fh</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__be32</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">switch</span> <span class="p">((</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEFAULT</span> <span class="s">&quot; %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">pos</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEFAULT</span> <span class="s">&quot; %08x %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEFAULT</span> <span class="s">&quot; %08x %08x %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
				<span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">2</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEFAULT</span> <span class="s">&quot; %08x %08x %08x %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
				<span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">3</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_inode_attrs_need_update - check if the inode attributes need updating</span>
<span class="cm"> * @inode - pointer to inode</span>
<span class="cm"> * @fattr - attributes</span>
<span class="cm"> *</span>
<span class="cm"> * Attempt to divine whether or not an RPC call reply carrying stale</span>
<span class="cm"> * attributes got scheduled after another call carrying updated ones.</span>
<span class="cm"> *</span>
<span class="cm"> * To do so, the function first assumes that a more recent ctime means</span>
<span class="cm"> * that the attributes in fattr are newer, however it also attempt to</span>
<span class="cm"> * catch the case where ctime either didn&#39;t change, or went backwards</span>
<span class="cm"> * (if someone reset the clock on the server) by looking at whether</span>
<span class="cm"> * or not this RPC call was started after the inode was last updated.</span>
<span class="cm"> * Note also the check for wraparound of &#39;attr_gencount&#39;</span>
<span class="cm"> *</span>
<span class="cm"> * The function returns &#39;true&#39; if it thinks the attributes in &#39;fattr&#39; are</span>
<span class="cm"> * more recent than the ones cached in the inode.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_inode_attrs_need_update</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">gencount</span> <span class="o">-</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">attr_gencount</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span>
		<span class="n">nfs_ctime_need_update</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fattr</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">nfs_size_need_update</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fattr</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">attr_gencount</span> <span class="o">-</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">nfs_read_attr_generation_counter</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_refresh_inode_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfs_inode_attrs_need_update</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fattr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">nfs_update_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fattr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nfs_check_inode_attributes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fattr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_refresh_inode - try to update the inode attribute cache</span>
<span class="cm"> * @inode - pointer to inode</span>
<span class="cm"> * @fattr - updated attributes</span>
<span class="cm"> *</span>
<span class="cm"> * Check that an RPC call that returned attributes has not overlapped with</span>
<span class="cm"> * other recent updates of the inode metadata, then decide whether it is</span>
<span class="cm"> * safe to do a full update of the inode attributes, or whether just to</span>
<span class="cm"> * call nfs_check_inode_attributes.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nfs_refresh_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">nfs_refresh_inode_locked</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fattr</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_post_op_update_inode_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="o">|</span><span class="n">NFS_INO_REVAL_PAGECACHE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_DATA</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">nfs_refresh_inode_locked</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fattr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_post_op_update_inode - try to update the inode attribute cache</span>
<span class="cm"> * @inode - pointer to inode</span>
<span class="cm"> * @fattr - updated attributes</span>
<span class="cm"> *</span>
<span class="cm"> * After an operation that has changed the inode metadata, mark the</span>
<span class="cm"> * attribute cache as being invalid, then try to update it.</span>
<span class="cm"> *</span>
<span class="cm"> * NB: if the server didn&#39;t return any post op attributes, this</span>
<span class="cm"> * function will force the retrieval of attributes before the next</span>
<span class="cm"> * NFS request.  Thus it should be used only for operations that</span>
<span class="cm"> * are expected to change one or more attributes, to avoid</span>
<span class="cm"> * unnecessary NFS requests and trips through nfs_update_inode().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nfs_post_op_update_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">nfs_post_op_update_inode_locked</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fattr</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_post_op_update_inode_force_wcc - try to update the inode attribute cache</span>
<span class="cm"> * @inode - pointer to inode</span>
<span class="cm"> * @fattr - updated attributes</span>
<span class="cm"> *</span>
<span class="cm"> * After an operation that has changed the inode metadata, mark the</span>
<span class="cm"> * attribute cache as being invalid, then try to update it. Fake up</span>
<span class="cm"> * weak cache consistency data, if none exist.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is mainly designed to be used by the -&gt;write_done() functions.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nfs_post_op_update_inode_force_wcc</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="cm">/* Don&#39;t do a WCC update if these attributes are already stale */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
			<span class="o">!</span><span class="n">nfs_inode_attrs_need_update</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fattr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">NFS_ATTR_FATTR_PRECHANGE</span>
				<span class="o">|</span> <span class="n">NFS_ATTR_FATTR_PRESIZE</span>
				<span class="o">|</span> <span class="n">NFS_ATTR_FATTR_PREMTIME</span>
				<span class="o">|</span> <span class="n">NFS_ATTR_FATTR_PRECTIME</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_noforce</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_CHANGE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_PRECHANGE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">pre_change_attr</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_version</span><span class="p">;</span>
		<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">|=</span> <span class="n">NFS_ATTR_FATTR_PRECHANGE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_CTIME</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_PRECTIME</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">pre_ctime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">pre_ctime</span><span class="p">));</span>
		<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">|=</span> <span class="n">NFS_ATTR_FATTR_PRECTIME</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_MTIME</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_PREMTIME</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">pre_mtime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">pre_mtime</span><span class="p">));</span>
		<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">|=</span> <span class="n">NFS_ATTR_FATTR_PREMTIME</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_SIZE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_PRESIZE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">pre_size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">|=</span> <span class="n">NFS_ATTR_FATTR_PRESIZE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out_noforce:</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">nfs_post_op_update_inode_locked</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fattr</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Many nfs protocol calls return the new file attributes after</span>
<span class="cm"> * an operation.  Here we update the inode to reflect the state</span>
<span class="cm"> * of the server&#39;s inode.</span>
<span class="cm"> *</span>
<span class="cm"> * This is a bit tricky because we have to make sure all dirty pages</span>
<span class="cm"> * have been sent off to the server before calling invalidate_inode_pages.</span>
<span class="cm"> * To make sure no other process adds more write requests while we try</span>
<span class="cm"> * our best to flush them, we make them sleep during the attribute refresh.</span>
<span class="cm"> *</span>
<span class="cm"> * A very similar scenario holds for the dir cache.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_update_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">loff_t</span> <span class="n">cur_isize</span><span class="p">,</span> <span class="n">new_isize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">invalid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">save_cache_validity</span><span class="p">;</span>

	<span class="n">dfprintk</span><span class="p">(</span><span class="n">VFS</span><span class="p">,</span> <span class="s">&quot;NFS: %s(%s/%ld fh_crc=0x%08x ct=%d info=0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
			<span class="n">nfs_display_fhandle_hash</span><span class="p">(</span><span class="n">NFS_FH</span><span class="p">(</span><span class="n">inode</span><span class="p">)),</span>
			<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="p">),</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_FILEID</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">fileid</span> <span class="o">!=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">fileid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;NFS: server %s error: fileid changed</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;fsid %s: expected fileid 0x%Lx, got 0x%Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nfs_client</span><span class="o">-&gt;</span><span class="n">cl_hostname</span><span class="p">,</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">fileid</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">fileid</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure the inode&#39;s type hasn&#39;t changed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_TYPE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		* Big trouble! The inode has become a different object.</span>
<span class="cm">		*/</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;NFS: %s: inode %ld mode changed, %07o to %07o</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">server</span> <span class="o">=</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="cm">/* Update the fsid? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_FSID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">nfs_fsid_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">IS_AUTOMOUNT</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">server</span><span class="o">-&gt;</span><span class="n">fsid</span> <span class="o">=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Update the read time so we don&#39;t revalidate too often.</span>
<span class="cm">	 */</span>
	<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">read_cache_jiffies</span> <span class="o">=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">time_start</span><span class="p">;</span>

	<span class="n">save_cache_validity</span> <span class="o">=</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span><span class="p">;</span>
	<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">NFS_INO_INVALID_ATTR</span>
			<span class="o">|</span> <span class="n">NFS_INO_INVALID_ATIME</span>
			<span class="o">|</span> <span class="n">NFS_INO_REVAL_FORCED</span>
			<span class="o">|</span> <span class="n">NFS_INO_REVAL_PAGECACHE</span><span class="p">);</span>

	<span class="cm">/* Do atomic weak cache consistency updates */</span>
	<span class="n">invalid</span> <span class="o">|=</span> <span class="n">nfs_wcc_update_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fattr</span><span class="p">);</span>

	<span class="cm">/* More cache consistency checks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_CHANGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_version</span> <span class="o">!=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">change_attr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: change_attr change on server for file %s/%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
			<span class="n">invalid</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span>
				<span class="o">|</span> <span class="n">NFS_INO_INVALID_DATA</span>
				<span class="o">|</span> <span class="n">NFS_INO_INVALID_ACCESS</span>
				<span class="o">|</span> <span class="n">NFS_INO_INVALID_ACL</span>
				<span class="o">|</span> <span class="n">NFS_INO_REVAL_PAGECACHE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
				<span class="n">nfs_force_lookup_revalidate</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_version</span> <span class="o">=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">change_attr</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">caps</span> <span class="o">&amp;</span> <span class="n">NFS_CAP_CHANGE_ATTR</span><span class="p">)</span>
		<span class="n">invalid</span> <span class="o">|=</span> <span class="n">save_cache_validity</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_MTIME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">mtime</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">caps</span> <span class="o">&amp;</span> <span class="n">NFS_CAP_MTIME</span><span class="p">)</span>
		<span class="n">invalid</span> <span class="o">|=</span> <span class="n">save_cache_validity</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NFS_INO_INVALID_ATTR</span>
				<span class="o">|</span> <span class="n">NFS_INO_REVAL_FORCED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_CTIME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">ctime</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">caps</span> <span class="o">&amp;</span> <span class="n">NFS_CAP_CTIME</span><span class="p">)</span>
		<span class="n">invalid</span> <span class="o">|=</span> <span class="n">save_cache_validity</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NFS_INO_INVALID_ATTR</span>
				<span class="o">|</span> <span class="n">NFS_INO_REVAL_FORCED</span><span class="p">);</span>

	<span class="cm">/* Check if our cached file size is stale */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_isize</span> <span class="o">=</span> <span class="n">nfs_size_to_loff_t</span><span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
		<span class="n">cur_isize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_isize</span> <span class="o">!=</span> <span class="n">cur_isize</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Do we perhaps have any outstanding writes, or has</span>
<span class="cm">			 * the file grown beyond our last write? */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">npages</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NFS_INO_LAYOUTCOMMIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="o">||</span>
			     <span class="n">new_isize</span> <span class="o">&gt;</span> <span class="n">cur_isize</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">new_isize</span><span class="p">);</span>
				<span class="n">invalid</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="o">|</span><span class="n">NFS_INO_INVALID_DATA</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: isize change on server for file %s/%ld &quot;</span>
					<span class="s">&quot;(%Ld to %Ld)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span>
					<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">cur_isize</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">new_isize</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">invalid</span> <span class="o">|=</span> <span class="n">save_cache_validity</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NFS_INO_INVALID_ATTR</span>
				<span class="o">|</span> <span class="n">NFS_INO_REVAL_PAGECACHE</span>
				<span class="o">|</span> <span class="n">NFS_INO_REVAL_FORCED</span><span class="p">);</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_ATIME</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">atime</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">));</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">caps</span> <span class="o">&amp;</span> <span class="n">NFS_CAP_ATIME</span><span class="p">)</span>
		<span class="n">invalid</span> <span class="o">|=</span> <span class="n">save_cache_validity</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NFS_INO_INVALID_ATIME</span>
				<span class="o">|</span> <span class="n">NFS_INO_REVAL_FORCED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_MODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_IALLUGO</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_IALLUGO</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">umode_t</span> <span class="n">newmode</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">;</span>
			<span class="n">newmode</span> <span class="o">|=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_IALLUGO</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">newmode</span><span class="p">;</span>
			<span class="n">invalid</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="o">|</span><span class="n">NFS_INO_INVALID_ACCESS</span><span class="o">|</span><span class="n">NFS_INO_INVALID_ACL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">caps</span> <span class="o">&amp;</span> <span class="n">NFS_CAP_MODE</span><span class="p">)</span>
		<span class="n">invalid</span> <span class="o">|=</span> <span class="n">save_cache_validity</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NFS_INO_INVALID_ATTR</span>
				<span class="o">|</span> <span class="n">NFS_INO_INVALID_ACCESS</span>
				<span class="o">|</span> <span class="n">NFS_INO_INVALID_ACL</span>
				<span class="o">|</span> <span class="n">NFS_INO_REVAL_FORCED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_OWNER</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">!=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">invalid</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="o">|</span><span class="n">NFS_INO_INVALID_ACCESS</span><span class="o">|</span><span class="n">NFS_INO_INVALID_ACL</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">caps</span> <span class="o">&amp;</span> <span class="n">NFS_CAP_OWNER</span><span class="p">)</span>
		<span class="n">invalid</span> <span class="o">|=</span> <span class="n">save_cache_validity</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NFS_INO_INVALID_ATTR</span>
				<span class="o">|</span> <span class="n">NFS_INO_INVALID_ACCESS</span>
				<span class="o">|</span> <span class="n">NFS_INO_INVALID_ACL</span>
				<span class="o">|</span> <span class="n">NFS_INO_REVAL_FORCED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_GROUP</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">!=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">invalid</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="o">|</span><span class="n">NFS_INO_INVALID_ACCESS</span><span class="o">|</span><span class="n">NFS_INO_INVALID_ACL</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">caps</span> <span class="o">&amp;</span> <span class="n">NFS_CAP_OWNER_GROUP</span><span class="p">)</span>
		<span class="n">invalid</span> <span class="o">|=</span> <span class="n">save_cache_validity</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NFS_INO_INVALID_ATTR</span>
				<span class="o">|</span> <span class="n">NFS_INO_INVALID_ACCESS</span>
				<span class="o">|</span> <span class="n">NFS_INO_INVALID_ACL</span>
				<span class="o">|</span> <span class="n">NFS_INO_REVAL_FORCED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_NLINK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">!=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">invalid</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
				<span class="n">invalid</span> <span class="o">|=</span> <span class="n">NFS_INO_INVALID_DATA</span><span class="p">;</span>
			<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">caps</span> <span class="o">&amp;</span> <span class="n">NFS_CAP_NLINK</span><span class="p">)</span>
		<span class="n">invalid</span> <span class="o">|=</span> <span class="n">save_cache_validity</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NFS_INO_INVALID_ATTR</span>
				<span class="o">|</span> <span class="n">NFS_INO_REVAL_FORCED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_SPACE_USED</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * report the blocks in 512byte units</span>
<span class="cm">		 */</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="n">nfs_calc_block_size</span><span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">du</span><span class="p">.</span><span class="n">nfs3</span><span class="p">.</span><span class="n">used</span><span class="p">);</span>
 	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">&amp;</span> <span class="n">NFS_ATTR_FATTR_BLOCKS_USED</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="n">fattr</span><span class="o">-&gt;</span><span class="n">du</span><span class="p">.</span><span class="n">nfs2</span><span class="p">.</span><span class="n">blocks</span><span class="p">;</span>

	<span class="cm">/* Update attrtimeo value if we&#39;re out of the unstable period */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">invalid</span> <span class="o">&amp;</span> <span class="n">NFS_INO_INVALID_ATTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nfs_inc_stats</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">NFSIOS_ATTRINVALIDATE</span><span class="p">);</span>
		<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">attrtimeo</span> <span class="o">=</span> <span class="n">NFS_MINATTRTIMEO</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">attrtimeo_timestamp</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
		<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">attr_gencount</span> <span class="o">=</span> <span class="n">nfs_inc_attr_generation_counter</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">time_in_range_open</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">attrtimeo_timestamp</span><span class="p">,</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">attrtimeo_timestamp</span> <span class="o">+</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">attrtimeo</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">attrtimeo</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">NFS_MAXATTRTIMEO</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
				<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">attrtimeo</span> <span class="o">=</span> <span class="n">NFS_MAXATTRTIMEO</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">attrtimeo_timestamp</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">invalid</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NFS_INO_INVALID_ATTR</span><span class="p">;</span>
	<span class="cm">/* Don&#39;t invalidate the data if we were to blame */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span>
				<span class="o">||</span> <span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)))</span>
		<span class="n">invalid</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NFS_INO_INVALID_DATA</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nfs_have_delegation</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">FMODE_READ</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">save_cache_validity</span> <span class="o">&amp;</span> <span class="n">NFS_INO_REVAL_FORCED</span><span class="p">))</span>
		<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">|=</span> <span class="n">invalid</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out_err:</span>
	<span class="cm">/*</span>
<span class="cm">	 * No need to worry about unhashing the dentry, as the</span>
<span class="cm">	 * lookup validation will know that the inode is bad.</span>
<span class="cm">	 * (But we fall through to invalidate the caches.)</span>
<span class="cm">	 */</span>
	<span class="n">nfs_invalidate_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ESTALE</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#ifdef CONFIG_NFS_V4</span>

<span class="cm">/*</span>
<span class="cm"> * Clean out any remaining NFSv4 state that might be left over due</span>
<span class="cm"> * to open() calls that passed nfs_atomic_lookup, but failed to call</span>
<span class="cm"> * nfs_open().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nfs4_evict_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">truncate_inode_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">clear_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">pnfs_return_layout</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">pnfs_destroy_layout</span><span class="p">(</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="cm">/* If we are holding a delegation, return it! */</span>
	<span class="n">nfs_inode_return_delegation_noreclaim</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="cm">/* First call standard NFS clear_inode() code */</span>
	<span class="n">nfs_clear_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">nfs_alloc_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span><span class="p">;</span>
	<span class="n">nfsi</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="p">)</span><span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">nfs_inode_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nfsi</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>
	<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">cache_validity</span> <span class="o">=</span> <span class="mi">0UL</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_NFS_V3_ACL</span>
	<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">acl_access</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>
	<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">acl_default</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_NFS_V4</span>
	<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">nfs4_acl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_NFS_V4 */</span><span class="cp"></span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs_i_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span><span class="p">,</span> <span class="n">i_rcu</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">nfs_inode_cachep</span><span class="p">,</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nfs_destroy_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rcu</span><span class="p">,</span> <span class="n">nfs_i_callback</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">nfs4_init_once</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_NFS_V4</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">open_states</span><span class="p">);</span>
	<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">delegation</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">delegation_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">init_rwsem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">rwsem</span><span class="p">);</span>
	<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">layout</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_once</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="p">)</span> <span class="n">foo</span><span class="p">;</span>

	<span class="n">inode_init_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">open_files</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">access_cache_entry_lru</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">access_cache_inode_lru</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">commit_info</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">npages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">commit_info</span><span class="p">.</span><span class="n">ncommit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">commit_info</span><span class="p">.</span><span class="n">rpcs_out</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">silly_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">silly_list</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">waitqueue</span><span class="p">);</span>
	<span class="n">nfs4_init_once</span><span class="p">(</span><span class="n">nfsi</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">nfs_init_inodecache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nfs_inode_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;nfs_inode_cache&quot;</span><span class="p">,</span>
					     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_inode</span><span class="p">),</span>
					     <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="o">|</span>
						<span class="n">SLAB_MEM_SPREAD</span><span class="p">),</span>
					     <span class="n">init_once</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfs_inode_cachep</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs_destroy_inodecache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">nfs_inode_cachep</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">nfsiod_workqueue</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * start up the nfsiod workqueue</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfsiod_start</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;RPC:       creating workqueue nfsiod</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">wq</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">&quot;nfsiod&quot;</span><span class="p">,</span> <span class="n">WQ_MEM_RECLAIM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wq</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">nfsiod_workqueue</span> <span class="o">=</span> <span class="n">wq</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Destroy the nfsiod workqueue</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfsiod_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>

	<span class="n">wq</span> <span class="o">=</span> <span class="n">nfsiod_workqueue</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wq</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">nfsiod_workqueue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">nfs_net_id</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">nfs_net_id</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_net_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nfs_clients_init</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nfs_dns_resolver_cache_init</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs_net_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nfs_dns_resolver_cache_destroy</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">nfs_cleanup_cb_ident_idr</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pernet_operations</span> <span class="n">nfs_net_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">nfs_net_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">exit</span> <span class="o">=</span> <span class="n">nfs_net_exit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id</span>   <span class="o">=</span> <span class="o">&amp;</span><span class="n">nfs_net_id</span><span class="p">,</span>
	<span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_net</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize NFS</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_nfs_fs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfs_idmap_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out10</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfs_dns_resolver_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out9</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">register_pernet_subsys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfs_net_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out8</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfs_fscache_register</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out7</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfsiod_start</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out6</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfs_fs_proc_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out5</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfs_init_nfspagecache</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out4</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfs_init_inodecache</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out3</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfs_init_readpagecache</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfs_init_writepagecache</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nfs_init_directcache</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="n">rpc_proc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfs_rpcstat</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">register_nfs_fs</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="n">rpc_proc_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="s">&quot;nfs&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">nfs_destroy_directcache</span><span class="p">();</span>
<span class="nl">out0:</span>
	<span class="n">nfs_destroy_writepagecache</span><span class="p">();</span>
<span class="nl">out1:</span>
	<span class="n">nfs_destroy_readpagecache</span><span class="p">();</span>
<span class="nl">out2:</span>
	<span class="n">nfs_destroy_inodecache</span><span class="p">();</span>
<span class="nl">out3:</span>
	<span class="n">nfs_destroy_nfspagecache</span><span class="p">();</span>
<span class="nl">out4:</span>
	<span class="n">nfs_fs_proc_exit</span><span class="p">();</span>
<span class="nl">out5:</span>
	<span class="n">nfsiod_stop</span><span class="p">();</span>
<span class="nl">out6:</span>
	<span class="n">nfs_fscache_unregister</span><span class="p">();</span>
<span class="nl">out7:</span>
	<span class="n">unregister_pernet_subsys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfs_net_ops</span><span class="p">);</span>
<span class="nl">out8:</span>
	<span class="n">nfs_dns_resolver_destroy</span><span class="p">();</span>
<span class="nl">out9:</span>
	<span class="n">nfs_idmap_quit</span><span class="p">();</span>
<span class="nl">out10:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">exit_nfs_fs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nfs_destroy_directcache</span><span class="p">();</span>
	<span class="n">nfs_destroy_writepagecache</span><span class="p">();</span>
	<span class="n">nfs_destroy_readpagecache</span><span class="p">();</span>
	<span class="n">nfs_destroy_inodecache</span><span class="p">();</span>
	<span class="n">nfs_destroy_nfspagecache</span><span class="p">();</span>
	<span class="n">nfs_fscache_unregister</span><span class="p">();</span>
	<span class="n">unregister_pernet_subsys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfs_net_ops</span><span class="p">);</span>
	<span class="n">nfs_dns_resolver_destroy</span><span class="p">();</span>
	<span class="n">nfs_idmap_quit</span><span class="p">();</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="n">rpc_proc_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="s">&quot;nfs&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">unregister_nfs_fs</span><span class="p">();</span>
	<span class="n">nfs_fs_proc_exit</span><span class="p">();</span>
	<span class="n">nfsiod_stop</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Not quite true; I just maintain it */</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Olaf Kirch &lt;okir@monad.swb.de&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">enable_ino64</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">init_nfs_fs</span><span class="p">)</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">exit_nfs_fs</span><span class="p">)</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
